// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ei.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Ei.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(ActionKeyValuePair);
GPBObjCClassDeclaration(AppInfo);
GPBObjCClassDeclaration(ArtifactInventoryItem);
GPBObjCClassDeclaration(ArtifactSpec);
GPBObjCClassDeclaration(ArtifactsClientInfo);
GPBObjCClassDeclaration(ArtifactsClientInfo_LaunchCount);
GPBObjCClassDeclaration(ArtifactsConfigurationResponse);
GPBObjCClassDeclaration(ArtifactsConfigurationResponse_ArtifactParameters);
GPBObjCClassDeclaration(ArtifactsConfigurationResponse_CraftingLevelInfo);
GPBObjCClassDeclaration(ArtifactsConfigurationResponse_MissionParameters);
GPBObjCClassDeclaration(ArtifactsConfigurationResponse_MissionParameters_Duration);
GPBObjCClassDeclaration(ArtifactsDB);
GPBObjCClassDeclaration(ArtifactsDB_ActiveArtifactSet);
GPBObjCClassDeclaration(ArtifactsDB_ActiveArtifactSlot);
GPBObjCClassDeclaration(ArtifactsDB_CraftableArtifact);
GPBObjCClassDeclaration(Backup);
GPBObjCClassDeclaration(Backup_AchievementInfo);
GPBObjCClassDeclaration(Backup_ActiveBoost);
GPBObjCClassDeclaration(Backup_Artifacts);
GPBObjCClassDeclaration(Backup_Game);
GPBObjCClassDeclaration(Backup_Misc);
GPBObjCClassDeclaration(Backup_Mission);
GPBObjCClassDeclaration(Backup_MissionInfo);
GPBObjCClassDeclaration(Backup_NewsHeadline);
GPBObjCClassDeclaration(Backup_OwnedBoost);
GPBObjCClassDeclaration(Backup_ResearchItem);
GPBObjCClassDeclaration(Backup_Settings);
GPBObjCClassDeclaration(Backup_Shells);
GPBObjCClassDeclaration(Backup_Simulation);
GPBObjCClassDeclaration(Backup_Stats);
GPBObjCClassDeclaration(Backup_Tutorial);
GPBObjCClassDeclaration(BasicRequestInfo);
GPBObjCClassDeclaration(CompleteArtifact);
GPBObjCClassDeclaration(CompleteMissionResponse);
GPBObjCClassDeclaration(CompleteMissionResponse_SecureArtifactSpec);
GPBObjCClassDeclaration(ConsumeArtifactRequest);
GPBObjCClassDeclaration(ConsumeArtifactResponse);
GPBObjCClassDeclaration(Contract);
GPBObjCClassDeclaration(ContractCoopStatusResponse);
GPBObjCClassDeclaration(ContractCoopStatusResponse_ChickenRun);
GPBObjCClassDeclaration(ContractCoopStatusResponse_ContributionInfo);
GPBObjCClassDeclaration(ContractCoopStatusResponse_CoopGift);
GPBObjCClassDeclaration(Contract_Goal);
GPBObjCClassDeclaration(Contract_GoalSet);
GPBObjCClassDeclaration(ContractsResponse);
GPBObjCClassDeclaration(CoopBuffState);
GPBObjCClassDeclaration(CoopChickenRunEntry);
GPBObjCClassDeclaration(CraftArtifactRequest);
GPBObjCClassDeclaration(CraftArtifactResponse);
GPBObjCClassDeclaration(CurrencyFlowLog);
GPBObjCClassDeclaration(DLCCatalog);
GPBObjCClassDeclaration(DLCItem);
GPBObjCClassDeclaration(DeviceInfo);
GPBObjCClassDeclaration(EggIncCurrentEvents);
GPBObjCClassDeclaration(EggIncEvent);
GPBObjCClassDeclaration(FarmProductionParams);
GPBObjCClassDeclaration(GenericAction);
GPBObjCClassDeclaration(IAPSaleEntry);
GPBObjCClassDeclaration(InGameMail);
GPBObjCClassDeclaration(InventorySlot);
GPBObjCClassDeclaration(LiveConfig);
GPBObjCClassDeclaration(LiveConfig_BoostsConfig);
GPBObjCClassDeclaration(LiveConfig_BoostsConfig_ItemConfig);
GPBObjCClassDeclaration(LiveConfig_GiftConfig);
GPBObjCClassDeclaration(LiveConfig_GiftConfig_GiftMuConfig);
GPBObjCClassDeclaration(LiveConfig_GiftConfig_GiftValueConfig);
GPBObjCClassDeclaration(LiveConfig_MiscConfig);
GPBObjCClassDeclaration(LocalContract);
GPBObjCClassDeclaration(MailDB);
GPBObjCClassDeclaration(MissionInfo);
GPBObjCClassDeclaration(MissionInfo_Fuel);
GPBObjCClassDeclaration(MissionRequest);
GPBObjCClassDeclaration(MyContracts);
GPBObjCClassDeclaration(PlayerFarmInfo);
GPBObjCClassDeclaration(Reward);
GPBObjCClassDeclaration(SalesInfo);
GPBObjCClassDeclaration(ServerGift);
GPBObjCClassDeclaration(SetArtifactRequest);
GPBObjCClassDeclaration(SetArtifactResponse);
GPBObjCClassDeclaration(ShellDB);
GPBObjCClassDeclaration(ShellDB_ChickenConfig);
GPBObjCClassDeclaration(ShellDB_FarmConfiguration);
GPBObjCClassDeclaration(ShellDB_SavedFarmConfiguration);
GPBObjCClassDeclaration(ShellDB_ShellConfiguration);
GPBObjCClassDeclaration(ShellDB_ShellElementStatus);
GPBObjCClassDeclaration(ShellDB_ShellGroupConfiguration);
GPBObjCClassDeclaration(ShellDB_ShellSetConfiguration);
GPBObjCClassDeclaration(ShellDB_ShellSetVariationStatus);
GPBObjCClassDeclaration(ShellDB_ShellStatus);
GPBObjCClassDeclaration(ShellGroupSpec);
GPBObjCClassDeclaration(ShellObjectSpec);
GPBObjCClassDeclaration(ShellObjectSpec_LODPiece);
GPBObjCClassDeclaration(ShellSetSpec);
GPBObjCClassDeclaration(ShellSetSpec_VariationSpec);
GPBObjCClassDeclaration(ShellSpec);
GPBObjCClassDeclaration(ShellSpec_ShellPiece);

#pragma mark - EiRoot

@implementation EiRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - EiRoot_FileDescriptor

static GPBFileDescriptor *EiRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"ei"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - Enum Platform

GPBEnumDescriptor *Platform_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Ios\000Droid\000";
    static const int32_t values[] = {
        Platform_Ios,
        Platform_Droid,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Platform)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Platform_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Platform_IsValidValue(int32_t value__) {
  switch (value__) {
    case Platform_Ios:
    case Platform_Droid:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum DeviceFormFactor

GPBEnumDescriptor *DeviceFormFactor_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Phone\000Tablet\000";
    static const int32_t values[] = {
        DeviceFormFactor_Phone,
        DeviceFormFactor_Tablet,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(DeviceFormFactor)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:DeviceFormFactor_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL DeviceFormFactor_IsValidValue(int32_t value__) {
  switch (value__) {
    case DeviceFormFactor_Phone:
    case DeviceFormFactor_Tablet:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum AdNetwork

GPBEnumDescriptor *AdNetwork_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Vungle\000Chartboost\000AdColony\000HyperMx\000Unity"
        "\000Facebook\000Applovin\000";
    static const int32_t values[] = {
        AdNetwork_Vungle,
        AdNetwork_Chartboost,
        AdNetwork_AdColony,
        AdNetwork_HyperMx,
        AdNetwork_Unity,
        AdNetwork_Facebook,
        AdNetwork_Applovin,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(AdNetwork)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AdNetwork_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AdNetwork_IsValidValue(int32_t value__) {
  switch (value__) {
    case AdNetwork_Vungle:
    case AdNetwork_Chartboost:
    case AdNetwork_AdColony:
    case AdNetwork_HyperMx:
    case AdNetwork_Unity:
    case AdNetwork_Facebook:
    case AdNetwork_Applovin:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Egg

GPBEnumDescriptor *Egg_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Edible\000Superfood\000Medical\000RocketFuel\000Supe"
        "rMaterial\000Fusion\000Quantum\000Immortality\000Tac"
        "hyon\000Graviton\000Dilithium\000Prodigy\000Terrafor"
        "m\000Antimatter\000DarkMatter\000Ai\000Nebula\000Univer"
        "se\000Enlightenment\000Chocolate\000Easter\000Waterb"
        "alloon\000Firework\000Pumpkin\000Unknown\000";
    static const int32_t values[] = {
        Egg_Edible,
        Egg_Superfood,
        Egg_Medical,
        Egg_RocketFuel,
        Egg_SuperMaterial,
        Egg_Fusion,
        Egg_Quantum,
        Egg_Immortality,
        Egg_Tachyon,
        Egg_Graviton,
        Egg_Dilithium,
        Egg_Prodigy,
        Egg_Terraform,
        Egg_Antimatter,
        Egg_DarkMatter,
        Egg_Ai,
        Egg_Nebula,
        Egg_Universe,
        Egg_Enlightenment,
        Egg_Chocolate,
        Egg_Easter,
        Egg_Waterballoon,
        Egg_Firework,
        Egg_Pumpkin,
        Egg_Unknown,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Egg)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Egg_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Egg_IsValidValue(int32_t value__) {
  switch (value__) {
    case Egg_Edible:
    case Egg_Superfood:
    case Egg_Medical:
    case Egg_RocketFuel:
    case Egg_SuperMaterial:
    case Egg_Fusion:
    case Egg_Quantum:
    case Egg_Immortality:
    case Egg_Tachyon:
    case Egg_Graviton:
    case Egg_Dilithium:
    case Egg_Prodigy:
    case Egg_Terraform:
    case Egg_Antimatter:
    case Egg_DarkMatter:
    case Egg_Ai:
    case Egg_Nebula:
    case Egg_Universe:
    case Egg_Enlightenment:
    case Egg_Chocolate:
    case Egg_Easter:
    case Egg_Waterballoon:
    case Egg_Firework:
    case Egg_Pumpkin:
    case Egg_Unknown:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum FarmType

GPBEnumDescriptor *FarmType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Empty\000Home\000Contract\000";
    static const int32_t values[] = {
        FarmType_Empty,
        FarmType_Home,
        FarmType_Contract,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(FarmType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:FarmType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL FarmType_IsValidValue(int32_t value__) {
  switch (value__) {
    case FarmType_Empty:
    case FarmType_Home:
    case FarmType_Contract:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum GoalType

GPBEnumDescriptor *GoalType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "EggsLaid\000UnknownGoal\000";
    static const int32_t values[] = {
        GoalType_EggsLaid,
        GoalType_UnknownGoal,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GoalType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GoalType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GoalType_IsValidValue(int32_t value__) {
  switch (value__) {
    case GoalType_EggsLaid:
    case GoalType_UnknownGoal:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum RewardType

GPBEnumDescriptor *RewardType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Cash\000Gold\000SoulEggs\000EggsOfProphecy\000EpicRe"
        "searchItem\000PiggyFill\000PiggyMultiplier\000Pig"
        "gyLevelBump\000Boost\000BoostToken\000Artifact\000Ar"
        "tifactCase\000Chicken\000ShellScript\000UnknownRe"
        "ward\000";
    static const int32_t values[] = {
        RewardType_Cash,
        RewardType_Gold,
        RewardType_SoulEggs,
        RewardType_EggsOfProphecy,
        RewardType_EpicResearchItem,
        RewardType_PiggyFill,
        RewardType_PiggyMultiplier,
        RewardType_PiggyLevelBump,
        RewardType_Boost,
        RewardType_BoostToken,
        RewardType_Artifact,
        RewardType_ArtifactCase,
        RewardType_Chicken,
        RewardType_ShellScript,
        RewardType_UnknownReward,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RewardType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RewardType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RewardType_IsValidValue(int32_t value__) {
  switch (value__) {
    case RewardType_Cash:
    case RewardType_Gold:
    case RewardType_SoulEggs:
    case RewardType_EggsOfProphecy:
    case RewardType_EpicResearchItem:
    case RewardType_PiggyFill:
    case RewardType_PiggyMultiplier:
    case RewardType_PiggyLevelBump:
    case RewardType_Boost:
    case RewardType_BoostToken:
    case RewardType_Artifact:
    case RewardType_ArtifactCase:
    case RewardType_Chicken:
    case RewardType_ShellScript:
    case RewardType_UnknownReward:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Backup

@implementation Backup

@dynamic hasUserId, userId;
@dynamic hasEiUserId, eiUserId;
@dynamic hasGameServicesId, gameServicesId;
@dynamic hasDeviceId, deviceId;
@dynamic hasUserName, userName;
@dynamic hasApproxTime, approxTime;
@dynamic hasVersion, version;
@dynamic hasForceOfferBackup, forceOfferBackup;
@dynamic hasForceBackup, forceBackup;
@dynamic hasSettings, settings;
@dynamic hasTutorial, tutorial;
@dynamic hasStats, stats;
@dynamic hasGame, game;
@dynamic hasArtifacts, artifacts;
@dynamic hasShells, shells;
@dynamic hasSim, sim;
@dynamic farmsArray, farmsArray_Count;
@dynamic hasMission, mission;
@dynamic hasMisc, misc;
@dynamic hasContracts, contracts;
@dynamic hasArtifactsDb, artifactsDb;
@dynamic hasShellDb, shellDb;
@dynamic readMailIdsArray, readMailIdsArray_Count;
@dynamic hasChecksum, checksum;
@dynamic hasSignature, signature;

typedef struct Backup__storage_ {
  uint32_t _has_storage_[1];
  uint32_t version;
  NSString *userId;
  NSString *userName;
  Backup_Settings *settings;
  Backup_Tutorial *tutorial;
  Backup_Stats *stats;
  Backup_Game *game;
  Backup_Simulation *sim;
  Backup_Mission *mission;
  Backup_Misc *misc;
  NSMutableArray *farmsArray;
  MyContracts *contracts;
  Backup_Artifacts *artifacts;
  ArtifactsDB *artifactsDb;
  NSString *gameServicesId;
  NSString *deviceId;
  NSString *eiUserId;
  NSMutableArray *readMailIdsArray;
  ShellDB *shellDb;
  Backup_Shells *shells;
  NSString *signature;
  double approxTime;
  uint64_t checksum;
} Backup__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Backup__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userName",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_FieldNumber_UserName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Backup__storage_, userName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "approxTime",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_FieldNumber_ApproxTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Backup__storage_, approxTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "settings",
        .dataTypeSpecific.clazz = GPBObjCClass(Backup_Settings),
        .number = Backup_FieldNumber_Settings,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Backup__storage_, settings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tutorial",
        .dataTypeSpecific.clazz = GPBObjCClass(Backup_Tutorial),
        .number = Backup_FieldNumber_Tutorial,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(Backup__storage_, tutorial),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stats",
        .dataTypeSpecific.clazz = GPBObjCClass(Backup_Stats),
        .number = Backup_FieldNumber_Stats,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(Backup__storage_, stats),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "game",
        .dataTypeSpecific.clazz = GPBObjCClass(Backup_Game),
        .number = Backup_FieldNumber_Game,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(Backup__storage_, game),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sim",
        .dataTypeSpecific.clazz = GPBObjCClass(Backup_Simulation),
        .number = Backup_FieldNumber_Sim,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(Backup__storage_, sim),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mission",
        .dataTypeSpecific.clazz = GPBObjCClass(Backup_Mission),
        .number = Backup_FieldNumber_Mission,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(Backup__storage_, mission),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "misc",
        .dataTypeSpecific.clazz = GPBObjCClass(Backup_Misc),
        .number = Backup_FieldNumber_Misc,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(Backup__storage_, misc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "farmsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Backup_Simulation),
        .number = Backup_FieldNumber_FarmsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Backup__storage_, farmsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "contracts",
        .dataTypeSpecific.clazz = GPBObjCClass(MyContracts),
        .number = Backup_FieldNumber_Contracts,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(Backup__storage_, contracts),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "artifacts",
        .dataTypeSpecific.clazz = GPBObjCClass(Backup_Artifacts),
        .number = Backup_FieldNumber_Artifacts,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(Backup__storage_, artifacts),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "artifactsDb",
        .dataTypeSpecific.clazz = GPBObjCClass(ArtifactsDB),
        .number = Backup_FieldNumber_ArtifactsDb,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(Backup__storage_, artifactsDb),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gameServicesId",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_FieldNumber_GameServicesId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Backup__storage_, gameServicesId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceId",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_FieldNumber_DeviceId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Backup__storage_, deviceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "eiUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_FieldNumber_EiUserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Backup__storage_, eiUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "forceOfferBackup",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_FieldNumber_ForceOfferBackup,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "version",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_FieldNumber_Version,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Backup__storage_, version),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "forceBackup",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_FieldNumber_ForceBackup,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "readMailIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_FieldNumber_ReadMailIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Backup__storage_, readMailIdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "shellDb",
        .dataTypeSpecific.clazz = GPBObjCClass(ShellDB),
        .number = Backup_FieldNumber_ShellDb,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(Backup__storage_, shellDb),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "shells",
        .dataTypeSpecific.clazz = GPBObjCClass(Backup_Shells),
        .number = Backup_FieldNumber_Shells,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(Backup__storage_, shells),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "checksum",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_FieldNumber_Checksum,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(Backup__storage_, checksum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "signature",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_FieldNumber_Signature,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(Backup__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Backup class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Backup__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Backup_Settings

@implementation Backup_Settings

@dynamic hasSfx, sfx;
@dynamic hasMusic, music;
@dynamic hasLowBatteryMode, lowBatteryMode;
@dynamic hasLowPerformanceMode, lowPerformanceMode;
@dynamic hasForceTouchChickenBtn, forceTouchChickenBtn;
@dynamic hasNotificationsQueried, notificationsQueried;
@dynamic hasNotificationsOn, notificationsOn;
@dynamic hasNotifyDailyGift, notifyDailyGift;
@dynamic hasCoppaQueried, coppaQueried;
@dynamic hasCoppaRestricted, coppaRestricted;
@dynamic hasGdprConsentQueried, gdprConsentQueried;
@dynamic hasGdprAgeRestricted, gdprAgeRestricted;
@dynamic hasGdprConsentGiven, gdprConsentGiven;
@dynamic hasAgeQueried, ageQueried;
@dynamic hasAgeRestricted, ageRestricted;
@dynamic hasDataCollectionConsentQueried, dataCollectionConsentQueried;
@dynamic hasDataCollectionConsentGiven, dataCollectionConsentGiven;
@dynamic hasLastDayAgeQueried, lastDayAgeQueried;
@dynamic hasUserAdsEnabled, userAdsEnabled;
@dynamic hasUserCloudEnabled, userCloudEnabled;
@dynamic hasUserAnalyticsEnabled, userAnalyticsEnabled;
@dynamic hasUserPersonalizedAdsEnabled, userPersonalizedAdsEnabled;
@dynamic hasLowPerformance, lowPerformance;
@dynamic hasAutoStopFueling, autoStopFueling;
@dynamic hasLastBackupTime, lastBackupTime;

typedef struct Backup_Settings__storage_ {
  uint32_t _has_storage_[2];
  uint32_t lastDayAgeQueried;
  double lastBackupTime;
} Backup_Settings__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueBool = NO,
        .core.name = "sfx",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Settings_FieldNumber_Sfx,
        .core.hasIndex = 0,
        .core.offset = 1,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "music",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Settings_FieldNumber_Music,
        .core.hasIndex = 2,
        .core.offset = 3,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "lowBatteryMode",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Settings_FieldNumber_LowBatteryMode,
        .core.hasIndex = 4,
        .core.offset = 5,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "lowPerformanceMode",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Settings_FieldNumber_LowPerformanceMode,
        .core.hasIndex = 6,
        .core.offset = 7,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "notificationsQueried",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Settings_FieldNumber_NotificationsQueried,
        .core.hasIndex = 10,
        .core.offset = 11,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "notificationsOn",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Settings_FieldNumber_NotificationsOn,
        .core.hasIndex = 12,
        .core.offset = 13,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "coppaQueried",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Settings_FieldNumber_CoppaQueried,
        .core.hasIndex = 16,
        .core.offset = 17,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "coppaRestricted",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Settings_FieldNumber_CoppaRestricted,
        .core.hasIndex = 18,
        .core.offset = 19,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "forceTouchChickenBtn",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Settings_FieldNumber_ForceTouchChickenBtn,
        .core.hasIndex = 8,
        .core.offset = 9,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "lowPerformance",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Settings_FieldNumber_LowPerformance,
        .core.hasIndex = 43,
        .core.offset = 44,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "notifyDailyGift",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Settings_FieldNumber_NotifyDailyGift,
        .core.hasIndex = 14,
        .core.offset = 15,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "gdprConsentQueried",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Settings_FieldNumber_GdprConsentQueried,
        .core.hasIndex = 20,
        .core.offset = 21,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "gdprConsentGiven",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Settings_FieldNumber_GdprConsentGiven,
        .core.hasIndex = 24,
        .core.offset = 25,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = YES,
        .core.name = "userAdsEnabled",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Settings_FieldNumber_UserAdsEnabled,
        .core.hasIndex = 35,
        .core.offset = 36,  // Stored in _has_storage_ to save space.
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = YES,
        .core.name = "userCloudEnabled",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Settings_FieldNumber_UserCloudEnabled,
        .core.hasIndex = 37,
        .core.offset = 38,  // Stored in _has_storage_ to save space.
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "gdprAgeRestricted",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Settings_FieldNumber_GdprAgeRestricted,
        .core.hasIndex = 22,
        .core.offset = 23,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "lastDayAgeQueried",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Settings_FieldNumber_LastDayAgeQueried,
        .core.hasIndex = 34,
        .core.offset = (uint32_t)offsetof(Backup_Settings__storage_, lastDayAgeQueried),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "ageQueried",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Settings_FieldNumber_AgeQueried,
        .core.hasIndex = 26,
        .core.offset = 27,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "ageRestricted",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Settings_FieldNumber_AgeRestricted,
        .core.hasIndex = 28,
        .core.offset = 29,  // Stored in _has_storage_ to save space.
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "dataCollectionConsentQueried",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Settings_FieldNumber_DataCollectionConsentQueried,
        .core.hasIndex = 30,
        .core.offset = 31,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "dataCollectionConsentGiven",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Settings_FieldNumber_DataCollectionConsentGiven,
        .core.hasIndex = 32,
        .core.offset = 33,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = YES,
        .core.name = "userAnalyticsEnabled",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Settings_FieldNumber_UserAnalyticsEnabled,
        .core.hasIndex = 39,
        .core.offset = 40,  // Stored in _has_storage_ to save space.
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = YES,
        .core.name = "userPersonalizedAdsEnabled",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Settings_FieldNumber_UserPersonalizedAdsEnabled,
        .core.hasIndex = 41,
        .core.offset = 42,  // Stored in _has_storage_ to save space.
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "lastBackupTime",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Settings_FieldNumber_LastBackupTime,
        .core.hasIndex = 47,
        .core.offset = (uint32_t)offsetof(Backup_Settings__storage_, lastBackupTime),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "autoStopFueling",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Settings_FieldNumber_AutoStopFueling,
        .core.hasIndex = 45,
        .core.offset = 46,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Backup_Settings class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(Backup_Settings__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Backup)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Backup_Tutorial

@implementation Backup_Tutorial

@dynamic hasIntroShown, introShown;
@dynamic hasClickTutorialShown, clickTutorialShown;
@dynamic hasBuyHabShown, buyHabShown;
@dynamic hasHireVehicleShown, hireVehicleShown;
@dynamic hasQNumShown, qNumShown;
@dynamic hasSNumShown, sNumShown;
@dynamic hasContractsTabShown, contractsTabShown;
@dynamic hasContractInfoShown, contractInfoShown;
@dynamic hasJoinCoopShown, joinCoopShown;
@dynamic hasSwitchFarmShown, switchFarmShown;
@dynamic tutorialShownArray, tutorialShownArray_Count;

typedef struct Backup_Tutorial__storage_ {
  uint32_t _has_storage_[1];
  GPBBoolArray *tutorialShownArray;
} Backup_Tutorial__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "introShown",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Tutorial_FieldNumber_IntroShown,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "clickTutorialShown",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Tutorial_FieldNumber_ClickTutorialShown,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "buyHabShown",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Tutorial_FieldNumber_BuyHabShown,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "hireVehicleShown",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Tutorial_FieldNumber_HireVehicleShown,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "qNumShown",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Tutorial_FieldNumber_QNumShown,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "sNumShown",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Tutorial_FieldNumber_SNumShown,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "contractsTabShown",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Tutorial_FieldNumber_ContractsTabShown,
        .hasIndex = 12,
        .offset = 13,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "contractInfoShown",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Tutorial_FieldNumber_ContractInfoShown,
        .hasIndex = 14,
        .offset = 15,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "joinCoopShown",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Tutorial_FieldNumber_JoinCoopShown,
        .hasIndex = 16,
        .offset = 17,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "switchFarmShown",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Tutorial_FieldNumber_SwitchFarmShown,
        .hasIndex = 18,
        .offset = 19,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "tutorialShownArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Tutorial_FieldNumber_TutorialShownArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Backup_Tutorial__storage_, tutorialShownArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Backup_Tutorial class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Backup_Tutorial__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Backup)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Backup_Stats

@implementation Backup_Stats

@dynamic eggTotalsOldArray, eggTotalsOldArray_Count;
@dynamic eggTotalsArray, eggTotalsArray_Count;
@dynamic hasUnlimitedChickensUses, unlimitedChickensUses;
@dynamic hasRefillUses, refillUses;
@dynamic hasWarp1Uses, warp1Uses;
@dynamic hasWarp8Uses, warp8Uses;
@dynamic hasBoostsUsed, boostsUsed;
@dynamic hasVideoDoublerUses, videoDoublerUses;
@dynamic hasDroneTakedowns, droneTakedowns;
@dynamic hasDroneTakedownsElite, droneTakedownsElite;
@dynamic hasNumPrestiges, numPrestiges;
@dynamic hasNumPiggyBreaks, numPiggyBreaks;
@dynamic hasIapPacksPurchased, iapPacksPurchased;
@dynamic hasPiggyFull, piggyFull;
@dynamic hasPiggyFoundFull, piggyFoundFull;
@dynamic hasTimePiggyFilledRealtime, timePiggyFilledRealtime;
@dynamic hasTimePiggyFullGametime, timePiggyFullGametime;
@dynamic hasLostPiggyIncrements, lostPiggyIncrements;

typedef struct Backup_Stats__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt64Array *eggTotalsOldArray;
  GPBDoubleArray *eggTotalsArray;
  uint64_t refillUses;
  uint64_t videoDoublerUses;
  uint64_t warp1Uses;
  uint64_t warp8Uses;
  uint64_t droneTakedowns;
  uint64_t unlimitedChickensUses;
  uint64_t numPrestiges;
  uint64_t droneTakedownsElite;
  uint64_t numPiggyBreaks;
  uint64_t iapPacksPurchased;
  uint64_t boostsUsed;
  double timePiggyFilledRealtime;
  double timePiggyFullGametime;
  uint64_t lostPiggyIncrements;
} Backup_Stats__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "eggTotalsOldArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Stats_FieldNumber_EggTotalsOldArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Backup_Stats__storage_, eggTotalsOldArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "refillUses",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Stats_FieldNumber_RefillUses,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Backup_Stats__storage_, refillUses),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "videoDoublerUses",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Stats_FieldNumber_VideoDoublerUses,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Backup_Stats__storage_, videoDoublerUses),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "warp1Uses",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Stats_FieldNumber_Warp1Uses,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Backup_Stats__storage_, warp1Uses),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "warp8Uses",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Stats_FieldNumber_Warp8Uses,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Backup_Stats__storage_, warp8Uses),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "droneTakedowns",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Stats_FieldNumber_DroneTakedowns,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Backup_Stats__storage_, droneTakedowns),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "unlimitedChickensUses",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Stats_FieldNumber_UnlimitedChickensUses,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Backup_Stats__storage_, unlimitedChickensUses),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "eggTotalsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Stats_FieldNumber_EggTotalsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Backup_Stats__storage_, eggTotalsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "numPrestiges",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Stats_FieldNumber_NumPrestiges,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Backup_Stats__storage_, numPrestiges),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "droneTakedownsElite",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Stats_FieldNumber_DroneTakedownsElite,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Backup_Stats__storage_, droneTakedownsElite),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "numPiggyBreaks",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Stats_FieldNumber_NumPiggyBreaks,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Backup_Stats__storage_, numPiggyBreaks),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "iapPacksPurchased",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Stats_FieldNumber_IapPacksPurchased,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Backup_Stats__storage_, iapPacksPurchased),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "boostsUsed",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Stats_FieldNumber_BoostsUsed,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Backup_Stats__storage_, boostsUsed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "piggyFull",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Stats_FieldNumber_PiggyFull,
        .hasIndex = 11,
        .offset = 12,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "piggyFoundFull",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Stats_FieldNumber_PiggyFoundFull,
        .hasIndex = 13,
        .offset = 14,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "timePiggyFilledRealtime",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Stats_FieldNumber_TimePiggyFilledRealtime,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(Backup_Stats__storage_, timePiggyFilledRealtime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "timePiggyFullGametime",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Stats_FieldNumber_TimePiggyFullGametime,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(Backup_Stats__storage_, timePiggyFullGametime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "lostPiggyIncrements",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Stats_FieldNumber_LostPiggyIncrements,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(Backup_Stats__storage_, lostPiggyIncrements),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Backup_Stats class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Backup_Stats__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\000egg_totals_OLD\000\004\004\201\244\000\005\004\201\244\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Backup)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Backup_Game

@implementation Backup_Game

@dynamic hasCurrentFarm, currentFarm;
@dynamic hasMaxEggReached, maxEggReached;
@dynamic hasGoldenEggsEarned, goldenEggsEarned;
@dynamic hasGoldenEggsSpent, goldenEggsSpent;
@dynamic hasUncliamedGoldenEggs, uncliamedGoldenEggs;
@dynamic hasSoulEggs, soulEggs;
@dynamic hasUnclaimedSoulEggs, unclaimedSoulEggs;
@dynamic hasSoulEggsD, soulEggsD;
@dynamic hasUnclaimedSoulEggsD, unclaimedSoulEggsD;
@dynamic hasEggsOfProphecy, eggsOfProphecy;
@dynamic hasUnclaimedEggsOfProphecy, unclaimedEggsOfProphecy;
@dynamic hasShellScriptsEarned, shellScriptsEarned;
@dynamic hasShellScriptsSpent, shellScriptsSpent;
@dynamic hasUnclaimedShellScripts, unclaimedShellScripts;
@dynamic hasPrestigeCashEarned, prestigeCashEarned;
@dynamic hasPrestigeSoulBoostCash, prestigeSoulBoostCash;
@dynamic hasLifetimeCashEarned, lifetimeCashEarned;
@dynamic hasPiggyBank, piggyBank;
@dynamic hasPiggyFullAlertShown, piggyFullAlertShown;
@dynamic hasPermitLevel, permitLevel;
@dynamic epicResearchArray, epicResearchArray_Count;
@dynamic hasHyperloopStation, hyperloopStation;
@dynamic hasNextDailyGiftTime, nextDailyGiftTime;
@dynamic hasLastDailyGiftCollectedDay, lastDailyGiftCollectedDay;
@dynamic hasNumDailyGiftsCollected, numDailyGiftsCollected;
@dynamic newsArray, newsArray_Count;
@dynamic hasLastNewsTime, lastNewsTime;
@dynamic hasCurrentMultiplier, currentMultiplier;
@dynamic hasCurrentMultiplierExpiration, currentMultiplierExpiration;
@dynamic achievementsArray, achievementsArray_Count;
@dynamic maxFarmSizeReachedArray, maxFarmSizeReachedArray_Count;
@dynamic eggMedalLevelArray, eggMedalLevelArray_Count;
@dynamic hasLongIdleNotificationSet, longIdleNotificationSet;
@dynamic hasLongIdleNotificationThreshold, longIdleNotificationThreshold;
@dynamic hasLongIdleReward, longIdleReward;
@dynamic boostsArray, boostsArray_Count;
@dynamic hasTotalTimeCheatsDetected, totalTimeCheatsDetected;
@dynamic hasForceEliteContracts, forceEliteContracts;
@dynamic hasNewPlayerEventEndTime, newPlayerEventEndTime;

typedef struct Backup_Game__storage_ {
  uint32_t _has_storage_[2];
  Egg maxEggReached;
  uint32_t permitLevel;
  uint32_t lastDailyGiftCollectedDay;
  uint32_t currentFarm;
  uint32_t numDailyGiftsCollected;
  uint32_t totalTimeCheatsDetected;
  NSMutableArray *epicResearchArray;
  NSMutableArray *newsArray;
  NSMutableArray *achievementsArray;
  GPBUInt64Array *maxFarmSizeReachedArray;
  GPBUInt32Array *eggMedalLevelArray;
  NSMutableArray *boostsArray;
  uint64_t goldenEggsEarned;
  uint64_t goldenEggsSpent;
  uint64_t soulEggs;
  double prestigeCashEarned;
  double lifetimeCashEarned;
  uint64_t piggyBank;
  double nextDailyGiftTime;
  double lastNewsTime;
  double currentMultiplier;
  double currentMultiplierExpiration;
  uint64_t uncliamedGoldenEggs;
  uint64_t unclaimedSoulEggs;
  uint64_t eggsOfProphecy;
  uint64_t unclaimedEggsOfProphecy;
  double longIdleNotificationThreshold;
  double longIdleReward;
  double prestigeSoulBoostCash;
  double soulEggsD;
  double unclaimedSoulEggsD;
  double newPlayerEventEndTime;
  uint64_t shellScriptsEarned;
  uint64_t shellScriptsSpent;
  uint64_t unclaimedShellScripts;
} Backup_Game__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = Egg_Edible,
        .core.name = "maxEggReached",
        .core.dataTypeSpecific.enumDescFunc = Egg_EnumDescriptor,
        .core.number = Backup_Game_FieldNumber_MaxEggReached,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, maxEggReached),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "goldenEggsEarned",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_GoldenEggsEarned,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, goldenEggsEarned),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "goldenEggsSpent",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_GoldenEggsSpent,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, goldenEggsSpent),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "soulEggs",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_SoulEggs,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, soulEggs),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "prestigeCashEarned",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_PrestigeCashEarned,
        .core.hasIndex = 14,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, prestigeCashEarned),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "lifetimeCashEarned",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_LifetimeCashEarned,
        .core.hasIndex = 16,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, lifetimeCashEarned),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "piggyBank",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_PiggyBank,
        .core.hasIndex = 17,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, piggyBank),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "permitLevel",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_PermitLevel,
        .core.hasIndex = 20,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, permitLevel),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "epicResearchArray",
        .core.dataTypeSpecific.clazz = GPBObjCClass(Backup_ResearchItem),
        .core.number = Backup_Game_FieldNumber_EpicResearchArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, epicResearchArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "nextDailyGiftTime",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_NextDailyGiftTime,
        .core.hasIndex = 23,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, nextDailyGiftTime),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "newsArray",
        .core.dataTypeSpecific.clazz = GPBObjCClass(Backup_NewsHeadline),
        .core.number = Backup_Game_FieldNumber_NewsArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, newsArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "lastNewsTime",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_LastNewsTime,
        .core.hasIndex = 26,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, lastNewsTime),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "currentMultiplier",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_CurrentMultiplier,
        .core.hasIndex = 27,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, currentMultiplier),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "currentMultiplierExpiration",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_CurrentMultiplierExpiration,
        .core.hasIndex = 28,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, currentMultiplierExpiration),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "achievementsArray",
        .core.dataTypeSpecific.clazz = GPBObjCClass(Backup_AchievementInfo),
        .core.number = Backup_Game_FieldNumber_AchievementsArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, achievementsArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "uncliamedGoldenEggs",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_UncliamedGoldenEggs,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, uncliamedGoldenEggs),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "unclaimedSoulEggs",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_UnclaimedSoulEggs,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, unclaimedSoulEggs),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "maxFarmSizeReachedArray",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_MaxFarmSizeReachedArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, maxFarmSizeReachedArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "eggMedalLevelArray",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_EggMedalLevelArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, eggMedalLevelArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "lastDailyGiftCollectedDay",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_LastDailyGiftCollectedDay,
        .core.hasIndex = 24,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, lastDailyGiftCollectedDay),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "currentFarm",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_CurrentFarm,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, currentFarm),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "eggsOfProphecy",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_EggsOfProphecy,
        .core.hasIndex = 9,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, eggsOfProphecy),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "unclaimedEggsOfProphecy",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_UnclaimedEggsOfProphecy,
        .core.hasIndex = 10,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, unclaimedEggsOfProphecy),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "longIdleNotificationSet",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_LongIdleNotificationSet,
        .core.hasIndex = 29,
        .core.offset = 30,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "longIdleNotificationThreshold",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_LongIdleNotificationThreshold,
        .core.hasIndex = 31,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, longIdleNotificationThreshold),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "longIdleReward",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_LongIdleReward,
        .core.hasIndex = 32,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, longIdleReward),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "numDailyGiftsCollected",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_NumDailyGiftsCollected,
        .core.hasIndex = 25,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, numDailyGiftsCollected),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "hyperloopStation",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_HyperloopStation,
        .core.hasIndex = 21,
        .core.offset = 22,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "boostsArray",
        .core.dataTypeSpecific.clazz = GPBObjCClass(Backup_OwnedBoost),
        .core.number = Backup_Game_FieldNumber_BoostsArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, boostsArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "piggyFullAlertShown",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_PiggyFullAlertShown,
        .core.hasIndex = 18,
        .core.offset = 19,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "totalTimeCheatsDetected",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_TotalTimeCheatsDetected,
        .core.hasIndex = 33,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, totalTimeCheatsDetected),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "prestigeSoulBoostCash",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_PrestigeSoulBoostCash,
        .core.hasIndex = 15,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, prestigeSoulBoostCash),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "soulEggsD",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_SoulEggsD,
        .core.hasIndex = 7,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, soulEggsD),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "unclaimedSoulEggsD",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_UnclaimedSoulEggsD,
        .core.hasIndex = 8,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, unclaimedSoulEggsD),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "forceEliteContracts",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_ForceEliteContracts,
        .core.hasIndex = 34,
        .core.offset = 35,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "newPlayerEventEndTime",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_NewPlayerEventEndTime,
        .core.hasIndex = 36,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, newPlayerEventEndTime),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "shellScriptsEarned",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_ShellScriptsEarned,
        .core.hasIndex = 11,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, shellScriptsEarned),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "shellScriptsSpent",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_ShellScriptsSpent,
        .core.hasIndex = 12,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, shellScriptsSpent),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "unclaimedShellScripts",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Game_FieldNumber_UnclaimedShellScripts,
        .core.hasIndex = 13,
        .core.offset = (uint32_t)offsetof(Backup_Game__storage_, unclaimedShellScripts),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Backup_Game class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(Backup_Game__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Backup)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Backup_Artifacts

@implementation Backup_Artifacts

@dynamic hasInfusing, infusing;
@dynamic hasItemBeingInfused, itemBeingInfused;
@dynamic hasSpecBeingInfused, specBeingInfused;
@dynamic hasEggTypeInfusing, eggTypeInfusing;
@dynamic hasInfusingEggsRequired, infusingEggsRequired;
@dynamic hasEggsInfused, eggsInfused;
@dynamic hasFlowPercentageArtifacts, flowPercentageArtifacts;
@dynamic hasFuelingEnabled, fuelingEnabled;
@dynamic hasTankFillingEnabled, tankFillingEnabled;
@dynamic hasTankLevel, tankLevel;
@dynamic tankFuelsArray, tankFuelsArray_Count;
@dynamic hasLastFueledShip, lastFueledShip;
@dynamic hasInventoryScore, inventoryScore;
@dynamic hasCraftingXp, craftingXp;
@dynamic hasEnabled, enabled;
@dynamic hasIntroShown, introShown;
@dynamic hasInfusingEnabledDeprecated, infusingEnabledDeprecated;

typedef struct Backup_Artifacts__storage_ {
  uint32_t _has_storage_[1];
  Egg eggTypeInfusing;
  MissionInfo_Spaceship lastFueledShip;
  uint32_t tankLevel;
  ArtifactInventoryItem *itemBeingInfused;
  ArtifactSpec *specBeingInfused;
  GPBDoubleArray *tankFuelsArray;
  double infusingEggsRequired;
  double eggsInfused;
  double flowPercentageArtifacts;
  double inventoryScore;
  double craftingXp;
} Backup_Artifacts__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueBool = NO,
        .core.name = "infusing",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Artifacts_FieldNumber_Infusing,
        .core.hasIndex = 0,
        .core.offset = 1,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "itemBeingInfused",
        .core.dataTypeSpecific.clazz = GPBObjCClass(ArtifactInventoryItem),
        .core.number = Backup_Artifacts_FieldNumber_ItemBeingInfused,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(Backup_Artifacts__storage_, itemBeingInfused),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = Egg_Edible,
        .core.name = "eggTypeInfusing",
        .core.dataTypeSpecific.enumDescFunc = Egg_EnumDescriptor,
        .core.number = Backup_Artifacts_FieldNumber_EggTypeInfusing,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(Backup_Artifacts__storage_, eggTypeInfusing),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "infusingEggsRequired",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Artifacts_FieldNumber_InfusingEggsRequired,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(Backup_Artifacts__storage_, infusingEggsRequired),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "eggsInfused",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Artifacts_FieldNumber_EggsInfused,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(Backup_Artifacts__storage_, eggsInfused),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueDouble = 0.5,
        .core.name = "flowPercentageArtifacts",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Artifacts_FieldNumber_FlowPercentageArtifacts,
        .core.hasIndex = 7,
        .core.offset = (uint32_t)offsetof(Backup_Artifacts__storage_, flowPercentageArtifacts),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueBool = YES,
        .core.name = "fuelingEnabled",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Artifacts_FieldNumber_FuelingEnabled,
        .core.hasIndex = 8,
        .core.offset = 9,  // Stored in _has_storage_ to save space.
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = YES,
        .core.name = "infusingEnabledDeprecated",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Artifacts_FieldNumber_InfusingEnabledDeprecated,
        .core.hasIndex = 20,
        .core.offset = 21,  // Stored in _has_storage_ to save space.
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueEnum = MissionInfo_Spaceship_ChickenOne,
        .core.name = "lastFueledShip",
        .core.dataTypeSpecific.enumDescFunc = MissionInfo_Spaceship_EnumDescriptor,
        .core.number = Backup_Artifacts_FieldNumber_LastFueledShip,
        .core.hasIndex = 13,
        .core.offset = (uint32_t)offsetof(Backup_Artifacts__storage_, lastFueledShip),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "inventoryScore",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Artifacts_FieldNumber_InventoryScore,
        .core.hasIndex = 14,
        .core.offset = (uint32_t)offsetof(Backup_Artifacts__storage_, inventoryScore),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "enabled",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Artifacts_FieldNumber_Enabled,
        .core.hasIndex = 16,
        .core.offset = 17,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "introShown",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Artifacts_FieldNumber_IntroShown,
        .core.hasIndex = 18,
        .core.offset = 19,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "specBeingInfused",
        .core.dataTypeSpecific.clazz = GPBObjCClass(ArtifactSpec),
        .core.number = Backup_Artifacts_FieldNumber_SpecBeingInfused,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(Backup_Artifacts__storage_, specBeingInfused),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "tankFillingEnabled",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Artifacts_FieldNumber_TankFillingEnabled,
        .core.hasIndex = 10,
        .core.offset = 11,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "tankLevel",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Artifacts_FieldNumber_TankLevel,
        .core.hasIndex = 12,
        .core.offset = (uint32_t)offsetof(Backup_Artifacts__storage_, tankLevel),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "tankFuelsArray",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Artifacts_FieldNumber_TankFuelsArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(Backup_Artifacts__storage_, tankFuelsArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "craftingXp",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Artifacts_FieldNumber_CraftingXp,
        .core.hasIndex = 15,
        .core.offset = (uint32_t)offsetof(Backup_Artifacts__storage_, craftingXp),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Backup_Artifacts class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(Backup_Artifacts__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\010\010\247\352\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Backup)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Backup_Shells

@implementation Backup_Shells

@dynamic hasIntroAlert, introAlert;
@dynamic hasContractsIntroAlert, contractsIntroAlert;
@dynamic numNewArray, numNewArray_Count;

typedef struct Backup_Shells__storage_ {
  uint32_t _has_storage_[1];
  GPBInt32Array *numNewArray;
} Backup_Shells__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "introAlert",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Shells_FieldNumber_IntroAlert,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "contractsIntroAlert",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Shells_FieldNumber_ContractsIntroAlert,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "numNewArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Shells_FieldNumber_NumNewArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Backup_Shells__storage_, numNewArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Backup_Shells class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Backup_Shells__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Backup)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Backup_Simulation

@implementation Backup_Simulation

@dynamic hasEggType, eggType;
@dynamic hasFarmType, farmType;
@dynamic hasContractId, contractId;
@dynamic hasCashEarned, cashEarned;
@dynamic hasCashSpent, cashSpent;
@dynamic hasUnclaimedCash, unclaimedCash;
@dynamic hasLastStepTime, lastStepTime;
@dynamic hasNumChickens, numChickens;
@dynamic hasNumChickensUnsettled, numChickensUnsettled;
@dynamic hasNumChickensRunning, numChickensRunning;
@dynamic hasEggsLaid, eggsLaid;
@dynamic hasEggsShipped, eggsShipped;
@dynamic hasEggsPaidFor, eggsPaidFor;
@dynamic hasSilosOwned, silosOwned;
@dynamic habsArray, habsArray_Count;
@dynamic habPopulationArray, habPopulationArray_Count;
@dynamic habPopulationIndoundArray, habPopulationIndoundArray_Count;
@dynamic habIncubatorPopuplationArray, habIncubatorPopuplationArray_Count;
@dynamic hasHatcheryPopulation, hatcheryPopulation;
@dynamic vehiclesArray, vehiclesArray_Count;
@dynamic trainLengthArray, trainLengthArray_Count;
@dynamic commonResearchArray, commonResearchArray_Count;
@dynamic activeBoostsArray, activeBoostsArray_Count;
@dynamic hasLastCashBoostTime, lastCashBoostTime;
@dynamic hasTimeCheatsDetected, timeCheatsDetected;
@dynamic hasTimeCheatDebt, timeCheatDebt;
@dynamic hasBoostTokensReceived, boostTokensReceived;
@dynamic hasBoostTokensSpent, boostTokensSpent;
@dynamic hasBoostTokensGiven, boostTokensGiven;
@dynamic hasUnclaimedBoostTokens, unclaimedBoostTokens;
@dynamic hasGametimeUntilNextBoostToken, gametimeUntilNextBoostToken;

typedef struct Backup_Simulation__storage_ {
  uint32_t _has_storage_[1];
  Egg eggType;
  uint32_t silosOwned;
  FarmType farmType;
  uint32_t timeCheatsDetected;
  uint32_t boostTokensReceived;
  uint32_t boostTokensSpent;
  uint32_t unclaimedBoostTokens;
  uint32_t boostTokensGiven;
  GPBUInt32Array *habsArray;
  GPBUInt64Array *habPopulationArray;
  GPBUInt64Array *habPopulationIndoundArray;
  GPBDoubleArray *habIncubatorPopuplationArray;
  GPBUInt32Array *vehiclesArray;
  NSMutableArray *commonResearchArray;
  NSString *contractId;
  GPBUInt32Array *trainLengthArray;
  NSMutableArray *activeBoostsArray;
  double cashEarned;
  double cashSpent;
  double unclaimedCash;
  double lastStepTime;
  uint64_t numChickens;
  uint64_t numChickensUnsettled;
  uint64_t numChickensRunning;
  double eggsLaid;
  double eggsPaidFor;
  double hatcheryPopulation;
  double timeCheatDebt;
  double gametimeUntilNextBoostToken;
  double eggsShipped;
  double lastCashBoostTime;
} Backup_Simulation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = Egg_Edible,
        .core.name = "eggType",
        .core.dataTypeSpecific.enumDescFunc = Egg_EnumDescriptor,
        .core.number = Backup_Simulation_FieldNumber_EggType,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(Backup_Simulation__storage_, eggType),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "cashEarned",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Simulation_FieldNumber_CashEarned,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(Backup_Simulation__storage_, cashEarned),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "cashSpent",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Simulation_FieldNumber_CashSpent,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(Backup_Simulation__storage_, cashSpent),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "unclaimedCash",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Simulation_FieldNumber_UnclaimedCash,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(Backup_Simulation__storage_, unclaimedCash),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "lastStepTime",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Simulation_FieldNumber_LastStepTime,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(Backup_Simulation__storage_, lastStepTime),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "numChickens",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Simulation_FieldNumber_NumChickens,
        .core.hasIndex = 7,
        .core.offset = (uint32_t)offsetof(Backup_Simulation__storage_, numChickens),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "numChickensUnsettled",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Simulation_FieldNumber_NumChickensUnsettled,
        .core.hasIndex = 8,
        .core.offset = (uint32_t)offsetof(Backup_Simulation__storage_, numChickensUnsettled),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "numChickensRunning",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Simulation_FieldNumber_NumChickensRunning,
        .core.hasIndex = 9,
        .core.offset = (uint32_t)offsetof(Backup_Simulation__storage_, numChickensRunning),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "eggsLaid",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Simulation_FieldNumber_EggsLaid,
        .core.hasIndex = 10,
        .core.offset = (uint32_t)offsetof(Backup_Simulation__storage_, eggsLaid),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "eggsPaidFor",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Simulation_FieldNumber_EggsPaidFor,
        .core.hasIndex = 12,
        .core.offset = (uint32_t)offsetof(Backup_Simulation__storage_, eggsPaidFor),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "silosOwned",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Simulation_FieldNumber_SilosOwned,
        .core.hasIndex = 13,
        .core.offset = (uint32_t)offsetof(Backup_Simulation__storage_, silosOwned),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "habsArray",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Simulation_FieldNumber_HabsArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(Backup_Simulation__storage_, habsArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "habPopulationArray",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Simulation_FieldNumber_HabPopulationArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(Backup_Simulation__storage_, habPopulationArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "habPopulationIndoundArray",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Simulation_FieldNumber_HabPopulationIndoundArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(Backup_Simulation__storage_, habPopulationIndoundArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "habIncubatorPopuplationArray",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Simulation_FieldNumber_HabIncubatorPopuplationArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(Backup_Simulation__storage_, habIncubatorPopuplationArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "hatcheryPopulation",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Simulation_FieldNumber_HatcheryPopulation,
        .core.hasIndex = 14,
        .core.offset = (uint32_t)offsetof(Backup_Simulation__storage_, hatcheryPopulation),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "vehiclesArray",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Simulation_FieldNumber_VehiclesArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(Backup_Simulation__storage_, vehiclesArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "commonResearchArray",
        .core.dataTypeSpecific.clazz = GPBObjCClass(Backup_ResearchItem),
        .core.number = Backup_Simulation_FieldNumber_CommonResearchArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(Backup_Simulation__storage_, commonResearchArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = FarmType_Empty,
        .core.name = "farmType",
        .core.dataTypeSpecific.enumDescFunc = FarmType_EnumDescriptor,
        .core.number = Backup_Simulation_FieldNumber_FarmType,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(Backup_Simulation__storage_, farmType),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "contractId",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Simulation_FieldNumber_ContractId,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(Backup_Simulation__storage_, contractId),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "trainLengthArray",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Simulation_FieldNumber_TrainLengthArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(Backup_Simulation__storage_, trainLengthArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "activeBoostsArray",
        .core.dataTypeSpecific.clazz = GPBObjCClass(Backup_ActiveBoost),
        .core.number = Backup_Simulation_FieldNumber_ActiveBoostsArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(Backup_Simulation__storage_, activeBoostsArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "timeCheatsDetected",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Simulation_FieldNumber_TimeCheatsDetected,
        .core.hasIndex = 16,
        .core.offset = (uint32_t)offsetof(Backup_Simulation__storage_, timeCheatsDetected),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "timeCheatDebt",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Simulation_FieldNumber_TimeCheatDebt,
        .core.hasIndex = 17,
        .core.offset = (uint32_t)offsetof(Backup_Simulation__storage_, timeCheatDebt),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "boostTokensReceived",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Simulation_FieldNumber_BoostTokensReceived,
        .core.hasIndex = 18,
        .core.offset = (uint32_t)offsetof(Backup_Simulation__storage_, boostTokensReceived),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "boostTokensSpent",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Simulation_FieldNumber_BoostTokensSpent,
        .core.hasIndex = 19,
        .core.offset = (uint32_t)offsetof(Backup_Simulation__storage_, boostTokensSpent),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "unclaimedBoostTokens",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Simulation_FieldNumber_UnclaimedBoostTokens,
        .core.hasIndex = 21,
        .core.offset = (uint32_t)offsetof(Backup_Simulation__storage_, unclaimedBoostTokens),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "boostTokensGiven",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Simulation_FieldNumber_BoostTokensGiven,
        .core.hasIndex = 20,
        .core.offset = (uint32_t)offsetof(Backup_Simulation__storage_, boostTokensGiven),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "gametimeUntilNextBoostToken",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Simulation_FieldNumber_GametimeUntilNextBoostToken,
        .core.hasIndex = 22,
        .core.offset = (uint32_t)offsetof(Backup_Simulation__storage_, gametimeUntilNextBoostToken),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "eggsShipped",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Simulation_FieldNumber_EggsShipped,
        .core.hasIndex = 11,
        .core.offset = (uint32_t)offsetof(Backup_Simulation__storage_, eggsShipped),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "lastCashBoostTime",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Simulation_FieldNumber_LastCashBoostTime,
        .core.hasIndex = 15,
        .core.offset = (uint32_t)offsetof(Backup_Simulation__storage_, lastCashBoostTime),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Backup_Simulation class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(Backup_Simulation__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Backup)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Backup_Mission

@implementation Backup_Mission

@dynamic hasCurrentMission, currentMission;
@dynamic hasReferenceValue, referenceValue;
@dynamic currentMissionsArray, currentMissionsArray_Count;
@dynamic missionsArray, missionsArray_Count;

typedef struct Backup_Mission__storage_ {
  uint32_t _has_storage_[1];
  NSString *currentMission;
  NSMutableArray *missionsArray;
  NSMutableArray *currentMissionsArray;
  double referenceValue;
} Backup_Mission__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "currentMission",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Mission_FieldNumber_CurrentMission,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Backup_Mission__storage_, currentMission),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "referenceValue",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Mission_FieldNumber_ReferenceValue,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Backup_Mission__storage_, referenceValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "missionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Backup_MissionInfo),
        .number = Backup_Mission_FieldNumber_MissionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Backup_Mission__storage_, missionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "currentMissionsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_Mission_FieldNumber_CurrentMissionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Backup_Mission__storage_, currentMissionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Backup_Mission class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Backup_Mission__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Backup)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Backup_Misc

@implementation Backup_Misc

@dynamic hasChickenBtnPrefBig, chickenBtnPrefBig;
@dynamic hasFreeHatcheryRefillGiven, freeHatcheryRefillGiven;
@dynamic hasLastShareFarmValue, lastShareFarmValue;
@dynamic hasLastShareSwarmFarmValue, lastShareSwarmFarmValue;
@dynamic hasLastShareSwarmSize, lastShareSwarmSize;
@dynamic hasLastPrestigeAlertSoulEggsDeprecated, lastPrestigeAlertSoulEggsDeprecated;
@dynamic hasFriendRank, friendRank;
@dynamic hasFriendRankPop, friendRankPop;
@dynamic hasGlobalRank, globalRank;
@dynamic hasGlobalRankPop, globalRankPop;
@dynamic hasChallengesAlert, challengesAlert;
@dynamic hasTrophyAlert, trophyAlert;
@dynamic hasArAlert, arAlert;
@dynamic hasContractsAlert, contractsAlert;
@dynamic hasCoopAlert, coopAlert;
@dynamic hasSwitchAlert, switchAlert;
@dynamic hasEggOfProphecyAlert, eggOfProphecyAlert;
@dynamic hasBoostTokenAlert, boostTokenAlert;
@dynamic hasSoulEggAlert, soulEggAlert;
@dynamic hasBackupReminderAlert, backupReminderAlert;

typedef struct Backup_Misc__storage_ {
  uint32_t _has_storage_[1];
  double lastShareFarmValue;
  double lastShareSwarmFarmValue;
  double lastShareSwarmSize;
  uint64_t friendRank;
  uint64_t friendRankPop;
  uint64_t globalRank;
  uint64_t globalRankPop;
  uint64_t lastPrestigeAlertSoulEggsDeprecated;
} Backup_Misc__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueBool = NO,
        .core.name = "chickenBtnPrefBig",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Misc_FieldNumber_ChickenBtnPrefBig,
        .core.hasIndex = 0,
        .core.offset = 1,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "freeHatcheryRefillGiven",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Misc_FieldNumber_FreeHatcheryRefillGiven,
        .core.hasIndex = 2,
        .core.offset = 3,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueDouble = 10000000,
        .core.name = "lastShareFarmValue",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Misc_FieldNumber_LastShareFarmValue,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(Backup_Misc__storage_, lastShareFarmValue),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueDouble = 10000000,
        .core.name = "lastShareSwarmFarmValue",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Misc_FieldNumber_LastShareSwarmFarmValue,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(Backup_Misc__storage_, lastShareSwarmFarmValue),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueDouble = 140,
        .core.name = "lastShareSwarmSize",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Misc_FieldNumber_LastShareSwarmSize,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(Backup_Misc__storage_, lastShareSwarmSize),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "friendRank",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Misc_FieldNumber_FriendRank,
        .core.hasIndex = 8,
        .core.offset = (uint32_t)offsetof(Backup_Misc__storage_, friendRank),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "friendRankPop",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Misc_FieldNumber_FriendRankPop,
        .core.hasIndex = 9,
        .core.offset = (uint32_t)offsetof(Backup_Misc__storage_, friendRankPop),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "globalRank",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Misc_FieldNumber_GlobalRank,
        .core.hasIndex = 10,
        .core.offset = (uint32_t)offsetof(Backup_Misc__storage_, globalRank),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "globalRankPop",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Misc_FieldNumber_GlobalRankPop,
        .core.hasIndex = 11,
        .core.offset = (uint32_t)offsetof(Backup_Misc__storage_, globalRankPop),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueUInt64 = 45ULL,
        .core.name = "lastPrestigeAlertSoulEggsDeprecated",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Misc_FieldNumber_LastPrestigeAlertSoulEggsDeprecated,
        .core.hasIndex = 7,
        .core.offset = (uint32_t)offsetof(Backup_Misc__storage_, lastPrestigeAlertSoulEggsDeprecated),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "trophyAlert",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Misc_FieldNumber_TrophyAlert,
        .core.hasIndex = 14,
        .core.offset = 15,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "arAlert",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Misc_FieldNumber_ArAlert,
        .core.hasIndex = 16,
        .core.offset = 17,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "contractsAlert",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Misc_FieldNumber_ContractsAlert,
        .core.hasIndex = 18,
        .core.offset = 19,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "coopAlert",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Misc_FieldNumber_CoopAlert,
        .core.hasIndex = 20,
        .core.offset = 21,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "switchAlert",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Misc_FieldNumber_SwitchAlert,
        .core.hasIndex = 22,
        .core.offset = 23,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "eggOfProphecyAlert",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Misc_FieldNumber_EggOfProphecyAlert,
        .core.hasIndex = 24,
        .core.offset = 25,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "boostTokenAlert",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Misc_FieldNumber_BoostTokenAlert,
        .core.hasIndex = 26,
        .core.offset = 27,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "soulEggAlert",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Misc_FieldNumber_SoulEggAlert,
        .core.hasIndex = 28,
        .core.offset = 29,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "backupReminderAlert",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Misc_FieldNumber_BackupReminderAlert,
        .core.hasIndex = 30,
        .core.offset = 31,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "challengesAlert",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Backup_Misc_FieldNumber_ChallengesAlert,
        .core.hasIndex = 12,
        .core.offset = 13,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Backup_Misc class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(Backup_Misc__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\n\004\250\245\244\244\352\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Backup)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Backup_ResearchItem

@implementation Backup_ResearchItem

@dynamic hasId_p, id_p;
@dynamic hasLevel, level;

typedef struct Backup_ResearchItem__storage_ {
  uint32_t _has_storage_[1];
  uint32_t level;
  NSString *id_p;
} Backup_ResearchItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_ResearchItem_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Backup_ResearchItem__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "level",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_ResearchItem_FieldNumber_Level,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Backup_ResearchItem__storage_, level),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Backup_ResearchItem class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Backup_ResearchItem__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Backup)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Backup_NewsHeadline

@implementation Backup_NewsHeadline

@dynamic hasId_p, id_p;
@dynamic hasRead, read;

typedef struct Backup_NewsHeadline__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
} Backup_NewsHeadline__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_NewsHeadline_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Backup_NewsHeadline__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "read",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_NewsHeadline_FieldNumber_Read,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Backup_NewsHeadline class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Backup_NewsHeadline__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Backup)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Backup_AchievementInfo

@implementation Backup_AchievementInfo

@dynamic hasId_p, id_p;
@dynamic hasAchieved, achieved;

typedef struct Backup_AchievementInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
} Backup_AchievementInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_AchievementInfo_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Backup_AchievementInfo__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "achieved",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_AchievementInfo_FieldNumber_Achieved,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Backup_AchievementInfo class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Backup_AchievementInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Backup)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Backup_ActiveBoost

@implementation Backup_ActiveBoost

@dynamic hasBoostId, boostId;
@dynamic hasTimeRemaining, timeRemaining;
@dynamic hasReferenceValue, referenceValue;

typedef struct Backup_ActiveBoost__storage_ {
  uint32_t _has_storage_[1];
  NSString *boostId;
  double timeRemaining;
  double referenceValue;
} Backup_ActiveBoost__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "boostId",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_ActiveBoost_FieldNumber_BoostId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Backup_ActiveBoost__storage_, boostId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeRemaining",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_ActiveBoost_FieldNumber_TimeRemaining,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Backup_ActiveBoost__storage_, timeRemaining),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "referenceValue",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_ActiveBoost_FieldNumber_ReferenceValue,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Backup_ActiveBoost__storage_, referenceValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Backup_ActiveBoost class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Backup_ActiveBoost__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Backup)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Backup_OwnedBoost

@implementation Backup_OwnedBoost

@dynamic hasBoostId, boostId;
@dynamic hasCount, count;

typedef struct Backup_OwnedBoost__storage_ {
  uint32_t _has_storage_[1];
  uint32_t count;
  NSString *boostId;
} Backup_OwnedBoost__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "boostId",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_OwnedBoost_FieldNumber_BoostId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Backup_OwnedBoost__storage_, boostId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "count",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_OwnedBoost_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Backup_OwnedBoost__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Backup_OwnedBoost class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Backup_OwnedBoost__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Backup)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Backup_MissionInfo

@implementation Backup_MissionInfo

@dynamic hasId_p, id_p;
@dynamic hasCompleted, completed;
@dynamic hasReferenceValue, referenceValue;

typedef struct Backup_MissionInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  double referenceValue;
} Backup_MissionInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_MissionInfo_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Backup_MissionInfo__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "completed",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_MissionInfo_FieldNumber_Completed,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "referenceValue",
        .dataTypeSpecific.clazz = Nil,
        .number = Backup_MissionInfo_FieldNumber_ReferenceValue,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Backup_MissionInfo__storage_, referenceValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Backup_MissionInfo class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Backup_MissionInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Backup)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EggIncFirstContactRequest

@implementation EggIncFirstContactRequest

@dynamic hasRinfo, rinfo;
@dynamic hasEiUserId, eiUserId;
@dynamic hasUserId, userId;
@dynamic hasGameServicesId, gameServicesId;
@dynamic hasDeviceId, deviceId;
@dynamic hasUsername, username;
@dynamic hasClientVersion, clientVersion;
@dynamic hasPlatform, platform;

typedef struct EggIncFirstContactRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t clientVersion;
  Platform platform;
  NSString *userId;
  NSString *eiUserId;
  NSString *deviceId;
  NSString *username;
  NSString *gameServicesId;
  BasicRequestInfo *rinfo;
} EggIncFirstContactRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "userId",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = EggIncFirstContactRequest_FieldNumber_UserId,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(EggIncFirstContactRequest__storage_, userId),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "clientVersion",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = EggIncFirstContactRequest_FieldNumber_ClientVersion,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(EggIncFirstContactRequest__storage_, clientVersion),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueEnum = Platform_Ios,
        .core.name = "platform",
        .core.dataTypeSpecific.enumDescFunc = Platform_EnumDescriptor,
        .core.number = EggIncFirstContactRequest_FieldNumber_Platform,
        .core.hasIndex = 7,
        .core.offset = (uint32_t)offsetof(EggIncFirstContactRequest__storage_, platform),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "eiUserId",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = EggIncFirstContactRequest_FieldNumber_EiUserId,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(EggIncFirstContactRequest__storage_, eiUserId),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "deviceId",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = EggIncFirstContactRequest_FieldNumber_DeviceId,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(EggIncFirstContactRequest__storage_, deviceId),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "username",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = EggIncFirstContactRequest_FieldNumber_Username,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(EggIncFirstContactRequest__storage_, username),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "gameServicesId",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = EggIncFirstContactRequest_FieldNumber_GameServicesId,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(EggIncFirstContactRequest__storage_, gameServicesId),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "rinfo",
        .core.dataTypeSpecific.clazz = GPBObjCClass(BasicRequestInfo),
        .core.number = EggIncFirstContactRequest_FieldNumber_Rinfo,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(EggIncFirstContactRequest__storage_, rinfo),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EggIncFirstContactRequest class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(EggIncFirstContactRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EggIncFirstContactResponse

@implementation EggIncFirstContactResponse

@dynamic hasEiUserId, eiUserId;
@dynamic idsTransferredArray, idsTransferredArray_Count;
@dynamic hasErrorCode, errorCode;
@dynamic hasErrorMessage, errorMessage;
@dynamic hasBackup, backup;

typedef struct EggIncFirstContactResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t errorCode;
  Backup *backup;
  NSString *eiUserId;
  NSMutableArray *idsTransferredArray;
  NSString *errorMessage;
} EggIncFirstContactResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "backup",
        .dataTypeSpecific.clazz = GPBObjCClass(Backup),
        .number = EggIncFirstContactResponse_FieldNumber_Backup,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EggIncFirstContactResponse__storage_, backup),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "eiUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = EggIncFirstContactResponse_FieldNumber_EiUserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EggIncFirstContactResponse__storage_, eiUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "idsTransferredArray",
        .dataTypeSpecific.clazz = Nil,
        .number = EggIncFirstContactResponse_FieldNumber_IdsTransferredArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EggIncFirstContactResponse__storage_, idsTransferredArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "errorCode",
        .dataTypeSpecific.clazz = Nil,
        .number = EggIncFirstContactResponse_FieldNumber_ErrorCode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EggIncFirstContactResponse__storage_, errorCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "errorMessage",
        .dataTypeSpecific.clazz = Nil,
        .number = EggIncFirstContactResponse_FieldNumber_ErrorMessage,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EggIncFirstContactResponse__storage_, errorMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EggIncFirstContactResponse class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EggIncFirstContactResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum EggIncFirstContactResponse_ErrorCodes

GPBEnumDescriptor *EggIncFirstContactResponse_ErrorCodes_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "NoError\000ExistingUserWGamerId\000UserNotFoun"
        "d\000BackupConflict\000";
    static const int32_t values[] = {
        EggIncFirstContactResponse_ErrorCodes_NoError,
        EggIncFirstContactResponse_ErrorCodes_ExistingUserWGamerId,
        EggIncFirstContactResponse_ErrorCodes_UserNotFound,
        EggIncFirstContactResponse_ErrorCodes_BackupConflict,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(EggIncFirstContactResponse_ErrorCodes)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:EggIncFirstContactResponse_ErrorCodes_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL EggIncFirstContactResponse_ErrorCodes_IsValidValue(int32_t value__) {
  switch (value__) {
    case EggIncFirstContactResponse_ErrorCodes_NoError:
    case EggIncFirstContactResponse_ErrorCodes_ExistingUserWGamerId:
    case EggIncFirstContactResponse_ErrorCodes_UserNotFound:
    case EggIncFirstContactResponse_ErrorCodes_BackupConflict:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - EggIncAdConfig

@implementation EggIncAdConfig

@dynamic networkPriorityArray, networkPriorityArray_Count;

typedef struct EggIncAdConfig__storage_ {
  uint32_t _has_storage_[1];
  GPBEnumArray *networkPriorityArray;
} EggIncAdConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "networkPriorityArray",
        .dataTypeSpecific.enumDescFunc = AdNetwork_EnumDescriptor,
        .number = EggIncAdConfig_FieldNumber_NetworkPriorityArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EggIncAdConfig__storage_, networkPriorityArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EggIncAdConfig class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EggIncAdConfig__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DailyGiftInfo

@implementation DailyGiftInfo

@dynamic hasCurrentDay, currentDay;
@dynamic hasSecondsToNextDay, secondsToNextDay;

typedef struct DailyGiftInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t currentDay;
  double secondsToNextDay;
} DailyGiftInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "currentDay",
        .dataTypeSpecific.clazz = Nil,
        .number = DailyGiftInfo_FieldNumber_CurrentDay,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DailyGiftInfo__storage_, currentDay),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "secondsToNextDay",
        .dataTypeSpecific.clazz = Nil,
        .number = DailyGiftInfo_FieldNumber_SecondsToNextDay,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DailyGiftInfo__storage_, secondsToNextDay),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DailyGiftInfo class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DailyGiftInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SalesInfoRequest

@implementation SalesInfoRequest

@dynamic hasUserId, userId;
@dynamic hasPiggyFull, piggyFull;
@dynamic hasPiggyFoundFull, piggyFoundFull;
@dynamic hasSecondsFullRealtime, secondsFullRealtime;
@dynamic hasSecondsFullGametime, secondsFullGametime;
@dynamic hasLostIncrements, lostIncrements;
@dynamic hasCurrentClientVersion, currentClientVersion;

typedef struct SalesInfoRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t lostIncrements;
  uint32_t currentClientVersion;
  NSString *userId;
  double secondsFullRealtime;
  double secondsFullGametime;
} SalesInfoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = SalesInfoRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SalesInfoRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "piggyFull",
        .dataTypeSpecific.clazz = Nil,
        .number = SalesInfoRequest_FieldNumber_PiggyFull,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "piggyFoundFull",
        .dataTypeSpecific.clazz = Nil,
        .number = SalesInfoRequest_FieldNumber_PiggyFoundFull,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "secondsFullRealtime",
        .dataTypeSpecific.clazz = Nil,
        .number = SalesInfoRequest_FieldNumber_SecondsFullRealtime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SalesInfoRequest__storage_, secondsFullRealtime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "secondsFullGametime",
        .dataTypeSpecific.clazz = Nil,
        .number = SalesInfoRequest_FieldNumber_SecondsFullGametime,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SalesInfoRequest__storage_, secondsFullGametime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "lostIncrements",
        .dataTypeSpecific.clazz = Nil,
        .number = SalesInfoRequest_FieldNumber_LostIncrements,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(SalesInfoRequest__storage_, lostIncrements),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "currentClientVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = SalesInfoRequest_FieldNumber_CurrentClientVersion,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(SalesInfoRequest__storage_, currentClientVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SalesInfoRequest class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SalesInfoRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IAPSaleEntry

@implementation IAPSaleEntry

@dynamic hasProductId, productId;
@dynamic hasSecondsRemaining, secondsRemaining;
@dynamic hasDiscountString, discountString;
@dynamic hasSaleId, saleId;

typedef struct IAPSaleEntry__storage_ {
  uint32_t _has_storage_[1];
  NSString *productId;
  NSString *discountString;
  NSString *saleId;
  double secondsRemaining;
} IAPSaleEntry__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "productId",
        .dataTypeSpecific.clazz = Nil,
        .number = IAPSaleEntry_FieldNumber_ProductId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IAPSaleEntry__storage_, productId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "secondsRemaining",
        .dataTypeSpecific.clazz = Nil,
        .number = IAPSaleEntry_FieldNumber_SecondsRemaining,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IAPSaleEntry__storage_, secondsRemaining),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "discountString",
        .dataTypeSpecific.clazz = Nil,
        .number = IAPSaleEntry_FieldNumber_DiscountString,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IAPSaleEntry__storage_, discountString),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "saleId",
        .dataTypeSpecific.clazz = Nil,
        .number = IAPSaleEntry_FieldNumber_SaleId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(IAPSaleEntry__storage_, saleId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IAPSaleEntry class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IAPSaleEntry__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SalesInfo

@implementation SalesInfo

@dynamic salesArray, salesArray_Count;

typedef struct SalesInfo__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *salesArray;
} SalesInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "salesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(IAPSaleEntry),
        .number = SalesInfo_FieldNumber_SalesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SalesInfo__storage_, salesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SalesInfo class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SalesInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EggIncEvent

@implementation EggIncEvent

@dynamic hasIdentifier, identifier;
@dynamic hasSecondsRemaining, secondsRemaining;
@dynamic hasType, type;
@dynamic hasMultiplier, multiplier;
@dynamic hasSubtitle, subtitle;
@dynamic hasStartTime, startTime;
@dynamic hasDuration, duration;

typedef struct EggIncEvent__storage_ {
  uint32_t _has_storage_[1];
  NSString *identifier;
  NSString *type;
  NSString *subtitle;
  double secondsRemaining;
  double multiplier;
  double startTime;
  double duration;
} EggIncEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.clazz = Nil,
        .number = EggIncEvent_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EggIncEvent__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "secondsRemaining",
        .dataTypeSpecific.clazz = Nil,
        .number = EggIncEvent_FieldNumber_SecondsRemaining,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EggIncEvent__storage_, secondsRemaining),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "type",
        .dataTypeSpecific.clazz = Nil,
        .number = EggIncEvent_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EggIncEvent__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "multiplier",
        .dataTypeSpecific.clazz = Nil,
        .number = EggIncEvent_FieldNumber_Multiplier,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EggIncEvent__storage_, multiplier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "subtitle",
        .dataTypeSpecific.clazz = Nil,
        .number = EggIncEvent_FieldNumber_Subtitle,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(EggIncEvent__storage_, subtitle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "startTime",
        .dataTypeSpecific.clazz = Nil,
        .number = EggIncEvent_FieldNumber_StartTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(EggIncEvent__storage_, startTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "duration",
        .dataTypeSpecific.clazz = Nil,
        .number = EggIncEvent_FieldNumber_Duration,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(EggIncEvent__storage_, duration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EggIncEvent class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EggIncEvent__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EggIncCurrentEvents

@implementation EggIncCurrentEvents

@dynamic eventsArray, eventsArray_Count;

typedef struct EggIncCurrentEvents__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *eventsArray;
} EggIncCurrentEvents__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "eventsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(EggIncEvent),
        .number = EggIncCurrentEvents_FieldNumber_EventsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EggIncCurrentEvents__storage_, eventsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EggIncCurrentEvents class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EggIncCurrentEvents__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeviceInfo

@implementation DeviceInfo

@dynamic hasDeviceId, deviceId;
@dynamic hasAdvertisingId, advertisingId;
@dynamic hasPlatform, platform;
@dynamic hasFormFactor, formFactor;
@dynamic hasDeviceName, deviceName;
@dynamic hasPlatformVersion, platformVersion;
@dynamic hasLocaleCountry, localeCountry;
@dynamic hasLocaleLanguage, localeLanguage;
@dynamic hasGpuVendor, gpuVendor;
@dynamic hasGpuModel, gpuModel;
@dynamic hasDeviceBucket, deviceBucket;
@dynamic hasScreenWidth, screenWidth;
@dynamic hasScreenHeight, screenHeight;

typedef struct DeviceInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t screenWidth;
  uint32_t screenHeight;
  NSString *deviceId;
  NSString *platform;
  NSString *formFactor;
  NSString *deviceName;
  NSString *platformVersion;
  NSString *localeCountry;
  NSString *localeLanguage;
  NSString *gpuVendor;
  NSString *gpuModel;
  NSString *deviceBucket;
  NSString *advertisingId;
} DeviceInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deviceId",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfo_FieldNumber_DeviceId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, deviceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "platform",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfo_FieldNumber_Platform,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, platform),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "formFactor",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfo_FieldNumber_FormFactor,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, formFactor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceName",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfo_FieldNumber_DeviceName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, deviceName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "platformVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfo_FieldNumber_PlatformVersion,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, platformVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "localeCountry",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfo_FieldNumber_LocaleCountry,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, localeCountry),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "localeLanguage",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfo_FieldNumber_LocaleLanguage,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, localeLanguage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gpuVendor",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfo_FieldNumber_GpuVendor,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, gpuVendor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gpuModel",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfo_FieldNumber_GpuModel,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, gpuModel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceBucket",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfo_FieldNumber_DeviceBucket,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, deviceBucket),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "screenWidth",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfo_FieldNumber_ScreenWidth,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, screenWidth),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "screenHeight",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfo_FieldNumber_ScreenHeight,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, screenHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "advertisingId",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfo_FieldNumber_AdvertisingId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, advertisingId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeviceInfo class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeviceInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AppInfo

@implementation AppInfo

@dynamic hasVersionStr, versionStr;
@dynamic hasSessions, sessions;
@dynamic hasNumPrestiges, numPrestiges;
@dynamic hasSoulEggs, soulEggs;
@dynamic hasCurrentEgg, currentEgg;
@dynamic hasGoldEarned, goldEarned;
@dynamic hasGoldSpent, goldSpent;
@dynamic hasCurrentMission, currentMission;
@dynamic hasPiggySize, piggySize;
@dynamic hasNumPiggyBreaks, numPiggyBreaks;
@dynamic hasVerifiedPiggyBreaks, verifiedPiggyBreaks;
@dynamic hasIapPacksPurchased, iapPacksPurchased;
@dynamic hasPermitLevel, permitLevel;
@dynamic hasVideoDoublerUses, videoDoublerUses;
@dynamic hasDroneTakedowns, droneTakedowns;
@dynamic hasDroneTakedownsElite, droneTakedownsElite;
@dynamic hasTrophiesUnlocked, trophiesUnlocked;
@dynamic hasEggLevel, eggLevel;
@dynamic hasStruggleFactor, struggleFactor;
@dynamic hasPiggyFull, piggyFull;
@dynamic hasPiggyFoundFull, piggyFoundFull;
@dynamic hasTimePiggyFullRealtime, timePiggyFullRealtime;
@dynamic hasTimePiggyFullGametime, timePiggyFullGametime;
@dynamic hasLostPiggyIncrements, lostPiggyIncrements;
@dynamic hasSaleId, saleId;
@dynamic hasUnlimitedChickensUses, unlimitedChickensUses;
@dynamic hasRefillUses, refillUses;
@dynamic hasShortWarpUses, shortWarpUses;
@dynamic hasLongWarpUses, longWarpUses;

typedef struct AppInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t sessions;
  uint32_t numPrestiges;
  uint32_t currentEgg;
  uint32_t currentMission;
  uint32_t piggySize;
  uint32_t permitLevel;
  float eggLevel;
  float struggleFactor;
  NSString *versionStr;
  NSString *saleId;
  uint64_t soulEggs;
  uint64_t goldEarned;
  uint64_t goldSpent;
  uint64_t numPiggyBreaks;
  uint64_t iapPacksPurchased;
  uint64_t unlimitedChickensUses;
  uint64_t refillUses;
  uint64_t videoDoublerUses;
  uint64_t shortWarpUses;
  uint64_t longWarpUses;
  uint64_t droneTakedowns;
  uint64_t droneTakedownsElite;
  double timePiggyFullRealtime;
  double timePiggyFullGametime;
  uint64_t lostPiggyIncrements;
  uint64_t verifiedPiggyBreaks;
} AppInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "versionStr",
        .dataTypeSpecific.clazz = Nil,
        .number = AppInfo_FieldNumber_VersionStr,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AppInfo__storage_, versionStr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sessions",
        .dataTypeSpecific.clazz = Nil,
        .number = AppInfo_FieldNumber_Sessions,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AppInfo__storage_, sessions),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "numPrestiges",
        .dataTypeSpecific.clazz = Nil,
        .number = AppInfo_FieldNumber_NumPrestiges,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AppInfo__storage_, numPrestiges),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "soulEggs",
        .dataTypeSpecific.clazz = Nil,
        .number = AppInfo_FieldNumber_SoulEggs,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AppInfo__storage_, soulEggs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "currentEgg",
        .dataTypeSpecific.clazz = Nil,
        .number = AppInfo_FieldNumber_CurrentEgg,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AppInfo__storage_, currentEgg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "goldEarned",
        .dataTypeSpecific.clazz = Nil,
        .number = AppInfo_FieldNumber_GoldEarned,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AppInfo__storage_, goldEarned),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "goldSpent",
        .dataTypeSpecific.clazz = Nil,
        .number = AppInfo_FieldNumber_GoldSpent,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(AppInfo__storage_, goldSpent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "currentMission",
        .dataTypeSpecific.clazz = Nil,
        .number = AppInfo_FieldNumber_CurrentMission,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(AppInfo__storage_, currentMission),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "piggySize",
        .dataTypeSpecific.clazz = Nil,
        .number = AppInfo_FieldNumber_PiggySize,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(AppInfo__storage_, piggySize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "numPiggyBreaks",
        .dataTypeSpecific.clazz = Nil,
        .number = AppInfo_FieldNumber_NumPiggyBreaks,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(AppInfo__storage_, numPiggyBreaks),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "iapPacksPurchased",
        .dataTypeSpecific.clazz = Nil,
        .number = AppInfo_FieldNumber_IapPacksPurchased,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(AppInfo__storage_, iapPacksPurchased),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "permitLevel",
        .dataTypeSpecific.clazz = Nil,
        .number = AppInfo_FieldNumber_PermitLevel,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(AppInfo__storage_, permitLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "unlimitedChickensUses",
        .dataTypeSpecific.clazz = Nil,
        .number = AppInfo_FieldNumber_UnlimitedChickensUses,
        .hasIndex = 28,
        .offset = (uint32_t)offsetof(AppInfo__storage_, unlimitedChickensUses),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "refillUses",
        .dataTypeSpecific.clazz = Nil,
        .number = AppInfo_FieldNumber_RefillUses,
        .hasIndex = 29,
        .offset = (uint32_t)offsetof(AppInfo__storage_, refillUses),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "videoDoublerUses",
        .dataTypeSpecific.clazz = Nil,
        .number = AppInfo_FieldNumber_VideoDoublerUses,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(AppInfo__storage_, videoDoublerUses),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "shortWarpUses",
        .dataTypeSpecific.clazz = Nil,
        .number = AppInfo_FieldNumber_ShortWarpUses,
        .hasIndex = 30,
        .offset = (uint32_t)offsetof(AppInfo__storage_, shortWarpUses),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "longWarpUses",
        .dataTypeSpecific.clazz = Nil,
        .number = AppInfo_FieldNumber_LongWarpUses,
        .hasIndex = 31,
        .offset = (uint32_t)offsetof(AppInfo__storage_, longWarpUses),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "droneTakedowns",
        .dataTypeSpecific.clazz = Nil,
        .number = AppInfo_FieldNumber_DroneTakedowns,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(AppInfo__storage_, droneTakedowns),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "droneTakedownsElite",
        .dataTypeSpecific.clazz = Nil,
        .number = AppInfo_FieldNumber_DroneTakedownsElite,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(AppInfo__storage_, droneTakedownsElite),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "trophiesUnlocked",
        .dataTypeSpecific.clazz = Nil,
        .number = AppInfo_FieldNumber_TrophiesUnlocked,
        .hasIndex = 16,
        .offset = 17,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "eggLevel",
        .dataTypeSpecific.clazz = Nil,
        .number = AppInfo_FieldNumber_EggLevel,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(AppInfo__storage_, eggLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "struggleFactor",
        .dataTypeSpecific.clazz = Nil,
        .number = AppInfo_FieldNumber_StruggleFactor,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(AppInfo__storage_, struggleFactor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "piggyFull",
        .dataTypeSpecific.clazz = Nil,
        .number = AppInfo_FieldNumber_PiggyFull,
        .hasIndex = 20,
        .offset = 21,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "piggyFoundFull",
        .dataTypeSpecific.clazz = Nil,
        .number = AppInfo_FieldNumber_PiggyFoundFull,
        .hasIndex = 22,
        .offset = 23,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "timePiggyFullRealtime",
        .dataTypeSpecific.clazz = Nil,
        .number = AppInfo_FieldNumber_TimePiggyFullRealtime,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(AppInfo__storage_, timePiggyFullRealtime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "timePiggyFullGametime",
        .dataTypeSpecific.clazz = Nil,
        .number = AppInfo_FieldNumber_TimePiggyFullGametime,
        .hasIndex = 25,
        .offset = (uint32_t)offsetof(AppInfo__storage_, timePiggyFullGametime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "lostPiggyIncrements",
        .dataTypeSpecific.clazz = Nil,
        .number = AppInfo_FieldNumber_LostPiggyIncrements,
        .hasIndex = 26,
        .offset = (uint32_t)offsetof(AppInfo__storage_, lostPiggyIncrements),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "saleId",
        .dataTypeSpecific.clazz = Nil,
        .number = AppInfo_FieldNumber_SaleId,
        .hasIndex = 27,
        .offset = (uint32_t)offsetof(AppInfo__storage_, saleId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "verifiedPiggyBreaks",
        .dataTypeSpecific.clazz = Nil,
        .number = AppInfo_FieldNumber_VerifiedPiggyBreaks,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(AppInfo__storage_, verifiedPiggyBreaks),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AppInfo class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AppInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ActionKeyValuePair

@implementation ActionKeyValuePair

@dynamic hasKey, key;
@dynamic hasValue, value;

typedef struct ActionKeyValuePair__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
  NSString *value;
} ActionKeyValuePair__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = ActionKeyValuePair_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ActionKeyValuePair__storage_, key),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = ActionKeyValuePair_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ActionKeyValuePair__storage_, value),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ActionKeyValuePair class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ActionKeyValuePair__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GenericAction

@implementation GenericAction

@dynamic hasUserId, userId;
@dynamic hasAdvertisingId, advertisingId;
@dynamic hasApproxTimeDep, approxTimeDep;
@dynamic hasApproxTime, approxTime;
@dynamic hasActionName, actionName;
@dynamic dataArray, dataArray_Count;
@dynamic hasApp, app;
@dynamic hasDevice, device;

typedef struct GenericAction__storage_ {
  uint32_t _has_storage_[1];
  float approxTimeDep;
  NSString *userId;
  NSString *actionName;
  NSMutableArray *dataArray;
  AppInfo *app;
  DeviceInfo *device;
  NSString *advertisingId;
  double approxTime;
} GenericAction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = GenericAction_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GenericAction__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "approxTimeDep",
        .dataTypeSpecific.clazz = Nil,
        .number = GenericAction_FieldNumber_ApproxTimeDep,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GenericAction__storage_, approxTimeDep),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "actionName",
        .dataTypeSpecific.clazz = Nil,
        .number = GenericAction_FieldNumber_ActionName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GenericAction__storage_, actionName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dataArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ActionKeyValuePair),
        .number = GenericAction_FieldNumber_DataArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GenericAction__storage_, dataArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "app",
        .dataTypeSpecific.clazz = GPBObjCClass(AppInfo),
        .number = GenericAction_FieldNumber_App,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GenericAction__storage_, app),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "device",
        .dataTypeSpecific.clazz = GPBObjCClass(DeviceInfo),
        .number = GenericAction_FieldNumber_Device,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GenericAction__storage_, device),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "advertisingId",
        .dataTypeSpecific.clazz = Nil,
        .number = GenericAction_FieldNumber_AdvertisingId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GenericAction__storage_, advertisingId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "approxTime",
        .dataTypeSpecific.clazz = Nil,
        .number = GenericAction_FieldNumber_ApproxTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GenericAction__storage_, approxTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GenericAction class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GenericAction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\006\244\343\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GenericActionBatchRequest

@implementation GenericActionBatchRequest

@dynamic hasRinfo, rinfo;
@dynamic actionsArray, actionsArray_Count;

typedef struct GenericActionBatchRequest__storage_ {
  uint32_t _has_storage_[1];
  BasicRequestInfo *rinfo;
  NSMutableArray *actionsArray;
} GenericActionBatchRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rinfo",
        .dataTypeSpecific.clazz = GPBObjCClass(BasicRequestInfo),
        .number = GenericActionBatchRequest_FieldNumber_Rinfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GenericActionBatchRequest__storage_, rinfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "actionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GenericAction),
        .number = GenericActionBatchRequest_FieldNumber_ActionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GenericActionBatchRequest__storage_, actionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GenericActionBatchRequest class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GenericActionBatchRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VerifyPurchaseRequest

@implementation VerifyPurchaseRequest

@dynamic hasRinfo, rinfo;
@dynamic hasSku, sku;
@dynamic hasTransactionId, transactionId;
@dynamic hasReceipt, receipt;
@dynamic hasPlatform, platform;
@dynamic hasSandbox, sandbox;
@dynamic hasLog, log;

typedef struct VerifyPurchaseRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *sku;
  NSString *transactionId;
  NSString *receipt;
  NSString *platform;
  GenericAction *log;
  BasicRequestInfo *rinfo;
} VerifyPurchaseRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sku",
        .dataTypeSpecific.clazz = Nil,
        .number = VerifyPurchaseRequest_FieldNumber_Sku,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VerifyPurchaseRequest__storage_, sku),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "transactionId",
        .dataTypeSpecific.clazz = Nil,
        .number = VerifyPurchaseRequest_FieldNumber_TransactionId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VerifyPurchaseRequest__storage_, transactionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "receipt",
        .dataTypeSpecific.clazz = Nil,
        .number = VerifyPurchaseRequest_FieldNumber_Receipt,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(VerifyPurchaseRequest__storage_, receipt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "platform",
        .dataTypeSpecific.clazz = Nil,
        .number = VerifyPurchaseRequest_FieldNumber_Platform,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(VerifyPurchaseRequest__storage_, platform),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "log",
        .dataTypeSpecific.clazz = GPBObjCClass(GenericAction),
        .number = VerifyPurchaseRequest_FieldNumber_Log,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(VerifyPurchaseRequest__storage_, log),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rinfo",
        .dataTypeSpecific.clazz = GPBObjCClass(BasicRequestInfo),
        .number = VerifyPurchaseRequest_FieldNumber_Rinfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VerifyPurchaseRequest__storage_, rinfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sandbox",
        .dataTypeSpecific.clazz = Nil,
        .number = VerifyPurchaseRequest_FieldNumber_Sandbox,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VerifyPurchaseRequest class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VerifyPurchaseRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VerifyPurchaseResponse

@implementation VerifyPurchaseResponse

@dynamic hasVerified, verified;
@dynamic hasMessage, message;

typedef struct VerifyPurchaseResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *message;
} VerifyPurchaseResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "verified",
        .dataTypeSpecific.clazz = Nil,
        .number = VerifyPurchaseResponse_FieldNumber_Verified,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = Nil,
        .number = VerifyPurchaseResponse_FieldNumber_Message,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VerifyPurchaseResponse__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VerifyPurchaseResponse class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VerifyPurchaseResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CurrencyFlowLog

@implementation CurrencyFlowLog

@dynamic hasUserId, userId;
@dynamic hasApproxTime, approxTime;
@dynamic hasCurrency, currency;
@dynamic hasAmount, amount;
@dynamic hasLocation, location;
@dynamic hasVersion, version;
@dynamic hasPlatform, platform;
@dynamic hasSoulEggs, soulEggs;
@dynamic hasTicketsSpent, ticketsSpent;
@dynamic hasGoldSpent, goldSpent;

typedef struct CurrencyFlowLog__storage_ {
  uint32_t _has_storage_[1];
  RewardType currency;
  NSString *userId;
  NSString *location;
  NSString *version;
  NSString *platform;
  double approxTime;
  int64_t amount;
  double soulEggs;
  uint64_t ticketsSpent;
  uint64_t goldSpent;
} CurrencyFlowLog__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "userId",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = CurrencyFlowLog_FieldNumber_UserId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(CurrencyFlowLog__storage_, userId),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "approxTime",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = CurrencyFlowLog_FieldNumber_ApproxTime,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(CurrencyFlowLog__storage_, approxTime),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueEnum = RewardType_Cash,
        .core.name = "currency",
        .core.dataTypeSpecific.enumDescFunc = RewardType_EnumDescriptor,
        .core.number = CurrencyFlowLog_FieldNumber_Currency,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(CurrencyFlowLog__storage_, currency),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueInt64 = 0LL,
        .core.name = "amount",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = CurrencyFlowLog_FieldNumber_Amount,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(CurrencyFlowLog__storage_, amount),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeInt64,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "location",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = CurrencyFlowLog_FieldNumber_Location,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(CurrencyFlowLog__storage_, location),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "version",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = CurrencyFlowLog_FieldNumber_Version,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(CurrencyFlowLog__storage_, version),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "platform",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = CurrencyFlowLog_FieldNumber_Platform,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(CurrencyFlowLog__storage_, platform),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "soulEggs",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = CurrencyFlowLog_FieldNumber_SoulEggs,
        .core.hasIndex = 7,
        .core.offset = (uint32_t)offsetof(CurrencyFlowLog__storage_, soulEggs),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "ticketsSpent",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = CurrencyFlowLog_FieldNumber_TicketsSpent,
        .core.hasIndex = 8,
        .core.offset = (uint32_t)offsetof(CurrencyFlowLog__storage_, ticketsSpent),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "goldSpent",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = CurrencyFlowLog_FieldNumber_GoldSpent,
        .core.hasIndex = 9,
        .core.offset = (uint32_t)offsetof(CurrencyFlowLog__storage_, goldSpent),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CurrencyFlowLog class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(CurrencyFlowLog__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CurrencyFlowBatchRequest

@implementation CurrencyFlowBatchRequest

@dynamic hasRinfo, rinfo;
@dynamic logsArray, logsArray_Count;

typedef struct CurrencyFlowBatchRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *logsArray;
  BasicRequestInfo *rinfo;
} CurrencyFlowBatchRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "logsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(CurrencyFlowLog),
        .number = CurrencyFlowBatchRequest_FieldNumber_LogsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CurrencyFlowBatchRequest__storage_, logsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rinfo",
        .dataTypeSpecific.clazz = GPBObjCClass(BasicRequestInfo),
        .number = CurrencyFlowBatchRequest_FieldNumber_Rinfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CurrencyFlowBatchRequest__storage_, rinfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CurrencyFlowBatchRequest class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CurrencyFlowBatchRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Reward

@implementation Reward

@dynamic hasRewardType, rewardType;
@dynamic hasRewardSubType, rewardSubType;
@dynamic hasRewardAmount, rewardAmount;

typedef struct Reward__storage_ {
  uint32_t _has_storage_[1];
  RewardType rewardType;
  NSString *rewardSubType;
  double rewardAmount;
} Reward__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = RewardType_Cash,
        .core.name = "rewardType",
        .core.dataTypeSpecific.enumDescFunc = RewardType_EnumDescriptor,
        .core.number = Reward_FieldNumber_RewardType,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(Reward__storage_, rewardType),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "rewardSubType",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Reward_FieldNumber_RewardSubType,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(Reward__storage_, rewardSubType),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "rewardAmount",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Reward_FieldNumber_RewardAmount,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(Reward__storage_, rewardAmount),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Reward class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(Reward__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Contract

@implementation Contract

@dynamic hasIdentifier, identifier;
@dynamic hasName, name;
@dynamic hasDescription_p, description_p;
@dynamic hasEgg, egg;
@dynamic goalsArray, goalsArray_Count;
@dynamic goalSetsArray, goalSetsArray_Count;
@dynamic hasCoopAllowed, coopAllowed;
@dynamic hasMaxCoopSize, maxCoopSize;
@dynamic hasMaxBoosts, maxBoosts;
@dynamic hasMinutesPerToken, minutesPerToken;
@dynamic hasChickenRunCooldownMinutes, chickenRunCooldownMinutes;
@dynamic hasStartTime, startTime;
@dynamic hasExpirationTime, expirationTime;
@dynamic hasLengthSeconds, lengthSeconds;
@dynamic hasMaxSoulEggs, maxSoulEggs;
@dynamic hasMinClientVersion, minClientVersion;
@dynamic hasLeggacy, leggacy;
@dynamic hasDebug, debug;

typedef struct Contract__storage_ {
  uint32_t _has_storage_[1];
  Egg egg;
  uint32_t maxCoopSize;
  uint32_t maxBoosts;
  uint32_t minClientVersion;
  NSString *identifier;
  NSMutableArray *goalsArray;
  NSString *name;
  NSString *description_p;
  NSMutableArray *goalSetsArray;
  double expirationTime;
  double lengthSeconds;
  double maxSoulEggs;
  double minutesPerToken;
  double startTime;
  double chickenRunCooldownMinutes;
} Contract__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "identifier",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Contract_FieldNumber_Identifier,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(Contract__storage_, identifier),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = Egg_Edible,
        .core.name = "egg",
        .core.dataTypeSpecific.enumDescFunc = Egg_EnumDescriptor,
        .core.number = Contract_FieldNumber_Egg,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(Contract__storage_, egg),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "goalsArray",
        .core.dataTypeSpecific.clazz = GPBObjCClass(Contract_Goal),
        .core.number = Contract_FieldNumber_GoalsArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(Contract__storage_, goalsArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "coopAllowed",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Contract_FieldNumber_CoopAllowed,
        .core.hasIndex = 4,
        .core.offset = 5,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "maxCoopSize",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Contract_FieldNumber_MaxCoopSize,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(Contract__storage_, maxCoopSize),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "expirationTime",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Contract_FieldNumber_ExpirationTime,
        .core.hasIndex = 11,
        .core.offset = (uint32_t)offsetof(Contract__storage_, expirationTime),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "lengthSeconds",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Contract_FieldNumber_LengthSeconds,
        .core.hasIndex = 12,
        .core.offset = (uint32_t)offsetof(Contract__storage_, lengthSeconds),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "name",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Contract_FieldNumber_Name,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(Contract__storage_, name),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "description_p",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Contract_FieldNumber_Description_p,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(Contract__storage_, description_p),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "debug",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Contract_FieldNumber_Debug,
        .core.hasIndex = 17,
        .core.offset = 18,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "maxBoosts",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Contract_FieldNumber_MaxBoosts,
        .core.hasIndex = 7,
        .core.offset = (uint32_t)offsetof(Contract__storage_, maxBoosts),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "maxSoulEggs",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Contract_FieldNumber_MaxSoulEggs,
        .core.hasIndex = 13,
        .core.offset = (uint32_t)offsetof(Contract__storage_, maxSoulEggs),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "minClientVersion",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Contract_FieldNumber_MinClientVersion,
        .core.hasIndex = 14,
        .core.offset = (uint32_t)offsetof(Contract__storage_, minClientVersion),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueDouble = 60,
        .core.name = "minutesPerToken",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Contract_FieldNumber_MinutesPerToken,
        .core.hasIndex = 8,
        .core.offset = (uint32_t)offsetof(Contract__storage_, minutesPerToken),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "goalSetsArray",
        .core.dataTypeSpecific.clazz = GPBObjCClass(Contract_GoalSet),
        .core.number = Contract_FieldNumber_GoalSetsArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(Contract__storage_, goalSetsArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "startTime",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Contract_FieldNumber_StartTime,
        .core.hasIndex = 10,
        .core.offset = (uint32_t)offsetof(Contract__storage_, startTime),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueDouble = 60,
        .core.name = "chickenRunCooldownMinutes",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Contract_FieldNumber_ChickenRunCooldownMinutes,
        .core.hasIndex = 9,
        .core.offset = (uint32_t)offsetof(Contract__storage_, chickenRunCooldownMinutes),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "leggacy",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Contract_FieldNumber_Leggacy,
        .core.hasIndex = 15,
        .core.offset = 16,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Contract class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(Contract__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Contract_Goal

@implementation Contract_Goal

@dynamic hasType, type;
@dynamic hasTargetAmount, targetAmount;
@dynamic hasRewardType, rewardType;
@dynamic hasRewardSubType, rewardSubType;
@dynamic hasRewardAmount, rewardAmount;
@dynamic hasTargetSoulEggs, targetSoulEggs;

typedef struct Contract_Goal__storage_ {
  uint32_t _has_storage_[1];
  GoalType type;
  RewardType rewardType;
  NSString *rewardSubType;
  double targetAmount;
  double rewardAmount;
  double targetSoulEggs;
} Contract_Goal__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = GoalType_EggsLaid,
        .core.name = "type",
        .core.dataTypeSpecific.enumDescFunc = GoalType_EnumDescriptor,
        .core.number = Contract_Goal_FieldNumber_Type,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(Contract_Goal__storage_, type),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "targetAmount",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Contract_Goal_FieldNumber_TargetAmount,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(Contract_Goal__storage_, targetAmount),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueEnum = RewardType_Cash,
        .core.name = "rewardType",
        .core.dataTypeSpecific.enumDescFunc = RewardType_EnumDescriptor,
        .core.number = Contract_Goal_FieldNumber_RewardType,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(Contract_Goal__storage_, rewardType),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "rewardSubType",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Contract_Goal_FieldNumber_RewardSubType,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(Contract_Goal__storage_, rewardSubType),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "rewardAmount",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Contract_Goal_FieldNumber_RewardAmount,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(Contract_Goal__storage_, rewardAmount),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "targetSoulEggs",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Contract_Goal_FieldNumber_TargetSoulEggs,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(Contract_Goal__storage_, targetSoulEggs),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Contract_Goal class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(Contract_Goal__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Contract)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Contract_GoalSet

@implementation Contract_GoalSet

@dynamic goalsArray, goalsArray_Count;

typedef struct Contract_GoalSet__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *goalsArray;
} Contract_GoalSet__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "goalsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Contract_Goal),
        .number = Contract_GoalSet_FieldNumber_GoalsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Contract_GoalSet__storage_, goalsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Contract_GoalSet class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Contract_GoalSet__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Contract)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BasicRequestInfo

@implementation BasicRequestInfo

@dynamic hasEiUserId, eiUserId;
@dynamic hasClientVersion, clientVersion;
@dynamic hasVersion, version;
@dynamic hasBuild, build;
@dynamic hasPlatform, platform;
@dynamic hasCountry, country;
@dynamic hasLanguage, language;
@dynamic hasDebug, debug;

typedef struct BasicRequestInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t clientVersion;
  NSString *eiUserId;
  NSString *version;
  NSString *build;
  NSString *platform;
  NSString *country;
  NSString *language;
} BasicRequestInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "eiUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = BasicRequestInfo_FieldNumber_EiUserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BasicRequestInfo__storage_, eiUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clientVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = BasicRequestInfo_FieldNumber_ClientVersion,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BasicRequestInfo__storage_, clientVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "version",
        .dataTypeSpecific.clazz = Nil,
        .number = BasicRequestInfo_FieldNumber_Version,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BasicRequestInfo__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "build",
        .dataTypeSpecific.clazz = Nil,
        .number = BasicRequestInfo_FieldNumber_Build,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BasicRequestInfo__storage_, build),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "platform",
        .dataTypeSpecific.clazz = Nil,
        .number = BasicRequestInfo_FieldNumber_Platform,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BasicRequestInfo__storage_, platform),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "country",
        .dataTypeSpecific.clazz = Nil,
        .number = BasicRequestInfo_FieldNumber_Country,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BasicRequestInfo__storage_, country),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "language",
        .dataTypeSpecific.clazz = Nil,
        .number = BasicRequestInfo_FieldNumber_Language,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BasicRequestInfo__storage_, language),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "debug",
        .dataTypeSpecific.clazz = Nil,
        .number = BasicRequestInfo_FieldNumber_Debug,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BasicRequestInfo class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BasicRequestInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ContractsRequest

@implementation ContractsRequest

@dynamic hasSoulEggs, soulEggs;
@dynamic hasClientVersion, clientVersion;

typedef struct ContractsRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t clientVersion;
  double soulEggs;
} ContractsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "soulEggs",
        .dataTypeSpecific.clazz = Nil,
        .number = ContractsRequest_FieldNumber_SoulEggs,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ContractsRequest__storage_, soulEggs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "clientVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = ContractsRequest_FieldNumber_ClientVersion,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ContractsRequest__storage_, clientVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ContractsRequest class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ContractsRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ContractsResponse

@implementation ContractsResponse

@dynamic contractsArray, contractsArray_Count;
@dynamic hasWarningMessage, warningMessage;
@dynamic hasServerTime, serverTime;
@dynamic hasMaxEop, maxEop;

typedef struct ContractsResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t maxEop;
  NSMutableArray *contractsArray;
  NSString *warningMessage;
  double serverTime;
} ContractsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueMessage = nil,
        .core.name = "contractsArray",
        .core.dataTypeSpecific.clazz = GPBObjCClass(Contract),
        .core.number = ContractsResponse_FieldNumber_ContractsArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(ContractsResponse__storage_, contractsArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "serverTime",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ContractsResponse_FieldNumber_ServerTime,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ContractsResponse__storage_, serverTime),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueUInt32 = 1000U,
        .core.name = "maxEop",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ContractsResponse_FieldNumber_MaxEop,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ContractsResponse__storage_, maxEop),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "warningMessage",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ContractsResponse_FieldNumber_WarningMessage,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ContractsResponse__storage_, warningMessage),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ContractsResponse class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ContractsResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ContractCoopStatusRequest

@implementation ContractCoopStatusRequest

@dynamic hasRinfo, rinfo;
@dynamic hasContractIdentifier, contractIdentifier;
@dynamic hasCoopIdentifier, coopIdentifier;
@dynamic hasUserId, userId;
@dynamic hasClientVersion, clientVersion;

typedef struct ContractCoopStatusRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t clientVersion;
  NSString *contractIdentifier;
  NSString *coopIdentifier;
  NSString *userId;
  BasicRequestInfo *rinfo;
} ContractCoopStatusRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contractIdentifier",
        .dataTypeSpecific.clazz = Nil,
        .number = ContractCoopStatusRequest_FieldNumber_ContractIdentifier,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ContractCoopStatusRequest__storage_, contractIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "coopIdentifier",
        .dataTypeSpecific.clazz = Nil,
        .number = ContractCoopStatusRequest_FieldNumber_CoopIdentifier,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ContractCoopStatusRequest__storage_, coopIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = ContractCoopStatusRequest_FieldNumber_UserId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ContractCoopStatusRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clientVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = ContractCoopStatusRequest_FieldNumber_ClientVersion,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ContractCoopStatusRequest__storage_, clientVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "rinfo",
        .dataTypeSpecific.clazz = GPBObjCClass(BasicRequestInfo),
        .number = ContractCoopStatusRequest_FieldNumber_Rinfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ContractCoopStatusRequest__storage_, rinfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ContractCoopStatusRequest class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ContractCoopStatusRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FarmProductionParams

@implementation FarmProductionParams

@dynamic hasFarmPopulation, farmPopulation;
@dynamic hasFarmCapacity, farmCapacity;
@dynamic hasElr, elr;
@dynamic hasIhr, ihr;
@dynamic hasSr, sr;
@dynamic hasDelivered, delivered;

typedef struct FarmProductionParams__storage_ {
  uint32_t _has_storage_[1];
  double farmPopulation;
  double farmCapacity;
  double elr;
  double ihr;
  double sr;
  double delivered;
} FarmProductionParams__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "farmPopulation",
        .dataTypeSpecific.clazz = Nil,
        .number = FarmProductionParams_FieldNumber_FarmPopulation,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FarmProductionParams__storage_, farmPopulation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "farmCapacity",
        .dataTypeSpecific.clazz = Nil,
        .number = FarmProductionParams_FieldNumber_FarmCapacity,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FarmProductionParams__storage_, farmCapacity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "elr",
        .dataTypeSpecific.clazz = Nil,
        .number = FarmProductionParams_FieldNumber_Elr,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FarmProductionParams__storage_, elr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "ihr",
        .dataTypeSpecific.clazz = Nil,
        .number = FarmProductionParams_FieldNumber_Ihr,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FarmProductionParams__storage_, ihr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "sr",
        .dataTypeSpecific.clazz = Nil,
        .number = FarmProductionParams_FieldNumber_Sr,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(FarmProductionParams__storage_, sr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "delivered",
        .dataTypeSpecific.clazz = Nil,
        .number = FarmProductionParams_FieldNumber_Delivered,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(FarmProductionParams__storage_, delivered),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FarmProductionParams class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FarmProductionParams__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PlayerFarmInfo

@implementation PlayerFarmInfo

@dynamic hasClientVersion, clientVersion;
@dynamic hasSoulEggs, soulEggs;
@dynamic hasEggsOfProphecy, eggsOfProphecy;
@dynamic hasPermitLevel, permitLevel;
@dynamic hasHyperloopStation, hyperloopStation;
@dynamic eggMedalLevelArray, eggMedalLevelArray_Count;
@dynamic epicResearchArray, epicResearchArray_Count;
@dynamic hasEggType, eggType;
@dynamic hasCashOnHand, cashOnHand;
@dynamic habsArray, habsArray_Count;
@dynamic habPopulationArray, habPopulationArray_Count;
@dynamic habCapacityArray, habCapacityArray_Count;
@dynamic vehiclesArray, vehiclesArray_Count;
@dynamic trainLengthArray, trainLengthArray_Count;
@dynamic hasSilosOwned, silosOwned;
@dynamic commonResearchArray, commonResearchArray_Count;
@dynamic activeBoostsArray, activeBoostsArray_Count;
@dynamic hasBoostTokensOnHand, boostTokensOnHand;
@dynamic equippedArtifactsArray, equippedArtifactsArray_Count;
@dynamic hasArtifactInventoryScore, artifactInventoryScore;
@dynamic hasFarmAppearance, farmAppearance;
@dynamic hasTimestamp, timestamp;

typedef struct PlayerFarmInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t permitLevel;
  Egg eggType;
  uint32_t silosOwned;
  uint32_t boostTokensOnHand;
  uint32_t clientVersion;
  GPBUInt32Array *eggMedalLevelArray;
  NSMutableArray *epicResearchArray;
  GPBUInt32Array *habsArray;
  GPBUInt64Array *habPopulationArray;
  GPBUInt32Array *vehiclesArray;
  GPBUInt32Array *trainLengthArray;
  NSMutableArray *commonResearchArray;
  NSMutableArray *activeBoostsArray;
  NSMutableArray *equippedArtifactsArray;
  ShellDB_FarmConfiguration *farmAppearance;
  GPBUInt64Array *habCapacityArray;
  double soulEggs;
  uint64_t eggsOfProphecy;
  double cashOnHand;
  uint64_t artifactInventoryScore;
  double timestamp;
} PlayerFarmInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueDouble = 0,
        .core.name = "soulEggs",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = PlayerFarmInfo_FieldNumber_SoulEggs,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(PlayerFarmInfo__storage_, soulEggs),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "eggsOfProphecy",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = PlayerFarmInfo_FieldNumber_EggsOfProphecy,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(PlayerFarmInfo__storage_, eggsOfProphecy),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "permitLevel",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = PlayerFarmInfo_FieldNumber_PermitLevel,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(PlayerFarmInfo__storage_, permitLevel),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "hyperloopStation",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = PlayerFarmInfo_FieldNumber_HyperloopStation,
        .core.hasIndex = 4,
        .core.offset = 5,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "eggMedalLevelArray",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = PlayerFarmInfo_FieldNumber_EggMedalLevelArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(PlayerFarmInfo__storage_, eggMedalLevelArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "epicResearchArray",
        .core.dataTypeSpecific.clazz = GPBObjCClass(Backup_ResearchItem),
        .core.number = PlayerFarmInfo_FieldNumber_EpicResearchArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(PlayerFarmInfo__storage_, epicResearchArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = Egg_Edible,
        .core.name = "eggType",
        .core.dataTypeSpecific.enumDescFunc = Egg_EnumDescriptor,
        .core.number = PlayerFarmInfo_FieldNumber_EggType,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(PlayerFarmInfo__storage_, eggType),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "cashOnHand",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = PlayerFarmInfo_FieldNumber_CashOnHand,
        .core.hasIndex = 7,
        .core.offset = (uint32_t)offsetof(PlayerFarmInfo__storage_, cashOnHand),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "habsArray",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = PlayerFarmInfo_FieldNumber_HabsArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(PlayerFarmInfo__storage_, habsArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "habPopulationArray",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = PlayerFarmInfo_FieldNumber_HabPopulationArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(PlayerFarmInfo__storage_, habPopulationArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "vehiclesArray",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = PlayerFarmInfo_FieldNumber_VehiclesArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(PlayerFarmInfo__storage_, vehiclesArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "trainLengthArray",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = PlayerFarmInfo_FieldNumber_TrainLengthArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(PlayerFarmInfo__storage_, trainLengthArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "silosOwned",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = PlayerFarmInfo_FieldNumber_SilosOwned,
        .core.hasIndex = 8,
        .core.offset = (uint32_t)offsetof(PlayerFarmInfo__storage_, silosOwned),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "commonResearchArray",
        .core.dataTypeSpecific.clazz = GPBObjCClass(Backup_ResearchItem),
        .core.number = PlayerFarmInfo_FieldNumber_CommonResearchArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(PlayerFarmInfo__storage_, commonResearchArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "activeBoostsArray",
        .core.dataTypeSpecific.clazz = GPBObjCClass(Backup_ActiveBoost),
        .core.number = PlayerFarmInfo_FieldNumber_ActiveBoostsArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(PlayerFarmInfo__storage_, activeBoostsArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "boostTokensOnHand",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = PlayerFarmInfo_FieldNumber_BoostTokensOnHand,
        .core.hasIndex = 9,
        .core.offset = (uint32_t)offsetof(PlayerFarmInfo__storage_, boostTokensOnHand),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "equippedArtifactsArray",
        .core.dataTypeSpecific.clazz = GPBObjCClass(CompleteArtifact),
        .core.number = PlayerFarmInfo_FieldNumber_EquippedArtifactsArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(PlayerFarmInfo__storage_, equippedArtifactsArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "artifactInventoryScore",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = PlayerFarmInfo_FieldNumber_ArtifactInventoryScore,
        .core.hasIndex = 10,
        .core.offset = (uint32_t)offsetof(PlayerFarmInfo__storage_, artifactInventoryScore),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "farmAppearance",
        .core.dataTypeSpecific.clazz = GPBObjCClass(ShellDB_FarmConfiguration),
        .core.number = PlayerFarmInfo_FieldNumber_FarmAppearance,
        .core.hasIndex = 11,
        .core.offset = (uint32_t)offsetof(PlayerFarmInfo__storage_, farmAppearance),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "clientVersion",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = PlayerFarmInfo_FieldNumber_ClientVersion,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(PlayerFarmInfo__storage_, clientVersion),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "habCapacityArray",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = PlayerFarmInfo_FieldNumber_HabCapacityArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(PlayerFarmInfo__storage_, habCapacityArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "timestamp",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = PlayerFarmInfo_FieldNumber_Timestamp,
        .core.hasIndex = 12,
        .core.offset = (uint32_t)offsetof(PlayerFarmInfo__storage_, timestamp),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PlayerFarmInfo class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(PlayerFarmInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ContractCoopStatusResponse

@implementation ContractCoopStatusResponse

@dynamic hasContractIdentifier, contractIdentifier;
@dynamic hasTotalAmount, totalAmount;
@dynamic hasCoopIdentifier, coopIdentifier;
@dynamic contributorsArray, contributorsArray_Count;
@dynamic hasAutoGenerated, autoGenerated;
@dynamic hasPublic_p, public_p;
@dynamic hasCreatorId, creatorId;
@dynamic hasSecondsRemaining, secondsRemaining;
@dynamic hasAllMembersReporting, allMembersReporting;
@dynamic hasGracePeriodSecondsRemaining, gracePeriodSecondsRemaining;
@dynamic giftsArray, giftsArray_Count;
@dynamic chickenRunsArray, chickenRunsArray_Count;
@dynamic hasLocalTimestamp, localTimestamp;

typedef struct ContractCoopStatusResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *contractIdentifier;
  NSString *coopIdentifier;
  NSMutableArray *contributorsArray;
  NSString *creatorId;
  NSMutableArray *giftsArray;
  NSMutableArray *chickenRunsArray;
  double totalAmount;
  double secondsRemaining;
  double gracePeriodSecondsRemaining;
  double localTimestamp;
} ContractCoopStatusResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contractIdentifier",
        .dataTypeSpecific.clazz = Nil,
        .number = ContractCoopStatusResponse_FieldNumber_ContractIdentifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ContractCoopStatusResponse__storage_, contractIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "totalAmount",
        .dataTypeSpecific.clazz = Nil,
        .number = ContractCoopStatusResponse_FieldNumber_TotalAmount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ContractCoopStatusResponse__storage_, totalAmount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "coopIdentifier",
        .dataTypeSpecific.clazz = Nil,
        .number = ContractCoopStatusResponse_FieldNumber_CoopIdentifier,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ContractCoopStatusResponse__storage_, coopIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "contributorsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ContractCoopStatusResponse_ContributionInfo),
        .number = ContractCoopStatusResponse_FieldNumber_ContributorsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ContractCoopStatusResponse__storage_, contributorsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "secondsRemaining",
        .dataTypeSpecific.clazz = Nil,
        .number = ContractCoopStatusResponse_FieldNumber_SecondsRemaining,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ContractCoopStatusResponse__storage_, secondsRemaining),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "allMembersReporting",
        .dataTypeSpecific.clazz = Nil,
        .number = ContractCoopStatusResponse_FieldNumber_AllMembersReporting,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "gracePeriodSecondsRemaining",
        .dataTypeSpecific.clazz = Nil,
        .number = ContractCoopStatusResponse_FieldNumber_GracePeriodSecondsRemaining,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ContractCoopStatusResponse__storage_, gracePeriodSecondsRemaining),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "autoGenerated",
        .dataTypeSpecific.clazz = Nil,
        .number = ContractCoopStatusResponse_FieldNumber_AutoGenerated,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "creatorId",
        .dataTypeSpecific.clazz = Nil,
        .number = ContractCoopStatusResponse_FieldNumber_CreatorId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ContractCoopStatusResponse__storage_, creatorId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "public_p",
        .dataTypeSpecific.clazz = Nil,
        .number = ContractCoopStatusResponse_FieldNumber_Public_p,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "giftsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ContractCoopStatusResponse_CoopGift),
        .number = ContractCoopStatusResponse_FieldNumber_GiftsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ContractCoopStatusResponse__storage_, giftsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "localTimestamp",
        .dataTypeSpecific.clazz = Nil,
        .number = ContractCoopStatusResponse_FieldNumber_LocalTimestamp,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ContractCoopStatusResponse__storage_, localTimestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "chickenRunsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ContractCoopStatusResponse_ChickenRun),
        .number = ContractCoopStatusResponse_FieldNumber_ChickenRunsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ContractCoopStatusResponse__storage_, chickenRunsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ContractCoopStatusResponse class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ContractCoopStatusResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ContractCoopStatusResponse_MemberStatus

GPBEnumDescriptor *ContractCoopStatusResponse_MemberStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Valid\000KickedInactive\000KickedPrivate\000Kicke"
        "dCheats\000KickedLeech\000";
    static const int32_t values[] = {
        ContractCoopStatusResponse_MemberStatus_Valid,
        ContractCoopStatusResponse_MemberStatus_KickedInactive,
        ContractCoopStatusResponse_MemberStatus_KickedPrivate,
        ContractCoopStatusResponse_MemberStatus_KickedCheats,
        ContractCoopStatusResponse_MemberStatus_KickedLeech,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ContractCoopStatusResponse_MemberStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ContractCoopStatusResponse_MemberStatus_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ContractCoopStatusResponse_MemberStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case ContractCoopStatusResponse_MemberStatus_Valid:
    case ContractCoopStatusResponse_MemberStatus_KickedInactive:
    case ContractCoopStatusResponse_MemberStatus_KickedPrivate:
    case ContractCoopStatusResponse_MemberStatus_KickedCheats:
    case ContractCoopStatusResponse_MemberStatus_KickedLeech:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ContractCoopStatusResponse_ContributionInfo

@implementation ContractCoopStatusResponse_ContributionInfo

@dynamic hasUserId, userId;
@dynamic hasUserName, userName;
@dynamic hasContractIdentifier, contractIdentifier;
@dynamic hasContributionAmount, contributionAmount;
@dynamic hasContributionRate, contributionRate;
@dynamic hasSoulPower, soulPower;
@dynamic hasProductionParams, productionParams;
@dynamic hasFarmInfo, farmInfo;
@dynamic hasRankChange, rankChange;
@dynamic hasActive, active;
@dynamic hasLeech, leech;
@dynamic hasTimeCheatDetected, timeCheatDetected;
@dynamic hasPlatform, platform;
@dynamic hasPushId, pushId;
@dynamic hasBanVotes, banVotes;
@dynamic hasAutojoined, autojoined;
@dynamic hasBoostTokens, boostTokens;
@dynamic hasBoostTokensSpent, boostTokensSpent;
@dynamic buffHistoryArray, buffHistoryArray_Count;
@dynamic hasChickenRunCooldown, chickenRunCooldown;

typedef struct ContractCoopStatusResponse_ContributionInfo__storage_ {
  uint32_t _has_storage_[1];
  Platform platform;
  int32_t rankChange;
  uint32_t banVotes;
  uint32_t boostTokens;
  uint32_t boostTokensSpent;
  NSString *userId;
  NSString *userName;
  NSString *pushId;
  NSMutableArray *buffHistoryArray;
  FarmProductionParams *productionParams;
  PlayerFarmInfo *farmInfo;
  NSString *contractIdentifier;
  double contributionAmount;
  double contributionRate;
  double soulPower;
  double chickenRunCooldown;
} ContractCoopStatusResponse_ContributionInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "userId",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ContractCoopStatusResponse_ContributionInfo_FieldNumber_UserId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ContractCoopStatusResponse_ContributionInfo__storage_, userId),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "userName",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ContractCoopStatusResponse_ContributionInfo_FieldNumber_UserName,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ContractCoopStatusResponse_ContributionInfo__storage_, userName),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "contributionAmount",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ContractCoopStatusResponse_ContributionInfo_FieldNumber_ContributionAmount,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ContractCoopStatusResponse_ContributionInfo__storage_, contributionAmount),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "active",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ContractCoopStatusResponse_ContributionInfo_FieldNumber_Active,
        .core.hasIndex = 9,
        .core.offset = 10,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueEnum = Platform_Ios,
        .core.name = "platform",
        .core.dataTypeSpecific.enumDescFunc = Platform_EnumDescriptor,
        .core.number = ContractCoopStatusResponse_ContributionInfo_FieldNumber_Platform,
        .core.hasIndex = 15,
        .core.offset = (uint32_t)offsetof(ContractCoopStatusResponse_ContributionInfo__storage_, platform),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "contributionRate",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ContractCoopStatusResponse_ContributionInfo_FieldNumber_ContributionRate,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(ContractCoopStatusResponse_ContributionInfo__storage_, contributionRate),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "timeCheatDetected",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ContractCoopStatusResponse_ContributionInfo_FieldNumber_TimeCheatDetected,
        .core.hasIndex = 13,
        .core.offset = 14,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "rankChange",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ContractCoopStatusResponse_ContributionInfo_FieldNumber_RankChange,
        .core.hasIndex = 8,
        .core.offset = (uint32_t)offsetof(ContractCoopStatusResponse_ContributionInfo__storage_, rankChange),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "pushId",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ContractCoopStatusResponse_ContributionInfo_FieldNumber_PushId,
        .core.hasIndex = 16,
        .core.offset = (uint32_t)offsetof(ContractCoopStatusResponse_ContributionInfo__storage_, pushId),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "banVotes",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ContractCoopStatusResponse_ContributionInfo_FieldNumber_BanVotes,
        .core.hasIndex = 17,
        .core.offset = (uint32_t)offsetof(ContractCoopStatusResponse_ContributionInfo__storage_, banVotes),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "soulPower",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ContractCoopStatusResponse_ContributionInfo_FieldNumber_SoulPower,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(ContractCoopStatusResponse_ContributionInfo__storage_, soulPower),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "boostTokens",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ContractCoopStatusResponse_ContributionInfo_FieldNumber_BoostTokens,
        .core.hasIndex = 20,
        .core.offset = (uint32_t)offsetof(ContractCoopStatusResponse_ContributionInfo__storage_, boostTokens),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "buffHistoryArray",
        .core.dataTypeSpecific.clazz = GPBObjCClass(CoopBuffState),
        .core.number = ContractCoopStatusResponse_ContributionInfo_FieldNumber_BuffHistoryArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(ContractCoopStatusResponse_ContributionInfo__storage_, buffHistoryArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "boostTokensSpent",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ContractCoopStatusResponse_ContributionInfo_FieldNumber_BoostTokensSpent,
        .core.hasIndex = 21,
        .core.offset = (uint32_t)offsetof(ContractCoopStatusResponse_ContributionInfo__storage_, boostTokensSpent),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "productionParams",
        .core.dataTypeSpecific.clazz = GPBObjCClass(FarmProductionParams),
        .core.number = ContractCoopStatusResponse_ContributionInfo_FieldNumber_ProductionParams,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(ContractCoopStatusResponse_ContributionInfo__storage_, productionParams),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "leech",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ContractCoopStatusResponse_ContributionInfo_FieldNumber_Leech,
        .core.hasIndex = 11,
        .core.offset = 12,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "autojoined",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ContractCoopStatusResponse_ContributionInfo_FieldNumber_Autojoined,
        .core.hasIndex = 18,
        .core.offset = 19,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "farmInfo",
        .core.dataTypeSpecific.clazz = GPBObjCClass(PlayerFarmInfo),
        .core.number = ContractCoopStatusResponse_ContributionInfo_FieldNumber_FarmInfo,
        .core.hasIndex = 7,
        .core.offset = (uint32_t)offsetof(ContractCoopStatusResponse_ContributionInfo__storage_, farmInfo),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "contractIdentifier",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ContractCoopStatusResponse_ContributionInfo_FieldNumber_ContractIdentifier,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ContractCoopStatusResponse_ContributionInfo__storage_, contractIdentifier),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "chickenRunCooldown",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ContractCoopStatusResponse_ContributionInfo_FieldNumber_ChickenRunCooldown,
        .core.hasIndex = 22,
        .core.offset = (uint32_t)offsetof(ContractCoopStatusResponse_ContributionInfo__storage_, chickenRunCooldown),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ContractCoopStatusResponse_ContributionInfo class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ContractCoopStatusResponse_ContributionInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ContractCoopStatusResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ContractCoopStatusResponse_CoopGift

@implementation ContractCoopStatusResponse_CoopGift

@dynamic hasUserId, userId;
@dynamic hasUserName, userName;
@dynamic hasAmount, amount;

typedef struct ContractCoopStatusResponse_CoopGift__storage_ {
  uint32_t _has_storage_[1];
  uint32_t amount;
  NSString *userId;
  NSString *userName;
} ContractCoopStatusResponse_CoopGift__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = ContractCoopStatusResponse_CoopGift_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ContractCoopStatusResponse_CoopGift__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = ContractCoopStatusResponse_CoopGift_FieldNumber_Amount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ContractCoopStatusResponse_CoopGift__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "userName",
        .dataTypeSpecific.clazz = Nil,
        .number = ContractCoopStatusResponse_CoopGift_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ContractCoopStatusResponse_CoopGift__storage_, userName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ContractCoopStatusResponse_CoopGift class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ContractCoopStatusResponse_CoopGift__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ContractCoopStatusResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ContractCoopStatusResponse_ChickenRun

@implementation ContractCoopStatusResponse_ChickenRun

@dynamic hasUserId, userId;
@dynamic hasUserName, userName;
@dynamic hasAmount, amount;

typedef struct ContractCoopStatusResponse_ChickenRun__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  NSString *userName;
  uint64_t amount;
} ContractCoopStatusResponse_ChickenRun__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = ContractCoopStatusResponse_ChickenRun_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ContractCoopStatusResponse_ChickenRun__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = ContractCoopStatusResponse_ChickenRun_FieldNumber_Amount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ContractCoopStatusResponse_ChickenRun__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "userName",
        .dataTypeSpecific.clazz = Nil,
        .number = ContractCoopStatusResponse_ChickenRun_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ContractCoopStatusResponse_ChickenRun__storage_, userName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ContractCoopStatusResponse_ChickenRun class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ContractCoopStatusResponse_ChickenRun__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ContractCoopStatusResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LocalContract

@implementation LocalContract

@dynamic hasContract, contract;
@dynamic hasCoopIdentifier, coopIdentifier;
@dynamic hasAccepted, accepted;
@dynamic hasTimeAccepted, timeAccepted;
@dynamic hasCancelled, cancelled;
@dynamic hasNew_p, new_p;
@dynamic hasCoopSharedEndTime, coopSharedEndTime;
@dynamic hasCoopGracePeriodEndTime, coopGracePeriodEndTime;
@dynamic hasCoopContributionFinalized, coopContributionFinalized;
@dynamic hasCoopLastUploadedContribution, coopLastUploadedContribution;
@dynamic hasCoopUserId, coopUserId;
@dynamic hasCoopShareFarm, coopShareFarm;
@dynamic hasLastAmountWhenRewardGiven, lastAmountWhenRewardGiven;
@dynamic hasNumGoalsAchieved, numGoalsAchieved;
@dynamic hasBoostsUsed, boostsUsed;
@dynamic hasLeague, league;
@dynamic hasLastNagTime, lastNagTime;

typedef struct LocalContract__storage_ {
  uint32_t _has_storage_[1];
  uint32_t boostsUsed;
  uint32_t numGoalsAchieved;
  uint32_t league;
  Contract *contract;
  NSString *coopIdentifier;
  NSString *coopUserId;
  double timeAccepted;
  double coopSharedEndTime;
  double lastAmountWhenRewardGiven;
  double coopGracePeriodEndTime;
  double coopLastUploadedContribution;
  double lastNagTime;
} LocalContract__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contract",
        .dataTypeSpecific.clazz = GPBObjCClass(Contract),
        .number = LocalContract_FieldNumber_Contract,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LocalContract__storage_, contract),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "coopIdentifier",
        .dataTypeSpecific.clazz = Nil,
        .number = LocalContract_FieldNumber_CoopIdentifier,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LocalContract__storage_, coopIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeAccepted",
        .dataTypeSpecific.clazz = Nil,
        .number = LocalContract_FieldNumber_TimeAccepted,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LocalContract__storage_, timeAccepted),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "cancelled",
        .dataTypeSpecific.clazz = Nil,
        .number = LocalContract_FieldNumber_Cancelled,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "coopSharedEndTime",
        .dataTypeSpecific.clazz = Nil,
        .number = LocalContract_FieldNumber_CoopSharedEndTime,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(LocalContract__storage_, coopSharedEndTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "lastAmountWhenRewardGiven",
        .dataTypeSpecific.clazz = Nil,
        .number = LocalContract_FieldNumber_LastAmountWhenRewardGiven,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(LocalContract__storage_, lastAmountWhenRewardGiven),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "accepted",
        .dataTypeSpecific.clazz = Nil,
        .number = LocalContract_FieldNumber_Accepted,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "new_p",
        .dataTypeSpecific.clazz = Nil,
        .number = LocalContract_FieldNumber_New_p,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "coopGracePeriodEndTime",
        .dataTypeSpecific.clazz = Nil,
        .number = LocalContract_FieldNumber_CoopGracePeriodEndTime,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(LocalContract__storage_, coopGracePeriodEndTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "coopContributionFinalized",
        .dataTypeSpecific.clazz = Nil,
        .number = LocalContract_FieldNumber_CoopContributionFinalized,
        .hasIndex = 11,
        .offset = 12,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "coopLastUploadedContribution",
        .dataTypeSpecific.clazz = Nil,
        .number = LocalContract_FieldNumber_CoopLastUploadedContribution,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(LocalContract__storage_, coopLastUploadedContribution),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "boostsUsed",
        .dataTypeSpecific.clazz = Nil,
        .number = LocalContract_FieldNumber_BoostsUsed,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(LocalContract__storage_, boostsUsed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "coopUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = LocalContract_FieldNumber_CoopUserId,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(LocalContract__storage_, coopUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "numGoalsAchieved",
        .dataTypeSpecific.clazz = Nil,
        .number = LocalContract_FieldNumber_NumGoalsAchieved,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(LocalContract__storage_, numGoalsAchieved),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "league",
        .dataTypeSpecific.clazz = Nil,
        .number = LocalContract_FieldNumber_League,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(LocalContract__storage_, league),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "lastNagTime",
        .dataTypeSpecific.clazz = Nil,
        .number = LocalContract_FieldNumber_LastNagTime,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(LocalContract__storage_, lastNagTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "coopShareFarm",
        .dataTypeSpecific.clazz = Nil,
        .number = LocalContract_FieldNumber_CoopShareFarm,
        .hasIndex = 15,
        .offset = 16,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LocalContract class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LocalContract__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MyContracts

@implementation MyContracts

@dynamic contractIdsSeenArray, contractIdsSeenArray_Count;
@dynamic contractsArray, contractsArray_Count;
@dynamic archiveArray, archiveArray_Count;
@dynamic currentCoopStatusesArray, currentCoopStatusesArray_Count;

typedef struct MyContracts__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *contractsArray;
  NSMutableArray *archiveArray;
  NSMutableArray *contractIdsSeenArray;
  NSMutableArray *currentCoopStatusesArray;
} MyContracts__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contractsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(LocalContract),
        .number = MyContracts_FieldNumber_ContractsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MyContracts__storage_, contractsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "archiveArray",
        .dataTypeSpecific.clazz = GPBObjCClass(LocalContract),
        .number = MyContracts_FieldNumber_ArchiveArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MyContracts__storage_, archiveArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "contractIdsSeenArray",
        .dataTypeSpecific.clazz = Nil,
        .number = MyContracts_FieldNumber_ContractIdsSeenArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MyContracts__storage_, contractIdsSeenArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "currentCoopStatusesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ContractCoopStatusResponse),
        .number = MyContracts_FieldNumber_CurrentCoopStatusesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MyContracts__storage_, currentCoopStatusesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MyContracts class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MyContracts__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QueryCoopRequest

@implementation QueryCoopRequest

@dynamic hasRinfo, rinfo;
@dynamic hasContractIdentifier, contractIdentifier;
@dynamic hasCoopIdentifier, coopIdentifier;
@dynamic hasLeague, league;
@dynamic hasClientVersion, clientVersion;

typedef struct QueryCoopRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t clientVersion;
  uint32_t league;
  NSString *contractIdentifier;
  NSString *coopIdentifier;
  BasicRequestInfo *rinfo;
} QueryCoopRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contractIdentifier",
        .dataTypeSpecific.clazz = Nil,
        .number = QueryCoopRequest_FieldNumber_ContractIdentifier,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QueryCoopRequest__storage_, contractIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "coopIdentifier",
        .dataTypeSpecific.clazz = Nil,
        .number = QueryCoopRequest_FieldNumber_CoopIdentifier,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(QueryCoopRequest__storage_, coopIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clientVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = QueryCoopRequest_FieldNumber_ClientVersion,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(QueryCoopRequest__storage_, clientVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "league",
        .dataTypeSpecific.clazz = Nil,
        .number = QueryCoopRequest_FieldNumber_League,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(QueryCoopRequest__storage_, league),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "rinfo",
        .dataTypeSpecific.clazz = GPBObjCClass(BasicRequestInfo),
        .number = QueryCoopRequest_FieldNumber_Rinfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QueryCoopRequest__storage_, rinfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[QueryCoopRequest class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QueryCoopRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QueryCoopResponse

@implementation QueryCoopResponse

@dynamic hasExists, exists;
@dynamic hasFull, full;
@dynamic hasExpired, expired;
@dynamic hasDifferentLeague, differentLeague;
@dynamic hasBanned, banned;

typedef struct QueryCoopResponse__storage_ {
  uint32_t _has_storage_[1];
} QueryCoopResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "exists",
        .dataTypeSpecific.clazz = Nil,
        .number = QueryCoopResponse_FieldNumber_Exists,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "full",
        .dataTypeSpecific.clazz = Nil,
        .number = QueryCoopResponse_FieldNumber_Full,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "banned",
        .dataTypeSpecific.clazz = Nil,
        .number = QueryCoopResponse_FieldNumber_Banned,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "differentLeague",
        .dataTypeSpecific.clazz = Nil,
        .number = QueryCoopResponse_FieldNumber_DifferentLeague,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "expired",
        .dataTypeSpecific.clazz = Nil,
        .number = QueryCoopResponse_FieldNumber_Expired,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[QueryCoopResponse class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QueryCoopResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CreateCoopRequest

@implementation CreateCoopRequest

@dynamic hasRinfo, rinfo;
@dynamic hasContractIdentifier, contractIdentifier;
@dynamic hasCoopIdentifier, coopIdentifier;
@dynamic hasSecondsRemaining, secondsRemaining;
@dynamic hasUserId, userId;
@dynamic hasUserName, userName;
@dynamic hasSoulPower, soulPower;
@dynamic hasEop, eop;
@dynamic hasLeague, league;
@dynamic hasPlatform, platform;
@dynamic hasClientVersion, clientVersion;

typedef struct CreateCoopRequest__storage_ {
  uint32_t _has_storage_[1];
  Platform platform;
  uint32_t clientVersion;
  uint32_t league;
  NSString *contractIdentifier;
  NSString *coopIdentifier;
  NSString *userId;
  NSString *userName;
  BasicRequestInfo *rinfo;
  double secondsRemaining;
  double soulPower;
  double eop;
} CreateCoopRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "contractIdentifier",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = CreateCoopRequest_FieldNumber_ContractIdentifier,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(CreateCoopRequest__storage_, contractIdentifier),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "coopIdentifier",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = CreateCoopRequest_FieldNumber_CoopIdentifier,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(CreateCoopRequest__storage_, coopIdentifier),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "secondsRemaining",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = CreateCoopRequest_FieldNumber_SecondsRemaining,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(CreateCoopRequest__storage_, secondsRemaining),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "userId",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = CreateCoopRequest_FieldNumber_UserId,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(CreateCoopRequest__storage_, userId),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "userName",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = CreateCoopRequest_FieldNumber_UserName,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(CreateCoopRequest__storage_, userName),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = Platform_Ios,
        .core.name = "platform",
        .core.dataTypeSpecific.enumDescFunc = Platform_EnumDescriptor,
        .core.number = CreateCoopRequest_FieldNumber_Platform,
        .core.hasIndex = 9,
        .core.offset = (uint32_t)offsetof(CreateCoopRequest__storage_, platform),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "clientVersion",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = CreateCoopRequest_FieldNumber_ClientVersion,
        .core.hasIndex = 10,
        .core.offset = (uint32_t)offsetof(CreateCoopRequest__storage_, clientVersion),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "soulPower",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = CreateCoopRequest_FieldNumber_SoulPower,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(CreateCoopRequest__storage_, soulPower),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "league",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = CreateCoopRequest_FieldNumber_League,
        .core.hasIndex = 8,
        .core.offset = (uint32_t)offsetof(CreateCoopRequest__storage_, league),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "rinfo",
        .core.dataTypeSpecific.clazz = GPBObjCClass(BasicRequestInfo),
        .core.number = CreateCoopRequest_FieldNumber_Rinfo,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(CreateCoopRequest__storage_, rinfo),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "eop",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = CreateCoopRequest_FieldNumber_Eop,
        .core.hasIndex = 7,
        .core.offset = (uint32_t)offsetof(CreateCoopRequest__storage_, eop),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CreateCoopRequest class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(CreateCoopRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CreateCoopResponse

@implementation CreateCoopResponse

@dynamic hasSuccess, success;
@dynamic hasMessage, message;

typedef struct CreateCoopResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *message;
} CreateCoopResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.clazz = Nil,
        .number = CreateCoopResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = Nil,
        .number = CreateCoopResponse_FieldNumber_Message,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CreateCoopResponse__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CreateCoopResponse class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CreateCoopResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - JoinCoopRequest

@implementation JoinCoopRequest

@dynamic hasRinfo, rinfo;
@dynamic hasContractIdentifier, contractIdentifier;
@dynamic hasCoopIdentifier, coopIdentifier;
@dynamic hasUserId, userId;
@dynamic hasUserName, userName;
@dynamic hasSoulPower, soulPower;
@dynamic hasEop, eop;
@dynamic hasLeague, league;
@dynamic hasPlatform, platform;
@dynamic hasSecondsRemaining, secondsRemaining;
@dynamic hasClientVersion, clientVersion;

typedef struct JoinCoopRequest__storage_ {
  uint32_t _has_storage_[1];
  Platform platform;
  uint32_t clientVersion;
  uint32_t league;
  NSString *contractIdentifier;
  NSString *coopIdentifier;
  NSString *userId;
  NSString *userName;
  BasicRequestInfo *rinfo;
  double soulPower;
  double secondsRemaining;
  double eop;
} JoinCoopRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "contractIdentifier",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = JoinCoopRequest_FieldNumber_ContractIdentifier,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(JoinCoopRequest__storage_, contractIdentifier),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "coopIdentifier",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = JoinCoopRequest_FieldNumber_CoopIdentifier,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(JoinCoopRequest__storage_, coopIdentifier),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "userId",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = JoinCoopRequest_FieldNumber_UserId,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(JoinCoopRequest__storage_, userId),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "userName",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = JoinCoopRequest_FieldNumber_UserName,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(JoinCoopRequest__storage_, userName),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = Platform_Ios,
        .core.name = "platform",
        .core.dataTypeSpecific.enumDescFunc = Platform_EnumDescriptor,
        .core.number = JoinCoopRequest_FieldNumber_Platform,
        .core.hasIndex = 8,
        .core.offset = (uint32_t)offsetof(JoinCoopRequest__storage_, platform),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "clientVersion",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = JoinCoopRequest_FieldNumber_ClientVersion,
        .core.hasIndex = 10,
        .core.offset = (uint32_t)offsetof(JoinCoopRequest__storage_, clientVersion),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "soulPower",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = JoinCoopRequest_FieldNumber_SoulPower,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(JoinCoopRequest__storage_, soulPower),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "league",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = JoinCoopRequest_FieldNumber_League,
        .core.hasIndex = 7,
        .core.offset = (uint32_t)offsetof(JoinCoopRequest__storage_, league),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "rinfo",
        .core.dataTypeSpecific.clazz = GPBObjCClass(BasicRequestInfo),
        .core.number = JoinCoopRequest_FieldNumber_Rinfo,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(JoinCoopRequest__storage_, rinfo),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "secondsRemaining",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = JoinCoopRequest_FieldNumber_SecondsRemaining,
        .core.hasIndex = 9,
        .core.offset = (uint32_t)offsetof(JoinCoopRequest__storage_, secondsRemaining),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "eop",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = JoinCoopRequest_FieldNumber_Eop,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(JoinCoopRequest__storage_, eop),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[JoinCoopRequest class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(JoinCoopRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - JoinCoopResponse

@implementation JoinCoopResponse

@dynamic hasSuccess, success;
@dynamic hasMessage, message;
@dynamic hasBanned, banned;
@dynamic hasCoopIdentifier, coopIdentifier;
@dynamic hasSecondsRemaining, secondsRemaining;
@dynamic hasMatchPercent, matchPercent;
@dynamic hasNumMembers, numMembers;

typedef struct JoinCoopResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t numMembers;
  NSString *message;
  NSString *coopIdentifier;
  double secondsRemaining;
  double matchPercent;
} JoinCoopResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.clazz = Nil,
        .number = JoinCoopResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = Nil,
        .number = JoinCoopResponse_FieldNumber_Message,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(JoinCoopResponse__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "secondsRemaining",
        .dataTypeSpecific.clazz = Nil,
        .number = JoinCoopResponse_FieldNumber_SecondsRemaining,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(JoinCoopResponse__storage_, secondsRemaining),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "banned",
        .dataTypeSpecific.clazz = Nil,
        .number = JoinCoopResponse_FieldNumber_Banned,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "coopIdentifier",
        .dataTypeSpecific.clazz = Nil,
        .number = JoinCoopResponse_FieldNumber_CoopIdentifier,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(JoinCoopResponse__storage_, coopIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "matchPercent",
        .dataTypeSpecific.clazz = Nil,
        .number = JoinCoopResponse_FieldNumber_MatchPercent,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(JoinCoopResponse__storage_, matchPercent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "numMembers",
        .dataTypeSpecific.clazz = Nil,
        .number = JoinCoopResponse_FieldNumber_NumMembers,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(JoinCoopResponse__storage_, numMembers),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[JoinCoopResponse class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(JoinCoopResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AutoJoinCoopRequest

@implementation AutoJoinCoopRequest

@dynamic hasRinfo, rinfo;
@dynamic hasContractIdentifier, contractIdentifier;
@dynamic hasUserId, userId;
@dynamic hasUserName, userName;
@dynamic hasSoulPower, soulPower;
@dynamic hasEop, eop;
@dynamic hasLeague, league;
@dynamic hasSecondsRemaining, secondsRemaining;
@dynamic hasPlatform, platform;
@dynamic hasClientVersion, clientVersion;

typedef struct AutoJoinCoopRequest__storage_ {
  uint32_t _has_storage_[1];
  Platform platform;
  uint32_t clientVersion;
  uint32_t league;
  NSString *contractIdentifier;
  NSString *userId;
  NSString *userName;
  BasicRequestInfo *rinfo;
  double soulPower;
  double secondsRemaining;
  double eop;
} AutoJoinCoopRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "contractIdentifier",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = AutoJoinCoopRequest_FieldNumber_ContractIdentifier,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(AutoJoinCoopRequest__storage_, contractIdentifier),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "userId",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = AutoJoinCoopRequest_FieldNumber_UserId,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(AutoJoinCoopRequest__storage_, userId),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "userName",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = AutoJoinCoopRequest_FieldNumber_UserName,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(AutoJoinCoopRequest__storage_, userName),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "soulPower",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = AutoJoinCoopRequest_FieldNumber_SoulPower,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(AutoJoinCoopRequest__storage_, soulPower),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "secondsRemaining",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = AutoJoinCoopRequest_FieldNumber_SecondsRemaining,
        .core.hasIndex = 7,
        .core.offset = (uint32_t)offsetof(AutoJoinCoopRequest__storage_, secondsRemaining),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueEnum = Platform_Ios,
        .core.name = "platform",
        .core.dataTypeSpecific.enumDescFunc = Platform_EnumDescriptor,
        .core.number = AutoJoinCoopRequest_FieldNumber_Platform,
        .core.hasIndex = 8,
        .core.offset = (uint32_t)offsetof(AutoJoinCoopRequest__storage_, platform),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "clientVersion",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = AutoJoinCoopRequest_FieldNumber_ClientVersion,
        .core.hasIndex = 9,
        .core.offset = (uint32_t)offsetof(AutoJoinCoopRequest__storage_, clientVersion),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "league",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = AutoJoinCoopRequest_FieldNumber_League,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(AutoJoinCoopRequest__storage_, league),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "rinfo",
        .core.dataTypeSpecific.clazz = GPBObjCClass(BasicRequestInfo),
        .core.number = AutoJoinCoopRequest_FieldNumber_Rinfo,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(AutoJoinCoopRequest__storage_, rinfo),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "eop",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = AutoJoinCoopRequest_FieldNumber_Eop,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(AutoJoinCoopRequest__storage_, eop),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AutoJoinCoopRequest class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(AutoJoinCoopRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateCoopPermissionsRequest

@implementation UpdateCoopPermissionsRequest

@dynamic hasRinfo, rinfo;
@dynamic hasContractIdentifier, contractIdentifier;
@dynamic hasCoopIdentifier, coopIdentifier;
@dynamic hasRequestingUserId, requestingUserId;
@dynamic hasPublic_p, public_p;
@dynamic hasClientVersion, clientVersion;

typedef struct UpdateCoopPermissionsRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t clientVersion;
  NSString *contractIdentifier;
  NSString *coopIdentifier;
  NSString *requestingUserId;
  BasicRequestInfo *rinfo;
} UpdateCoopPermissionsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contractIdentifier",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateCoopPermissionsRequest_FieldNumber_ContractIdentifier,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateCoopPermissionsRequest__storage_, contractIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "coopIdentifier",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateCoopPermissionsRequest_FieldNumber_CoopIdentifier,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateCoopPermissionsRequest__storage_, coopIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "requestingUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateCoopPermissionsRequest_FieldNumber_RequestingUserId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateCoopPermissionsRequest__storage_, requestingUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "public_p",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateCoopPermissionsRequest_FieldNumber_Public_p,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "clientVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateCoopPermissionsRequest_FieldNumber_ClientVersion,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(UpdateCoopPermissionsRequest__storage_, clientVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "rinfo",
        .dataTypeSpecific.clazz = GPBObjCClass(BasicRequestInfo),
        .number = UpdateCoopPermissionsRequest_FieldNumber_Rinfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateCoopPermissionsRequest__storage_, rinfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateCoopPermissionsRequest class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateCoopPermissionsRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateCoopPermissionsResponse

@implementation UpdateCoopPermissionsResponse

@dynamic hasSuccess, success;
@dynamic hasMessage, message;

typedef struct UpdateCoopPermissionsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *message;
} UpdateCoopPermissionsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateCoopPermissionsResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = Nil,
        .number = UpdateCoopPermissionsResponse_FieldNumber_Message,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateCoopPermissionsResponse__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateCoopPermissionsResponse class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateCoopPermissionsResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LeaveCoopRequest

@implementation LeaveCoopRequest

@dynamic hasRinfo, rinfo;
@dynamic hasContractIdentifier, contractIdentifier;
@dynamic hasCoopIdentifier, coopIdentifier;
@dynamic hasPlayerIdentifier, playerIdentifier;
@dynamic hasClientVersion, clientVersion;

typedef struct LeaveCoopRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t clientVersion;
  NSString *contractIdentifier;
  NSString *coopIdentifier;
  NSString *playerIdentifier;
  BasicRequestInfo *rinfo;
} LeaveCoopRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contractIdentifier",
        .dataTypeSpecific.clazz = Nil,
        .number = LeaveCoopRequest_FieldNumber_ContractIdentifier,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LeaveCoopRequest__storage_, contractIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "coopIdentifier",
        .dataTypeSpecific.clazz = Nil,
        .number = LeaveCoopRequest_FieldNumber_CoopIdentifier,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LeaveCoopRequest__storage_, coopIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "playerIdentifier",
        .dataTypeSpecific.clazz = Nil,
        .number = LeaveCoopRequest_FieldNumber_PlayerIdentifier,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LeaveCoopRequest__storage_, playerIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clientVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = LeaveCoopRequest_FieldNumber_ClientVersion,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LeaveCoopRequest__storage_, clientVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "rinfo",
        .dataTypeSpecific.clazz = GPBObjCClass(BasicRequestInfo),
        .number = LeaveCoopRequest_FieldNumber_Rinfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LeaveCoopRequest__storage_, rinfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LeaveCoopRequest class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LeaveCoopRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GiftPlayerCoopRequest

@implementation GiftPlayerCoopRequest

@dynamic hasRinfo, rinfo;
@dynamic hasContractIdentifier, contractIdentifier;
@dynamic hasCoopIdentifier, coopIdentifier;
@dynamic hasPlayerIdentifier, playerIdentifier;
@dynamic hasRequestingUserId, requestingUserId;
@dynamic hasRequestingUserName, requestingUserName;
@dynamic hasAmount, amount;
@dynamic hasClientVersion, clientVersion;

typedef struct GiftPlayerCoopRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t amount;
  uint32_t clientVersion;
  NSString *contractIdentifier;
  NSString *coopIdentifier;
  NSString *playerIdentifier;
  NSString *requestingUserId;
  NSString *requestingUserName;
  BasicRequestInfo *rinfo;
} GiftPlayerCoopRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contractIdentifier",
        .dataTypeSpecific.clazz = Nil,
        .number = GiftPlayerCoopRequest_FieldNumber_ContractIdentifier,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GiftPlayerCoopRequest__storage_, contractIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "coopIdentifier",
        .dataTypeSpecific.clazz = Nil,
        .number = GiftPlayerCoopRequest_FieldNumber_CoopIdentifier,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GiftPlayerCoopRequest__storage_, coopIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "playerIdentifier",
        .dataTypeSpecific.clazz = Nil,
        .number = GiftPlayerCoopRequest_FieldNumber_PlayerIdentifier,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GiftPlayerCoopRequest__storage_, playerIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "requestingUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = GiftPlayerCoopRequest_FieldNumber_RequestingUserId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GiftPlayerCoopRequest__storage_, requestingUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = GiftPlayerCoopRequest_FieldNumber_Amount,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GiftPlayerCoopRequest__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "requestingUserName",
        .dataTypeSpecific.clazz = Nil,
        .number = GiftPlayerCoopRequest_FieldNumber_RequestingUserName,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GiftPlayerCoopRequest__storage_, requestingUserName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clientVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = GiftPlayerCoopRequest_FieldNumber_ClientVersion,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GiftPlayerCoopRequest__storage_, clientVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "rinfo",
        .dataTypeSpecific.clazz = GPBObjCClass(BasicRequestInfo),
        .number = GiftPlayerCoopRequest_FieldNumber_Rinfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GiftPlayerCoopRequest__storage_, rinfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GiftPlayerCoopRequest class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GiftPlayerCoopRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendChickenRunCoopRequest

@implementation SendChickenRunCoopRequest

@dynamic hasRinfo, rinfo;
@dynamic hasContractIdentifier, contractIdentifier;
@dynamic hasCoopIdentifier, coopIdentifier;
@dynamic hasPlayerIdentifier, playerIdentifier;
@dynamic hasRequestingUserId, requestingUserId;
@dynamic hasRequestingUserName, requestingUserName;
@dynamic hasFarmPop, farmPop;
@dynamic hasClientVersion, clientVersion;

typedef struct SendChickenRunCoopRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t clientVersion;
  NSString *contractIdentifier;
  NSString *coopIdentifier;
  NSString *playerIdentifier;
  NSString *requestingUserId;
  NSString *requestingUserName;
  BasicRequestInfo *rinfo;
  uint64_t farmPop;
} SendChickenRunCoopRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contractIdentifier",
        .dataTypeSpecific.clazz = Nil,
        .number = SendChickenRunCoopRequest_FieldNumber_ContractIdentifier,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendChickenRunCoopRequest__storage_, contractIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "coopIdentifier",
        .dataTypeSpecific.clazz = Nil,
        .number = SendChickenRunCoopRequest_FieldNumber_CoopIdentifier,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SendChickenRunCoopRequest__storage_, coopIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "playerIdentifier",
        .dataTypeSpecific.clazz = Nil,
        .number = SendChickenRunCoopRequest_FieldNumber_PlayerIdentifier,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SendChickenRunCoopRequest__storage_, playerIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "requestingUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = SendChickenRunCoopRequest_FieldNumber_RequestingUserId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SendChickenRunCoopRequest__storage_, requestingUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "farmPop",
        .dataTypeSpecific.clazz = Nil,
        .number = SendChickenRunCoopRequest_FieldNumber_FarmPop,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SendChickenRunCoopRequest__storage_, farmPop),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "requestingUserName",
        .dataTypeSpecific.clazz = Nil,
        .number = SendChickenRunCoopRequest_FieldNumber_RequestingUserName,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SendChickenRunCoopRequest__storage_, requestingUserName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clientVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = SendChickenRunCoopRequest_FieldNumber_ClientVersion,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(SendChickenRunCoopRequest__storage_, clientVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "rinfo",
        .dataTypeSpecific.clazz = GPBObjCClass(BasicRequestInfo),
        .number = SendChickenRunCoopRequest_FieldNumber_Rinfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendChickenRunCoopRequest__storage_, rinfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendChickenRunCoopRequest class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendChickenRunCoopRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - KickPlayerCoopRequest

@implementation KickPlayerCoopRequest

@dynamic hasRinfo, rinfo;
@dynamic hasContractIdentifier, contractIdentifier;
@dynamic hasCoopIdentifier, coopIdentifier;
@dynamic hasPlayerIdentifier, playerIdentifier;
@dynamic hasRequestingUserId, requestingUserId;
@dynamic hasReason, reason;
@dynamic hasClientVersion, clientVersion;

typedef struct KickPlayerCoopRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t clientVersion;
  KickPlayerCoopRequest_Reason reason;
  NSString *contractIdentifier;
  NSString *coopIdentifier;
  NSString *playerIdentifier;
  NSString *requestingUserId;
  BasicRequestInfo *rinfo;
} KickPlayerCoopRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contractIdentifier",
        .dataTypeSpecific.clazz = Nil,
        .number = KickPlayerCoopRequest_FieldNumber_ContractIdentifier,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(KickPlayerCoopRequest__storage_, contractIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "coopIdentifier",
        .dataTypeSpecific.clazz = Nil,
        .number = KickPlayerCoopRequest_FieldNumber_CoopIdentifier,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(KickPlayerCoopRequest__storage_, coopIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "playerIdentifier",
        .dataTypeSpecific.clazz = Nil,
        .number = KickPlayerCoopRequest_FieldNumber_PlayerIdentifier,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(KickPlayerCoopRequest__storage_, playerIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "requestingUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = KickPlayerCoopRequest_FieldNumber_RequestingUserId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(KickPlayerCoopRequest__storage_, requestingUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clientVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = KickPlayerCoopRequest_FieldNumber_ClientVersion,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(KickPlayerCoopRequest__storage_, clientVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "rinfo",
        .dataTypeSpecific.clazz = GPBObjCClass(BasicRequestInfo),
        .number = KickPlayerCoopRequest_FieldNumber_Rinfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(KickPlayerCoopRequest__storage_, rinfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reason",
        .dataTypeSpecific.enumDescFunc = KickPlayerCoopRequest_Reason_EnumDescriptor,
        .number = KickPlayerCoopRequest_FieldNumber_Reason,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(KickPlayerCoopRequest__storage_, reason),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[KickPlayerCoopRequest class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(KickPlayerCoopRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum KickPlayerCoopRequest_Reason

GPBEnumDescriptor *KickPlayerCoopRequest_Reason_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Invalid\000Cheater\000Idle\000Leech\000Private\000";
    static const int32_t values[] = {
        KickPlayerCoopRequest_Reason_Invalid,
        KickPlayerCoopRequest_Reason_Cheater,
        KickPlayerCoopRequest_Reason_Idle,
        KickPlayerCoopRequest_Reason_Leech,
        KickPlayerCoopRequest_Reason_Private,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(KickPlayerCoopRequest_Reason)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:KickPlayerCoopRequest_Reason_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL KickPlayerCoopRequest_Reason_IsValidValue(int32_t value__) {
  switch (value__) {
    case KickPlayerCoopRequest_Reason_Invalid:
    case KickPlayerCoopRequest_Reason_Cheater:
    case KickPlayerCoopRequest_Reason_Idle:
    case KickPlayerCoopRequest_Reason_Leech:
    case KickPlayerCoopRequest_Reason_Private:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ContractCoopStatusUpdateRequest

@implementation ContractCoopStatusUpdateRequest

@dynamic hasRinfo, rinfo;
@dynamic hasUserId, userId;
@dynamic hasContractIdentifier, contractIdentifier;
@dynamic hasCoopIdentifier, coopIdentifier;
@dynamic hasPushUserId, pushUserId;
@dynamic hasAmount, amount;
@dynamic hasRate, rate;
@dynamic hasTimeCheatsDetected, timeCheatsDetected;
@dynamic hasSoulPower, soulPower;
@dynamic hasEop, eop;
@dynamic hasBoostTokens, boostTokens;
@dynamic hasBoostTokensSpent, boostTokensSpent;
@dynamic hasProductionParams, productionParams;
@dynamic hasFarmInfo, farmInfo;
@dynamic hasEggLayingRateBuff, eggLayingRateBuff;
@dynamic hasEarningsBuff, earningsBuff;

typedef struct ContractCoopStatusUpdateRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t timeCheatsDetected;
  uint32_t boostTokens;
  uint32_t boostTokensSpent;
  uint32_t eop;
  NSString *userId;
  NSString *contractIdentifier;
  NSString *coopIdentifier;
  NSString *pushUserId;
  BasicRequestInfo *rinfo;
  FarmProductionParams *productionParams;
  PlayerFarmInfo *farmInfo;
  double amount;
  double rate;
  double soulPower;
  double eggLayingRateBuff;
  double earningsBuff;
} ContractCoopStatusUpdateRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "userId",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ContractCoopStatusUpdateRequest_FieldNumber_UserId,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ContractCoopStatusUpdateRequest__storage_, userId),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "contractIdentifier",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ContractCoopStatusUpdateRequest_FieldNumber_ContractIdentifier,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ContractCoopStatusUpdateRequest__storage_, contractIdentifier),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "coopIdentifier",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ContractCoopStatusUpdateRequest_FieldNumber_CoopIdentifier,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ContractCoopStatusUpdateRequest__storage_, coopIdentifier),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "amount",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ContractCoopStatusUpdateRequest_FieldNumber_Amount,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(ContractCoopStatusUpdateRequest__storage_, amount),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "rate",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ContractCoopStatusUpdateRequest_FieldNumber_Rate,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(ContractCoopStatusUpdateRequest__storage_, rate),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "timeCheatsDetected",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ContractCoopStatusUpdateRequest_FieldNumber_TimeCheatsDetected,
        .core.hasIndex = 7,
        .core.offset = (uint32_t)offsetof(ContractCoopStatusUpdateRequest__storage_, timeCheatsDetected),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "soulPower",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ContractCoopStatusUpdateRequest_FieldNumber_SoulPower,
        .core.hasIndex = 8,
        .core.offset = (uint32_t)offsetof(ContractCoopStatusUpdateRequest__storage_, soulPower),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "pushUserId",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ContractCoopStatusUpdateRequest_FieldNumber_PushUserId,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(ContractCoopStatusUpdateRequest__storage_, pushUserId),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "boostTokens",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ContractCoopStatusUpdateRequest_FieldNumber_BoostTokens,
        .core.hasIndex = 10,
        .core.offset = (uint32_t)offsetof(ContractCoopStatusUpdateRequest__storage_, boostTokens),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueDouble = 1,
        .core.name = "eggLayingRateBuff",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ContractCoopStatusUpdateRequest_FieldNumber_EggLayingRateBuff,
        .core.hasIndex = 14,
        .core.offset = (uint32_t)offsetof(ContractCoopStatusUpdateRequest__storage_, eggLayingRateBuff),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueDouble = 1,
        .core.name = "earningsBuff",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ContractCoopStatusUpdateRequest_FieldNumber_EarningsBuff,
        .core.hasIndex = 15,
        .core.offset = (uint32_t)offsetof(ContractCoopStatusUpdateRequest__storage_, earningsBuff),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "rinfo",
        .core.dataTypeSpecific.clazz = GPBObjCClass(BasicRequestInfo),
        .core.number = ContractCoopStatusUpdateRequest_FieldNumber_Rinfo,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ContractCoopStatusUpdateRequest__storage_, rinfo),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "boostTokensSpent",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ContractCoopStatusUpdateRequest_FieldNumber_BoostTokensSpent,
        .core.hasIndex = 11,
        .core.offset = (uint32_t)offsetof(ContractCoopStatusUpdateRequest__storage_, boostTokensSpent),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "productionParams",
        .core.dataTypeSpecific.clazz = GPBObjCClass(FarmProductionParams),
        .core.number = ContractCoopStatusUpdateRequest_FieldNumber_ProductionParams,
        .core.hasIndex = 12,
        .core.offset = (uint32_t)offsetof(ContractCoopStatusUpdateRequest__storage_, productionParams),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "eop",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ContractCoopStatusUpdateRequest_FieldNumber_Eop,
        .core.hasIndex = 9,
        .core.offset = (uint32_t)offsetof(ContractCoopStatusUpdateRequest__storage_, eop),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "farmInfo",
        .core.dataTypeSpecific.clazz = GPBObjCClass(PlayerFarmInfo),
        .core.number = ContractCoopStatusUpdateRequest_FieldNumber_FarmInfo,
        .core.hasIndex = 13,
        .core.offset = (uint32_t)offsetof(ContractCoopStatusUpdateRequest__storage_, farmInfo),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ContractCoopStatusUpdateRequest class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ContractCoopStatusUpdateRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ContractCoopStatusUpdateResponse

@implementation ContractCoopStatusUpdateResponse

@dynamic hasFinalized, finalized;
@dynamic hasExists, exists;
@dynamic hasStatus, status;

typedef struct ContractCoopStatusUpdateResponse__storage_ {
  uint32_t _has_storage_[1];
  ContractCoopStatusResponse_MemberStatus status;
} ContractCoopStatusUpdateResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "finalized",
        .dataTypeSpecific.clazz = Nil,
        .number = ContractCoopStatusUpdateResponse_FieldNumber_Finalized,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "exists",
        .dataTypeSpecific.clazz = Nil,
        .number = ContractCoopStatusUpdateResponse_FieldNumber_Exists,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ContractCoopStatusResponse_MemberStatus_EnumDescriptor,
        .number = ContractCoopStatusUpdateResponse_FieldNumber_Status,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ContractCoopStatusUpdateResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ContractCoopStatusUpdateResponse class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ContractCoopStatusUpdateResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CoopBuffState

@implementation CoopBuffState

@dynamic hasEggLayingRate, eggLayingRate;
@dynamic hasEarnings, earnings;
@dynamic hasServerTimestamp, serverTimestamp;

typedef struct CoopBuffState__storage_ {
  uint32_t _has_storage_[1];
  double eggLayingRate;
  double earnings;
  double serverTimestamp;
} CoopBuffState__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueDouble = 1,
        .core.name = "eggLayingRate",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = CoopBuffState_FieldNumber_EggLayingRate,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(CoopBuffState__storage_, eggLayingRate),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueDouble = 1,
        .core.name = "earnings",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = CoopBuffState_FieldNumber_Earnings,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(CoopBuffState__storage_, earnings),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "serverTimestamp",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = CoopBuffState_FieldNumber_ServerTimestamp,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(CoopBuffState__storage_, serverTimestamp),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CoopBuffState class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(CoopBuffState__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CoopBuffHistory

@implementation CoopBuffHistory

@dynamic historyArray, historyArray_Count;

typedef struct CoopBuffHistory__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *historyArray;
} CoopBuffHistory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "historyArray",
        .dataTypeSpecific.clazz = GPBObjCClass(CoopBuffState),
        .number = CoopBuffHistory_FieldNumber_HistoryArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CoopBuffHistory__storage_, historyArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CoopBuffHistory class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CoopBuffHistory__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CoopChickenRunEntry

@implementation CoopChickenRunEntry

@dynamic hasUserId, userId;
@dynamic hasServerTimestamp, serverTimestamp;

typedef struct CoopChickenRunEntry__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  double serverTimestamp;
} CoopChickenRunEntry__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = CoopChickenRunEntry_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CoopChickenRunEntry__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "serverTimestamp",
        .dataTypeSpecific.clazz = Nil,
        .number = CoopChickenRunEntry_FieldNumber_ServerTimestamp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CoopChickenRunEntry__storage_, serverTimestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CoopChickenRunEntry class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CoopChickenRunEntry__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CoopLastChickenRunTimes

@implementation CoopLastChickenRunTimes

@dynamic entriesArray, entriesArray_Count;

typedef struct CoopLastChickenRunTimes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *entriesArray;
} CoopLastChickenRunTimes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "entriesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(CoopChickenRunEntry),
        .number = CoopLastChickenRunTimes_FieldNumber_EntriesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CoopLastChickenRunTimes__storage_, entriesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CoopLastChickenRunTimes class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CoopLastChickenRunTimes__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserDataInfoRequest

@implementation UserDataInfoRequest

@dynamic hasRinfo, rinfo;
@dynamic hasUserId, userId;
@dynamic hasDeviceId, deviceId;
@dynamic hasBackupChecksum, backupChecksum;

typedef struct UserDataInfoRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  NSString *deviceId;
  BasicRequestInfo *rinfo;
  uint64_t backupChecksum;
} UserDataInfoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = UserDataInfoRequest_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserDataInfoRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceId",
        .dataTypeSpecific.clazz = Nil,
        .number = UserDataInfoRequest_FieldNumber_DeviceId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserDataInfoRequest__storage_, deviceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "backupChecksum",
        .dataTypeSpecific.clazz = Nil,
        .number = UserDataInfoRequest_FieldNumber_BackupChecksum,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UserDataInfoRequest__storage_, backupChecksum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "rinfo",
        .dataTypeSpecific.clazz = GPBObjCClass(BasicRequestInfo),
        .number = UserDataInfoRequest_FieldNumber_Rinfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserDataInfoRequest__storage_, rinfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserDataInfoRequest class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserDataInfoRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserDataInfoResponse

@implementation UserDataInfoResponse

@dynamic hasBackupChecksum, backupChecksum;
@dynamic hasBackupTotalCash, backupTotalCash;
@dynamic coopMembershipsArray, coopMembershipsArray_Count;

typedef struct UserDataInfoResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *coopMembershipsArray;
  uint64_t backupChecksum;
  double backupTotalCash;
} UserDataInfoResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "backupChecksum",
        .dataTypeSpecific.clazz = Nil,
        .number = UserDataInfoResponse_FieldNumber_BackupChecksum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserDataInfoResponse__storage_, backupChecksum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "backupTotalCash",
        .dataTypeSpecific.clazz = Nil,
        .number = UserDataInfoResponse_FieldNumber_BackupTotalCash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserDataInfoResponse__storage_, backupTotalCash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "coopMembershipsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = UserDataInfoResponse_FieldNumber_CoopMembershipsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserDataInfoResponse__storage_, coopMembershipsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserDataInfoResponse class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserDataInfoResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ClearAllUserDataRequest

@implementation ClearAllUserDataRequest

@dynamic hasRinfo, rinfo;
@dynamic hasUserId, userId;
@dynamic hasDeviceId, deviceId;
@dynamic hasBackupChecksum, backupChecksum;

typedef struct ClearAllUserDataRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  NSString *deviceId;
  BasicRequestInfo *rinfo;
  uint64_t backupChecksum;
} ClearAllUserDataRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = ClearAllUserDataRequest_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ClearAllUserDataRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceId",
        .dataTypeSpecific.clazz = Nil,
        .number = ClearAllUserDataRequest_FieldNumber_DeviceId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ClearAllUserDataRequest__storage_, deviceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "backupChecksum",
        .dataTypeSpecific.clazz = Nil,
        .number = ClearAllUserDataRequest_FieldNumber_BackupChecksum,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ClearAllUserDataRequest__storage_, backupChecksum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "rinfo",
        .dataTypeSpecific.clazz = GPBObjCClass(BasicRequestInfo),
        .number = ClearAllUserDataRequest_FieldNumber_Rinfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ClearAllUserDataRequest__storage_, rinfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ClearAllUserDataRequest class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ClearAllUserDataRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServerGift

@implementation ServerGift

@dynamic hasUserId, userId;
@dynamic hasRewardType, rewardType;
@dynamic hasRewardSubType, rewardSubType;
@dynamic hasRewardAmount, rewardAmount;

typedef struct ServerGift__storage_ {
  uint32_t _has_storage_[1];
  RewardType rewardType;
  NSString *userId;
  NSString *rewardSubType;
  double rewardAmount;
} ServerGift__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "userId",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ServerGift_FieldNumber_UserId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ServerGift__storage_, userId),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = RewardType_Cash,
        .core.name = "rewardType",
        .core.dataTypeSpecific.enumDescFunc = RewardType_EnumDescriptor,
        .core.number = ServerGift_FieldNumber_RewardType,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ServerGift__storage_, rewardType),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "rewardSubType",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ServerGift_FieldNumber_RewardSubType,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ServerGift__storage_, rewardSubType),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "rewardAmount",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ServerGift_FieldNumber_RewardAmount,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ServerGift__storage_, rewardAmount),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServerGift class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ServerGift__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LiveConfig

@implementation LiveConfig

@dynamic hasConfigId, configId;
@dynamic hasBoostsConfig, boostsConfig;
@dynamic hasGiftConfig, giftConfig;
@dynamic hasMiscConfig, miscConfig;

typedef struct LiveConfig__storage_ {
  uint32_t _has_storage_[1];
  NSString *configId;
  LiveConfig_BoostsConfig *boostsConfig;
  LiveConfig_GiftConfig *giftConfig;
  LiveConfig_MiscConfig *miscConfig;
} LiveConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "configId",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_FieldNumber_ConfigId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LiveConfig__storage_, configId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "boostsConfig",
        .dataTypeSpecific.clazz = GPBObjCClass(LiveConfig_BoostsConfig),
        .number = LiveConfig_FieldNumber_BoostsConfig,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LiveConfig__storage_, boostsConfig),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "giftConfig",
        .dataTypeSpecific.clazz = GPBObjCClass(LiveConfig_GiftConfig),
        .number = LiveConfig_FieldNumber_GiftConfig,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LiveConfig__storage_, giftConfig),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "miscConfig",
        .dataTypeSpecific.clazz = GPBObjCClass(LiveConfig_MiscConfig),
        .number = LiveConfig_FieldNumber_MiscConfig,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LiveConfig__storage_, miscConfig),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LiveConfig class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LiveConfig__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LiveConfig_BoostsConfig

@implementation LiveConfig_BoostsConfig

@dynamic itemConfigsArray, itemConfigsArray_Count;
@dynamic hasCashBoostCooloffTime, cashBoostCooloffTime;

typedef struct LiveConfig_BoostsConfig__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemConfigsArray;
  double cashBoostCooloffTime;
} LiveConfig_BoostsConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemConfigsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(LiveConfig_BoostsConfig_ItemConfig),
        .number = LiveConfig_BoostsConfig_FieldNumber_ItemConfigsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LiveConfig_BoostsConfig__storage_, itemConfigsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cashBoostCooloffTime",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_BoostsConfig_FieldNumber_CashBoostCooloffTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LiveConfig_BoostsConfig__storage_, cashBoostCooloffTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LiveConfig_BoostsConfig class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LiveConfig_BoostsConfig__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(LiveConfig)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LiveConfig_BoostsConfig_ItemConfig

@implementation LiveConfig_BoostsConfig_ItemConfig

@dynamic hasBoostId, boostId;
@dynamic hasPrice, price;
@dynamic hasTokenPrice, tokenPrice;
@dynamic hasSeRequired, seRequired;

typedef struct LiveConfig_BoostsConfig_ItemConfig__storage_ {
  uint32_t _has_storage_[1];
  uint32_t price;
  uint32_t tokenPrice;
  NSString *boostId;
  double seRequired;
} LiveConfig_BoostsConfig_ItemConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "boostId",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_BoostsConfig_ItemConfig_FieldNumber_BoostId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LiveConfig_BoostsConfig_ItemConfig__storage_, boostId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "price",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_BoostsConfig_ItemConfig_FieldNumber_Price,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LiveConfig_BoostsConfig_ItemConfig__storage_, price),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tokenPrice",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_BoostsConfig_ItemConfig_FieldNumber_TokenPrice,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LiveConfig_BoostsConfig_ItemConfig__storage_, tokenPrice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "seRequired",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_BoostsConfig_ItemConfig_FieldNumber_SeRequired,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LiveConfig_BoostsConfig_ItemConfig__storage_, seRequired),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LiveConfig_BoostsConfig_ItemConfig class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LiveConfig_BoostsConfig_ItemConfig__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(LiveConfig_BoostsConfig)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LiveConfig_GiftConfig

@implementation LiveConfig_GiftConfig

@dynamic giftConfigsArray, giftConfigsArray_Count;
@dynamic hasGiftMuMinSpent, giftMuMinSpent;
@dynamic hasGiftMuMaxSpent, giftMuMaxSpent;
@dynamic hasGiftMuOverallMult, giftMuOverallMult;
@dynamic hasRandomGiftMuConfig, randomGiftMuConfig;
@dynamic hasVideoGiftMuConfig, videoGiftMuConfig;
@dynamic hasPackageInterval, packageInterval;
@dynamic hasVideoOfferInterval, videoOfferInterval;
@dynamic hasVideoOfferIntervalContract, videoOfferIntervalContract;
@dynamic hasVideoOfferIntervalPiggyFull, videoOfferIntervalPiggyFull;
@dynamic hasVideoOfferIntervalPiggyExtraFull, videoOfferIntervalPiggyExtraFull;
@dynamic hasVideoResetOnIdle, videoResetOnIdle;
@dynamic hasPackageIntervalContract, packageIntervalContract;
@dynamic hasPackageIntervalPiggyFull, packageIntervalPiggyFull;
@dynamic hasPackageIntervalPiggyExtraFull, packageIntervalPiggyExtraFull;
@dynamic hasPackageResetOnIdle, packageResetOnIdle;

typedef struct LiveConfig_GiftConfig__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *giftConfigsArray;
  LiveConfig_GiftConfig_GiftMuConfig *randomGiftMuConfig;
  LiveConfig_GiftConfig_GiftMuConfig *videoGiftMuConfig;
  double packageInterval;
  double videoOfferInterval;
  double videoOfferIntervalContract;
  double videoOfferIntervalPiggyFull;
  double videoOfferIntervalPiggyExtraFull;
  double packageIntervalContract;
  double packageIntervalPiggyFull;
  double packageIntervalPiggyExtraFull;
  double giftMuMinSpent;
  double giftMuMaxSpent;
  double giftMuOverallMult;
} LiveConfig_GiftConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "packageInterval",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_GiftConfig_FieldNumber_PackageInterval,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LiveConfig_GiftConfig__storage_, packageInterval),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "videoOfferInterval",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_GiftConfig_FieldNumber_VideoOfferInterval,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(LiveConfig_GiftConfig__storage_, videoOfferInterval),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "videoOfferIntervalContract",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_GiftConfig_FieldNumber_VideoOfferIntervalContract,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(LiveConfig_GiftConfig__storage_, videoOfferIntervalContract),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "videoOfferIntervalPiggyFull",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_GiftConfig_FieldNumber_VideoOfferIntervalPiggyFull,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(LiveConfig_GiftConfig__storage_, videoOfferIntervalPiggyFull),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "videoOfferIntervalPiggyExtraFull",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_GiftConfig_FieldNumber_VideoOfferIntervalPiggyExtraFull,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(LiveConfig_GiftConfig__storage_, videoOfferIntervalPiggyExtraFull),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "packageIntervalContract",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_GiftConfig_FieldNumber_PackageIntervalContract,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(LiveConfig_GiftConfig__storage_, packageIntervalContract),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "packageIntervalPiggyFull",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_GiftConfig_FieldNumber_PackageIntervalPiggyFull,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(LiveConfig_GiftConfig__storage_, packageIntervalPiggyFull),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "packageIntervalPiggyExtraFull",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_GiftConfig_FieldNumber_PackageIntervalPiggyExtraFull,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(LiveConfig_GiftConfig__storage_, packageIntervalPiggyExtraFull),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "giftConfigsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(LiveConfig_GiftConfig_GiftValueConfig),
        .number = LiveConfig_GiftConfig_FieldNumber_GiftConfigsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LiveConfig_GiftConfig__storage_, giftConfigsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "giftMuMinSpent",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_GiftConfig_FieldNumber_GiftMuMinSpent,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LiveConfig_GiftConfig__storage_, giftMuMinSpent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "giftMuMaxSpent",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_GiftConfig_FieldNumber_GiftMuMaxSpent,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LiveConfig_GiftConfig__storage_, giftMuMaxSpent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "giftMuOverallMult",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_GiftConfig_FieldNumber_GiftMuOverallMult,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LiveConfig_GiftConfig__storage_, giftMuOverallMult),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "packageResetOnIdle",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_GiftConfig_FieldNumber_PackageResetOnIdle,
        .hasIndex = 15,
        .offset = 16,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "videoResetOnIdle",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_GiftConfig_FieldNumber_VideoResetOnIdle,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "randomGiftMuConfig",
        .dataTypeSpecific.clazz = GPBObjCClass(LiveConfig_GiftConfig_GiftMuConfig),
        .number = LiveConfig_GiftConfig_FieldNumber_RandomGiftMuConfig,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LiveConfig_GiftConfig__storage_, randomGiftMuConfig),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "videoGiftMuConfig",
        .dataTypeSpecific.clazz = GPBObjCClass(LiveConfig_GiftConfig_GiftMuConfig),
        .number = LiveConfig_GiftConfig_FieldNumber_VideoGiftMuConfig,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LiveConfig_GiftConfig__storage_, videoGiftMuConfig),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LiveConfig_GiftConfig class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LiveConfig_GiftConfig__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(LiveConfig)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LiveConfig_GiftConfig_GiftValueConfig

@implementation LiveConfig_GiftConfig_GiftValueConfig

@dynamic hasGiftId, giftId;
@dynamic hasAmount, amount;
@dynamic hasRandMin, randMin;
@dynamic hasRandMax, randMax;
@dynamic hasVideoMin, videoMin;
@dynamic hasVideoMax, videoMax;

typedef struct LiveConfig_GiftConfig_GiftValueConfig__storage_ {
  uint32_t _has_storage_[1];
  NSString *giftId;
  double randMin;
  double randMax;
  double amount;
  double videoMin;
  double videoMax;
} LiveConfig_GiftConfig_GiftValueConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "giftId",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_GiftConfig_GiftValueConfig_FieldNumber_GiftId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LiveConfig_GiftConfig_GiftValueConfig__storage_, giftId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "randMin",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_GiftConfig_GiftValueConfig_FieldNumber_RandMin,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LiveConfig_GiftConfig_GiftValueConfig__storage_, randMin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "randMax",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_GiftConfig_GiftValueConfig_FieldNumber_RandMax,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LiveConfig_GiftConfig_GiftValueConfig__storage_, randMax),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_GiftConfig_GiftValueConfig_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LiveConfig_GiftConfig_GiftValueConfig__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "videoMin",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_GiftConfig_GiftValueConfig_FieldNumber_VideoMin,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LiveConfig_GiftConfig_GiftValueConfig__storage_, videoMin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "videoMax",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_GiftConfig_GiftValueConfig_FieldNumber_VideoMax,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LiveConfig_GiftConfig_GiftValueConfig__storage_, videoMax),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LiveConfig_GiftConfig_GiftValueConfig class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LiveConfig_GiftConfig_GiftValueConfig__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(LiveConfig_GiftConfig)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LiveConfig_GiftConfig_GiftMuConfig

@implementation LiveConfig_GiftConfig_GiftMuConfig

@dynamic hasMinSpent, minSpent;
@dynamic hasMaxSpent, maxSpent;
@dynamic hasOverallMult, overallMult;

typedef struct LiveConfig_GiftConfig_GiftMuConfig__storage_ {
  uint32_t _has_storage_[1];
  double minSpent;
  double maxSpent;
  double overallMult;
} LiveConfig_GiftConfig_GiftMuConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "minSpent",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_GiftConfig_GiftMuConfig_FieldNumber_MinSpent,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LiveConfig_GiftConfig_GiftMuConfig__storage_, minSpent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "maxSpent",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_GiftConfig_GiftMuConfig_FieldNumber_MaxSpent,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LiveConfig_GiftConfig_GiftMuConfig__storage_, maxSpent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "overallMult",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_GiftConfig_GiftMuConfig_FieldNumber_OverallMult,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LiveConfig_GiftConfig_GiftMuConfig__storage_, overallMult),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LiveConfig_GiftConfig_GiftMuConfig class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LiveConfig_GiftConfig_GiftMuConfig__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(LiveConfig_GiftConfig)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LiveConfig_MiscConfig

@implementation LiveConfig_MiscConfig

@dynamic hasAskToTrack, askToTrack;
@dynamic hasAskToTrackMinSoulEggs, askToTrackMinSoulEggs;
@dynamic hasAskToTrackMessage, askToTrackMessage;
@dynamic hasAskToTrackShowPreDialog, askToTrackShowPreDialog;
@dynamic hasAskToTrackAfterPrivacy, askToTrackAfterPrivacy;
@dynamic hasChickenRunBoostPercentage, chickenRunBoostPercentage;
@dynamic hasShellsIntroTickets, shellsIntroTickets;
@dynamic hasShellsMaxFreeChickenConfigs, shellsMaxFreeChickenConfigs;
@dynamic hasShellsIntroAlertThreshold, shellsIntroAlertThreshold;
@dynamic hasContractsExpertLeagueMinSoulPower, contractsExpertLeagueMinSoulPower;

typedef struct LiveConfig_MiscConfig__storage_ {
  uint32_t _has_storage_[1];
  uint32_t shellsIntroTickets;
  uint32_t shellsMaxFreeChickenConfigs;
  uint32_t shellsIntroAlertThreshold;
  NSString *askToTrackMessage;
  double askToTrackMinSoulEggs;
  double chickenRunBoostPercentage;
  double contractsExpertLeagueMinSoulPower;
} LiveConfig_MiscConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "askToTrack",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_MiscConfig_FieldNumber_AskToTrack,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "askToTrackMinSoulEggs",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_MiscConfig_FieldNumber_AskToTrackMinSoulEggs,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LiveConfig_MiscConfig__storage_, askToTrackMinSoulEggs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "askToTrackMessage",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_MiscConfig_FieldNumber_AskToTrackMessage,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LiveConfig_MiscConfig__storage_, askToTrackMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "askToTrackShowPreDialog",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_MiscConfig_FieldNumber_AskToTrackShowPreDialog,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "askToTrackAfterPrivacy",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_MiscConfig_FieldNumber_AskToTrackAfterPrivacy,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "chickenRunBoostPercentage",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_MiscConfig_FieldNumber_ChickenRunBoostPercentage,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(LiveConfig_MiscConfig__storage_, chickenRunBoostPercentage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "shellsIntroTickets",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_MiscConfig_FieldNumber_ShellsIntroTickets,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(LiveConfig_MiscConfig__storage_, shellsIntroTickets),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "shellsMaxFreeChickenConfigs",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_MiscConfig_FieldNumber_ShellsMaxFreeChickenConfigs,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(LiveConfig_MiscConfig__storage_, shellsMaxFreeChickenConfigs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "shellsIntroAlertThreshold",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_MiscConfig_FieldNumber_ShellsIntroAlertThreshold,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(LiveConfig_MiscConfig__storage_, shellsIntroAlertThreshold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "contractsExpertLeagueMinSoulPower",
        .dataTypeSpecific.clazz = Nil,
        .number = LiveConfig_MiscConfig_FieldNumber_ContractsExpertLeagueMinSoulPower,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(LiveConfig_MiscConfig__storage_, contractsExpertLeagueMinSoulPower),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LiveConfig_MiscConfig class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LiveConfig_MiscConfig__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(LiveConfig)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InGameMail

@implementation InGameMail

@dynamic hasId_p, id_p;
@dynamic hasTitle, title;
@dynamic hasDate, date;
@dynamic hasMessage, message;
@dynamic hasAction, action;
@dynamic hasURL, URL;
@dynamic hasPlatform, platform;
@dynamic buildsArray, buildsArray_Count;
@dynamic hasMinClientVersion, minClientVersion;
@dynamic hasMaxClientVersion, maxClientVersion;
@dynamic hasMinSoulEggs, minSoulEggs;
@dynamic hasMinMysticalBonus, minMysticalBonus;
@dynamic hasGoldTip, goldTip;

typedef struct InGameMail__storage_ {
  uint32_t _has_storage_[1];
  uint32_t platform;
  uint32_t minClientVersion;
  uint32_t maxClientVersion;
  NSString *id_p;
  NSString *title;
  NSString *message;
  NSString *action;
  NSString *URL;
  NSString *date;
  NSMutableArray *buildsArray;
  double goldTip;
  double minSoulEggs;
  double minMysticalBonus;
} InGameMail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = InGameMail_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InGameMail__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "title",
        .dataTypeSpecific.clazz = Nil,
        .number = InGameMail_FieldNumber_Title,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InGameMail__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = Nil,
        .number = InGameMail_FieldNumber_Message,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(InGameMail__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "action",
        .dataTypeSpecific.clazz = Nil,
        .number = InGameMail_FieldNumber_Action,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(InGameMail__storage_, action),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.clazz = Nil,
        .number = InGameMail_FieldNumber_URL,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(InGameMail__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "goldTip",
        .dataTypeSpecific.clazz = Nil,
        .number = InGameMail_FieldNumber_GoldTip,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(InGameMail__storage_, goldTip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "platform",
        .dataTypeSpecific.clazz = Nil,
        .number = InGameMail_FieldNumber_Platform,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(InGameMail__storage_, platform),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = InGameMail_FieldNumber_Date,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(InGameMail__storage_, date),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "buildsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = InGameMail_FieldNumber_BuildsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InGameMail__storage_, buildsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "minClientVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = InGameMail_FieldNumber_MinClientVersion,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(InGameMail__storage_, minClientVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "minSoulEggs",
        .dataTypeSpecific.clazz = Nil,
        .number = InGameMail_FieldNumber_MinSoulEggs,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(InGameMail__storage_, minSoulEggs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "maxClientVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = InGameMail_FieldNumber_MaxClientVersion,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(InGameMail__storage_, maxClientVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "minMysticalBonus",
        .dataTypeSpecific.clazz = Nil,
        .number = InGameMail_FieldNumber_MinMysticalBonus,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(InGameMail__storage_, minMysticalBonus),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InGameMail class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InGameMail__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\005!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MailDB

@implementation MailDB

@dynamic mailArray, mailArray_Count;

typedef struct MailDB__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *mailArray;
} MailDB__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mailArray",
        .dataTypeSpecific.clazz = GPBObjCClass(InGameMail),
        .number = MailDB_FieldNumber_MailArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MailDB__storage_, mailArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MailDB class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MailDB__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PeriodicalsResponse

@implementation PeriodicalsResponse

@dynamic hasSales, sales;
@dynamic hasEvents, events;
@dynamic hasContracts, contracts;
@dynamic giftsArray, giftsArray_Count;
@dynamic hasLiveConfig, liveConfig;
@dynamic hasMailBag, mailBag;

typedef struct PeriodicalsResponse__storage_ {
  uint32_t _has_storage_[1];
  SalesInfo *sales;
  EggIncCurrentEvents *events;
  ContractsResponse *contracts;
  NSMutableArray *giftsArray;
  LiveConfig *liveConfig;
  MailDB *mailBag;
} PeriodicalsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sales",
        .dataTypeSpecific.clazz = GPBObjCClass(SalesInfo),
        .number = PeriodicalsResponse_FieldNumber_Sales,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PeriodicalsResponse__storage_, sales),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "events",
        .dataTypeSpecific.clazz = GPBObjCClass(EggIncCurrentEvents),
        .number = PeriodicalsResponse_FieldNumber_Events,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PeriodicalsResponse__storage_, events),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "contracts",
        .dataTypeSpecific.clazz = GPBObjCClass(ContractsResponse),
        .number = PeriodicalsResponse_FieldNumber_Contracts,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PeriodicalsResponse__storage_, contracts),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "giftsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ServerGift),
        .number = PeriodicalsResponse_FieldNumber_GiftsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PeriodicalsResponse__storage_, giftsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "liveConfig",
        .dataTypeSpecific.clazz = GPBObjCClass(LiveConfig),
        .number = PeriodicalsResponse_FieldNumber_LiveConfig,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PeriodicalsResponse__storage_, liveConfig),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mailBag",
        .dataTypeSpecific.clazz = GPBObjCClass(MailDB),
        .number = PeriodicalsResponse_FieldNumber_MailBag,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PeriodicalsResponse__storage_, mailBag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PeriodicalsResponse class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PeriodicalsResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetPeriodicalsRequest

@implementation GetPeriodicalsRequest

@dynamic hasRinfo, rinfo;
@dynamic hasUserId, userId;
@dynamic hasPiggyFull, piggyFull;
@dynamic hasPiggyFoundFull, piggyFoundFull;
@dynamic hasSecondsFullRealtime, secondsFullRealtime;
@dynamic hasSecondsFullGametime, secondsFullGametime;
@dynamic hasLostIncrements, lostIncrements;
@dynamic hasSoulEggs, soulEggs;
@dynamic hasMysticalEarningsMult, mysticalEarningsMult;
@dynamic hasEop, eop;
@dynamic hasContractsUnlocked, contractsUnlocked;
@dynamic hasArtifactsUnlocked, artifactsUnlocked;
@dynamic hasCurrentClientVersion, currentClientVersion;
@dynamic hasDebug, debug;

typedef struct GetPeriodicalsRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t lostIncrements;
  uint32_t currentClientVersion;
  uint32_t eop;
  NSString *userId;
  BasicRequestInfo *rinfo;
  double secondsFullRealtime;
  double secondsFullGametime;
  double soulEggs;
  double mysticalEarningsMult;
} GetPeriodicalsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = GetPeriodicalsRequest_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetPeriodicalsRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "piggyFull",
        .dataTypeSpecific.clazz = Nil,
        .number = GetPeriodicalsRequest_FieldNumber_PiggyFull,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "piggyFoundFull",
        .dataTypeSpecific.clazz = Nil,
        .number = GetPeriodicalsRequest_FieldNumber_PiggyFoundFull,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "secondsFullRealtime",
        .dataTypeSpecific.clazz = Nil,
        .number = GetPeriodicalsRequest_FieldNumber_SecondsFullRealtime,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GetPeriodicalsRequest__storage_, secondsFullRealtime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "secondsFullGametime",
        .dataTypeSpecific.clazz = Nil,
        .number = GetPeriodicalsRequest_FieldNumber_SecondsFullGametime,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GetPeriodicalsRequest__storage_, secondsFullGametime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "lostIncrements",
        .dataTypeSpecific.clazz = Nil,
        .number = GetPeriodicalsRequest_FieldNumber_LostIncrements,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(GetPeriodicalsRequest__storage_, lostIncrements),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "soulEggs",
        .dataTypeSpecific.clazz = Nil,
        .number = GetPeriodicalsRequest_FieldNumber_SoulEggs,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(GetPeriodicalsRequest__storage_, soulEggs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "currentClientVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = GetPeriodicalsRequest_FieldNumber_CurrentClientVersion,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(GetPeriodicalsRequest__storage_, currentClientVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "debug",
        .dataTypeSpecific.clazz = Nil,
        .number = GetPeriodicalsRequest_FieldNumber_Debug,
        .hasIndex = 17,
        .offset = 18,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "rinfo",
        .dataTypeSpecific.clazz = GPBObjCClass(BasicRequestInfo),
        .number = GetPeriodicalsRequest_FieldNumber_Rinfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetPeriodicalsRequest__storage_, rinfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mysticalEarningsMult",
        .dataTypeSpecific.clazz = Nil,
        .number = GetPeriodicalsRequest_FieldNumber_MysticalEarningsMult,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(GetPeriodicalsRequest__storage_, mysticalEarningsMult),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "eop",
        .dataTypeSpecific.clazz = Nil,
        .number = GetPeriodicalsRequest_FieldNumber_Eop,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(GetPeriodicalsRequest__storage_, eop),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "contractsUnlocked",
        .dataTypeSpecific.clazz = Nil,
        .number = GetPeriodicalsRequest_FieldNumber_ContractsUnlocked,
        .hasIndex = 12,
        .offset = 13,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "artifactsUnlocked",
        .dataTypeSpecific.clazz = Nil,
        .number = GetPeriodicalsRequest_FieldNumber_ArtifactsUnlocked,
        .hasIndex = 14,
        .offset = 15,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetPeriodicalsRequest class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetPeriodicalsRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ConfigRequest

@implementation ConfigRequest

@dynamic hasRinfo, rinfo;
@dynamic hasSoulEggs, soulEggs;
@dynamic hasArtifactsEnabled, artifactsEnabled;
@dynamic hasFuelTankUnlocked, fuelTankUnlocked;

typedef struct ConfigRequest__storage_ {
  uint32_t _has_storage_[1];
  BasicRequestInfo *rinfo;
  double soulEggs;
} ConfigRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rinfo",
        .dataTypeSpecific.clazz = GPBObjCClass(BasicRequestInfo),
        .number = ConfigRequest_FieldNumber_Rinfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ConfigRequest__storage_, rinfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "soulEggs",
        .dataTypeSpecific.clazz = Nil,
        .number = ConfigRequest_FieldNumber_SoulEggs,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ConfigRequest__storage_, soulEggs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "artifactsEnabled",
        .dataTypeSpecific.clazz = Nil,
        .number = ConfigRequest_FieldNumber_ArtifactsEnabled,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "fuelTankUnlocked",
        .dataTypeSpecific.clazz = Nil,
        .number = ConfigRequest_FieldNumber_FuelTankUnlocked,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ConfigRequest class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ConfigRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ConfigResponse

@implementation ConfigResponse

@dynamic hasLiveConfig, liveConfig;
@dynamic hasMailBag, mailBag;
@dynamic hasDlcCatalog, dlcCatalog;

typedef struct ConfigResponse__storage_ {
  uint32_t _has_storage_[1];
  LiveConfig *liveConfig;
  MailDB *mailBag;
  DLCCatalog *dlcCatalog;
} ConfigResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "liveConfig",
        .dataTypeSpecific.clazz = GPBObjCClass(LiveConfig),
        .number = ConfigResponse_FieldNumber_LiveConfig,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ConfigResponse__storage_, liveConfig),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mailBag",
        .dataTypeSpecific.clazz = GPBObjCClass(MailDB),
        .number = ConfigResponse_FieldNumber_MailBag,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ConfigResponse__storage_, mailBag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dlcCatalog",
        .dataTypeSpecific.clazz = GPBObjCClass(DLCCatalog),
        .number = ConfigResponse_FieldNumber_DlcCatalog,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ConfigResponse__storage_, dlcCatalog),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ConfigResponse class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ConfigResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AdAttributionRawData

@implementation AdAttributionRawData

@dynamic hasDeviceAdId, deviceAdId;
@dynamic hasUserId, userId;
@dynamic hasAdNetwork, adNetwork;
@dynamic hasJsonData, jsonData;

typedef struct AdAttributionRawData__storage_ {
  uint32_t _has_storage_[1];
  NSString *deviceAdId;
  NSString *adNetwork;
  NSString *jsonData;
  NSString *userId;
} AdAttributionRawData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deviceAdId",
        .dataTypeSpecific.clazz = Nil,
        .number = AdAttributionRawData_FieldNumber_DeviceAdId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AdAttributionRawData__storage_, deviceAdId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "adNetwork",
        .dataTypeSpecific.clazz = Nil,
        .number = AdAttributionRawData_FieldNumber_AdNetwork,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AdAttributionRawData__storage_, adNetwork),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "jsonData",
        .dataTypeSpecific.clazz = Nil,
        .number = AdAttributionRawData_FieldNumber_JsonData,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AdAttributionRawData__storage_, jsonData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = AdAttributionRawData_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AdAttributionRawData__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AdAttributionRawData class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AdAttributionRawData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AdAttributionRow

@implementation AdAttributionRow

@dynamic hasUserId, userId;
@dynamic hasAdId, adId;
@dynamic hasAdNetwork, adNetwork;
@dynamic hasCampaign, campaign;
@dynamic hasKeyword, keyword;
@dynamic hasExtra, extra;
@dynamic hasClickDate, clickDate;
@dynamic hasDownloadDate, downloadDate;
@dynamic hasApproxTime, approxTime;

typedef struct AdAttributionRow__storage_ {
  uint32_t _has_storage_[1];
  float clickDate;
  float downloadDate;
  float approxTime;
  NSString *userId;
  NSString *adId;
  NSString *adNetwork;
  NSString *campaign;
  NSString *keyword;
  NSString *extra;
} AdAttributionRow__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = AdAttributionRow_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AdAttributionRow__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "adId",
        .dataTypeSpecific.clazz = Nil,
        .number = AdAttributionRow_FieldNumber_AdId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AdAttributionRow__storage_, adId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "adNetwork",
        .dataTypeSpecific.clazz = Nil,
        .number = AdAttributionRow_FieldNumber_AdNetwork,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AdAttributionRow__storage_, adNetwork),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "campaign",
        .dataTypeSpecific.clazz = Nil,
        .number = AdAttributionRow_FieldNumber_Campaign,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AdAttributionRow__storage_, campaign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "keyword",
        .dataTypeSpecific.clazz = Nil,
        .number = AdAttributionRow_FieldNumber_Keyword,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AdAttributionRow__storage_, keyword),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extra",
        .dataTypeSpecific.clazz = Nil,
        .number = AdAttributionRow_FieldNumber_Extra,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AdAttributionRow__storage_, extra),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clickDate",
        .dataTypeSpecific.clazz = Nil,
        .number = AdAttributionRow_FieldNumber_ClickDate,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(AdAttributionRow__storage_, clickDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "downloadDate",
        .dataTypeSpecific.clazz = Nil,
        .number = AdAttributionRow_FieldNumber_DownloadDate,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(AdAttributionRow__storage_, downloadDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "approxTime",
        .dataTypeSpecific.clazz = Nil,
        .number = AdAttributionRow_FieldNumber_ApproxTime,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(AdAttributionRow__storage_, approxTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AdAttributionRow class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AdAttributionRow__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AdAttributionInfo

@implementation AdAttributionInfo

@dynamic hasDeviceAdId, deviceAdId;
@dynamic hasNetworkName, networkName;
@dynamic hasAttribution, attribution;
@dynamic hasOrgName, orgName;
@dynamic hasOrgId, orgId;
@dynamic hasCampaignName, campaignName;
@dynamic hasCampaignId, campaignId;
@dynamic hasClickDate, clickDate;
@dynamic hasConversionDate, conversionDate;
@dynamic hasConversionType, conversionType;
@dynamic hasGeo, geo;
@dynamic hasAdgroupName, adgroupName;
@dynamic hasAdgroupId, adgroupId;
@dynamic hasKeyword, keyword;
@dynamic hasKeywordId, keywordId;
@dynamic hasKeywordExtra, keywordExtra;
@dynamic hasCreativesetName, creativesetName;
@dynamic hasCreativesetId, creativesetId;

typedef struct AdAttributionInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *deviceAdId;
  NSString *networkName;
  NSString *orgName;
  NSString *orgId;
  NSString *campaignName;
  NSString *campaignId;
  NSString *clickDate;
  NSString *conversionDate;
  NSString *conversionType;
  NSString *geo;
  NSString *adgroupName;
  NSString *adgroupId;
  NSString *keyword;
  NSString *keywordId;
  NSString *keywordExtra;
  NSString *creativesetName;
  NSString *creativesetId;
} AdAttributionInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deviceAdId",
        .dataTypeSpecific.clazz = Nil,
        .number = AdAttributionInfo_FieldNumber_DeviceAdId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AdAttributionInfo__storage_, deviceAdId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "networkName",
        .dataTypeSpecific.clazz = Nil,
        .number = AdAttributionInfo_FieldNumber_NetworkName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AdAttributionInfo__storage_, networkName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "attribution",
        .dataTypeSpecific.clazz = Nil,
        .number = AdAttributionInfo_FieldNumber_Attribution,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "orgName",
        .dataTypeSpecific.clazz = Nil,
        .number = AdAttributionInfo_FieldNumber_OrgName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AdAttributionInfo__storage_, orgName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "orgId",
        .dataTypeSpecific.clazz = Nil,
        .number = AdAttributionInfo_FieldNumber_OrgId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AdAttributionInfo__storage_, orgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "campaignName",
        .dataTypeSpecific.clazz = Nil,
        .number = AdAttributionInfo_FieldNumber_CampaignName,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(AdAttributionInfo__storage_, campaignName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "campaignId",
        .dataTypeSpecific.clazz = Nil,
        .number = AdAttributionInfo_FieldNumber_CampaignId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(AdAttributionInfo__storage_, campaignId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clickDate",
        .dataTypeSpecific.clazz = Nil,
        .number = AdAttributionInfo_FieldNumber_ClickDate,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(AdAttributionInfo__storage_, clickDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "conversionDate",
        .dataTypeSpecific.clazz = Nil,
        .number = AdAttributionInfo_FieldNumber_ConversionDate,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(AdAttributionInfo__storage_, conversionDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "conversionType",
        .dataTypeSpecific.clazz = Nil,
        .number = AdAttributionInfo_FieldNumber_ConversionType,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(AdAttributionInfo__storage_, conversionType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "geo",
        .dataTypeSpecific.clazz = Nil,
        .number = AdAttributionInfo_FieldNumber_Geo,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(AdAttributionInfo__storage_, geo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "adgroupName",
        .dataTypeSpecific.clazz = Nil,
        .number = AdAttributionInfo_FieldNumber_AdgroupName,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(AdAttributionInfo__storage_, adgroupName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "adgroupId",
        .dataTypeSpecific.clazz = Nil,
        .number = AdAttributionInfo_FieldNumber_AdgroupId,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(AdAttributionInfo__storage_, adgroupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "keyword",
        .dataTypeSpecific.clazz = Nil,
        .number = AdAttributionInfo_FieldNumber_Keyword,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(AdAttributionInfo__storage_, keyword),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "keywordId",
        .dataTypeSpecific.clazz = Nil,
        .number = AdAttributionInfo_FieldNumber_KeywordId,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(AdAttributionInfo__storage_, keywordId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "keywordExtra",
        .dataTypeSpecific.clazz = Nil,
        .number = AdAttributionInfo_FieldNumber_KeywordExtra,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(AdAttributionInfo__storage_, keywordExtra),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "creativesetName",
        .dataTypeSpecific.clazz = Nil,
        .number = AdAttributionInfo_FieldNumber_CreativesetName,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(AdAttributionInfo__storage_, creativesetName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "creativesetId",
        .dataTypeSpecific.clazz = Nil,
        .number = AdAttributionInfo_FieldNumber_CreativesetId,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(AdAttributionInfo__storage_, creativesetId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AdAttributionInfo class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AdAttributionInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ArtifactsClientInfo

@implementation ArtifactsClientInfo

@dynamic hasMissionCapacityMult, missionCapacityMult;
@dynamic hasMissionDurationMult, missionDurationMult;
@dynamic hasMissionFtlDurationMult, missionFtlDurationMult;
@dynamic launchCountsArray, launchCountsArray_Count;

typedef struct ArtifactsClientInfo__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *launchCountsArray;
  double missionCapacityMult;
  double missionDurationMult;
  double missionFtlDurationMult;
} ArtifactsClientInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "missionCapacityMult",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsClientInfo_FieldNumber_MissionCapacityMult,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ArtifactsClientInfo__storage_, missionCapacityMult),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "missionDurationMult",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsClientInfo_FieldNumber_MissionDurationMult,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ArtifactsClientInfo__storage_, missionDurationMult),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "launchCountsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ArtifactsClientInfo_LaunchCount),
        .number = ArtifactsClientInfo_FieldNumber_LaunchCountsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ArtifactsClientInfo__storage_, launchCountsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "missionFtlDurationMult",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsClientInfo_FieldNumber_MissionFtlDurationMult,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ArtifactsClientInfo__storage_, missionFtlDurationMult),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ArtifactsClientInfo class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ArtifactsClientInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ArtifactsClientInfo_LaunchCount

@implementation ArtifactsClientInfo_LaunchCount

@dynamic hasShip, ship;
@dynamic hasNumLaunches, numLaunches;
@dynamic hasLaunchPoints, launchPoints;

typedef struct ArtifactsClientInfo_LaunchCount__storage_ {
  uint32_t _has_storage_[1];
  MissionInfo_Spaceship ship;
  uint32_t numLaunches;
  double launchPoints;
} ArtifactsClientInfo_LaunchCount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ship",
        .dataTypeSpecific.enumDescFunc = MissionInfo_Spaceship_EnumDescriptor,
        .number = ArtifactsClientInfo_LaunchCount_FieldNumber_Ship,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ArtifactsClientInfo_LaunchCount__storage_, ship),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "numLaunches",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsClientInfo_LaunchCount_FieldNumber_NumLaunches,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ArtifactsClientInfo_LaunchCount__storage_, numLaunches),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "launchPoints",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsClientInfo_LaunchCount_FieldNumber_LaunchPoints,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ArtifactsClientInfo_LaunchCount__storage_, launchPoints),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ArtifactsClientInfo_LaunchCount class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ArtifactsClientInfo_LaunchCount__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ArtifactsClientInfo)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MissionInfo

@implementation MissionInfo

@dynamic hasShip, ship;
@dynamic hasStatus, status;
@dynamic hasDurationType, durationType;
@dynamic fuelArray, fuelArray_Count;
@dynamic hasLevel, level;
@dynamic hasDurationSeconds, durationSeconds;
@dynamic hasCapacity, capacity;
@dynamic hasQualityBump, qualityBump;
@dynamic hasSecondsRemaining, secondsRemaining;
@dynamic hasStartTimeDerived, startTimeDerived;
@dynamic hasMissionLog, missionLog;
@dynamic hasIdentifier, identifier;

typedef struct MissionInfo__storage_ {
  uint32_t _has_storage_[1];
  MissionInfo_Spaceship ship;
  MissionInfo_Status status;
  MissionInfo_DurationType durationType;
  uint32_t capacity;
  uint32_t level;
  NSMutableArray *fuelArray;
  NSString *identifier;
  NSString *missionLog;
  double durationSeconds;
  double secondsRemaining;
  double startTimeDerived;
  double qualityBump;
} MissionInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ship",
        .dataTypeSpecific.enumDescFunc = MissionInfo_Spaceship_EnumDescriptor,
        .number = MissionInfo_FieldNumber_Ship,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MissionInfo__storage_, ship),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = MissionInfo_Status_EnumDescriptor,
        .number = MissionInfo_FieldNumber_Status,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MissionInfo__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "durationType",
        .dataTypeSpecific.enumDescFunc = MissionInfo_DurationType_EnumDescriptor,
        .number = MissionInfo_FieldNumber_DurationType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MissionInfo__storage_, durationType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "fuelArray",
        .dataTypeSpecific.clazz = GPBObjCClass(MissionInfo_Fuel),
        .number = MissionInfo_FieldNumber_FuelArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MissionInfo__storage_, fuelArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "durationSeconds",
        .dataTypeSpecific.clazz = Nil,
        .number = MissionInfo_FieldNumber_DurationSeconds,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MissionInfo__storage_, durationSeconds),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "secondsRemaining",
        .dataTypeSpecific.clazz = Nil,
        .number = MissionInfo_FieldNumber_SecondsRemaining,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(MissionInfo__storage_, secondsRemaining),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "identifier",
        .dataTypeSpecific.clazz = Nil,
        .number = MissionInfo_FieldNumber_Identifier,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(MissionInfo__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "startTimeDerived",
        .dataTypeSpecific.clazz = Nil,
        .number = MissionInfo_FieldNumber_StartTimeDerived,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(MissionInfo__storage_, startTimeDerived),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "capacity",
        .dataTypeSpecific.clazz = Nil,
        .number = MissionInfo_FieldNumber_Capacity,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(MissionInfo__storage_, capacity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "missionLog",
        .dataTypeSpecific.clazz = Nil,
        .number = MissionInfo_FieldNumber_MissionLog,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(MissionInfo__storage_, missionLog),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "qualityBump",
        .dataTypeSpecific.clazz = Nil,
        .number = MissionInfo_FieldNumber_QualityBump,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(MissionInfo__storage_, qualityBump),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "level",
        .dataTypeSpecific.clazz = Nil,
        .number = MissionInfo_FieldNumber_Level,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MissionInfo__storage_, level),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MissionInfo class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MissionInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum MissionInfo_Spaceship

GPBEnumDescriptor *MissionInfo_Spaceship_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ChickenOne\000ChickenNine\000ChickenHeavy\000Bcr\000"
        "MilleniumChicken\000CorellihenCorvette\000Gale"
        "ggtica\000Chickfiant\000Voyegger\000Henerprise\000";
    static const int32_t values[] = {
        MissionInfo_Spaceship_ChickenOne,
        MissionInfo_Spaceship_ChickenNine,
        MissionInfo_Spaceship_ChickenHeavy,
        MissionInfo_Spaceship_Bcr,
        MissionInfo_Spaceship_MilleniumChicken,
        MissionInfo_Spaceship_CorellihenCorvette,
        MissionInfo_Spaceship_Galeggtica,
        MissionInfo_Spaceship_Chickfiant,
        MissionInfo_Spaceship_Voyegger,
        MissionInfo_Spaceship_Henerprise,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MissionInfo_Spaceship)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MissionInfo_Spaceship_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MissionInfo_Spaceship_IsValidValue(int32_t value__) {
  switch (value__) {
    case MissionInfo_Spaceship_ChickenOne:
    case MissionInfo_Spaceship_ChickenNine:
    case MissionInfo_Spaceship_ChickenHeavy:
    case MissionInfo_Spaceship_Bcr:
    case MissionInfo_Spaceship_MilleniumChicken:
    case MissionInfo_Spaceship_CorellihenCorvette:
    case MissionInfo_Spaceship_Galeggtica:
    case MissionInfo_Spaceship_Chickfiant:
    case MissionInfo_Spaceship_Voyegger:
    case MissionInfo_Spaceship_Henerprise:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MissionInfo_Status

GPBEnumDescriptor *MissionInfo_Status_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Fueling\000PrepareToLaunch\000Exploring\000Return"
        "ed\000Analyzing\000Complete\000Archived\000";
    static const int32_t values[] = {
        MissionInfo_Status_Fueling,
        MissionInfo_Status_PrepareToLaunch,
        MissionInfo_Status_Exploring,
        MissionInfo_Status_Returned,
        MissionInfo_Status_Analyzing,
        MissionInfo_Status_Complete,
        MissionInfo_Status_Archived,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MissionInfo_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MissionInfo_Status_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MissionInfo_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case MissionInfo_Status_Fueling:
    case MissionInfo_Status_PrepareToLaunch:
    case MissionInfo_Status_Exploring:
    case MissionInfo_Status_Returned:
    case MissionInfo_Status_Analyzing:
    case MissionInfo_Status_Complete:
    case MissionInfo_Status_Archived:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MissionInfo_DurationType

GPBEnumDescriptor *MissionInfo_DurationType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Short\000Long\000Epic\000Tutorial\000";
    static const int32_t values[] = {
        MissionInfo_DurationType_Short,
        MissionInfo_DurationType_Long,
        MissionInfo_DurationType_Epic,
        MissionInfo_DurationType_Tutorial,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MissionInfo_DurationType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MissionInfo_DurationType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MissionInfo_DurationType_IsValidValue(int32_t value__) {
  switch (value__) {
    case MissionInfo_DurationType_Short:
    case MissionInfo_DurationType_Long:
    case MissionInfo_DurationType_Epic:
    case MissionInfo_DurationType_Tutorial:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - MissionInfo_Fuel

@implementation MissionInfo_Fuel

@dynamic hasEgg, egg;
@dynamic hasAmount, amount;

typedef struct MissionInfo_Fuel__storage_ {
  uint32_t _has_storage_[1];
  Egg egg;
  double amount;
} MissionInfo_Fuel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = Egg_Edible,
        .core.name = "egg",
        .core.dataTypeSpecific.enumDescFunc = Egg_EnumDescriptor,
        .core.number = MissionInfo_Fuel_FieldNumber_Egg,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(MissionInfo_Fuel__storage_, egg),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "amount",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = MissionInfo_Fuel_FieldNumber_Amount,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(MissionInfo_Fuel__storage_, amount),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MissionInfo_Fuel class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(MissionInfo_Fuel__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(MissionInfo)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ArtifactSpec

@implementation ArtifactSpec

@dynamic hasName, name;
@dynamic hasLevel, level;
@dynamic hasRarity, rarity;
@dynamic hasEgg, egg;

typedef struct ArtifactSpec__storage_ {
  uint32_t _has_storage_[1];
  ArtifactSpec_Name name;
  ArtifactSpec_Level level;
  ArtifactSpec_Rarity rarity;
  Egg egg;
} ArtifactSpec__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = ArtifactSpec_Name_LunarTotem,
        .core.name = "name",
        .core.dataTypeSpecific.enumDescFunc = ArtifactSpec_Name_EnumDescriptor,
        .core.number = ArtifactSpec_FieldNumber_Name,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ArtifactSpec__storage_, name),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueEnum = ArtifactSpec_Level_Inferior,
        .core.name = "level",
        .core.dataTypeSpecific.enumDescFunc = ArtifactSpec_Level_EnumDescriptor,
        .core.number = ArtifactSpec_FieldNumber_Level,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ArtifactSpec__storage_, level),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueEnum = ArtifactSpec_Rarity_Common,
        .core.name = "rarity",
        .core.dataTypeSpecific.enumDescFunc = ArtifactSpec_Rarity_EnumDescriptor,
        .core.number = ArtifactSpec_FieldNumber_Rarity,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ArtifactSpec__storage_, rarity),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueEnum = Egg_Edible,
        .core.name = "egg",
        .core.dataTypeSpecific.enumDescFunc = Egg_EnumDescriptor,
        .core.number = ArtifactSpec_FieldNumber_Egg,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ArtifactSpec__storage_, egg),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ArtifactSpec class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ArtifactSpec__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ArtifactSpec_Name

GPBEnumDescriptor *ArtifactSpec_Name_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "LunarTotem\000NeodymiumMedallion\000BeakOfMida"
        "s\000LightOfEggendil\000DemetersNecklace\000VialM"
        "artianDust\000OrnateGusset\000TheChalice\000BookO"
        "fBasan\000PhoenixFeather\000TungstenAnkh\000Aurel"
        "ianBrooch\000CarvedRainstick\000PuzzleCube\000Qua"
        "ntumMetronome\000ShipInABottle\000TachyonDefle"
        "ctor\000InterstellarCompass\000DilithiumMonocl"
        "e\000TitaniumActuator\000MercurysLens\000TachyonS"
        "tone\000DilithiumStone\000ShellStone\000LunarSton"
        "e\000SoulStone\000ProphecyStone\000QuantumStone\000T"
        "erraStone\000LifeStone\000ClarityStone\000Extrate"
        "rrestrialAluminum\000AncientTungsten\000SpaceR"
        "ocks\000AlienWood\000GoldMeteorite\000TauCetiGeod"
        "e\000CentaurianSteel\000EridaniFeather\000DronePa"
        "rts\000CelestialBronze\000LalandeHide\000SolarTit"
        "anium\000TachyonStoneFragment\000DilithiumSton"
        "eFragment\000ShellStoneFragment\000LunarStoneF"
        "ragment\000SoulStoneFragment\000ProphecyStoneF"
        "ragment\000QuantumStoneFragment\000TerraStoneF"
        "ragment\000LifeStoneFragment\000ClarityStoneFr"
        "agment\000Unknown\000";
    static const int32_t values[] = {
        ArtifactSpec_Name_LunarTotem,
        ArtifactSpec_Name_NeodymiumMedallion,
        ArtifactSpec_Name_BeakOfMidas,
        ArtifactSpec_Name_LightOfEggendil,
        ArtifactSpec_Name_DemetersNecklace,
        ArtifactSpec_Name_VialMartianDust,
        ArtifactSpec_Name_OrnateGusset,
        ArtifactSpec_Name_TheChalice,
        ArtifactSpec_Name_BookOfBasan,
        ArtifactSpec_Name_PhoenixFeather,
        ArtifactSpec_Name_TungstenAnkh,
        ArtifactSpec_Name_AurelianBrooch,
        ArtifactSpec_Name_CarvedRainstick,
        ArtifactSpec_Name_PuzzleCube,
        ArtifactSpec_Name_QuantumMetronome,
        ArtifactSpec_Name_ShipInABottle,
        ArtifactSpec_Name_TachyonDeflector,
        ArtifactSpec_Name_InterstellarCompass,
        ArtifactSpec_Name_DilithiumMonocle,
        ArtifactSpec_Name_TitaniumActuator,
        ArtifactSpec_Name_MercurysLens,
        ArtifactSpec_Name_TachyonStone,
        ArtifactSpec_Name_DilithiumStone,
        ArtifactSpec_Name_ShellStone,
        ArtifactSpec_Name_LunarStone,
        ArtifactSpec_Name_SoulStone,
        ArtifactSpec_Name_ProphecyStone,
        ArtifactSpec_Name_QuantumStone,
        ArtifactSpec_Name_TerraStone,
        ArtifactSpec_Name_LifeStone,
        ArtifactSpec_Name_ClarityStone,
        ArtifactSpec_Name_ExtraterrestrialAluminum,
        ArtifactSpec_Name_AncientTungsten,
        ArtifactSpec_Name_SpaceRocks,
        ArtifactSpec_Name_AlienWood,
        ArtifactSpec_Name_GoldMeteorite,
        ArtifactSpec_Name_TauCetiGeode,
        ArtifactSpec_Name_CentaurianSteel,
        ArtifactSpec_Name_EridaniFeather,
        ArtifactSpec_Name_DroneParts,
        ArtifactSpec_Name_CelestialBronze,
        ArtifactSpec_Name_LalandeHide,
        ArtifactSpec_Name_SolarTitanium,
        ArtifactSpec_Name_TachyonStoneFragment,
        ArtifactSpec_Name_DilithiumStoneFragment,
        ArtifactSpec_Name_ShellStoneFragment,
        ArtifactSpec_Name_LunarStoneFragment,
        ArtifactSpec_Name_SoulStoneFragment,
        ArtifactSpec_Name_ProphecyStoneFragment,
        ArtifactSpec_Name_QuantumStoneFragment,
        ArtifactSpec_Name_TerraStoneFragment,
        ArtifactSpec_Name_LifeStoneFragment,
        ArtifactSpec_Name_ClarityStoneFragment,
        ArtifactSpec_Name_Unknown,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ArtifactSpec_Name)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ArtifactSpec_Name_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ArtifactSpec_Name_IsValidValue(int32_t value__) {
  switch (value__) {
    case ArtifactSpec_Name_LunarTotem:
    case ArtifactSpec_Name_NeodymiumMedallion:
    case ArtifactSpec_Name_BeakOfMidas:
    case ArtifactSpec_Name_LightOfEggendil:
    case ArtifactSpec_Name_DemetersNecklace:
    case ArtifactSpec_Name_VialMartianDust:
    case ArtifactSpec_Name_OrnateGusset:
    case ArtifactSpec_Name_TheChalice:
    case ArtifactSpec_Name_BookOfBasan:
    case ArtifactSpec_Name_PhoenixFeather:
    case ArtifactSpec_Name_TungstenAnkh:
    case ArtifactSpec_Name_AurelianBrooch:
    case ArtifactSpec_Name_CarvedRainstick:
    case ArtifactSpec_Name_PuzzleCube:
    case ArtifactSpec_Name_QuantumMetronome:
    case ArtifactSpec_Name_ShipInABottle:
    case ArtifactSpec_Name_TachyonDeflector:
    case ArtifactSpec_Name_InterstellarCompass:
    case ArtifactSpec_Name_DilithiumMonocle:
    case ArtifactSpec_Name_TitaniumActuator:
    case ArtifactSpec_Name_MercurysLens:
    case ArtifactSpec_Name_TachyonStone:
    case ArtifactSpec_Name_DilithiumStone:
    case ArtifactSpec_Name_ShellStone:
    case ArtifactSpec_Name_LunarStone:
    case ArtifactSpec_Name_SoulStone:
    case ArtifactSpec_Name_ProphecyStone:
    case ArtifactSpec_Name_QuantumStone:
    case ArtifactSpec_Name_TerraStone:
    case ArtifactSpec_Name_LifeStone:
    case ArtifactSpec_Name_ClarityStone:
    case ArtifactSpec_Name_ExtraterrestrialAluminum:
    case ArtifactSpec_Name_AncientTungsten:
    case ArtifactSpec_Name_SpaceRocks:
    case ArtifactSpec_Name_AlienWood:
    case ArtifactSpec_Name_GoldMeteorite:
    case ArtifactSpec_Name_TauCetiGeode:
    case ArtifactSpec_Name_CentaurianSteel:
    case ArtifactSpec_Name_EridaniFeather:
    case ArtifactSpec_Name_DroneParts:
    case ArtifactSpec_Name_CelestialBronze:
    case ArtifactSpec_Name_LalandeHide:
    case ArtifactSpec_Name_SolarTitanium:
    case ArtifactSpec_Name_TachyonStoneFragment:
    case ArtifactSpec_Name_DilithiumStoneFragment:
    case ArtifactSpec_Name_ShellStoneFragment:
    case ArtifactSpec_Name_LunarStoneFragment:
    case ArtifactSpec_Name_SoulStoneFragment:
    case ArtifactSpec_Name_ProphecyStoneFragment:
    case ArtifactSpec_Name_QuantumStoneFragment:
    case ArtifactSpec_Name_TerraStoneFragment:
    case ArtifactSpec_Name_LifeStoneFragment:
    case ArtifactSpec_Name_ClarityStoneFragment:
    case ArtifactSpec_Name_Unknown:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ArtifactSpec_Level

GPBEnumDescriptor *ArtifactSpec_Level_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Inferior\000Lesser\000Normal\000Greater\000Superior\000";
    static const int32_t values[] = {
        ArtifactSpec_Level_Inferior,
        ArtifactSpec_Level_Lesser,
        ArtifactSpec_Level_Normal,
        ArtifactSpec_Level_Greater,
        ArtifactSpec_Level_Superior,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ArtifactSpec_Level)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ArtifactSpec_Level_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ArtifactSpec_Level_IsValidValue(int32_t value__) {
  switch (value__) {
    case ArtifactSpec_Level_Inferior:
    case ArtifactSpec_Level_Lesser:
    case ArtifactSpec_Level_Normal:
    case ArtifactSpec_Level_Greater:
    case ArtifactSpec_Level_Superior:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ArtifactSpec_Rarity

GPBEnumDescriptor *ArtifactSpec_Rarity_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Common\000Rare\000Epic\000Legendary\000";
    static const int32_t values[] = {
        ArtifactSpec_Rarity_Common,
        ArtifactSpec_Rarity_Rare,
        ArtifactSpec_Rarity_Epic,
        ArtifactSpec_Rarity_Legendary,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ArtifactSpec_Rarity)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ArtifactSpec_Rarity_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ArtifactSpec_Rarity_IsValidValue(int32_t value__) {
  switch (value__) {
    case ArtifactSpec_Rarity_Common:
    case ArtifactSpec_Rarity_Rare:
    case ArtifactSpec_Rarity_Epic:
    case ArtifactSpec_Rarity_Legendary:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ArtifactSpec_Type

GPBEnumDescriptor *ArtifactSpec_Type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Artifact\000Stone\000Ingredient\000StoneIngredien"
        "t\000";
    static const int32_t values[] = {
        ArtifactSpec_Type_Artifact,
        ArtifactSpec_Type_Stone,
        ArtifactSpec_Type_Ingredient,
        ArtifactSpec_Type_StoneIngredient,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ArtifactSpec_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ArtifactSpec_Type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ArtifactSpec_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case ArtifactSpec_Type_Artifact:
    case ArtifactSpec_Type_Stone:
    case ArtifactSpec_Type_Ingredient:
    case ArtifactSpec_Type_StoneIngredient:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - CompleteArtifact

@implementation CompleteArtifact

@dynamic hasSpec, spec;
@dynamic stonesArray, stonesArray_Count;

typedef struct CompleteArtifact__storage_ {
  uint32_t _has_storage_[1];
  ArtifactSpec *spec;
  NSMutableArray *stonesArray;
} CompleteArtifact__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "spec",
        .dataTypeSpecific.clazz = GPBObjCClass(ArtifactSpec),
        .number = CompleteArtifact_FieldNumber_Spec,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CompleteArtifact__storage_, spec),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stonesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ArtifactSpec),
        .number = CompleteArtifact_FieldNumber_StonesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CompleteArtifact__storage_, stonesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CompleteArtifact class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CompleteArtifact__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ArtifactInventoryItem

@implementation ArtifactInventoryItem

@dynamic hasItemId, itemId;
@dynamic hasArtifact, artifact;
@dynamic hasQuantity, quantity;
@dynamic hasServerId, serverId;

typedef struct ArtifactInventoryItem__storage_ {
  uint32_t _has_storage_[1];
  CompleteArtifact *artifact;
  NSString *serverId;
  uint64_t itemId;
  double quantity;
} ArtifactInventoryItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemId",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactInventoryItem_FieldNumber_ItemId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ArtifactInventoryItem__storage_, itemId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "artifact",
        .dataTypeSpecific.clazz = GPBObjCClass(CompleteArtifact),
        .number = ArtifactInventoryItem_FieldNumber_Artifact,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ArtifactInventoryItem__storage_, artifact),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "quantity",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactInventoryItem_FieldNumber_Quantity,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ArtifactInventoryItem__storage_, quantity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "serverId",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactInventoryItem_FieldNumber_ServerId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ArtifactInventoryItem__storage_, serverId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ArtifactInventoryItem class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ArtifactInventoryItem__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InventorySlot

@implementation InventorySlot

@dynamic hasOccupied, occupied;
@dynamic hasItemId, itemId;

typedef struct InventorySlot__storage_ {
  uint32_t _has_storage_[1];
  uint32_t itemId;
} InventorySlot__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "occupied",
        .dataTypeSpecific.clazz = Nil,
        .number = InventorySlot_FieldNumber_Occupied,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "itemId",
        .dataTypeSpecific.clazz = Nil,
        .number = InventorySlot_FieldNumber_ItemId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(InventorySlot__storage_, itemId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InventorySlot class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InventorySlot__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ArtifactsConfigurationRequest

@implementation ArtifactsConfigurationRequest

@dynamic hasRinfo, rinfo;
@dynamic hasClientVersion, clientVersion;

typedef struct ArtifactsConfigurationRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t clientVersion;
  BasicRequestInfo *rinfo;
} ArtifactsConfigurationRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "clientVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsConfigurationRequest_FieldNumber_ClientVersion,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ArtifactsConfigurationRequest__storage_, clientVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "rinfo",
        .dataTypeSpecific.clazz = GPBObjCClass(BasicRequestInfo),
        .number = ArtifactsConfigurationRequest_FieldNumber_Rinfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ArtifactsConfigurationRequest__storage_, rinfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ArtifactsConfigurationRequest class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ArtifactsConfigurationRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ArtifactsConfigurationResponse

@implementation ArtifactsConfigurationResponse

@dynamic missionParametersArray, missionParametersArray_Count;
@dynamic artifactParametersArray, artifactParametersArray_Count;
@dynamic craftingLevelInfosArray, craftingLevelInfosArray_Count;

typedef struct ArtifactsConfigurationResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *missionParametersArray;
  NSMutableArray *artifactParametersArray;
  NSMutableArray *craftingLevelInfosArray;
} ArtifactsConfigurationResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "missionParametersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ArtifactsConfigurationResponse_MissionParameters),
        .number = ArtifactsConfigurationResponse_FieldNumber_MissionParametersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ArtifactsConfigurationResponse__storage_, missionParametersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "artifactParametersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ArtifactsConfigurationResponse_ArtifactParameters),
        .number = ArtifactsConfigurationResponse_FieldNumber_ArtifactParametersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ArtifactsConfigurationResponse__storage_, artifactParametersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "craftingLevelInfosArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ArtifactsConfigurationResponse_CraftingLevelInfo),
        .number = ArtifactsConfigurationResponse_FieldNumber_CraftingLevelInfosArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ArtifactsConfigurationResponse__storage_, craftingLevelInfosArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ArtifactsConfigurationResponse class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ArtifactsConfigurationResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ArtifactsConfigurationResponse_MissionParameters

@implementation ArtifactsConfigurationResponse_MissionParameters

@dynamic hasShip, ship;
@dynamic durationsArray, durationsArray_Count;
@dynamic levelMissionRequirementsArray, levelMissionRequirementsArray_Count;
@dynamic hasCapacityDeprecated, capacityDeprecated;

typedef struct ArtifactsConfigurationResponse_MissionParameters__storage_ {
  uint32_t _has_storage_[1];
  MissionInfo_Spaceship ship;
  uint32_t capacityDeprecated;
  NSMutableArray *durationsArray;
  GPBUInt32Array *levelMissionRequirementsArray;
} ArtifactsConfigurationResponse_MissionParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ship",
        .dataTypeSpecific.enumDescFunc = MissionInfo_Spaceship_EnumDescriptor,
        .number = ArtifactsConfigurationResponse_MissionParameters_FieldNumber_Ship,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ArtifactsConfigurationResponse_MissionParameters__storage_, ship),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "capacityDeprecated",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsConfigurationResponse_MissionParameters_FieldNumber_CapacityDeprecated,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ArtifactsConfigurationResponse_MissionParameters__storage_, capacityDeprecated),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "durationsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ArtifactsConfigurationResponse_MissionParameters_Duration),
        .number = ArtifactsConfigurationResponse_MissionParameters_FieldNumber_DurationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ArtifactsConfigurationResponse_MissionParameters__storage_, durationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "levelMissionRequirementsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsConfigurationResponse_MissionParameters_FieldNumber_LevelMissionRequirementsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ArtifactsConfigurationResponse_MissionParameters__storage_, levelMissionRequirementsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ArtifactsConfigurationResponse_MissionParameters class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ArtifactsConfigurationResponse_MissionParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\010\352\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ArtifactsConfigurationResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ArtifactsConfigurationResponse_MissionParameters_Duration

@implementation ArtifactsConfigurationResponse_MissionParameters_Duration

@dynamic hasDurationType, durationType;
@dynamic hasSeconds, seconds;
@dynamic hasQuality, quality;
@dynamic hasMinQuality, minQuality;
@dynamic hasMaxQuality, maxQuality;
@dynamic hasCapacity, capacity;
@dynamic hasLevelCapacityBump, levelCapacityBump;
@dynamic hasLevelQualityBump, levelQualityBump;

typedef struct ArtifactsConfigurationResponse_MissionParameters_Duration__storage_ {
  uint32_t _has_storage_[1];
  MissionInfo_DurationType durationType;
  float quality;
  float minQuality;
  float maxQuality;
  uint32_t capacity;
  uint32_t levelCapacityBump;
  float levelQualityBump;
  double seconds;
} ArtifactsConfigurationResponse_MissionParameters_Duration__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "durationType",
        .dataTypeSpecific.enumDescFunc = MissionInfo_DurationType_EnumDescriptor,
        .number = ArtifactsConfigurationResponse_MissionParameters_Duration_FieldNumber_DurationType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ArtifactsConfigurationResponse_MissionParameters_Duration__storage_, durationType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "seconds",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsConfigurationResponse_MissionParameters_Duration_FieldNumber_Seconds,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ArtifactsConfigurationResponse_MissionParameters_Duration__storage_, seconds),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "quality",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsConfigurationResponse_MissionParameters_Duration_FieldNumber_Quality,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ArtifactsConfigurationResponse_MissionParameters_Duration__storage_, quality),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "minQuality",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsConfigurationResponse_MissionParameters_Duration_FieldNumber_MinQuality,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ArtifactsConfigurationResponse_MissionParameters_Duration__storage_, minQuality),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "maxQuality",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsConfigurationResponse_MissionParameters_Duration_FieldNumber_MaxQuality,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ArtifactsConfigurationResponse_MissionParameters_Duration__storage_, maxQuality),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "capacity",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsConfigurationResponse_MissionParameters_Duration_FieldNumber_Capacity,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ArtifactsConfigurationResponse_MissionParameters_Duration__storage_, capacity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "levelCapacityBump",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsConfigurationResponse_MissionParameters_Duration_FieldNumber_LevelCapacityBump,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ArtifactsConfigurationResponse_MissionParameters_Duration__storage_, levelCapacityBump),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "levelQualityBump",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsConfigurationResponse_MissionParameters_Duration_FieldNumber_LevelQualityBump,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ArtifactsConfigurationResponse_MissionParameters_Duration__storage_, levelQualityBump),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ArtifactsConfigurationResponse_MissionParameters_Duration class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ArtifactsConfigurationResponse_MissionParameters_Duration__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ArtifactsConfigurationResponse_MissionParameters)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ArtifactsConfigurationResponse_ArtifactParameters

@implementation ArtifactsConfigurationResponse_ArtifactParameters

@dynamic hasSpec, spec;
@dynamic hasBaseQuality, baseQuality;
@dynamic hasOddsMultiplier, oddsMultiplier;
@dynamic hasValue, value;
@dynamic hasCraftingPrice, craftingPrice;
@dynamic hasCraftingPriceLow, craftingPriceLow;
@dynamic hasCraftingPriceDomain, craftingPriceDomain;
@dynamic hasCraftingPriceCurve, craftingPriceCurve;
@dynamic hasCraftingXp, craftingXp;

typedef struct ArtifactsConfigurationResponse_ArtifactParameters__storage_ {
  uint32_t _has_storage_[1];
  uint32_t craftingPriceDomain;
  ArtifactSpec *spec;
  double baseQuality;
  double value;
  double oddsMultiplier;
  double craftingPrice;
  double craftingPriceLow;
  double craftingPriceCurve;
  uint64_t craftingXp;
} ArtifactsConfigurationResponse_ArtifactParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "spec",
        .dataTypeSpecific.clazz = GPBObjCClass(ArtifactSpec),
        .number = ArtifactsConfigurationResponse_ArtifactParameters_FieldNumber_Spec,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ArtifactsConfigurationResponse_ArtifactParameters__storage_, spec),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "baseQuality",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsConfigurationResponse_ArtifactParameters_FieldNumber_BaseQuality,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ArtifactsConfigurationResponse_ArtifactParameters__storage_, baseQuality),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsConfigurationResponse_ArtifactParameters_FieldNumber_Value,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ArtifactsConfigurationResponse_ArtifactParameters__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "oddsMultiplier",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsConfigurationResponse_ArtifactParameters_FieldNumber_OddsMultiplier,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ArtifactsConfigurationResponse_ArtifactParameters__storage_, oddsMultiplier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "craftingPrice",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsConfigurationResponse_ArtifactParameters_FieldNumber_CraftingPrice,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ArtifactsConfigurationResponse_ArtifactParameters__storage_, craftingPrice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "craftingPriceLow",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsConfigurationResponse_ArtifactParameters_FieldNumber_CraftingPriceLow,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ArtifactsConfigurationResponse_ArtifactParameters__storage_, craftingPriceLow),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "craftingPriceDomain",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsConfigurationResponse_ArtifactParameters_FieldNumber_CraftingPriceDomain,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ArtifactsConfigurationResponse_ArtifactParameters__storage_, craftingPriceDomain),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "craftingPriceCurve",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsConfigurationResponse_ArtifactParameters_FieldNumber_CraftingPriceCurve,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ArtifactsConfigurationResponse_ArtifactParameters__storage_, craftingPriceCurve),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "craftingXp",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsConfigurationResponse_ArtifactParameters_FieldNumber_CraftingXp,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ArtifactsConfigurationResponse_ArtifactParameters__storage_, craftingXp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ArtifactsConfigurationResponse_ArtifactParameters class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ArtifactsConfigurationResponse_ArtifactParameters__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ArtifactsConfigurationResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ArtifactsConfigurationResponse_CraftingLevelInfo

@implementation ArtifactsConfigurationResponse_CraftingLevelInfo

@dynamic hasXpRequired, xpRequired;
@dynamic hasRarityMult, rarityMult;

typedef struct ArtifactsConfigurationResponse_CraftingLevelInfo__storage_ {
  uint32_t _has_storage_[1];
  float rarityMult;
  double xpRequired;
} ArtifactsConfigurationResponse_CraftingLevelInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "xpRequired",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsConfigurationResponse_CraftingLevelInfo_FieldNumber_XpRequired,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ArtifactsConfigurationResponse_CraftingLevelInfo__storage_, xpRequired),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "rarityMult",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsConfigurationResponse_CraftingLevelInfo_FieldNumber_RarityMult,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ArtifactsConfigurationResponse_CraftingLevelInfo__storage_, rarityMult),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ArtifactsConfigurationResponse_CraftingLevelInfo class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ArtifactsConfigurationResponse_CraftingLevelInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ArtifactsConfigurationResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MissionRequest

@implementation MissionRequest

@dynamic hasRinfo, rinfo;
@dynamic hasClientVersion, clientVersion;
@dynamic hasEiUserId, eiUserId;
@dynamic hasInfo, info;
@dynamic hasClientInfo, clientInfo;

typedef struct MissionRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t clientVersion;
  MissionInfo *info;
  NSString *eiUserId;
  BasicRequestInfo *rinfo;
  ArtifactsClientInfo *clientInfo;
} MissionRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "clientVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = MissionRequest_FieldNumber_ClientVersion,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MissionRequest__storage_, clientVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "info",
        .dataTypeSpecific.clazz = GPBObjCClass(MissionInfo),
        .number = MissionRequest_FieldNumber_Info,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MissionRequest__storage_, info),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "eiUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = MissionRequest_FieldNumber_EiUserId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MissionRequest__storage_, eiUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rinfo",
        .dataTypeSpecific.clazz = GPBObjCClass(BasicRequestInfo),
        .number = MissionRequest_FieldNumber_Rinfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MissionRequest__storage_, rinfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clientInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(ArtifactsClientInfo),
        .number = MissionRequest_FieldNumber_ClientInfo,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MissionRequest__storage_, clientInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MissionRequest class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MissionRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MissionResponse

@implementation MissionResponse

@dynamic hasSuccess, success;
@dynamic hasInfo, info;

typedef struct MissionResponse__storage_ {
  uint32_t _has_storage_[1];
  MissionInfo *info;
} MissionResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.clazz = Nil,
        .number = MissionResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "info",
        .dataTypeSpecific.clazz = GPBObjCClass(MissionInfo),
        .number = MissionResponse_FieldNumber_Info,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MissionResponse__storage_, info),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MissionResponse class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MissionResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CompleteMissionResponse

@implementation CompleteMissionResponse

@dynamic hasSuccess, success;
@dynamic hasInfo, info;
@dynamic artifactsArray, artifactsArray_Count;
@dynamic otherRewardsArray, otherRewardsArray_Count;
@dynamic hasEiUserId, eiUserId;

typedef struct CompleteMissionResponse__storage_ {
  uint32_t _has_storage_[1];
  MissionInfo *info;
  NSMutableArray *artifactsArray;
  NSMutableArray *otherRewardsArray;
  NSString *eiUserId;
} CompleteMissionResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.clazz = Nil,
        .number = CompleteMissionResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "info",
        .dataTypeSpecific.clazz = GPBObjCClass(MissionInfo),
        .number = CompleteMissionResponse_FieldNumber_Info,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CompleteMissionResponse__storage_, info),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "artifactsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(CompleteMissionResponse_SecureArtifactSpec),
        .number = CompleteMissionResponse_FieldNumber_ArtifactsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CompleteMissionResponse__storage_, artifactsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "otherRewardsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Reward),
        .number = CompleteMissionResponse_FieldNumber_OtherRewardsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CompleteMissionResponse__storage_, otherRewardsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "eiUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = CompleteMissionResponse_FieldNumber_EiUserId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CompleteMissionResponse__storage_, eiUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CompleteMissionResponse class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CompleteMissionResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CompleteMissionResponse_SecureArtifactSpec

@implementation CompleteMissionResponse_SecureArtifactSpec

@dynamic hasSpec, spec;
@dynamic hasServerId, serverId;

typedef struct CompleteMissionResponse_SecureArtifactSpec__storage_ {
  uint32_t _has_storage_[1];
  ArtifactSpec *spec;
  NSString *serverId;
} CompleteMissionResponse_SecureArtifactSpec__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "spec",
        .dataTypeSpecific.clazz = GPBObjCClass(ArtifactSpec),
        .number = CompleteMissionResponse_SecureArtifactSpec_FieldNumber_Spec,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CompleteMissionResponse_SecureArtifactSpec__storage_, spec),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "serverId",
        .dataTypeSpecific.clazz = Nil,
        .number = CompleteMissionResponse_SecureArtifactSpec_FieldNumber_ServerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CompleteMissionResponse_SecureArtifactSpec__storage_, serverId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CompleteMissionResponse_SecureArtifactSpec class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CompleteMissionResponse_SecureArtifactSpec__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(CompleteMissionResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CollectContractArtifactRewardsRequest

@implementation CollectContractArtifactRewardsRequest

@dynamic hasRinfo, rinfo;
@dynamic hasContractIdentifier, contractIdentifier;
@dynamic hasLeague, league;
@dynamic hasGoalIndex, goalIndex;
@dynamic hasBestShip, bestShip;

typedef struct CollectContractArtifactRewardsRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t goalIndex;
  MissionInfo_Spaceship bestShip;
  uint32_t league;
  BasicRequestInfo *rinfo;
  NSString *contractIdentifier;
} CollectContractArtifactRewardsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rinfo",
        .dataTypeSpecific.clazz = GPBObjCClass(BasicRequestInfo),
        .number = CollectContractArtifactRewardsRequest_FieldNumber_Rinfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CollectContractArtifactRewardsRequest__storage_, rinfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "contractIdentifier",
        .dataTypeSpecific.clazz = Nil,
        .number = CollectContractArtifactRewardsRequest_FieldNumber_ContractIdentifier,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CollectContractArtifactRewardsRequest__storage_, contractIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "goalIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = CollectContractArtifactRewardsRequest_FieldNumber_GoalIndex,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CollectContractArtifactRewardsRequest__storage_, goalIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "bestShip",
        .dataTypeSpecific.enumDescFunc = MissionInfo_Spaceship_EnumDescriptor,
        .number = CollectContractArtifactRewardsRequest_FieldNumber_BestShip,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CollectContractArtifactRewardsRequest__storage_, bestShip),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "league",
        .dataTypeSpecific.clazz = Nil,
        .number = CollectContractArtifactRewardsRequest_FieldNumber_League,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CollectContractArtifactRewardsRequest__storage_, league),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CollectContractArtifactRewardsRequest class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CollectContractArtifactRewardsRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CraftArtifactRequest

@implementation CraftArtifactRequest

@dynamic hasRinfo, rinfo;
@dynamic hasEiUserId, eiUserId;
@dynamic hasSpec, spec;
@dynamic hasItemId, itemId;
@dynamic hasGoldPricePaid, goldPricePaid;
@dynamic hasCraftingCount, craftingCount;
@dynamic hasCraftingXp, craftingXp;
@dynamic ingredientsArray, ingredientsArray_Count;

typedef struct CraftArtifactRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t craftingCount;
  NSString *eiUserId;
  ArtifactSpec *spec;
  NSMutableArray *ingredientsArray;
  BasicRequestInfo *rinfo;
  uint64_t itemId;
  double goldPricePaid;
  double craftingXp;
} CraftArtifactRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "eiUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = CraftArtifactRequest_FieldNumber_EiUserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CraftArtifactRequest__storage_, eiUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "spec",
        .dataTypeSpecific.clazz = GPBObjCClass(ArtifactSpec),
        .number = CraftArtifactRequest_FieldNumber_Spec,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CraftArtifactRequest__storage_, spec),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "itemId",
        .dataTypeSpecific.clazz = Nil,
        .number = CraftArtifactRequest_FieldNumber_ItemId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CraftArtifactRequest__storage_, itemId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "ingredientsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ArtifactInventoryItem),
        .number = CraftArtifactRequest_FieldNumber_IngredientsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CraftArtifactRequest__storage_, ingredientsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rinfo",
        .dataTypeSpecific.clazz = GPBObjCClass(BasicRequestInfo),
        .number = CraftArtifactRequest_FieldNumber_Rinfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CraftArtifactRequest__storage_, rinfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "goldPricePaid",
        .dataTypeSpecific.clazz = Nil,
        .number = CraftArtifactRequest_FieldNumber_GoldPricePaid,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CraftArtifactRequest__storage_, goldPricePaid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "craftingCount",
        .dataTypeSpecific.clazz = Nil,
        .number = CraftArtifactRequest_FieldNumber_CraftingCount,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(CraftArtifactRequest__storage_, craftingCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "craftingXp",
        .dataTypeSpecific.clazz = Nil,
        .number = CraftArtifactRequest_FieldNumber_CraftingXp,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(CraftArtifactRequest__storage_, craftingXp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CraftArtifactRequest class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CraftArtifactRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CraftArtifactResponse

@implementation CraftArtifactResponse

@dynamic hasItemId, itemId;
@dynamic hasEiUserId, eiUserId;
@dynamic hasRarityAchieved, rarityAchieved;
@dynamic hasServerId, serverId;

typedef struct CraftArtifactResponse__storage_ {
  uint32_t _has_storage_[1];
  ArtifactSpec_Rarity rarityAchieved;
  NSString *serverId;
  NSString *eiUserId;
  uint64_t itemId;
} CraftArtifactResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemId",
        .dataTypeSpecific.clazz = Nil,
        .number = CraftArtifactResponse_FieldNumber_ItemId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CraftArtifactResponse__storage_, itemId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "rarityAchieved",
        .dataTypeSpecific.enumDescFunc = ArtifactSpec_Rarity_EnumDescriptor,
        .number = CraftArtifactResponse_FieldNumber_RarityAchieved,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CraftArtifactResponse__storage_, rarityAchieved),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "serverId",
        .dataTypeSpecific.clazz = Nil,
        .number = CraftArtifactResponse_FieldNumber_ServerId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CraftArtifactResponse__storage_, serverId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "eiUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = CraftArtifactResponse_FieldNumber_EiUserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CraftArtifactResponse__storage_, eiUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CraftArtifactResponse class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CraftArtifactResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ConsumeArtifactRequest

@implementation ConsumeArtifactRequest

@dynamic hasRinfo, rinfo;
@dynamic hasEiUserId, eiUserId;
@dynamic hasSpec, spec;
@dynamic hasArtifactServerId, artifactServerId;
@dynamic hasOriginalItemId, originalItemId;
@dynamic additionalServerIdsArray, additionalServerIdsArray_Count;
@dynamic additionalItemIdsArray, additionalItemIdsArray_Count;
@dynamic hasQuantity, quantity;

typedef struct ConsumeArtifactRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t quantity;
  ArtifactSpec *spec;
  NSString *eiUserId;
  BasicRequestInfo *rinfo;
  NSString *artifactServerId;
  NSMutableArray *additionalServerIdsArray;
  GPBUInt64Array *additionalItemIdsArray;
  uint64_t originalItemId;
} ConsumeArtifactRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "spec",
        .dataTypeSpecific.clazz = GPBObjCClass(ArtifactSpec),
        .number = ConsumeArtifactRequest_FieldNumber_Spec,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ConsumeArtifactRequest__storage_, spec),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "originalItemId",
        .dataTypeSpecific.clazz = Nil,
        .number = ConsumeArtifactRequest_FieldNumber_OriginalItemId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ConsumeArtifactRequest__storage_, originalItemId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "eiUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = ConsumeArtifactRequest_FieldNumber_EiUserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ConsumeArtifactRequest__storage_, eiUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rinfo",
        .dataTypeSpecific.clazz = GPBObjCClass(BasicRequestInfo),
        .number = ConsumeArtifactRequest_FieldNumber_Rinfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ConsumeArtifactRequest__storage_, rinfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "artifactServerId",
        .dataTypeSpecific.clazz = Nil,
        .number = ConsumeArtifactRequest_FieldNumber_ArtifactServerId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ConsumeArtifactRequest__storage_, artifactServerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "quantity",
        .dataTypeSpecific.clazz = Nil,
        .number = ConsumeArtifactRequest_FieldNumber_Quantity,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ConsumeArtifactRequest__storage_, quantity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "additionalServerIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = ConsumeArtifactRequest_FieldNumber_AdditionalServerIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ConsumeArtifactRequest__storage_, additionalServerIdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "additionalItemIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = ConsumeArtifactRequest_FieldNumber_AdditionalItemIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ConsumeArtifactRequest__storage_, additionalItemIdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ConsumeArtifactRequest class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ConsumeArtifactRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ConsumeArtifactResponse

@implementation ConsumeArtifactResponse

@dynamic hasSuccess, success;
@dynamic hasOriginalItemId, originalItemId;
@dynamic additionalItemIdsArray, additionalItemIdsArray_Count;
@dynamic byproductsArray, byproductsArray_Count;
@dynamic otherRewardsArray, otherRewardsArray_Count;
@dynamic hasEiUserId, eiUserId;

typedef struct ConsumeArtifactResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *byproductsArray;
  NSMutableArray *otherRewardsArray;
  NSString *eiUserId;
  GPBUInt64Array *additionalItemIdsArray;
  uint64_t originalItemId;
} ConsumeArtifactResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.clazz = Nil,
        .number = ConsumeArtifactResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "originalItemId",
        .dataTypeSpecific.clazz = Nil,
        .number = ConsumeArtifactResponse_FieldNumber_OriginalItemId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ConsumeArtifactResponse__storage_, originalItemId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "byproductsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ArtifactSpec),
        .number = ConsumeArtifactResponse_FieldNumber_ByproductsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ConsumeArtifactResponse__storage_, byproductsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "otherRewardsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Reward),
        .number = ConsumeArtifactResponse_FieldNumber_OtherRewardsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ConsumeArtifactResponse__storage_, otherRewardsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "eiUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = ConsumeArtifactResponse_FieldNumber_EiUserId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ConsumeArtifactResponse__storage_, eiUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "additionalItemIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = ConsumeArtifactResponse_FieldNumber_AdditionalItemIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ConsumeArtifactResponse__storage_, additionalItemIdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ConsumeArtifactResponse class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ConsumeArtifactResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AuthenticateArtifactResponse

@implementation AuthenticateArtifactResponse

@dynamic hasSuccess, success;
@dynamic hasOriginalItemId, originalItemId;
@dynamic hasDemote, demote;
@dynamic hasDelete_p, delete_p;
@dynamic hasEiUserId, eiUserId;

typedef struct AuthenticateArtifactResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *eiUserId;
  uint64_t originalItemId;
} AuthenticateArtifactResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.clazz = Nil,
        .number = AuthenticateArtifactResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "originalItemId",
        .dataTypeSpecific.clazz = Nil,
        .number = AuthenticateArtifactResponse_FieldNumber_OriginalItemId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AuthenticateArtifactResponse__storage_, originalItemId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "demote",
        .dataTypeSpecific.clazz = Nil,
        .number = AuthenticateArtifactResponse_FieldNumber_Demote,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "delete_p",
        .dataTypeSpecific.clazz = Nil,
        .number = AuthenticateArtifactResponse_FieldNumber_Delete_p,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "eiUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = AuthenticateArtifactResponse_FieldNumber_EiUserId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(AuthenticateArtifactResponse__storage_, eiUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AuthenticateArtifactResponse class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AuthenticateArtifactResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetArtifactRequest

@implementation SetArtifactRequest

@dynamic hasRinfo, rinfo;
@dynamic hasArtifact, artifact;
@dynamic stonesArray, stonesArray_Count;
@dynamic hasGoldPricePaid, goldPricePaid;

typedef struct SetArtifactRequest__storage_ {
  uint32_t _has_storage_[1];
  BasicRequestInfo *rinfo;
  ArtifactInventoryItem *artifact;
  NSMutableArray *stonesArray;
  double goldPricePaid;
} SetArtifactRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rinfo",
        .dataTypeSpecific.clazz = GPBObjCClass(BasicRequestInfo),
        .number = SetArtifactRequest_FieldNumber_Rinfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetArtifactRequest__storage_, rinfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "artifact",
        .dataTypeSpecific.clazz = GPBObjCClass(ArtifactInventoryItem),
        .number = SetArtifactRequest_FieldNumber_Artifact,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SetArtifactRequest__storage_, artifact),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stonesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ArtifactSpec),
        .number = SetArtifactRequest_FieldNumber_StonesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SetArtifactRequest__storage_, stonesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "goldPricePaid",
        .dataTypeSpecific.clazz = Nil,
        .number = SetArtifactRequest_FieldNumber_GoldPricePaid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SetArtifactRequest__storage_, goldPricePaid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetArtifactRequest class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetArtifactRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetArtifactResponse

@implementation SetArtifactResponse

@dynamic hasSuccess, success;
@dynamic hasOriginalItemId, originalItemId;
@dynamic hasEiUserId, eiUserId;

typedef struct SetArtifactResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *eiUserId;
  uint64_t originalItemId;
} SetArtifactResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.clazz = Nil,
        .number = SetArtifactResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "originalItemId",
        .dataTypeSpecific.clazz = Nil,
        .number = SetArtifactResponse_FieldNumber_OriginalItemId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SetArtifactResponse__storage_, originalItemId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "eiUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = SetArtifactResponse_FieldNumber_EiUserId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SetArtifactResponse__storage_, eiUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetArtifactResponse class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetArtifactResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ArtifactsDB

@implementation ArtifactsDB

@dynamic inventoryItemsArray, inventoryItemsArray_Count;
@dynamic hasItemSequence, itemSequence;
@dynamic inventorySlotsArray, inventorySlotsArray_Count;
@dynamic activeArtifactsArray, activeArtifactsArray_Count;
@dynamic activeArtifactSetsArray, activeArtifactSetsArray_Count;
@dynamic artifactStatusArray, artifactStatusArray_Count;
@dynamic missionInfosArray, missionInfosArray_Count;
@dynamic missionArchiveArray, missionArchiveArray_Count;
@dynamic discoveredArtifactsDeprecatedArray, discoveredArtifactsDeprecatedArray_Count;
@dynamic craftableArtifactsDeprecatedArray, craftableArtifactsDeprecatedArray_Count;
@dynamic craftingCountsDeprecatedArray, craftingCountsDeprecatedArray_Count;

typedef struct ArtifactsDB__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *inventoryItemsArray;
  NSMutableArray *inventorySlotsArray;
  NSMutableArray *missionInfosArray;
  NSMutableArray *missionArchiveArray;
  NSMutableArray *activeArtifactsArray;
  NSMutableArray *discoveredArtifactsDeprecatedArray;
  NSMutableArray *craftableArtifactsDeprecatedArray;
  NSMutableArray *craftingCountsDeprecatedArray;
  NSMutableArray *activeArtifactSetsArray;
  NSMutableArray *artifactStatusArray;
  uint64_t itemSequence;
} ArtifactsDB__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inventoryItemsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ArtifactInventoryItem),
        .number = ArtifactsDB_FieldNumber_InventoryItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ArtifactsDB__storage_, inventoryItemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "itemSequence",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsDB_FieldNumber_ItemSequence,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ArtifactsDB__storage_, itemSequence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "inventorySlotsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(InventorySlot),
        .number = ArtifactsDB_FieldNumber_InventorySlotsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ArtifactsDB__storage_, inventorySlotsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "missionInfosArray",
        .dataTypeSpecific.clazz = GPBObjCClass(MissionInfo),
        .number = ArtifactsDB_FieldNumber_MissionInfosArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ArtifactsDB__storage_, missionInfosArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "missionArchiveArray",
        .dataTypeSpecific.clazz = GPBObjCClass(MissionInfo),
        .number = ArtifactsDB_FieldNumber_MissionArchiveArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ArtifactsDB__storage_, missionArchiveArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "activeArtifactsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ArtifactsDB_ActiveArtifactSlot),
        .number = ArtifactsDB_FieldNumber_ActiveArtifactsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ArtifactsDB__storage_, activeArtifactsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "discoveredArtifactsDeprecatedArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ArtifactSpec),
        .number = ArtifactsDB_FieldNumber_DiscoveredArtifactsDeprecatedArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ArtifactsDB__storage_, discoveredArtifactsDeprecatedArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "craftableArtifactsDeprecatedArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ArtifactsDB_CraftableArtifact),
        .number = ArtifactsDB_FieldNumber_CraftableArtifactsDeprecatedArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ArtifactsDB__storage_, craftableArtifactsDeprecatedArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "craftingCountsDeprecatedArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ArtifactsDB_CraftableArtifact),
        .number = ArtifactsDB_FieldNumber_CraftingCountsDeprecatedArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ArtifactsDB__storage_, craftingCountsDeprecatedArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "activeArtifactSetsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ArtifactsDB_ActiveArtifactSet),
        .number = ArtifactsDB_FieldNumber_ActiveArtifactSetsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ArtifactsDB__storage_, activeArtifactSetsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "artifactStatusArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ArtifactsDB_CraftableArtifact),
        .number = ArtifactsDB_FieldNumber_ArtifactStatusArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ArtifactsDB__storage_, artifactStatusArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ArtifactsDB class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ArtifactsDB__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\010\000discovered_artifacts_DEPRECATED\000\t\000cra"
        "ftable_artifacts_DEPRECATED\000\n\000crafting_c"
        "ounts_DEPRECATED\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ArtifactsDB_ActiveArtifactSlot

@implementation ArtifactsDB_ActiveArtifactSlot

@dynamic hasOccupied, occupied;
@dynamic hasItemId, itemId;

typedef struct ArtifactsDB_ActiveArtifactSlot__storage_ {
  uint32_t _has_storage_[1];
  uint64_t itemId;
} ArtifactsDB_ActiveArtifactSlot__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "occupied",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsDB_ActiveArtifactSlot_FieldNumber_Occupied,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "itemId",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsDB_ActiveArtifactSlot_FieldNumber_ItemId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ArtifactsDB_ActiveArtifactSlot__storage_, itemId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ArtifactsDB_ActiveArtifactSlot class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ArtifactsDB_ActiveArtifactSlot__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ArtifactsDB)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ArtifactsDB_ActiveArtifactSet

@implementation ArtifactsDB_ActiveArtifactSet

@dynamic slotsArray, slotsArray_Count;

typedef struct ArtifactsDB_ActiveArtifactSet__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *slotsArray;
} ArtifactsDB_ActiveArtifactSet__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "slotsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ArtifactsDB_ActiveArtifactSlot),
        .number = ArtifactsDB_ActiveArtifactSet_FieldNumber_SlotsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ArtifactsDB_ActiveArtifactSet__storage_, slotsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ArtifactsDB_ActiveArtifactSet class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ArtifactsDB_ActiveArtifactSet__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ArtifactsDB)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ArtifactsDB_CraftableArtifact

@implementation ArtifactsDB_CraftableArtifact

@dynamic hasSpec, spec;
@dynamic hasDiscovered, discovered;
@dynamic hasCraftable, craftable;
@dynamic hasRecipeDiscovered, recipeDiscovered;
@dynamic hasSeen, seen;
@dynamic hasCount, count;

typedef struct ArtifactsDB_CraftableArtifact__storage_ {
  uint32_t _has_storage_[1];
  uint32_t count;
  ArtifactSpec *spec;
} ArtifactsDB_CraftableArtifact__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "spec",
        .dataTypeSpecific.clazz = GPBObjCClass(ArtifactSpec),
        .number = ArtifactsDB_CraftableArtifact_FieldNumber_Spec,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ArtifactsDB_CraftableArtifact__storage_, spec),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "seen",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsDB_CraftableArtifact_FieldNumber_Seen,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "count",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsDB_CraftableArtifact_FieldNumber_Count,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ArtifactsDB_CraftableArtifact__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "craftable",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsDB_CraftableArtifact_FieldNumber_Craftable,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "recipeDiscovered",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsDB_CraftableArtifact_FieldNumber_RecipeDiscovered,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "discovered",
        .dataTypeSpecific.clazz = Nil,
        .number = ArtifactsDB_CraftableArtifact_FieldNumber_Discovered,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ArtifactsDB_CraftableArtifact class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ArtifactsDB_CraftableArtifact__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ArtifactsDB)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AuthenticatedMessage

@implementation AuthenticatedMessage

@dynamic hasMessage, message;
@dynamic hasVersion, version;
@dynamic hasCode, code;
@dynamic hasCompressed, compressed;
@dynamic hasOriginalSize, originalSize;

typedef struct AuthenticatedMessage__storage_ {
  uint32_t _has_storage_[1];
  uint32_t version;
  uint32_t originalSize;
  NSData *message;
  NSString *code;
} AuthenticatedMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "message",
        .dataTypeSpecific.clazz = Nil,
        .number = AuthenticatedMessage_FieldNumber_Message,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AuthenticatedMessage__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "code",
        .dataTypeSpecific.clazz = Nil,
        .number = AuthenticatedMessage_FieldNumber_Code,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AuthenticatedMessage__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "version",
        .dataTypeSpecific.clazz = Nil,
        .number = AuthenticatedMessage_FieldNumber_Version,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AuthenticatedMessage__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "compressed",
        .dataTypeSpecific.clazz = Nil,
        .number = AuthenticatedMessage_FieldNumber_Compressed,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "originalSize",
        .dataTypeSpecific.clazz = Nil,
        .number = AuthenticatedMessage_FieldNumber_OriginalSize,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AuthenticatedMessage__storage_, originalSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AuthenticatedMessage class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AuthenticatedMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LogCompleteMissionPayload

@implementation LogCompleteMissionPayload

@dynamic hasReq, req;
@dynamic hasRes, res;

typedef struct LogCompleteMissionPayload__storage_ {
  uint32_t _has_storage_[1];
  MissionRequest *req;
  CompleteMissionResponse *res;
} LogCompleteMissionPayload__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "req",
        .dataTypeSpecific.clazz = GPBObjCClass(MissionRequest),
        .number = LogCompleteMissionPayload_FieldNumber_Req,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LogCompleteMissionPayload__storage_, req),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "res",
        .dataTypeSpecific.clazz = GPBObjCClass(CompleteMissionResponse),
        .number = LogCompleteMissionPayload_FieldNumber_Res,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LogCompleteMissionPayload__storage_, res),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LogCompleteMissionPayload class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LogCompleteMissionPayload__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LogCraftArtifactPayload

@implementation LogCraftArtifactPayload

@dynamic hasReq, req;
@dynamic hasRes, res;

typedef struct LogCraftArtifactPayload__storage_ {
  uint32_t _has_storage_[1];
  CraftArtifactRequest *req;
  CraftArtifactResponse *res;
} LogCraftArtifactPayload__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "req",
        .dataTypeSpecific.clazz = GPBObjCClass(CraftArtifactRequest),
        .number = LogCraftArtifactPayload_FieldNumber_Req,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LogCraftArtifactPayload__storage_, req),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "res",
        .dataTypeSpecific.clazz = GPBObjCClass(CraftArtifactResponse),
        .number = LogCraftArtifactPayload_FieldNumber_Res,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LogCraftArtifactPayload__storage_, res),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LogCraftArtifactPayload class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LogCraftArtifactPayload__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LogConsumeArtifactPayload

@implementation LogConsumeArtifactPayload

@dynamic hasReq, req;
@dynamic hasRes, res;

typedef struct LogConsumeArtifactPayload__storage_ {
  uint32_t _has_storage_[1];
  ConsumeArtifactRequest *req;
  ConsumeArtifactResponse *res;
} LogConsumeArtifactPayload__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "req",
        .dataTypeSpecific.clazz = GPBObjCClass(ConsumeArtifactRequest),
        .number = LogConsumeArtifactPayload_FieldNumber_Req,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LogConsumeArtifactPayload__storage_, req),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "res",
        .dataTypeSpecific.clazz = GPBObjCClass(ConsumeArtifactResponse),
        .number = LogConsumeArtifactPayload_FieldNumber_Res,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LogConsumeArtifactPayload__storage_, res),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LogConsumeArtifactPayload class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LogConsumeArtifactPayload__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LogSetArtifactPayload

@implementation LogSetArtifactPayload

@dynamic hasReq, req;
@dynamic hasRes, res;

typedef struct LogSetArtifactPayload__storage_ {
  uint32_t _has_storage_[1];
  SetArtifactRequest *req;
  SetArtifactResponse *res;
} LogSetArtifactPayload__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "req",
        .dataTypeSpecific.clazz = GPBObjCClass(SetArtifactRequest),
        .number = LogSetArtifactPayload_FieldNumber_Req,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LogSetArtifactPayload__storage_, req),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "res",
        .dataTypeSpecific.clazz = GPBObjCClass(SetArtifactResponse),
        .number = LogSetArtifactPayload_FieldNumber_Res,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LogSetArtifactPayload__storage_, res),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LogSetArtifactPayload class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LogSetArtifactPayload__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccountTransferPayload

@implementation AccountTransferPayload

@dynamic hasFromId, fromId;
@dynamic hasToEiUserId, toEiUserId;

typedef struct AccountTransferPayload__storage_ {
  uint32_t _has_storage_[1];
  NSString *fromId;
  NSString *toEiUserId;
} AccountTransferPayload__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fromId",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountTransferPayload_FieldNumber_FromId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountTransferPayload__storage_, fromId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "toEiUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = AccountTransferPayload_FieldNumber_ToEiUserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AccountTransferPayload__storage_, toEiUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountTransferPayload class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountTransferPayload__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SaveBackupResponse

@implementation SaveBackupResponse

@dynamic hasSuccess, success;
@dynamic hasErrorCode, errorCode;
@dynamic hasMessage, message;
@dynamic hasExistingBackup, existingBackup;

typedef struct SaveBackupResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t errorCode;
  NSString *message;
  Backup *existingBackup;
} SaveBackupResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.clazz = Nil,
        .number = SaveBackupResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "errorCode",
        .dataTypeSpecific.clazz = Nil,
        .number = SaveBackupResponse_FieldNumber_ErrorCode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SaveBackupResponse__storage_, errorCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = Nil,
        .number = SaveBackupResponse_FieldNumber_Message,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SaveBackupResponse__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "existingBackup",
        .dataTypeSpecific.clazz = GPBObjCClass(Backup),
        .number = SaveBackupResponse_FieldNumber_ExistingBackup,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SaveBackupResponse__storage_, existingBackup),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SaveBackupResponse class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SaveBackupResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum SaveBackupResponse_ErrorCodes

GPBEnumDescriptor *SaveBackupResponse_ErrorCodes_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "NoError\000UserNotFound\000CouldNotOverwrite\000B"
        "ackupOffered\000BadUserId\000";
    static const int32_t values[] = {
        SaveBackupResponse_ErrorCodes_NoError,
        SaveBackupResponse_ErrorCodes_UserNotFound,
        SaveBackupResponse_ErrorCodes_CouldNotOverwrite,
        SaveBackupResponse_ErrorCodes_BackupOffered,
        SaveBackupResponse_ErrorCodes_BadUserId,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SaveBackupResponse_ErrorCodes)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SaveBackupResponse_ErrorCodes_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SaveBackupResponse_ErrorCodes_IsValidValue(int32_t value__) {
  switch (value__) {
    case SaveBackupResponse_ErrorCodes_NoError:
    case SaveBackupResponse_ErrorCodes_UserNotFound:
    case SaveBackupResponse_ErrorCodes_CouldNotOverwrite:
    case SaveBackupResponse_ErrorCodes_BackupOffered:
    case SaveBackupResponse_ErrorCodes_BadUserId:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - CleanAccountRequest

@implementation CleanAccountRequest

@dynamic hasEiUserIdToKeep, eiUserIdToKeep;
@dynamic hasGameServicesId, gameServicesId;

typedef struct CleanAccountRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *eiUserIdToKeep;
  NSString *gameServicesId;
} CleanAccountRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "eiUserIdToKeep",
        .dataTypeSpecific.clazz = Nil,
        .number = CleanAccountRequest_FieldNumber_EiUserIdToKeep,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CleanAccountRequest__storage_, eiUserIdToKeep),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gameServicesId",
        .dataTypeSpecific.clazz = Nil,
        .number = CleanAccountRequest_FieldNumber_GameServicesId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CleanAccountRequest__storage_, gameServicesId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CleanAccountRequest class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CleanAccountRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ReturnEDTPayload

@implementation ReturnEDTPayload

@dynamic hasEiUserId, eiUserId;

typedef struct ReturnEDTPayload__storage_ {
  uint32_t _has_storage_[1];
  NSString *eiUserId;
} ReturnEDTPayload__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "eiUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = ReturnEDTPayload_FieldNumber_EiUserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ReturnEDTPayload__storage_, eiUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ReturnEDTPayload class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ReturnEDTPayload__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLCItem

@implementation DLCItem

@dynamic hasName, name;
@dynamic hasDirectory, directory;
@dynamic hasExt, ext;
@dynamic hasCompressed, compressed;
@dynamic hasOriginalSize, originalSize;
@dynamic hasURL, URL;
@dynamic hasChecksum, checksum;

typedef struct DLCItem__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *directory;
  NSString *ext;
  NSString *URL;
  NSString *checksum;
  uint64_t originalSize;
} DLCItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = DLCItem_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DLCItem__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "directory",
        .dataTypeSpecific.clazz = Nil,
        .number = DLCItem_FieldNumber_Directory,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DLCItem__storage_, directory),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ext",
        .dataTypeSpecific.clazz = Nil,
        .number = DLCItem_FieldNumber_Ext,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DLCItem__storage_, ext),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.clazz = Nil,
        .number = DLCItem_FieldNumber_URL,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DLCItem__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "checksum",
        .dataTypeSpecific.clazz = Nil,
        .number = DLCItem_FieldNumber_Checksum,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DLCItem__storage_, checksum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "compressed",
        .dataTypeSpecific.clazz = Nil,
        .number = DLCItem_FieldNumber_Compressed,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "originalSize",
        .dataTypeSpecific.clazz = Nil,
        .number = DLCItem_FieldNumber_OriginalSize,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DLCItem__storage_, originalSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLCItem class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLCItem__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShellSpec

@implementation ShellSpec

@dynamic hasIdentifier, identifier;
@dynamic hasPrimaryPiece, primaryPiece;
@dynamic piecesArray, piecesArray_Count;
@dynamic altAssetsArray, altAssetsArray_Count;
@dynamic hasName, name;
@dynamic hasSetIdentifier, setIdentifier;
@dynamic hasModifiedGeometry, modifiedGeometry;
@dynamic hasPrice, price;
@dynamic hasRequiredEop, requiredEop;
@dynamic hasRequiredSoulEggs, requiredSoulEggs;
@dynamic hasIsNew, isNew;
@dynamic hasExpires, expires;
@dynamic hasSecondsUntilAvailable, secondsUntilAvailable;
@dynamic hasSecondsRemaining, secondsRemaining;
@dynamic hasDefaultAppearance, defaultAppearance;

typedef struct ShellSpec__storage_ {
  uint32_t _has_storage_[1];
  uint32_t price;
  uint32_t requiredEop;
  NSString *identifier;
  NSString *name;
  NSMutableArray *piecesArray;
  ShellSpec_ShellPiece *primaryPiece;
  NSString *setIdentifier;
  NSMutableArray *altAssetsArray;
  double requiredSoulEggs;
  double secondsRemaining;
  double secondsUntilAvailable;
} ShellSpec__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.clazz = Nil,
        .number = ShellSpec_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ShellSpec__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = ShellSpec_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ShellSpec__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "price",
        .dataTypeSpecific.clazz = Nil,
        .number = ShellSpec_FieldNumber_Price,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ShellSpec__storage_, price),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "requiredEop",
        .dataTypeSpecific.clazz = Nil,
        .number = ShellSpec_FieldNumber_RequiredEop,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ShellSpec__storage_, requiredEop),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "requiredSoulEggs",
        .dataTypeSpecific.clazz = Nil,
        .number = ShellSpec_FieldNumber_RequiredSoulEggs,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ShellSpec__storage_, requiredSoulEggs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "defaultAppearance",
        .dataTypeSpecific.clazz = Nil,
        .number = ShellSpec_FieldNumber_DefaultAppearance,
        .hasIndex = 15,
        .offset = 16,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "piecesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ShellSpec_ShellPiece),
        .number = ShellSpec_FieldNumber_PiecesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ShellSpec__storage_, piecesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "primaryPiece",
        .dataTypeSpecific.clazz = GPBObjCClass(ShellSpec_ShellPiece),
        .number = ShellSpec_FieldNumber_PrimaryPiece,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ShellSpec__storage_, primaryPiece),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setIdentifier",
        .dataTypeSpecific.clazz = Nil,
        .number = ShellSpec_FieldNumber_SetIdentifier,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ShellSpec__storage_, setIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isNew",
        .dataTypeSpecific.clazz = Nil,
        .number = ShellSpec_FieldNumber_IsNew,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "expires",
        .dataTypeSpecific.clazz = Nil,
        .number = ShellSpec_FieldNumber_Expires,
        .hasIndex = 11,
        .offset = 12,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "secondsRemaining",
        .dataTypeSpecific.clazz = Nil,
        .number = ShellSpec_FieldNumber_SecondsRemaining,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ShellSpec__storage_, secondsRemaining),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "secondsUntilAvailable",
        .dataTypeSpecific.clazz = Nil,
        .number = ShellSpec_FieldNumber_SecondsUntilAvailable,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ShellSpec__storage_, secondsUntilAvailable),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "altAssetsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLCItem),
        .number = ShellSpec_FieldNumber_AltAssetsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ShellSpec__storage_, altAssetsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "modifiedGeometry",
        .dataTypeSpecific.clazz = Nil,
        .number = ShellSpec_FieldNumber_ModifiedGeometry,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShellSpec class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShellSpec__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ShellSpec_AssetType

GPBEnumDescriptor *ShellSpec_AssetType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Coop\000Shack\000SuperShack\000ShortHouse\000TheStan"
        "dard\000LongHouse\000DoubleDecker\000Warehouse\000Ce"
        "nter\000Bunker\000Eggkea\000Hab1K\000Hangar\000Tower\000Ha"
        "b10K\000Eggtopia\000Monolith\000PlanetPortal\000Chic"
        "kenUniverse\000Silo0Small\000Silo0Med\000Silo0Lar"
        "ge\000Silo1Small\000Silo1Med\000Silo1Large\000SiloAl"
        "l\000Mailbox\000TrophyCase\000Ground\000Hardscape\000Hy"
        "perloop\000Depot1\000Depot2\000Depot3\000Depot4\000Depo"
        "t5\000Depot6\000Depot7\000Lab1\000Lab2\000Lab3\000Lab4\000Lab"
        "5\000Lab6\000HatcheryEdible\000HatcherySuperfood\000"
        "HatcheryMedical\000HatcheryRocketFuel\000Hatch"
        "erySupermaterial\000HatcheryFusion\000Hatchery"
        "Quantum\000HatcheryImmortality\000HatcheryTach"
        "yon\000HatcheryGraviton\000HatcheryDilithium\000H"
        "atcheryProdigy\000HatcheryTerraform\000Hatcher"
        "yAntimatter\000HatcheryDarkMatter\000HatcheryA"
        "i\000HatcheryNebula\000HatcheryUniverse\000Hatche"
        "ryEnlightenment\000HatcheryChocolate\000Hatche"
        "ryEaster\000HatcheryWaterballoon\000HatcheryFi"
        "rework\000HatcheryPumpkin\000Hoa1\000Hoa2\000Hoa3\000Mi"
        "ssionControl1\000MissionControl2\000MissionCon"
        "trol3\000FuelTank1\000FuelTank2\000FuelTank3\000Fuel"
        "Tank4\000HatcheryGravitonTop\000HatcheryNebula"
        "Middle\000HatcheryNebulaTop\000HatcheryDarkMat"
        "terRing1\000HatcheryDarkMatterRing2\000Hatcher"
        "yDarkMatterRing3\000HatcheryAiTop1\000Hatchery"
        "AiTop2\000HatcheryAiTop3\000HatcheryAiTop4\000Hat"
        "cheryUniverseProbe\000HatcheryUniverseBolt\000"
        "HatcheryEnlightenmentOrb\000HyperloopTrack\000"
        "MailboxFull\000Chicken\000Hat\000Unknown\000";
    static const int32_t values[] = {
        ShellSpec_AssetType_Coop,
        ShellSpec_AssetType_Shack,
        ShellSpec_AssetType_SuperShack,
        ShellSpec_AssetType_ShortHouse,
        ShellSpec_AssetType_TheStandard,
        ShellSpec_AssetType_LongHouse,
        ShellSpec_AssetType_DoubleDecker,
        ShellSpec_AssetType_Warehouse,
        ShellSpec_AssetType_Center,
        ShellSpec_AssetType_Bunker,
        ShellSpec_AssetType_Eggkea,
        ShellSpec_AssetType_Hab1K,
        ShellSpec_AssetType_Hangar,
        ShellSpec_AssetType_Tower,
        ShellSpec_AssetType_Hab10K,
        ShellSpec_AssetType_Eggtopia,
        ShellSpec_AssetType_Monolith,
        ShellSpec_AssetType_PlanetPortal,
        ShellSpec_AssetType_ChickenUniverse,
        ShellSpec_AssetType_Silo0Small,
        ShellSpec_AssetType_Silo0Med,
        ShellSpec_AssetType_Silo0Large,
        ShellSpec_AssetType_Silo1Small,
        ShellSpec_AssetType_Silo1Med,
        ShellSpec_AssetType_Silo1Large,
        ShellSpec_AssetType_SiloAll,
        ShellSpec_AssetType_Mailbox,
        ShellSpec_AssetType_TrophyCase,
        ShellSpec_AssetType_Ground,
        ShellSpec_AssetType_Hardscape,
        ShellSpec_AssetType_Hyperloop,
        ShellSpec_AssetType_Depot1,
        ShellSpec_AssetType_Depot2,
        ShellSpec_AssetType_Depot3,
        ShellSpec_AssetType_Depot4,
        ShellSpec_AssetType_Depot5,
        ShellSpec_AssetType_Depot6,
        ShellSpec_AssetType_Depot7,
        ShellSpec_AssetType_Lab1,
        ShellSpec_AssetType_Lab2,
        ShellSpec_AssetType_Lab3,
        ShellSpec_AssetType_Lab4,
        ShellSpec_AssetType_Lab5,
        ShellSpec_AssetType_Lab6,
        ShellSpec_AssetType_HatcheryEdible,
        ShellSpec_AssetType_HatcherySuperfood,
        ShellSpec_AssetType_HatcheryMedical,
        ShellSpec_AssetType_HatcheryRocketFuel,
        ShellSpec_AssetType_HatcherySupermaterial,
        ShellSpec_AssetType_HatcheryFusion,
        ShellSpec_AssetType_HatcheryQuantum,
        ShellSpec_AssetType_HatcheryImmortality,
        ShellSpec_AssetType_HatcheryTachyon,
        ShellSpec_AssetType_HatcheryGraviton,
        ShellSpec_AssetType_HatcheryDilithium,
        ShellSpec_AssetType_HatcheryProdigy,
        ShellSpec_AssetType_HatcheryTerraform,
        ShellSpec_AssetType_HatcheryAntimatter,
        ShellSpec_AssetType_HatcheryDarkMatter,
        ShellSpec_AssetType_HatcheryAi,
        ShellSpec_AssetType_HatcheryNebula,
        ShellSpec_AssetType_HatcheryUniverse,
        ShellSpec_AssetType_HatcheryEnlightenment,
        ShellSpec_AssetType_HatcheryChocolate,
        ShellSpec_AssetType_HatcheryEaster,
        ShellSpec_AssetType_HatcheryWaterballoon,
        ShellSpec_AssetType_HatcheryFirework,
        ShellSpec_AssetType_HatcheryPumpkin,
        ShellSpec_AssetType_Hoa1,
        ShellSpec_AssetType_Hoa2,
        ShellSpec_AssetType_Hoa3,
        ShellSpec_AssetType_MissionControl1,
        ShellSpec_AssetType_MissionControl2,
        ShellSpec_AssetType_MissionControl3,
        ShellSpec_AssetType_FuelTank1,
        ShellSpec_AssetType_FuelTank2,
        ShellSpec_AssetType_FuelTank3,
        ShellSpec_AssetType_FuelTank4,
        ShellSpec_AssetType_HatcheryGravitonTop,
        ShellSpec_AssetType_HatcheryNebulaMiddle,
        ShellSpec_AssetType_HatcheryNebulaTop,
        ShellSpec_AssetType_HatcheryDarkMatterRing1,
        ShellSpec_AssetType_HatcheryDarkMatterRing2,
        ShellSpec_AssetType_HatcheryDarkMatterRing3,
        ShellSpec_AssetType_HatcheryAiTop1,
        ShellSpec_AssetType_HatcheryAiTop2,
        ShellSpec_AssetType_HatcheryAiTop3,
        ShellSpec_AssetType_HatcheryAiTop4,
        ShellSpec_AssetType_HatcheryUniverseProbe,
        ShellSpec_AssetType_HatcheryUniverseBolt,
        ShellSpec_AssetType_HatcheryEnlightenmentOrb,
        ShellSpec_AssetType_HyperloopTrack,
        ShellSpec_AssetType_MailboxFull,
        ShellSpec_AssetType_Chicken,
        ShellSpec_AssetType_Hat,
        ShellSpec_AssetType_Unknown,
    };
    static const char *extraTextFormatInfo = "&\013c\202\000\016c\203\000\023d\201\345\000\024d\201\343\000\025d\201\345\000\026d\201\345\000\027d\201\343\000\030d\201\345\000\037e\201\000 e\201\000!e\201\000\"e\201\000#e\201\000$e\201\000%e\201\000&c\201\000\'c\201\000(c\201\000)c\201\000*c\201\000+c\201\000Dc\201\000Ec\201\000Fc\201\000Gg\347\201\000Hg\347\201\000Ig\347\201\000Jd\344\201\000Kd\344\201\000Ld\344\201\000Md\344\201\000Qh\344\346\344\201\000Rh\344\346\344\201\000Sh\344\346\344\201\000Th\342\343\201\000Uh\342\343\201\000Vh\342\343\201\000Wh\342\343\201\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ShellSpec_AssetType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ShellSpec_AssetType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ShellSpec_AssetType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ShellSpec_AssetType_Coop:
    case ShellSpec_AssetType_Shack:
    case ShellSpec_AssetType_SuperShack:
    case ShellSpec_AssetType_ShortHouse:
    case ShellSpec_AssetType_TheStandard:
    case ShellSpec_AssetType_LongHouse:
    case ShellSpec_AssetType_DoubleDecker:
    case ShellSpec_AssetType_Warehouse:
    case ShellSpec_AssetType_Center:
    case ShellSpec_AssetType_Bunker:
    case ShellSpec_AssetType_Eggkea:
    case ShellSpec_AssetType_Hab1K:
    case ShellSpec_AssetType_Hangar:
    case ShellSpec_AssetType_Tower:
    case ShellSpec_AssetType_Hab10K:
    case ShellSpec_AssetType_Eggtopia:
    case ShellSpec_AssetType_Monolith:
    case ShellSpec_AssetType_PlanetPortal:
    case ShellSpec_AssetType_ChickenUniverse:
    case ShellSpec_AssetType_Silo0Small:
    case ShellSpec_AssetType_Silo0Med:
    case ShellSpec_AssetType_Silo0Large:
    case ShellSpec_AssetType_Silo1Small:
    case ShellSpec_AssetType_Silo1Med:
    case ShellSpec_AssetType_Silo1Large:
    case ShellSpec_AssetType_SiloAll:
    case ShellSpec_AssetType_Mailbox:
    case ShellSpec_AssetType_TrophyCase:
    case ShellSpec_AssetType_Ground:
    case ShellSpec_AssetType_Hardscape:
    case ShellSpec_AssetType_Hyperloop:
    case ShellSpec_AssetType_Depot1:
    case ShellSpec_AssetType_Depot2:
    case ShellSpec_AssetType_Depot3:
    case ShellSpec_AssetType_Depot4:
    case ShellSpec_AssetType_Depot5:
    case ShellSpec_AssetType_Depot6:
    case ShellSpec_AssetType_Depot7:
    case ShellSpec_AssetType_Lab1:
    case ShellSpec_AssetType_Lab2:
    case ShellSpec_AssetType_Lab3:
    case ShellSpec_AssetType_Lab4:
    case ShellSpec_AssetType_Lab5:
    case ShellSpec_AssetType_Lab6:
    case ShellSpec_AssetType_HatcheryEdible:
    case ShellSpec_AssetType_HatcherySuperfood:
    case ShellSpec_AssetType_HatcheryMedical:
    case ShellSpec_AssetType_HatcheryRocketFuel:
    case ShellSpec_AssetType_HatcherySupermaterial:
    case ShellSpec_AssetType_HatcheryFusion:
    case ShellSpec_AssetType_HatcheryQuantum:
    case ShellSpec_AssetType_HatcheryImmortality:
    case ShellSpec_AssetType_HatcheryTachyon:
    case ShellSpec_AssetType_HatcheryGraviton:
    case ShellSpec_AssetType_HatcheryDilithium:
    case ShellSpec_AssetType_HatcheryProdigy:
    case ShellSpec_AssetType_HatcheryTerraform:
    case ShellSpec_AssetType_HatcheryAntimatter:
    case ShellSpec_AssetType_HatcheryDarkMatter:
    case ShellSpec_AssetType_HatcheryAi:
    case ShellSpec_AssetType_HatcheryNebula:
    case ShellSpec_AssetType_HatcheryUniverse:
    case ShellSpec_AssetType_HatcheryEnlightenment:
    case ShellSpec_AssetType_HatcheryChocolate:
    case ShellSpec_AssetType_HatcheryEaster:
    case ShellSpec_AssetType_HatcheryWaterballoon:
    case ShellSpec_AssetType_HatcheryFirework:
    case ShellSpec_AssetType_HatcheryPumpkin:
    case ShellSpec_AssetType_Hoa1:
    case ShellSpec_AssetType_Hoa2:
    case ShellSpec_AssetType_Hoa3:
    case ShellSpec_AssetType_MissionControl1:
    case ShellSpec_AssetType_MissionControl2:
    case ShellSpec_AssetType_MissionControl3:
    case ShellSpec_AssetType_FuelTank1:
    case ShellSpec_AssetType_FuelTank2:
    case ShellSpec_AssetType_FuelTank3:
    case ShellSpec_AssetType_FuelTank4:
    case ShellSpec_AssetType_HatcheryGravitonTop:
    case ShellSpec_AssetType_HatcheryNebulaMiddle:
    case ShellSpec_AssetType_HatcheryNebulaTop:
    case ShellSpec_AssetType_HatcheryDarkMatterRing1:
    case ShellSpec_AssetType_HatcheryDarkMatterRing2:
    case ShellSpec_AssetType_HatcheryDarkMatterRing3:
    case ShellSpec_AssetType_HatcheryAiTop1:
    case ShellSpec_AssetType_HatcheryAiTop2:
    case ShellSpec_AssetType_HatcheryAiTop3:
    case ShellSpec_AssetType_HatcheryAiTop4:
    case ShellSpec_AssetType_HatcheryUniverseProbe:
    case ShellSpec_AssetType_HatcheryUniverseBolt:
    case ShellSpec_AssetType_HatcheryEnlightenmentOrb:
    case ShellSpec_AssetType_HyperloopTrack:
    case ShellSpec_AssetType_MailboxFull:
    case ShellSpec_AssetType_Chicken:
    case ShellSpec_AssetType_Hat:
    case ShellSpec_AssetType_Unknown:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ShellSpec_ShellPiece

@implementation ShellSpec_ShellPiece

@dynamic hasAssetType, assetType;
@dynamic hasDlc, dlc;

typedef struct ShellSpec_ShellPiece__storage_ {
  uint32_t _has_storage_[1];
  ShellSpec_AssetType assetType;
  DLCItem *dlc;
} ShellSpec_ShellPiece__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = ShellSpec_AssetType_Coop,
        .core.name = "assetType",
        .core.dataTypeSpecific.enumDescFunc = ShellSpec_AssetType_EnumDescriptor,
        .core.number = ShellSpec_ShellPiece_FieldNumber_AssetType,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ShellSpec_ShellPiece__storage_, assetType),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "dlc",
        .core.dataTypeSpecific.clazz = GPBObjCClass(DLCItem),
        .core.number = ShellSpec_ShellPiece_FieldNumber_Dlc,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ShellSpec_ShellPiece__storage_, dlc),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShellSpec_ShellPiece class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ShellSpec_ShellPiece__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ShellSpec)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShellSetSpec

@implementation ShellSetSpec

@dynamic hasIdentifier, identifier;
@dynamic hasName, name;
@dynamic hasPrice, price;
@dynamic hasPriceMultDeprecated, priceMultDeprecated;
@dynamic hasDiscount, discount;
@dynamic hasRequiredEop, requiredEop;
@dynamic hasRequiredSoulEggs, requiredSoulEggs;
@dynamic hasIsNew, isNew;
@dynamic hasExpires, expires;
@dynamic hasSecondsUntilAvailable, secondsUntilAvailable;
@dynamic hasSecondsRemaining, secondsRemaining;
@dynamic hasDecorator, decorator;
@dynamic hasModifiedGeometry, modifiedGeometry;
@dynamic hasElementSet, elementSet;
@dynamic hasHexBaseColor, hexBaseColor;
@dynamic variationsArray, variationsArray_Count;
@dynamic hasIcon, icon;
@dynamic hasDefaultAppearance, defaultAppearance;
@dynamic hasCustomAppearance, customAppearance;

typedef struct ShellSetSpec__storage_ {
  uint32_t _has_storage_[1];
  uint32_t price;
  uint32_t requiredEop;
  NSString *identifier;
  NSString *name;
  NSMutableArray *variationsArray;
  NSString *hexBaseColor;
  DLCItem *icon;
  double requiredSoulEggs;
  double priceMultDeprecated;
  double secondsRemaining;
  double discount;
  double secondsUntilAvailable;
} ShellSetSpec__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "identifier",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellSetSpec_FieldNumber_Identifier,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ShellSetSpec__storage_, identifier),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "name",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellSetSpec_FieldNumber_Name,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ShellSetSpec__storage_, name),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "price",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellSetSpec_FieldNumber_Price,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ShellSetSpec__storage_, price),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "requiredEop",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellSetSpec_FieldNumber_RequiredEop,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(ShellSetSpec__storage_, requiredEop),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "requiredSoulEggs",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellSetSpec_FieldNumber_RequiredSoulEggs,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(ShellSetSpec__storage_, requiredSoulEggs),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "defaultAppearance",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellSetSpec_FieldNumber_DefaultAppearance,
        .core.hasIndex = 21,
        .core.offset = 22,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "elementSet",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellSetSpec_FieldNumber_ElementSet,
        .core.hasIndex = 17,
        .core.offset = 18,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueDouble = 1,
        .core.name = "priceMultDeprecated",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellSetSpec_FieldNumber_PriceMultDeprecated,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ShellSetSpec__storage_, priceMultDeprecated),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "isNew",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellSetSpec_FieldNumber_IsNew,
        .core.hasIndex = 7,
        .core.offset = 8,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "expires",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellSetSpec_FieldNumber_Expires,
        .core.hasIndex = 9,
        .core.offset = 10,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "secondsRemaining",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellSetSpec_FieldNumber_SecondsRemaining,
        .core.hasIndex = 12,
        .core.offset = (uint32_t)offsetof(ShellSetSpec__storage_, secondsRemaining),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "customAppearance",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellSetSpec_FieldNumber_CustomAppearance,
        .core.hasIndex = 23,
        .core.offset = 24,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "modifiedGeometry",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellSetSpec_FieldNumber_ModifiedGeometry,
        .core.hasIndex = 15,
        .core.offset = 16,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "decorator",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellSetSpec_FieldNumber_Decorator,
        .core.hasIndex = 13,
        .core.offset = 14,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "variationsArray",
        .core.dataTypeSpecific.clazz = GPBObjCClass(ShellSetSpec_VariationSpec),
        .core.number = ShellSetSpec_FieldNumber_VariationsArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(ShellSetSpec__storage_, variationsArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "hexBaseColor",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellSetSpec_FieldNumber_HexBaseColor,
        .core.hasIndex = 19,
        .core.offset = (uint32_t)offsetof(ShellSetSpec__storage_, hexBaseColor),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "discount",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellSetSpec_FieldNumber_Discount,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(ShellSetSpec__storage_, discount),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "secondsUntilAvailable",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellSetSpec_FieldNumber_SecondsUntilAvailable,
        .core.hasIndex = 11,
        .core.offset = (uint32_t)offsetof(ShellSetSpec__storage_, secondsUntilAvailable),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "icon",
        .core.dataTypeSpecific.clazz = GPBObjCClass(DLCItem),
        .core.number = ShellSetSpec_FieldNumber_Icon,
        .core.hasIndex = 20,
        .core.offset = (uint32_t)offsetof(ShellSetSpec__storage_, icon),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShellSetSpec class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ShellSetSpec__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\010\005\244\352\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShellSetSpec_VariationSpec

@implementation ShellSetSpec_VariationSpec

@dynamic hasIdentifier, identifier;
@dynamic hasHexColor, hexColor;
@dynamic hasPrice, price;
@dynamic hasSortPriority, sortPriority;
@dynamic hasDefaultAppearance, defaultAppearance;
@dynamic hasCustomAppearance, customAppearance;

typedef struct ShellSetSpec_VariationSpec__storage_ {
  uint32_t _has_storage_[1];
  uint32_t price;
  int32_t sortPriority;
  NSString *identifier;
  NSString *hexColor;
} ShellSetSpec_VariationSpec__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.clazz = Nil,
        .number = ShellSetSpec_VariationSpec_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ShellSetSpec_VariationSpec__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hexColor",
        .dataTypeSpecific.clazz = Nil,
        .number = ShellSetSpec_VariationSpec_FieldNumber_HexColor,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ShellSetSpec_VariationSpec__storage_, hexColor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "price",
        .dataTypeSpecific.clazz = Nil,
        .number = ShellSetSpec_VariationSpec_FieldNumber_Price,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ShellSetSpec_VariationSpec__storage_, price),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "defaultAppearance",
        .dataTypeSpecific.clazz = Nil,
        .number = ShellSetSpec_VariationSpec_FieldNumber_DefaultAppearance,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "customAppearance",
        .dataTypeSpecific.clazz = Nil,
        .number = ShellSetSpec_VariationSpec_FieldNumber_CustomAppearance,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "sortPriority",
        .dataTypeSpecific.clazz = Nil,
        .number = ShellSetSpec_VariationSpec_FieldNumber_SortPriority,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ShellSetSpec_VariationSpec__storage_, sortPriority),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShellSetSpec_VariationSpec class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShellSetSpec_VariationSpec__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ShellSetSpec)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShellObjectSpec

@implementation ShellObjectSpec

@dynamic hasIdentifier, identifier;
@dynamic hasName, name;
@dynamic hasAssetType, assetType;
@dynamic hasObjectClass, objectClass;
@dynamic iconColorsArray, iconColorsArray_Count;
@dynamic hasPrice, price;
@dynamic hasRequiredEop, requiredEop;
@dynamic hasRequiredSoulEggs, requiredSoulEggs;
@dynamic hasIsNew, isNew;
@dynamic hasExpires, expires;
@dynamic hasSecondsUntilAvailable, secondsUntilAvailable;
@dynamic hasSecondsRemaining, secondsRemaining;
@dynamic metadataArray, metadataArray_Count;
@dynamic hasNoHats, noHats;
@dynamic hasChickenAnimation, chickenAnimation;
@dynamic hasSortPriority, sortPriority;
@dynamic piecesArray, piecesArray_Count;
@dynamic hasDefaultAppearance, defaultAppearance;

typedef struct ShellObjectSpec__storage_ {
  uint32_t _has_storage_[1];
  ShellSpec_AssetType assetType;
  uint32_t price;
  uint32_t requiredEop;
  ShellObjectSpec_ChickenAnimation chickenAnimation;
  int32_t sortPriority;
  NSString *identifier;
  NSString *name;
  GPBDoubleArray *metadataArray;
  NSMutableArray *piecesArray;
  NSString *objectClass;
  NSMutableArray *iconColorsArray;
  double requiredSoulEggs;
  double secondsRemaining;
  double secondsUntilAvailable;
} ShellObjectSpec__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "identifier",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellObjectSpec_FieldNumber_Identifier,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ShellObjectSpec__storage_, identifier),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "name",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellObjectSpec_FieldNumber_Name,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ShellObjectSpec__storage_, name),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = ShellSpec_AssetType_Coop,
        .core.name = "assetType",
        .core.dataTypeSpecific.enumDescFunc = ShellSpec_AssetType_EnumDescriptor,
        .core.number = ShellObjectSpec_FieldNumber_AssetType,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ShellObjectSpec__storage_, assetType),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "price",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellObjectSpec_FieldNumber_Price,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(ShellObjectSpec__storage_, price),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "requiredEop",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellObjectSpec_FieldNumber_RequiredEop,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(ShellObjectSpec__storage_, requiredEop),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "requiredSoulEggs",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellObjectSpec_FieldNumber_RequiredSoulEggs,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(ShellObjectSpec__storage_, requiredSoulEggs),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "metadataArray",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellObjectSpec_FieldNumber_MetadataArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(ShellObjectSpec__storage_, metadataArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "piecesArray",
        .core.dataTypeSpecific.clazz = GPBObjCClass(ShellObjectSpec_LODPiece),
        .core.number = ShellObjectSpec_FieldNumber_PiecesArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(ShellObjectSpec__storage_, piecesArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "defaultAppearance",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellObjectSpec_FieldNumber_DefaultAppearance,
        .core.hasIndex = 17,
        .core.offset = 18,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "isNew",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellObjectSpec_FieldNumber_IsNew,
        .core.hasIndex = 7,
        .core.offset = 8,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "expires",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellObjectSpec_FieldNumber_Expires,
        .core.hasIndex = 9,
        .core.offset = 10,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "secondsRemaining",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellObjectSpec_FieldNumber_SecondsRemaining,
        .core.hasIndex = 12,
        .core.offset = (uint32_t)offsetof(ShellObjectSpec__storage_, secondsRemaining),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "noHats",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellObjectSpec_FieldNumber_NoHats,
        .core.hasIndex = 13,
        .core.offset = 14,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "objectClass",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellObjectSpec_FieldNumber_ObjectClass,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ShellObjectSpec__storage_, objectClass),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "iconColorsArray",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellObjectSpec_FieldNumber_IconColorsArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(ShellObjectSpec__storage_, iconColorsArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = ShellObjectSpec_ChickenAnimation_StandardRun,
        .core.name = "chickenAnimation",
        .core.dataTypeSpecific.enumDescFunc = ShellObjectSpec_ChickenAnimation_EnumDescriptor,
        .core.number = ShellObjectSpec_FieldNumber_ChickenAnimation,
        .core.hasIndex = 15,
        .core.offset = (uint32_t)offsetof(ShellObjectSpec__storage_, chickenAnimation),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "sortPriority",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellObjectSpec_FieldNumber_SortPriority,
        .core.hasIndex = 16,
        .core.offset = (uint32_t)offsetof(ShellObjectSpec__storage_, sortPriority),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "secondsUntilAvailable",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellObjectSpec_FieldNumber_SecondsUntilAvailable,
        .core.hasIndex = 11,
        .core.offset = (uint32_t)offsetof(ShellObjectSpec__storage_, secondsUntilAvailable),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShellObjectSpec class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ShellObjectSpec__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ShellObjectSpec_ChickenAnimation

GPBEnumDescriptor *ShellObjectSpec_ChickenAnimation_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "StandardRun\000Slowmo\000Wobble\000WobbleLean\000Smo"
        "oth\000SmoothLean\000Hover\000SidewaysSmooth\000Side"
        "waysLean\000";
    static const int32_t values[] = {
        ShellObjectSpec_ChickenAnimation_StandardRun,
        ShellObjectSpec_ChickenAnimation_Slowmo,
        ShellObjectSpec_ChickenAnimation_Wobble,
        ShellObjectSpec_ChickenAnimation_WobbleLean,
        ShellObjectSpec_ChickenAnimation_Smooth,
        ShellObjectSpec_ChickenAnimation_SmoothLean,
        ShellObjectSpec_ChickenAnimation_Hover,
        ShellObjectSpec_ChickenAnimation_SidewaysSmooth,
        ShellObjectSpec_ChickenAnimation_SidewaysLean,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ShellObjectSpec_ChickenAnimation)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ShellObjectSpec_ChickenAnimation_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ShellObjectSpec_ChickenAnimation_IsValidValue(int32_t value__) {
  switch (value__) {
    case ShellObjectSpec_ChickenAnimation_StandardRun:
    case ShellObjectSpec_ChickenAnimation_Slowmo:
    case ShellObjectSpec_ChickenAnimation_Wobble:
    case ShellObjectSpec_ChickenAnimation_WobbleLean:
    case ShellObjectSpec_ChickenAnimation_Smooth:
    case ShellObjectSpec_ChickenAnimation_SmoothLean:
    case ShellObjectSpec_ChickenAnimation_Hover:
    case ShellObjectSpec_ChickenAnimation_SidewaysSmooth:
    case ShellObjectSpec_ChickenAnimation_SidewaysLean:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ShellObjectSpec_LODPiece

@implementation ShellObjectSpec_LODPiece

@dynamic hasDlc, dlc;
@dynamic hasLod, lod;

typedef struct ShellObjectSpec_LODPiece__storage_ {
  uint32_t _has_storage_[1];
  uint32_t lod;
  DLCItem *dlc;
} ShellObjectSpec_LODPiece__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dlc",
        .dataTypeSpecific.clazz = GPBObjCClass(DLCItem),
        .number = ShellObjectSpec_LODPiece_FieldNumber_Dlc,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ShellObjectSpec_LODPiece__storage_, dlc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lod",
        .dataTypeSpecific.clazz = Nil,
        .number = ShellObjectSpec_LODPiece_FieldNumber_Lod,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ShellObjectSpec_LODPiece__storage_, lod),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShellObjectSpec_LODPiece class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShellObjectSpec_LODPiece__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ShellObjectSpec)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShellGroupSpec

@implementation ShellGroupSpec

@dynamic hasIdentifier, identifier;
@dynamic hasName, name;
@dynamic hasAssetType, assetType;
@dynamic memberIdsArray, memberIdsArray_Count;
@dynamic hasPriceMultDeprecated, priceMultDeprecated;

typedef struct ShellGroupSpec__storage_ {
  uint32_t _has_storage_[1];
  ShellSpec_AssetType assetType;
  NSString *identifier;
  NSString *name;
  NSMutableArray *memberIdsArray;
  double priceMultDeprecated;
} ShellGroupSpec__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "identifier",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellGroupSpec_FieldNumber_Identifier,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ShellGroupSpec__storage_, identifier),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "name",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellGroupSpec_FieldNumber_Name,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ShellGroupSpec__storage_, name),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "memberIdsArray",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellGroupSpec_FieldNumber_MemberIdsArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(ShellGroupSpec__storage_, memberIdsArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "priceMultDeprecated",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellGroupSpec_FieldNumber_PriceMultDeprecated,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ShellGroupSpec__storage_, priceMultDeprecated),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueEnum = ShellSpec_AssetType_Coop,
        .core.name = "assetType",
        .core.dataTypeSpecific.enumDescFunc = ShellSpec_AssetType_EnumDescriptor,
        .core.number = ShellGroupSpec_FieldNumber_AssetType,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ShellGroupSpec__storage_, assetType),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShellGroupSpec class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ShellGroupSpec__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\005\244\352\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DLCCatalog

@implementation DLCCatalog

@dynamic itemsArray, itemsArray_Count;
@dynamic shellsArray, shellsArray_Count;
@dynamic shellSetsArray, shellSetsArray_Count;
@dynamic decoratorsArray, decoratorsArray_Count;
@dynamic shellObjectsArray, shellObjectsArray_Count;
@dynamic shellGroupsArray, shellGroupsArray_Count;

typedef struct DLCCatalog__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemsArray;
  NSMutableArray *shellsArray;
  NSMutableArray *shellSetsArray;
  NSMutableArray *shellObjectsArray;
  NSMutableArray *shellGroupsArray;
  NSMutableArray *decoratorsArray;
} DLCCatalog__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DLCItem),
        .number = DLCCatalog_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLCCatalog__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "shellsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ShellSpec),
        .number = DLCCatalog_FieldNumber_ShellsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLCCatalog__storage_, shellsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "shellSetsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ShellSetSpec),
        .number = DLCCatalog_FieldNumber_ShellSetsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLCCatalog__storage_, shellSetsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "shellObjectsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ShellObjectSpec),
        .number = DLCCatalog_FieldNumber_ShellObjectsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLCCatalog__storage_, shellObjectsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "shellGroupsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ShellGroupSpec),
        .number = DLCCatalog_FieldNumber_ShellGroupsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLCCatalog__storage_, shellGroupsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "decoratorsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ShellSetSpec),
        .number = DLCCatalog_FieldNumber_DecoratorsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DLCCatalog__storage_, decoratorsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DLCCatalog class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DLCCatalog__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShellDB

@implementation ShellDB

@dynamic shellInventoryArray, shellInventoryArray_Count;
@dynamic shellElementInventoryArray, shellElementInventoryArray_Count;
@dynamic shellVariationInventoryArray, shellVariationInventoryArray_Count;
@dynamic shellSetInventoryArray, shellSetInventoryArray_Count;
@dynamic shellObjectInventoryArray, shellObjectInventoryArray_Count;
@dynamic farmConfigsArray, farmConfigsArray_Count;
@dynamic savedConfigsArray, savedConfigsArray_Count;
@dynamic newShellsDownloadedArray, newShellsDownloadedArray_Count;
@dynamic newShellsSeenArray, newShellsSeenArray_Count;

typedef struct ShellDB__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *shellInventoryArray;
  NSMutableArray *shellSetInventoryArray;
  NSMutableArray *farmConfigsArray;
  NSMutableArray *shellObjectInventoryArray;
  NSMutableArray *shellElementInventoryArray;
  NSMutableArray *newShellsDownloadedArray;
  NSMutableArray *newShellsSeenArray;
  NSMutableArray *shellVariationInventoryArray;
  NSMutableArray *savedConfigsArray;
} ShellDB__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "shellInventoryArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ShellDB_ShellStatus),
        .number = ShellDB_FieldNumber_ShellInventoryArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ShellDB__storage_, shellInventoryArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "shellSetInventoryArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ShellDB_ShellStatus),
        .number = ShellDB_FieldNumber_ShellSetInventoryArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ShellDB__storage_, shellSetInventoryArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "farmConfigsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ShellDB_FarmConfiguration),
        .number = ShellDB_FieldNumber_FarmConfigsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ShellDB__storage_, farmConfigsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "shellObjectInventoryArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ShellDB_ShellStatus),
        .number = ShellDB_FieldNumber_ShellObjectInventoryArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ShellDB__storage_, shellObjectInventoryArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "shellElementInventoryArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ShellDB_ShellElementStatus),
        .number = ShellDB_FieldNumber_ShellElementInventoryArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ShellDB__storage_, shellElementInventoryArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "newShellsDownloadedArray",
        .dataTypeSpecific.clazz = Nil,
        .number = ShellDB_FieldNumber_NewShellsDownloadedArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ShellDB__storage_, newShellsDownloadedArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "newShellsSeenArray",
        .dataTypeSpecific.clazz = Nil,
        .number = ShellDB_FieldNumber_NewShellsSeenArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ShellDB__storage_, newShellsSeenArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "shellVariationInventoryArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ShellDB_ShellSetVariationStatus),
        .number = ShellDB_FieldNumber_ShellVariationInventoryArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ShellDB__storage_, shellVariationInventoryArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "savedConfigsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ShellDB_SavedFarmConfiguration),
        .number = ShellDB_FieldNumber_SavedConfigsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ShellDB__storage_, savedConfigsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShellDB class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShellDB__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ShellDB_FarmElement

GPBEnumDescriptor *ShellDB_FarmElement_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "HenHouse\000Silo\000Mailbox\000TrophyCase\000Ground\000"
        "Hardscape\000Hyperloop\000Depot\000Lab\000Hatchery\000H"
        "oa\000MissionControl\000FuelTank\000Chicken\000Hat\000U"
        "nknown\000";
    static const int32_t values[] = {
        ShellDB_FarmElement_HenHouse,
        ShellDB_FarmElement_Silo,
        ShellDB_FarmElement_Mailbox,
        ShellDB_FarmElement_TrophyCase,
        ShellDB_FarmElement_Ground,
        ShellDB_FarmElement_Hardscape,
        ShellDB_FarmElement_Hyperloop,
        ShellDB_FarmElement_Depot,
        ShellDB_FarmElement_Lab,
        ShellDB_FarmElement_Hatchery,
        ShellDB_FarmElement_Hoa,
        ShellDB_FarmElement_MissionControl,
        ShellDB_FarmElement_FuelTank,
        ShellDB_FarmElement_Chicken,
        ShellDB_FarmElement_Hat,
        ShellDB_FarmElement_Unknown,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ShellDB_FarmElement)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ShellDB_FarmElement_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ShellDB_FarmElement_IsValidValue(int32_t value__) {
  switch (value__) {
    case ShellDB_FarmElement_HenHouse:
    case ShellDB_FarmElement_Silo:
    case ShellDB_FarmElement_Mailbox:
    case ShellDB_FarmElement_TrophyCase:
    case ShellDB_FarmElement_Ground:
    case ShellDB_FarmElement_Hardscape:
    case ShellDB_FarmElement_Hyperloop:
    case ShellDB_FarmElement_Depot:
    case ShellDB_FarmElement_Lab:
    case ShellDB_FarmElement_Hatchery:
    case ShellDB_FarmElement_Hoa:
    case ShellDB_FarmElement_MissionControl:
    case ShellDB_FarmElement_FuelTank:
    case ShellDB_FarmElement_Chicken:
    case ShellDB_FarmElement_Hat:
    case ShellDB_FarmElement_Unknown:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ShellDB_ShellStatus

@implementation ShellDB_ShellStatus

@dynamic hasIdentifier, identifier;
@dynamic hasOwned, owned;

typedef struct ShellDB_ShellStatus__storage_ {
  uint32_t _has_storage_[1];
  NSString *identifier;
} ShellDB_ShellStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.clazz = Nil,
        .number = ShellDB_ShellStatus_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ShellDB_ShellStatus__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "owned",
        .dataTypeSpecific.clazz = Nil,
        .number = ShellDB_ShellStatus_FieldNumber_Owned,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShellDB_ShellStatus class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShellDB_ShellStatus__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ShellDB)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShellDB_ShellElementStatus

@implementation ShellDB_ShellElementStatus

@dynamic hasElement, element;
@dynamic hasSetIdentifier, setIdentifier;

typedef struct ShellDB_ShellElementStatus__storage_ {
  uint32_t _has_storage_[1];
  ShellDB_FarmElement element;
  NSString *setIdentifier;
} ShellDB_ShellElementStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = ShellDB_FarmElement_HenHouse,
        .core.name = "element",
        .core.dataTypeSpecific.enumDescFunc = ShellDB_FarmElement_EnumDescriptor,
        .core.number = ShellDB_ShellElementStatus_FieldNumber_Element,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ShellDB_ShellElementStatus__storage_, element),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "setIdentifier",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellDB_ShellElementStatus_FieldNumber_SetIdentifier,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ShellDB_ShellElementStatus__storage_, setIdentifier),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShellDB_ShellElementStatus class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ShellDB_ShellElementStatus__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ShellDB)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShellDB_ShellSetVariationStatus

@implementation ShellDB_ShellSetVariationStatus

@dynamic hasSetIdentifier, setIdentifier;
@dynamic ownedVariationsArray, ownedVariationsArray_Count;

typedef struct ShellDB_ShellSetVariationStatus__storage_ {
  uint32_t _has_storage_[1];
  NSString *setIdentifier;
  NSMutableArray *ownedVariationsArray;
} ShellDB_ShellSetVariationStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "setIdentifier",
        .dataTypeSpecific.clazz = Nil,
        .number = ShellDB_ShellSetVariationStatus_FieldNumber_SetIdentifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ShellDB_ShellSetVariationStatus__storage_, setIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ownedVariationsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = ShellDB_ShellSetVariationStatus_FieldNumber_OwnedVariationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ShellDB_ShellSetVariationStatus__storage_, ownedVariationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShellDB_ShellSetVariationStatus class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShellDB_ShellSetVariationStatus__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ShellDB)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShellDB_FarmConfiguration

@implementation ShellDB_FarmConfiguration

@dynamic shellConfigsArray, shellConfigsArray_Count;
@dynamic shellSetConfigsArray, shellSetConfigsArray_Count;
@dynamic hasConfigureChickensByGroup, configureChickensByGroup;
@dynamic groupConfigsArray, groupConfigsArray_Count;
@dynamic chickenConfigsArray, chickenConfigsArray_Count;

typedef struct ShellDB_FarmConfiguration__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *shellConfigsArray;
  NSMutableArray *shellSetConfigsArray;
  NSMutableArray *groupConfigsArray;
  NSMutableArray *chickenConfigsArray;
} ShellDB_FarmConfiguration__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "shellConfigsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ShellDB_ShellConfiguration),
        .number = ShellDB_FarmConfiguration_FieldNumber_ShellConfigsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ShellDB_FarmConfiguration__storage_, shellConfigsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "shellSetConfigsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ShellDB_ShellSetConfiguration),
        .number = ShellDB_FarmConfiguration_FieldNumber_ShellSetConfigsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ShellDB_FarmConfiguration__storage_, shellSetConfigsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "configureChickensByGroup",
        .dataTypeSpecific.clazz = Nil,
        .number = ShellDB_FarmConfiguration_FieldNumber_ConfigureChickensByGroup,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "groupConfigsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ShellDB_ShellGroupConfiguration),
        .number = ShellDB_FarmConfiguration_FieldNumber_GroupConfigsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ShellDB_FarmConfiguration__storage_, groupConfigsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chickenConfigsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ShellDB_ChickenConfig),
        .number = ShellDB_FarmConfiguration_FieldNumber_ChickenConfigsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ShellDB_FarmConfiguration__storage_, chickenConfigsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShellDB_FarmConfiguration class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShellDB_FarmConfiguration__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ShellDB)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShellDB_SavedFarmConfiguration

@implementation ShellDB_SavedFarmConfiguration

@dynamic hasName, name;
@dynamic hasConfig, config;
@dynamic hasClientSaveTime, clientSaveTime;

typedef struct ShellDB_SavedFarmConfiguration__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  ShellDB_FarmConfiguration *config;
  double clientSaveTime;
} ShellDB_SavedFarmConfiguration__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = ShellDB_SavedFarmConfiguration_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ShellDB_SavedFarmConfiguration__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "config",
        .dataTypeSpecific.clazz = GPBObjCClass(ShellDB_FarmConfiguration),
        .number = ShellDB_SavedFarmConfiguration_FieldNumber_Config,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ShellDB_SavedFarmConfiguration__storage_, config),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clientSaveTime",
        .dataTypeSpecific.clazz = Nil,
        .number = ShellDB_SavedFarmConfiguration_FieldNumber_ClientSaveTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ShellDB_SavedFarmConfiguration__storage_, clientSaveTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShellDB_SavedFarmConfiguration class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShellDB_SavedFarmConfiguration__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ShellDB)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShellDB_ShellConfiguration

@implementation ShellDB_ShellConfiguration

@dynamic hasAssetType, assetType;
@dynamic hasIndex, index;
@dynamic hasShellIdentifier, shellIdentifier;

typedef struct ShellDB_ShellConfiguration__storage_ {
  uint32_t _has_storage_[1];
  ShellSpec_AssetType assetType;
  uint32_t index;
  NSString *shellIdentifier;
} ShellDB_ShellConfiguration__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = ShellSpec_AssetType_Coop,
        .core.name = "assetType",
        .core.dataTypeSpecific.enumDescFunc = ShellSpec_AssetType_EnumDescriptor,
        .core.number = ShellDB_ShellConfiguration_FieldNumber_AssetType,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ShellDB_ShellConfiguration__storage_, assetType),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "index",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellDB_ShellConfiguration_FieldNumber_Index,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ShellDB_ShellConfiguration__storage_, index),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "shellIdentifier",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellDB_ShellConfiguration_FieldNumber_ShellIdentifier,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ShellDB_ShellConfiguration__storage_, shellIdentifier),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShellDB_ShellConfiguration class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ShellDB_ShellConfiguration__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ShellDB)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShellDB_ShellSetConfiguration

@implementation ShellDB_ShellSetConfiguration

@dynamic hasElement, element;
@dynamic hasIndex, index;
@dynamic hasShellSetIdentifier, shellSetIdentifier;
@dynamic hasVariationIdentifier, variationIdentifier;
@dynamic hasDecoratorIdentifier, decoratorIdentifier;

typedef struct ShellDB_ShellSetConfiguration__storage_ {
  uint32_t _has_storage_[1];
  ShellDB_FarmElement element;
  uint32_t index;
  NSString *shellSetIdentifier;
  NSString *variationIdentifier;
  NSString *decoratorIdentifier;
} ShellDB_ShellSetConfiguration__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = ShellDB_FarmElement_HenHouse,
        .core.name = "element",
        .core.dataTypeSpecific.enumDescFunc = ShellDB_FarmElement_EnumDescriptor,
        .core.number = ShellDB_ShellSetConfiguration_FieldNumber_Element,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ShellDB_ShellSetConfiguration__storage_, element),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "index",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellDB_ShellSetConfiguration_FieldNumber_Index,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ShellDB_ShellSetConfiguration__storage_, index),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "shellSetIdentifier",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellDB_ShellSetConfiguration_FieldNumber_ShellSetIdentifier,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ShellDB_ShellSetConfiguration__storage_, shellSetIdentifier),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "variationIdentifier",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellDB_ShellSetConfiguration_FieldNumber_VariationIdentifier,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ShellDB_ShellSetConfiguration__storage_, variationIdentifier),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "decoratorIdentifier",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellDB_ShellSetConfiguration_FieldNumber_DecoratorIdentifier,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(ShellDB_ShellSetConfiguration__storage_, decoratorIdentifier),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShellDB_ShellSetConfiguration class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ShellDB_ShellSetConfiguration__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ShellDB)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShellDB_ShellGroupConfiguration

@implementation ShellDB_ShellGroupConfiguration

@dynamic hasAssetType, assetType;
@dynamic hasGroupIdentifier, groupIdentifier;

typedef struct ShellDB_ShellGroupConfiguration__storage_ {
  uint32_t _has_storage_[1];
  ShellSpec_AssetType assetType;
  NSString *groupIdentifier;
} ShellDB_ShellGroupConfiguration__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = ShellSpec_AssetType_Coop,
        .core.name = "assetType",
        .core.dataTypeSpecific.enumDescFunc = ShellSpec_AssetType_EnumDescriptor,
        .core.number = ShellDB_ShellGroupConfiguration_FieldNumber_AssetType,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ShellDB_ShellGroupConfiguration__storage_, assetType),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "groupIdentifier",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellDB_ShellGroupConfiguration_FieldNumber_GroupIdentifier,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ShellDB_ShellGroupConfiguration__storage_, groupIdentifier),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShellDB_ShellGroupConfiguration class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ShellDB_ShellGroupConfiguration__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ShellDB)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShellDB_ChickenConfig

@implementation ShellDB_ChickenConfig

@dynamic hasChickenIdentifier, chickenIdentifier;
@dynamic hasHatIdentifier, hatIdentifier;

typedef struct ShellDB_ChickenConfig__storage_ {
  uint32_t _has_storage_[1];
  NSString *chickenIdentifier;
  NSString *hatIdentifier;
} ShellDB_ChickenConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chickenIdentifier",
        .dataTypeSpecific.clazz = Nil,
        .number = ShellDB_ChickenConfig_FieldNumber_ChickenIdentifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ShellDB_ChickenConfig__storage_, chickenIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hatIdentifier",
        .dataTypeSpecific.clazz = Nil,
        .number = ShellDB_ChickenConfig_FieldNumber_HatIdentifier,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ShellDB_ChickenConfig__storage_, hatIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShellDB_ChickenConfig class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShellDB_ChickenConfig__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ShellDB)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShellsActionLog

@implementation ShellsActionLog

@dynamic hasRinfo, rinfo;
@dynamic hasUserId, userId;
@dynamic hasAction, action;
@dynamic hasSubId, subId;
@dynamic hasFarmElement, farmElement;
@dynamic hasCost, cost;
@dynamic hasApproxTime, approxTime;
@dynamic hasVersion, version;
@dynamic hasFarmIndex, farmIndex;
@dynamic hasSoulEggs, soulEggs;
@dynamic hasTicketsSpent, ticketsSpent;
@dynamic hasGoldSpent, goldSpent;

typedef struct ShellsActionLog__storage_ {
  uint32_t _has_storage_[1];
  uint32_t cost;
  int32_t farmIndex;
  ShellDB_FarmElement farmElement;
  NSString *userId;
  NSString *action;
  NSString *subId;
  NSString *version;
  BasicRequestInfo *rinfo;
  double approxTime;
  double soulEggs;
  uint64_t ticketsSpent;
  uint64_t goldSpent;
} ShellsActionLog__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "userId",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellsActionLog_FieldNumber_UserId,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ShellsActionLog__storage_, userId),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "action",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellsActionLog_FieldNumber_Action,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ShellsActionLog__storage_, action),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "subId",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellsActionLog_FieldNumber_SubId,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ShellsActionLog__storage_, subId),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "cost",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellsActionLog_FieldNumber_Cost,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(ShellsActionLog__storage_, cost),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "approxTime",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellsActionLog_FieldNumber_ApproxTime,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(ShellsActionLog__storage_, approxTime),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "version",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellsActionLog_FieldNumber_Version,
        .core.hasIndex = 7,
        .core.offset = (uint32_t)offsetof(ShellsActionLog__storage_, version),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "farmIndex",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellsActionLog_FieldNumber_FarmIndex,
        .core.hasIndex = 8,
        .core.offset = (uint32_t)offsetof(ShellsActionLog__storage_, farmIndex),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "rinfo",
        .core.dataTypeSpecific.clazz = GPBObjCClass(BasicRequestInfo),
        .core.number = ShellsActionLog_FieldNumber_Rinfo,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ShellsActionLog__storage_, rinfo),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = ShellDB_FarmElement_HenHouse,
        .core.name = "farmElement",
        .core.dataTypeSpecific.enumDescFunc = ShellDB_FarmElement_EnumDescriptor,
        .core.number = ShellsActionLog_FieldNumber_FarmElement,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(ShellsActionLog__storage_, farmElement),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "soulEggs",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellsActionLog_FieldNumber_SoulEggs,
        .core.hasIndex = 9,
        .core.offset = (uint32_t)offsetof(ShellsActionLog__storage_, soulEggs),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "ticketsSpent",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellsActionLog_FieldNumber_TicketsSpent,
        .core.hasIndex = 10,
        .core.offset = (uint32_t)offsetof(ShellsActionLog__storage_, ticketsSpent),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "goldSpent",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ShellsActionLog_FieldNumber_GoldSpent,
        .core.hasIndex = 11,
        .core.offset = (uint32_t)offsetof(ShellsActionLog__storage_, goldSpent),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShellsActionLog class]
                                     rootClass:[EiRoot class]
                                          file:EiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ShellsActionLog__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
