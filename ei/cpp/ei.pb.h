// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ei.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ei_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ei_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ei_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ei_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[146]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ei_2eproto;
namespace ei {
class AccountTransferPayload;
struct AccountTransferPayloadDefaultTypeInternal;
extern AccountTransferPayloadDefaultTypeInternal _AccountTransferPayload_default_instance_;
class ActionKeyValuePair;
struct ActionKeyValuePairDefaultTypeInternal;
extern ActionKeyValuePairDefaultTypeInternal _ActionKeyValuePair_default_instance_;
class AdAttributionInfo;
struct AdAttributionInfoDefaultTypeInternal;
extern AdAttributionInfoDefaultTypeInternal _AdAttributionInfo_default_instance_;
class AdAttributionRawData;
struct AdAttributionRawDataDefaultTypeInternal;
extern AdAttributionRawDataDefaultTypeInternal _AdAttributionRawData_default_instance_;
class AdAttributionRow;
struct AdAttributionRowDefaultTypeInternal;
extern AdAttributionRowDefaultTypeInternal _AdAttributionRow_default_instance_;
class AppInfo;
struct AppInfoDefaultTypeInternal;
extern AppInfoDefaultTypeInternal _AppInfo_default_instance_;
class ArtifactInventoryItem;
struct ArtifactInventoryItemDefaultTypeInternal;
extern ArtifactInventoryItemDefaultTypeInternal _ArtifactInventoryItem_default_instance_;
class ArtifactSpec;
struct ArtifactSpecDefaultTypeInternal;
extern ArtifactSpecDefaultTypeInternal _ArtifactSpec_default_instance_;
class ArtifactsClientInfo;
struct ArtifactsClientInfoDefaultTypeInternal;
extern ArtifactsClientInfoDefaultTypeInternal _ArtifactsClientInfo_default_instance_;
class ArtifactsClientInfo_LaunchCount;
struct ArtifactsClientInfo_LaunchCountDefaultTypeInternal;
extern ArtifactsClientInfo_LaunchCountDefaultTypeInternal _ArtifactsClientInfo_LaunchCount_default_instance_;
class ArtifactsConfigurationRequest;
struct ArtifactsConfigurationRequestDefaultTypeInternal;
extern ArtifactsConfigurationRequestDefaultTypeInternal _ArtifactsConfigurationRequest_default_instance_;
class ArtifactsConfigurationResponse;
struct ArtifactsConfigurationResponseDefaultTypeInternal;
extern ArtifactsConfigurationResponseDefaultTypeInternal _ArtifactsConfigurationResponse_default_instance_;
class ArtifactsConfigurationResponse_ArtifactParameters;
struct ArtifactsConfigurationResponse_ArtifactParametersDefaultTypeInternal;
extern ArtifactsConfigurationResponse_ArtifactParametersDefaultTypeInternal _ArtifactsConfigurationResponse_ArtifactParameters_default_instance_;
class ArtifactsConfigurationResponse_MissionParameters;
struct ArtifactsConfigurationResponse_MissionParametersDefaultTypeInternal;
extern ArtifactsConfigurationResponse_MissionParametersDefaultTypeInternal _ArtifactsConfigurationResponse_MissionParameters_default_instance_;
class ArtifactsConfigurationResponse_MissionParameters_Duration;
struct ArtifactsConfigurationResponse_MissionParameters_DurationDefaultTypeInternal;
extern ArtifactsConfigurationResponse_MissionParameters_DurationDefaultTypeInternal _ArtifactsConfigurationResponse_MissionParameters_Duration_default_instance_;
class ArtifactsDB;
struct ArtifactsDBDefaultTypeInternal;
extern ArtifactsDBDefaultTypeInternal _ArtifactsDB_default_instance_;
class ArtifactsDB_ActiveArtifactSet;
struct ArtifactsDB_ActiveArtifactSetDefaultTypeInternal;
extern ArtifactsDB_ActiveArtifactSetDefaultTypeInternal _ArtifactsDB_ActiveArtifactSet_default_instance_;
class ArtifactsDB_ActiveArtifactSlot;
struct ArtifactsDB_ActiveArtifactSlotDefaultTypeInternal;
extern ArtifactsDB_ActiveArtifactSlotDefaultTypeInternal _ArtifactsDB_ActiveArtifactSlot_default_instance_;
class ArtifactsDB_CraftableArtifact;
struct ArtifactsDB_CraftableArtifactDefaultTypeInternal;
extern ArtifactsDB_CraftableArtifactDefaultTypeInternal _ArtifactsDB_CraftableArtifact_default_instance_;
class AuthenticateArtifactResponse;
struct AuthenticateArtifactResponseDefaultTypeInternal;
extern AuthenticateArtifactResponseDefaultTypeInternal _AuthenticateArtifactResponse_default_instance_;
class AuthenticatedMessage;
struct AuthenticatedMessageDefaultTypeInternal;
extern AuthenticatedMessageDefaultTypeInternal _AuthenticatedMessage_default_instance_;
class AutoJoinCoopRequest;
struct AutoJoinCoopRequestDefaultTypeInternal;
extern AutoJoinCoopRequestDefaultTypeInternal _AutoJoinCoopRequest_default_instance_;
class Backup;
struct BackupDefaultTypeInternal;
extern BackupDefaultTypeInternal _Backup_default_instance_;
class Backup_AchievementInfo;
struct Backup_AchievementInfoDefaultTypeInternal;
extern Backup_AchievementInfoDefaultTypeInternal _Backup_AchievementInfo_default_instance_;
class Backup_ActiveBoost;
struct Backup_ActiveBoostDefaultTypeInternal;
extern Backup_ActiveBoostDefaultTypeInternal _Backup_ActiveBoost_default_instance_;
class Backup_Artifacts;
struct Backup_ArtifactsDefaultTypeInternal;
extern Backup_ArtifactsDefaultTypeInternal _Backup_Artifacts_default_instance_;
class Backup_Game;
struct Backup_GameDefaultTypeInternal;
extern Backup_GameDefaultTypeInternal _Backup_Game_default_instance_;
class Backup_Misc;
struct Backup_MiscDefaultTypeInternal;
extern Backup_MiscDefaultTypeInternal _Backup_Misc_default_instance_;
class Backup_Mission;
struct Backup_MissionDefaultTypeInternal;
extern Backup_MissionDefaultTypeInternal _Backup_Mission_default_instance_;
class Backup_MissionInfo;
struct Backup_MissionInfoDefaultTypeInternal;
extern Backup_MissionInfoDefaultTypeInternal _Backup_MissionInfo_default_instance_;
class Backup_NewsHeadline;
struct Backup_NewsHeadlineDefaultTypeInternal;
extern Backup_NewsHeadlineDefaultTypeInternal _Backup_NewsHeadline_default_instance_;
class Backup_OwnedBoost;
struct Backup_OwnedBoostDefaultTypeInternal;
extern Backup_OwnedBoostDefaultTypeInternal _Backup_OwnedBoost_default_instance_;
class Backup_ResearchItem;
struct Backup_ResearchItemDefaultTypeInternal;
extern Backup_ResearchItemDefaultTypeInternal _Backup_ResearchItem_default_instance_;
class Backup_Settings;
struct Backup_SettingsDefaultTypeInternal;
extern Backup_SettingsDefaultTypeInternal _Backup_Settings_default_instance_;
class Backup_Shells;
struct Backup_ShellsDefaultTypeInternal;
extern Backup_ShellsDefaultTypeInternal _Backup_Shells_default_instance_;
class Backup_Simulation;
struct Backup_SimulationDefaultTypeInternal;
extern Backup_SimulationDefaultTypeInternal _Backup_Simulation_default_instance_;
class Backup_Stats;
struct Backup_StatsDefaultTypeInternal;
extern Backup_StatsDefaultTypeInternal _Backup_Stats_default_instance_;
class Backup_Tutorial;
struct Backup_TutorialDefaultTypeInternal;
extern Backup_TutorialDefaultTypeInternal _Backup_Tutorial_default_instance_;
class BasicRequestInfo;
struct BasicRequestInfoDefaultTypeInternal;
extern BasicRequestInfoDefaultTypeInternal _BasicRequestInfo_default_instance_;
class CleanAccountRequest;
struct CleanAccountRequestDefaultTypeInternal;
extern CleanAccountRequestDefaultTypeInternal _CleanAccountRequest_default_instance_;
class ClearAllUserDataRequest;
struct ClearAllUserDataRequestDefaultTypeInternal;
extern ClearAllUserDataRequestDefaultTypeInternal _ClearAllUserDataRequest_default_instance_;
class CollectContractArtifactRewardsRequest;
struct CollectContractArtifactRewardsRequestDefaultTypeInternal;
extern CollectContractArtifactRewardsRequestDefaultTypeInternal _CollectContractArtifactRewardsRequest_default_instance_;
class CompleteArtifact;
struct CompleteArtifactDefaultTypeInternal;
extern CompleteArtifactDefaultTypeInternal _CompleteArtifact_default_instance_;
class CompleteMissionResponse;
struct CompleteMissionResponseDefaultTypeInternal;
extern CompleteMissionResponseDefaultTypeInternal _CompleteMissionResponse_default_instance_;
class CompleteMissionResponse_SecureArtifactSpec;
struct CompleteMissionResponse_SecureArtifactSpecDefaultTypeInternal;
extern CompleteMissionResponse_SecureArtifactSpecDefaultTypeInternal _CompleteMissionResponse_SecureArtifactSpec_default_instance_;
class ConfigRequest;
struct ConfigRequestDefaultTypeInternal;
extern ConfigRequestDefaultTypeInternal _ConfigRequest_default_instance_;
class ConfigResponse;
struct ConfigResponseDefaultTypeInternal;
extern ConfigResponseDefaultTypeInternal _ConfigResponse_default_instance_;
class ConsumeArtifactRequest;
struct ConsumeArtifactRequestDefaultTypeInternal;
extern ConsumeArtifactRequestDefaultTypeInternal _ConsumeArtifactRequest_default_instance_;
class ConsumeArtifactResponse;
struct ConsumeArtifactResponseDefaultTypeInternal;
extern ConsumeArtifactResponseDefaultTypeInternal _ConsumeArtifactResponse_default_instance_;
class Contract;
struct ContractDefaultTypeInternal;
extern ContractDefaultTypeInternal _Contract_default_instance_;
class ContractCoopStatusRequest;
struct ContractCoopStatusRequestDefaultTypeInternal;
extern ContractCoopStatusRequestDefaultTypeInternal _ContractCoopStatusRequest_default_instance_;
class ContractCoopStatusResponse;
struct ContractCoopStatusResponseDefaultTypeInternal;
extern ContractCoopStatusResponseDefaultTypeInternal _ContractCoopStatusResponse_default_instance_;
class ContractCoopStatusResponse_ChickenRun;
struct ContractCoopStatusResponse_ChickenRunDefaultTypeInternal;
extern ContractCoopStatusResponse_ChickenRunDefaultTypeInternal _ContractCoopStatusResponse_ChickenRun_default_instance_;
class ContractCoopStatusResponse_ContributionInfo;
struct ContractCoopStatusResponse_ContributionInfoDefaultTypeInternal;
extern ContractCoopStatusResponse_ContributionInfoDefaultTypeInternal _ContractCoopStatusResponse_ContributionInfo_default_instance_;
class ContractCoopStatusResponse_CoopGift;
struct ContractCoopStatusResponse_CoopGiftDefaultTypeInternal;
extern ContractCoopStatusResponse_CoopGiftDefaultTypeInternal _ContractCoopStatusResponse_CoopGift_default_instance_;
class ContractCoopStatusUpdateRequest;
struct ContractCoopStatusUpdateRequestDefaultTypeInternal;
extern ContractCoopStatusUpdateRequestDefaultTypeInternal _ContractCoopStatusUpdateRequest_default_instance_;
class ContractCoopStatusUpdateResponse;
struct ContractCoopStatusUpdateResponseDefaultTypeInternal;
extern ContractCoopStatusUpdateResponseDefaultTypeInternal _ContractCoopStatusUpdateResponse_default_instance_;
class Contract_Goal;
struct Contract_GoalDefaultTypeInternal;
extern Contract_GoalDefaultTypeInternal _Contract_Goal_default_instance_;
class Contract_GoalSet;
struct Contract_GoalSetDefaultTypeInternal;
extern Contract_GoalSetDefaultTypeInternal _Contract_GoalSet_default_instance_;
class ContractsRequest;
struct ContractsRequestDefaultTypeInternal;
extern ContractsRequestDefaultTypeInternal _ContractsRequest_default_instance_;
class ContractsResponse;
struct ContractsResponseDefaultTypeInternal;
extern ContractsResponseDefaultTypeInternal _ContractsResponse_default_instance_;
class CoopBuffHistory;
struct CoopBuffHistoryDefaultTypeInternal;
extern CoopBuffHistoryDefaultTypeInternal _CoopBuffHistory_default_instance_;
class CoopBuffState;
struct CoopBuffStateDefaultTypeInternal;
extern CoopBuffStateDefaultTypeInternal _CoopBuffState_default_instance_;
class CoopChickenRunEntry;
struct CoopChickenRunEntryDefaultTypeInternal;
extern CoopChickenRunEntryDefaultTypeInternal _CoopChickenRunEntry_default_instance_;
class CoopLastChickenRunTimes;
struct CoopLastChickenRunTimesDefaultTypeInternal;
extern CoopLastChickenRunTimesDefaultTypeInternal _CoopLastChickenRunTimes_default_instance_;
class CraftArtifactRequest;
struct CraftArtifactRequestDefaultTypeInternal;
extern CraftArtifactRequestDefaultTypeInternal _CraftArtifactRequest_default_instance_;
class CraftArtifactResponse;
struct CraftArtifactResponseDefaultTypeInternal;
extern CraftArtifactResponseDefaultTypeInternal _CraftArtifactResponse_default_instance_;
class CreateCoopRequest;
struct CreateCoopRequestDefaultTypeInternal;
extern CreateCoopRequestDefaultTypeInternal _CreateCoopRequest_default_instance_;
class CreateCoopResponse;
struct CreateCoopResponseDefaultTypeInternal;
extern CreateCoopResponseDefaultTypeInternal _CreateCoopResponse_default_instance_;
class CurrencyFlowBatchRequest;
struct CurrencyFlowBatchRequestDefaultTypeInternal;
extern CurrencyFlowBatchRequestDefaultTypeInternal _CurrencyFlowBatchRequest_default_instance_;
class CurrencyFlowLog;
struct CurrencyFlowLogDefaultTypeInternal;
extern CurrencyFlowLogDefaultTypeInternal _CurrencyFlowLog_default_instance_;
class DLCCatalog;
struct DLCCatalogDefaultTypeInternal;
extern DLCCatalogDefaultTypeInternal _DLCCatalog_default_instance_;
class DLCItem;
struct DLCItemDefaultTypeInternal;
extern DLCItemDefaultTypeInternal _DLCItem_default_instance_;
class DailyGiftInfo;
struct DailyGiftInfoDefaultTypeInternal;
extern DailyGiftInfoDefaultTypeInternal _DailyGiftInfo_default_instance_;
class DeviceInfo;
struct DeviceInfoDefaultTypeInternal;
extern DeviceInfoDefaultTypeInternal _DeviceInfo_default_instance_;
class EggIncAdConfig;
struct EggIncAdConfigDefaultTypeInternal;
extern EggIncAdConfigDefaultTypeInternal _EggIncAdConfig_default_instance_;
class EggIncCurrentEvents;
struct EggIncCurrentEventsDefaultTypeInternal;
extern EggIncCurrentEventsDefaultTypeInternal _EggIncCurrentEvents_default_instance_;
class EggIncEvent;
struct EggIncEventDefaultTypeInternal;
extern EggIncEventDefaultTypeInternal _EggIncEvent_default_instance_;
class EggIncFirstContactRequest;
struct EggIncFirstContactRequestDefaultTypeInternal;
extern EggIncFirstContactRequestDefaultTypeInternal _EggIncFirstContactRequest_default_instance_;
class EggIncFirstContactResponse;
struct EggIncFirstContactResponseDefaultTypeInternal;
extern EggIncFirstContactResponseDefaultTypeInternal _EggIncFirstContactResponse_default_instance_;
class FarmProductionParams;
struct FarmProductionParamsDefaultTypeInternal;
extern FarmProductionParamsDefaultTypeInternal _FarmProductionParams_default_instance_;
class GenericAction;
struct GenericActionDefaultTypeInternal;
extern GenericActionDefaultTypeInternal _GenericAction_default_instance_;
class GenericActionBatchRequest;
struct GenericActionBatchRequestDefaultTypeInternal;
extern GenericActionBatchRequestDefaultTypeInternal _GenericActionBatchRequest_default_instance_;
class GetPeriodicalsRequest;
struct GetPeriodicalsRequestDefaultTypeInternal;
extern GetPeriodicalsRequestDefaultTypeInternal _GetPeriodicalsRequest_default_instance_;
class GiftPlayerCoopRequest;
struct GiftPlayerCoopRequestDefaultTypeInternal;
extern GiftPlayerCoopRequestDefaultTypeInternal _GiftPlayerCoopRequest_default_instance_;
class IAPSaleEntry;
struct IAPSaleEntryDefaultTypeInternal;
extern IAPSaleEntryDefaultTypeInternal _IAPSaleEntry_default_instance_;
class InGameMail;
struct InGameMailDefaultTypeInternal;
extern InGameMailDefaultTypeInternal _InGameMail_default_instance_;
class InventorySlot;
struct InventorySlotDefaultTypeInternal;
extern InventorySlotDefaultTypeInternal _InventorySlot_default_instance_;
class JoinCoopRequest;
struct JoinCoopRequestDefaultTypeInternal;
extern JoinCoopRequestDefaultTypeInternal _JoinCoopRequest_default_instance_;
class JoinCoopResponse;
struct JoinCoopResponseDefaultTypeInternal;
extern JoinCoopResponseDefaultTypeInternal _JoinCoopResponse_default_instance_;
class KickPlayerCoopRequest;
struct KickPlayerCoopRequestDefaultTypeInternal;
extern KickPlayerCoopRequestDefaultTypeInternal _KickPlayerCoopRequest_default_instance_;
class LeaveCoopRequest;
struct LeaveCoopRequestDefaultTypeInternal;
extern LeaveCoopRequestDefaultTypeInternal _LeaveCoopRequest_default_instance_;
class LiveConfig;
struct LiveConfigDefaultTypeInternal;
extern LiveConfigDefaultTypeInternal _LiveConfig_default_instance_;
class LiveConfig_BoostsConfig;
struct LiveConfig_BoostsConfigDefaultTypeInternal;
extern LiveConfig_BoostsConfigDefaultTypeInternal _LiveConfig_BoostsConfig_default_instance_;
class LiveConfig_BoostsConfig_ItemConfig;
struct LiveConfig_BoostsConfig_ItemConfigDefaultTypeInternal;
extern LiveConfig_BoostsConfig_ItemConfigDefaultTypeInternal _LiveConfig_BoostsConfig_ItemConfig_default_instance_;
class LiveConfig_GiftConfig;
struct LiveConfig_GiftConfigDefaultTypeInternal;
extern LiveConfig_GiftConfigDefaultTypeInternal _LiveConfig_GiftConfig_default_instance_;
class LiveConfig_GiftConfig_GiftMuConfig;
struct LiveConfig_GiftConfig_GiftMuConfigDefaultTypeInternal;
extern LiveConfig_GiftConfig_GiftMuConfigDefaultTypeInternal _LiveConfig_GiftConfig_GiftMuConfig_default_instance_;
class LiveConfig_GiftConfig_GiftValueConfig;
struct LiveConfig_GiftConfig_GiftValueConfigDefaultTypeInternal;
extern LiveConfig_GiftConfig_GiftValueConfigDefaultTypeInternal _LiveConfig_GiftConfig_GiftValueConfig_default_instance_;
class LiveConfig_MiscConfig;
struct LiveConfig_MiscConfigDefaultTypeInternal;
extern LiveConfig_MiscConfigDefaultTypeInternal _LiveConfig_MiscConfig_default_instance_;
class LocalContract;
struct LocalContractDefaultTypeInternal;
extern LocalContractDefaultTypeInternal _LocalContract_default_instance_;
class LogCompleteMissionPayload;
struct LogCompleteMissionPayloadDefaultTypeInternal;
extern LogCompleteMissionPayloadDefaultTypeInternal _LogCompleteMissionPayload_default_instance_;
class LogConsumeArtifactPayload;
struct LogConsumeArtifactPayloadDefaultTypeInternal;
extern LogConsumeArtifactPayloadDefaultTypeInternal _LogConsumeArtifactPayload_default_instance_;
class LogCraftArtifactPayload;
struct LogCraftArtifactPayloadDefaultTypeInternal;
extern LogCraftArtifactPayloadDefaultTypeInternal _LogCraftArtifactPayload_default_instance_;
class LogSetArtifactPayload;
struct LogSetArtifactPayloadDefaultTypeInternal;
extern LogSetArtifactPayloadDefaultTypeInternal _LogSetArtifactPayload_default_instance_;
class MailDB;
struct MailDBDefaultTypeInternal;
extern MailDBDefaultTypeInternal _MailDB_default_instance_;
class MissionInfo;
struct MissionInfoDefaultTypeInternal;
extern MissionInfoDefaultTypeInternal _MissionInfo_default_instance_;
class MissionInfo_Fuel;
struct MissionInfo_FuelDefaultTypeInternal;
extern MissionInfo_FuelDefaultTypeInternal _MissionInfo_Fuel_default_instance_;
class MissionRequest;
struct MissionRequestDefaultTypeInternal;
extern MissionRequestDefaultTypeInternal _MissionRequest_default_instance_;
class MissionResponse;
struct MissionResponseDefaultTypeInternal;
extern MissionResponseDefaultTypeInternal _MissionResponse_default_instance_;
class MyContracts;
struct MyContractsDefaultTypeInternal;
extern MyContractsDefaultTypeInternal _MyContracts_default_instance_;
class PeriodicalsResponse;
struct PeriodicalsResponseDefaultTypeInternal;
extern PeriodicalsResponseDefaultTypeInternal _PeriodicalsResponse_default_instance_;
class PlayerFarmInfo;
struct PlayerFarmInfoDefaultTypeInternal;
extern PlayerFarmInfoDefaultTypeInternal _PlayerFarmInfo_default_instance_;
class QueryCoopRequest;
struct QueryCoopRequestDefaultTypeInternal;
extern QueryCoopRequestDefaultTypeInternal _QueryCoopRequest_default_instance_;
class QueryCoopResponse;
struct QueryCoopResponseDefaultTypeInternal;
extern QueryCoopResponseDefaultTypeInternal _QueryCoopResponse_default_instance_;
class ReturnEDTPayload;
struct ReturnEDTPayloadDefaultTypeInternal;
extern ReturnEDTPayloadDefaultTypeInternal _ReturnEDTPayload_default_instance_;
class Reward;
struct RewardDefaultTypeInternal;
extern RewardDefaultTypeInternal _Reward_default_instance_;
class SalesInfo;
struct SalesInfoDefaultTypeInternal;
extern SalesInfoDefaultTypeInternal _SalesInfo_default_instance_;
class SalesInfoRequest;
struct SalesInfoRequestDefaultTypeInternal;
extern SalesInfoRequestDefaultTypeInternal _SalesInfoRequest_default_instance_;
class SaveBackupResponse;
struct SaveBackupResponseDefaultTypeInternal;
extern SaveBackupResponseDefaultTypeInternal _SaveBackupResponse_default_instance_;
class SendChickenRunCoopRequest;
struct SendChickenRunCoopRequestDefaultTypeInternal;
extern SendChickenRunCoopRequestDefaultTypeInternal _SendChickenRunCoopRequest_default_instance_;
class ServerGift;
struct ServerGiftDefaultTypeInternal;
extern ServerGiftDefaultTypeInternal _ServerGift_default_instance_;
class SetArtifactRequest;
struct SetArtifactRequestDefaultTypeInternal;
extern SetArtifactRequestDefaultTypeInternal _SetArtifactRequest_default_instance_;
class SetArtifactResponse;
struct SetArtifactResponseDefaultTypeInternal;
extern SetArtifactResponseDefaultTypeInternal _SetArtifactResponse_default_instance_;
class ShellDB;
struct ShellDBDefaultTypeInternal;
extern ShellDBDefaultTypeInternal _ShellDB_default_instance_;
class ShellDB_ChickenConfig;
struct ShellDB_ChickenConfigDefaultTypeInternal;
extern ShellDB_ChickenConfigDefaultTypeInternal _ShellDB_ChickenConfig_default_instance_;
class ShellDB_FarmConfiguration;
struct ShellDB_FarmConfigurationDefaultTypeInternal;
extern ShellDB_FarmConfigurationDefaultTypeInternal _ShellDB_FarmConfiguration_default_instance_;
class ShellDB_ShellConfiguration;
struct ShellDB_ShellConfigurationDefaultTypeInternal;
extern ShellDB_ShellConfigurationDefaultTypeInternal _ShellDB_ShellConfiguration_default_instance_;
class ShellDB_ShellElementStatus;
struct ShellDB_ShellElementStatusDefaultTypeInternal;
extern ShellDB_ShellElementStatusDefaultTypeInternal _ShellDB_ShellElementStatus_default_instance_;
class ShellDB_ShellGroupConfiguration;
struct ShellDB_ShellGroupConfigurationDefaultTypeInternal;
extern ShellDB_ShellGroupConfigurationDefaultTypeInternal _ShellDB_ShellGroupConfiguration_default_instance_;
class ShellDB_ShellSetConfiguration;
struct ShellDB_ShellSetConfigurationDefaultTypeInternal;
extern ShellDB_ShellSetConfigurationDefaultTypeInternal _ShellDB_ShellSetConfiguration_default_instance_;
class ShellDB_ShellSetVariationStatus;
struct ShellDB_ShellSetVariationStatusDefaultTypeInternal;
extern ShellDB_ShellSetVariationStatusDefaultTypeInternal _ShellDB_ShellSetVariationStatus_default_instance_;
class ShellDB_ShellStatus;
struct ShellDB_ShellStatusDefaultTypeInternal;
extern ShellDB_ShellStatusDefaultTypeInternal _ShellDB_ShellStatus_default_instance_;
class ShellGroupSpec;
struct ShellGroupSpecDefaultTypeInternal;
extern ShellGroupSpecDefaultTypeInternal _ShellGroupSpec_default_instance_;
class ShellObjectSpec;
struct ShellObjectSpecDefaultTypeInternal;
extern ShellObjectSpecDefaultTypeInternal _ShellObjectSpec_default_instance_;
class ShellObjectSpec_LODPiece;
struct ShellObjectSpec_LODPieceDefaultTypeInternal;
extern ShellObjectSpec_LODPieceDefaultTypeInternal _ShellObjectSpec_LODPiece_default_instance_;
class ShellSetSpec;
struct ShellSetSpecDefaultTypeInternal;
extern ShellSetSpecDefaultTypeInternal _ShellSetSpec_default_instance_;
class ShellSetSpec_VariationInfo;
struct ShellSetSpec_VariationInfoDefaultTypeInternal;
extern ShellSetSpec_VariationInfoDefaultTypeInternal _ShellSetSpec_VariationInfo_default_instance_;
class ShellSpec;
struct ShellSpecDefaultTypeInternal;
extern ShellSpecDefaultTypeInternal _ShellSpec_default_instance_;
class ShellSpec_ShellPiece;
struct ShellSpec_ShellPieceDefaultTypeInternal;
extern ShellSpec_ShellPieceDefaultTypeInternal _ShellSpec_ShellPiece_default_instance_;
class ShellsActionLog;
struct ShellsActionLogDefaultTypeInternal;
extern ShellsActionLogDefaultTypeInternal _ShellsActionLog_default_instance_;
class UpdateCoopPermissionsRequest;
struct UpdateCoopPermissionsRequestDefaultTypeInternal;
extern UpdateCoopPermissionsRequestDefaultTypeInternal _UpdateCoopPermissionsRequest_default_instance_;
class UpdateCoopPermissionsResponse;
struct UpdateCoopPermissionsResponseDefaultTypeInternal;
extern UpdateCoopPermissionsResponseDefaultTypeInternal _UpdateCoopPermissionsResponse_default_instance_;
class UserDataInfoRequest;
struct UserDataInfoRequestDefaultTypeInternal;
extern UserDataInfoRequestDefaultTypeInternal _UserDataInfoRequest_default_instance_;
class UserDataInfoResponse;
struct UserDataInfoResponseDefaultTypeInternal;
extern UserDataInfoResponseDefaultTypeInternal _UserDataInfoResponse_default_instance_;
class VerifyPurchaseRequest;
struct VerifyPurchaseRequestDefaultTypeInternal;
extern VerifyPurchaseRequestDefaultTypeInternal _VerifyPurchaseRequest_default_instance_;
class VerifyPurchaseResponse;
struct VerifyPurchaseResponseDefaultTypeInternal;
extern VerifyPurchaseResponseDefaultTypeInternal _VerifyPurchaseResponse_default_instance_;
}  // namespace ei
PROTOBUF_NAMESPACE_OPEN
template<> ::ei::AccountTransferPayload* Arena::CreateMaybeMessage<::ei::AccountTransferPayload>(Arena*);
template<> ::ei::ActionKeyValuePair* Arena::CreateMaybeMessage<::ei::ActionKeyValuePair>(Arena*);
template<> ::ei::AdAttributionInfo* Arena::CreateMaybeMessage<::ei::AdAttributionInfo>(Arena*);
template<> ::ei::AdAttributionRawData* Arena::CreateMaybeMessage<::ei::AdAttributionRawData>(Arena*);
template<> ::ei::AdAttributionRow* Arena::CreateMaybeMessage<::ei::AdAttributionRow>(Arena*);
template<> ::ei::AppInfo* Arena::CreateMaybeMessage<::ei::AppInfo>(Arena*);
template<> ::ei::ArtifactInventoryItem* Arena::CreateMaybeMessage<::ei::ArtifactInventoryItem>(Arena*);
template<> ::ei::ArtifactSpec* Arena::CreateMaybeMessage<::ei::ArtifactSpec>(Arena*);
template<> ::ei::ArtifactsClientInfo* Arena::CreateMaybeMessage<::ei::ArtifactsClientInfo>(Arena*);
template<> ::ei::ArtifactsClientInfo_LaunchCount* Arena::CreateMaybeMessage<::ei::ArtifactsClientInfo_LaunchCount>(Arena*);
template<> ::ei::ArtifactsConfigurationRequest* Arena::CreateMaybeMessage<::ei::ArtifactsConfigurationRequest>(Arena*);
template<> ::ei::ArtifactsConfigurationResponse* Arena::CreateMaybeMessage<::ei::ArtifactsConfigurationResponse>(Arena*);
template<> ::ei::ArtifactsConfigurationResponse_ArtifactParameters* Arena::CreateMaybeMessage<::ei::ArtifactsConfigurationResponse_ArtifactParameters>(Arena*);
template<> ::ei::ArtifactsConfigurationResponse_MissionParameters* Arena::CreateMaybeMessage<::ei::ArtifactsConfigurationResponse_MissionParameters>(Arena*);
template<> ::ei::ArtifactsConfigurationResponse_MissionParameters_Duration* Arena::CreateMaybeMessage<::ei::ArtifactsConfigurationResponse_MissionParameters_Duration>(Arena*);
template<> ::ei::ArtifactsDB* Arena::CreateMaybeMessage<::ei::ArtifactsDB>(Arena*);
template<> ::ei::ArtifactsDB_ActiveArtifactSet* Arena::CreateMaybeMessage<::ei::ArtifactsDB_ActiveArtifactSet>(Arena*);
template<> ::ei::ArtifactsDB_ActiveArtifactSlot* Arena::CreateMaybeMessage<::ei::ArtifactsDB_ActiveArtifactSlot>(Arena*);
template<> ::ei::ArtifactsDB_CraftableArtifact* Arena::CreateMaybeMessage<::ei::ArtifactsDB_CraftableArtifact>(Arena*);
template<> ::ei::AuthenticateArtifactResponse* Arena::CreateMaybeMessage<::ei::AuthenticateArtifactResponse>(Arena*);
template<> ::ei::AuthenticatedMessage* Arena::CreateMaybeMessage<::ei::AuthenticatedMessage>(Arena*);
template<> ::ei::AutoJoinCoopRequest* Arena::CreateMaybeMessage<::ei::AutoJoinCoopRequest>(Arena*);
template<> ::ei::Backup* Arena::CreateMaybeMessage<::ei::Backup>(Arena*);
template<> ::ei::Backup_AchievementInfo* Arena::CreateMaybeMessage<::ei::Backup_AchievementInfo>(Arena*);
template<> ::ei::Backup_ActiveBoost* Arena::CreateMaybeMessage<::ei::Backup_ActiveBoost>(Arena*);
template<> ::ei::Backup_Artifacts* Arena::CreateMaybeMessage<::ei::Backup_Artifacts>(Arena*);
template<> ::ei::Backup_Game* Arena::CreateMaybeMessage<::ei::Backup_Game>(Arena*);
template<> ::ei::Backup_Misc* Arena::CreateMaybeMessage<::ei::Backup_Misc>(Arena*);
template<> ::ei::Backup_Mission* Arena::CreateMaybeMessage<::ei::Backup_Mission>(Arena*);
template<> ::ei::Backup_MissionInfo* Arena::CreateMaybeMessage<::ei::Backup_MissionInfo>(Arena*);
template<> ::ei::Backup_NewsHeadline* Arena::CreateMaybeMessage<::ei::Backup_NewsHeadline>(Arena*);
template<> ::ei::Backup_OwnedBoost* Arena::CreateMaybeMessage<::ei::Backup_OwnedBoost>(Arena*);
template<> ::ei::Backup_ResearchItem* Arena::CreateMaybeMessage<::ei::Backup_ResearchItem>(Arena*);
template<> ::ei::Backup_Settings* Arena::CreateMaybeMessage<::ei::Backup_Settings>(Arena*);
template<> ::ei::Backup_Shells* Arena::CreateMaybeMessage<::ei::Backup_Shells>(Arena*);
template<> ::ei::Backup_Simulation* Arena::CreateMaybeMessage<::ei::Backup_Simulation>(Arena*);
template<> ::ei::Backup_Stats* Arena::CreateMaybeMessage<::ei::Backup_Stats>(Arena*);
template<> ::ei::Backup_Tutorial* Arena::CreateMaybeMessage<::ei::Backup_Tutorial>(Arena*);
template<> ::ei::BasicRequestInfo* Arena::CreateMaybeMessage<::ei::BasicRequestInfo>(Arena*);
template<> ::ei::CleanAccountRequest* Arena::CreateMaybeMessage<::ei::CleanAccountRequest>(Arena*);
template<> ::ei::ClearAllUserDataRequest* Arena::CreateMaybeMessage<::ei::ClearAllUserDataRequest>(Arena*);
template<> ::ei::CollectContractArtifactRewardsRequest* Arena::CreateMaybeMessage<::ei::CollectContractArtifactRewardsRequest>(Arena*);
template<> ::ei::CompleteArtifact* Arena::CreateMaybeMessage<::ei::CompleteArtifact>(Arena*);
template<> ::ei::CompleteMissionResponse* Arena::CreateMaybeMessage<::ei::CompleteMissionResponse>(Arena*);
template<> ::ei::CompleteMissionResponse_SecureArtifactSpec* Arena::CreateMaybeMessage<::ei::CompleteMissionResponse_SecureArtifactSpec>(Arena*);
template<> ::ei::ConfigRequest* Arena::CreateMaybeMessage<::ei::ConfigRequest>(Arena*);
template<> ::ei::ConfigResponse* Arena::CreateMaybeMessage<::ei::ConfigResponse>(Arena*);
template<> ::ei::ConsumeArtifactRequest* Arena::CreateMaybeMessage<::ei::ConsumeArtifactRequest>(Arena*);
template<> ::ei::ConsumeArtifactResponse* Arena::CreateMaybeMessage<::ei::ConsumeArtifactResponse>(Arena*);
template<> ::ei::Contract* Arena::CreateMaybeMessage<::ei::Contract>(Arena*);
template<> ::ei::ContractCoopStatusRequest* Arena::CreateMaybeMessage<::ei::ContractCoopStatusRequest>(Arena*);
template<> ::ei::ContractCoopStatusResponse* Arena::CreateMaybeMessage<::ei::ContractCoopStatusResponse>(Arena*);
template<> ::ei::ContractCoopStatusResponse_ChickenRun* Arena::CreateMaybeMessage<::ei::ContractCoopStatusResponse_ChickenRun>(Arena*);
template<> ::ei::ContractCoopStatusResponse_ContributionInfo* Arena::CreateMaybeMessage<::ei::ContractCoopStatusResponse_ContributionInfo>(Arena*);
template<> ::ei::ContractCoopStatusResponse_CoopGift* Arena::CreateMaybeMessage<::ei::ContractCoopStatusResponse_CoopGift>(Arena*);
template<> ::ei::ContractCoopStatusUpdateRequest* Arena::CreateMaybeMessage<::ei::ContractCoopStatusUpdateRequest>(Arena*);
template<> ::ei::ContractCoopStatusUpdateResponse* Arena::CreateMaybeMessage<::ei::ContractCoopStatusUpdateResponse>(Arena*);
template<> ::ei::Contract_Goal* Arena::CreateMaybeMessage<::ei::Contract_Goal>(Arena*);
template<> ::ei::Contract_GoalSet* Arena::CreateMaybeMessage<::ei::Contract_GoalSet>(Arena*);
template<> ::ei::ContractsRequest* Arena::CreateMaybeMessage<::ei::ContractsRequest>(Arena*);
template<> ::ei::ContractsResponse* Arena::CreateMaybeMessage<::ei::ContractsResponse>(Arena*);
template<> ::ei::CoopBuffHistory* Arena::CreateMaybeMessage<::ei::CoopBuffHistory>(Arena*);
template<> ::ei::CoopBuffState* Arena::CreateMaybeMessage<::ei::CoopBuffState>(Arena*);
template<> ::ei::CoopChickenRunEntry* Arena::CreateMaybeMessage<::ei::CoopChickenRunEntry>(Arena*);
template<> ::ei::CoopLastChickenRunTimes* Arena::CreateMaybeMessage<::ei::CoopLastChickenRunTimes>(Arena*);
template<> ::ei::CraftArtifactRequest* Arena::CreateMaybeMessage<::ei::CraftArtifactRequest>(Arena*);
template<> ::ei::CraftArtifactResponse* Arena::CreateMaybeMessage<::ei::CraftArtifactResponse>(Arena*);
template<> ::ei::CreateCoopRequest* Arena::CreateMaybeMessage<::ei::CreateCoopRequest>(Arena*);
template<> ::ei::CreateCoopResponse* Arena::CreateMaybeMessage<::ei::CreateCoopResponse>(Arena*);
template<> ::ei::CurrencyFlowBatchRequest* Arena::CreateMaybeMessage<::ei::CurrencyFlowBatchRequest>(Arena*);
template<> ::ei::CurrencyFlowLog* Arena::CreateMaybeMessage<::ei::CurrencyFlowLog>(Arena*);
template<> ::ei::DLCCatalog* Arena::CreateMaybeMessage<::ei::DLCCatalog>(Arena*);
template<> ::ei::DLCItem* Arena::CreateMaybeMessage<::ei::DLCItem>(Arena*);
template<> ::ei::DailyGiftInfo* Arena::CreateMaybeMessage<::ei::DailyGiftInfo>(Arena*);
template<> ::ei::DeviceInfo* Arena::CreateMaybeMessage<::ei::DeviceInfo>(Arena*);
template<> ::ei::EggIncAdConfig* Arena::CreateMaybeMessage<::ei::EggIncAdConfig>(Arena*);
template<> ::ei::EggIncCurrentEvents* Arena::CreateMaybeMessage<::ei::EggIncCurrentEvents>(Arena*);
template<> ::ei::EggIncEvent* Arena::CreateMaybeMessage<::ei::EggIncEvent>(Arena*);
template<> ::ei::EggIncFirstContactRequest* Arena::CreateMaybeMessage<::ei::EggIncFirstContactRequest>(Arena*);
template<> ::ei::EggIncFirstContactResponse* Arena::CreateMaybeMessage<::ei::EggIncFirstContactResponse>(Arena*);
template<> ::ei::FarmProductionParams* Arena::CreateMaybeMessage<::ei::FarmProductionParams>(Arena*);
template<> ::ei::GenericAction* Arena::CreateMaybeMessage<::ei::GenericAction>(Arena*);
template<> ::ei::GenericActionBatchRequest* Arena::CreateMaybeMessage<::ei::GenericActionBatchRequest>(Arena*);
template<> ::ei::GetPeriodicalsRequest* Arena::CreateMaybeMessage<::ei::GetPeriodicalsRequest>(Arena*);
template<> ::ei::GiftPlayerCoopRequest* Arena::CreateMaybeMessage<::ei::GiftPlayerCoopRequest>(Arena*);
template<> ::ei::IAPSaleEntry* Arena::CreateMaybeMessage<::ei::IAPSaleEntry>(Arena*);
template<> ::ei::InGameMail* Arena::CreateMaybeMessage<::ei::InGameMail>(Arena*);
template<> ::ei::InventorySlot* Arena::CreateMaybeMessage<::ei::InventorySlot>(Arena*);
template<> ::ei::JoinCoopRequest* Arena::CreateMaybeMessage<::ei::JoinCoopRequest>(Arena*);
template<> ::ei::JoinCoopResponse* Arena::CreateMaybeMessage<::ei::JoinCoopResponse>(Arena*);
template<> ::ei::KickPlayerCoopRequest* Arena::CreateMaybeMessage<::ei::KickPlayerCoopRequest>(Arena*);
template<> ::ei::LeaveCoopRequest* Arena::CreateMaybeMessage<::ei::LeaveCoopRequest>(Arena*);
template<> ::ei::LiveConfig* Arena::CreateMaybeMessage<::ei::LiveConfig>(Arena*);
template<> ::ei::LiveConfig_BoostsConfig* Arena::CreateMaybeMessage<::ei::LiveConfig_BoostsConfig>(Arena*);
template<> ::ei::LiveConfig_BoostsConfig_ItemConfig* Arena::CreateMaybeMessage<::ei::LiveConfig_BoostsConfig_ItemConfig>(Arena*);
template<> ::ei::LiveConfig_GiftConfig* Arena::CreateMaybeMessage<::ei::LiveConfig_GiftConfig>(Arena*);
template<> ::ei::LiveConfig_GiftConfig_GiftMuConfig* Arena::CreateMaybeMessage<::ei::LiveConfig_GiftConfig_GiftMuConfig>(Arena*);
template<> ::ei::LiveConfig_GiftConfig_GiftValueConfig* Arena::CreateMaybeMessage<::ei::LiveConfig_GiftConfig_GiftValueConfig>(Arena*);
template<> ::ei::LiveConfig_MiscConfig* Arena::CreateMaybeMessage<::ei::LiveConfig_MiscConfig>(Arena*);
template<> ::ei::LocalContract* Arena::CreateMaybeMessage<::ei::LocalContract>(Arena*);
template<> ::ei::LogCompleteMissionPayload* Arena::CreateMaybeMessage<::ei::LogCompleteMissionPayload>(Arena*);
template<> ::ei::LogConsumeArtifactPayload* Arena::CreateMaybeMessage<::ei::LogConsumeArtifactPayload>(Arena*);
template<> ::ei::LogCraftArtifactPayload* Arena::CreateMaybeMessage<::ei::LogCraftArtifactPayload>(Arena*);
template<> ::ei::LogSetArtifactPayload* Arena::CreateMaybeMessage<::ei::LogSetArtifactPayload>(Arena*);
template<> ::ei::MailDB* Arena::CreateMaybeMessage<::ei::MailDB>(Arena*);
template<> ::ei::MissionInfo* Arena::CreateMaybeMessage<::ei::MissionInfo>(Arena*);
template<> ::ei::MissionInfo_Fuel* Arena::CreateMaybeMessage<::ei::MissionInfo_Fuel>(Arena*);
template<> ::ei::MissionRequest* Arena::CreateMaybeMessage<::ei::MissionRequest>(Arena*);
template<> ::ei::MissionResponse* Arena::CreateMaybeMessage<::ei::MissionResponse>(Arena*);
template<> ::ei::MyContracts* Arena::CreateMaybeMessage<::ei::MyContracts>(Arena*);
template<> ::ei::PeriodicalsResponse* Arena::CreateMaybeMessage<::ei::PeriodicalsResponse>(Arena*);
template<> ::ei::PlayerFarmInfo* Arena::CreateMaybeMessage<::ei::PlayerFarmInfo>(Arena*);
template<> ::ei::QueryCoopRequest* Arena::CreateMaybeMessage<::ei::QueryCoopRequest>(Arena*);
template<> ::ei::QueryCoopResponse* Arena::CreateMaybeMessage<::ei::QueryCoopResponse>(Arena*);
template<> ::ei::ReturnEDTPayload* Arena::CreateMaybeMessage<::ei::ReturnEDTPayload>(Arena*);
template<> ::ei::Reward* Arena::CreateMaybeMessage<::ei::Reward>(Arena*);
template<> ::ei::SalesInfo* Arena::CreateMaybeMessage<::ei::SalesInfo>(Arena*);
template<> ::ei::SalesInfoRequest* Arena::CreateMaybeMessage<::ei::SalesInfoRequest>(Arena*);
template<> ::ei::SaveBackupResponse* Arena::CreateMaybeMessage<::ei::SaveBackupResponse>(Arena*);
template<> ::ei::SendChickenRunCoopRequest* Arena::CreateMaybeMessage<::ei::SendChickenRunCoopRequest>(Arena*);
template<> ::ei::ServerGift* Arena::CreateMaybeMessage<::ei::ServerGift>(Arena*);
template<> ::ei::SetArtifactRequest* Arena::CreateMaybeMessage<::ei::SetArtifactRequest>(Arena*);
template<> ::ei::SetArtifactResponse* Arena::CreateMaybeMessage<::ei::SetArtifactResponse>(Arena*);
template<> ::ei::ShellDB* Arena::CreateMaybeMessage<::ei::ShellDB>(Arena*);
template<> ::ei::ShellDB_ChickenConfig* Arena::CreateMaybeMessage<::ei::ShellDB_ChickenConfig>(Arena*);
template<> ::ei::ShellDB_FarmConfiguration* Arena::CreateMaybeMessage<::ei::ShellDB_FarmConfiguration>(Arena*);
template<> ::ei::ShellDB_ShellConfiguration* Arena::CreateMaybeMessage<::ei::ShellDB_ShellConfiguration>(Arena*);
template<> ::ei::ShellDB_ShellElementStatus* Arena::CreateMaybeMessage<::ei::ShellDB_ShellElementStatus>(Arena*);
template<> ::ei::ShellDB_ShellGroupConfiguration* Arena::CreateMaybeMessage<::ei::ShellDB_ShellGroupConfiguration>(Arena*);
template<> ::ei::ShellDB_ShellSetConfiguration* Arena::CreateMaybeMessage<::ei::ShellDB_ShellSetConfiguration>(Arena*);
template<> ::ei::ShellDB_ShellSetVariationStatus* Arena::CreateMaybeMessage<::ei::ShellDB_ShellSetVariationStatus>(Arena*);
template<> ::ei::ShellDB_ShellStatus* Arena::CreateMaybeMessage<::ei::ShellDB_ShellStatus>(Arena*);
template<> ::ei::ShellGroupSpec* Arena::CreateMaybeMessage<::ei::ShellGroupSpec>(Arena*);
template<> ::ei::ShellObjectSpec* Arena::CreateMaybeMessage<::ei::ShellObjectSpec>(Arena*);
template<> ::ei::ShellObjectSpec_LODPiece* Arena::CreateMaybeMessage<::ei::ShellObjectSpec_LODPiece>(Arena*);
template<> ::ei::ShellSetSpec* Arena::CreateMaybeMessage<::ei::ShellSetSpec>(Arena*);
template<> ::ei::ShellSetSpec_VariationInfo* Arena::CreateMaybeMessage<::ei::ShellSetSpec_VariationInfo>(Arena*);
template<> ::ei::ShellSpec* Arena::CreateMaybeMessage<::ei::ShellSpec>(Arena*);
template<> ::ei::ShellSpec_ShellPiece* Arena::CreateMaybeMessage<::ei::ShellSpec_ShellPiece>(Arena*);
template<> ::ei::ShellsActionLog* Arena::CreateMaybeMessage<::ei::ShellsActionLog>(Arena*);
template<> ::ei::UpdateCoopPermissionsRequest* Arena::CreateMaybeMessage<::ei::UpdateCoopPermissionsRequest>(Arena*);
template<> ::ei::UpdateCoopPermissionsResponse* Arena::CreateMaybeMessage<::ei::UpdateCoopPermissionsResponse>(Arena*);
template<> ::ei::UserDataInfoRequest* Arena::CreateMaybeMessage<::ei::UserDataInfoRequest>(Arena*);
template<> ::ei::UserDataInfoResponse* Arena::CreateMaybeMessage<::ei::UserDataInfoResponse>(Arena*);
template<> ::ei::VerifyPurchaseRequest* Arena::CreateMaybeMessage<::ei::VerifyPurchaseRequest>(Arena*);
template<> ::ei::VerifyPurchaseResponse* Arena::CreateMaybeMessage<::ei::VerifyPurchaseResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ei {

enum EggIncFirstContactResponse_ErrorCodes : int {
  EggIncFirstContactResponse_ErrorCodes_NO_ERROR = 0,
  EggIncFirstContactResponse_ErrorCodes_EXISTING_USER_W_GAMER_ID = 1,
  EggIncFirstContactResponse_ErrorCodes_USER_NOT_FOUND = 2,
  EggIncFirstContactResponse_ErrorCodes_BACKUP_CONFLICT = 3
};
bool EggIncFirstContactResponse_ErrorCodes_IsValid(int value);
constexpr EggIncFirstContactResponse_ErrorCodes EggIncFirstContactResponse_ErrorCodes_ErrorCodes_MIN = EggIncFirstContactResponse_ErrorCodes_NO_ERROR;
constexpr EggIncFirstContactResponse_ErrorCodes EggIncFirstContactResponse_ErrorCodes_ErrorCodes_MAX = EggIncFirstContactResponse_ErrorCodes_BACKUP_CONFLICT;
constexpr int EggIncFirstContactResponse_ErrorCodes_ErrorCodes_ARRAYSIZE = EggIncFirstContactResponse_ErrorCodes_ErrorCodes_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EggIncFirstContactResponse_ErrorCodes_descriptor();
template<typename T>
inline const std::string& EggIncFirstContactResponse_ErrorCodes_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EggIncFirstContactResponse_ErrorCodes>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EggIncFirstContactResponse_ErrorCodes_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EggIncFirstContactResponse_ErrorCodes_descriptor(), enum_t_value);
}
inline bool EggIncFirstContactResponse_ErrorCodes_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EggIncFirstContactResponse_ErrorCodes* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EggIncFirstContactResponse_ErrorCodes>(
    EggIncFirstContactResponse_ErrorCodes_descriptor(), name, value);
}
enum ContractCoopStatusResponse_MemberStatus : int {
  ContractCoopStatusResponse_MemberStatus_VALID = 0,
  ContractCoopStatusResponse_MemberStatus_KICKED_INACTIVE = 1,
  ContractCoopStatusResponse_MemberStatus_KICKED_PRIVATE = 2,
  ContractCoopStatusResponse_MemberStatus_KICKED_CHEATS = 3,
  ContractCoopStatusResponse_MemberStatus_KICKED_LEECH = 4
};
bool ContractCoopStatusResponse_MemberStatus_IsValid(int value);
constexpr ContractCoopStatusResponse_MemberStatus ContractCoopStatusResponse_MemberStatus_MemberStatus_MIN = ContractCoopStatusResponse_MemberStatus_VALID;
constexpr ContractCoopStatusResponse_MemberStatus ContractCoopStatusResponse_MemberStatus_MemberStatus_MAX = ContractCoopStatusResponse_MemberStatus_KICKED_LEECH;
constexpr int ContractCoopStatusResponse_MemberStatus_MemberStatus_ARRAYSIZE = ContractCoopStatusResponse_MemberStatus_MemberStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ContractCoopStatusResponse_MemberStatus_descriptor();
template<typename T>
inline const std::string& ContractCoopStatusResponse_MemberStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ContractCoopStatusResponse_MemberStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ContractCoopStatusResponse_MemberStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ContractCoopStatusResponse_MemberStatus_descriptor(), enum_t_value);
}
inline bool ContractCoopStatusResponse_MemberStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContractCoopStatusResponse_MemberStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ContractCoopStatusResponse_MemberStatus>(
    ContractCoopStatusResponse_MemberStatus_descriptor(), name, value);
}
enum KickPlayerCoopRequest_Reason : int {
  KickPlayerCoopRequest_Reason_INVALID = 0,
  KickPlayerCoopRequest_Reason_CHEATER = 1,
  KickPlayerCoopRequest_Reason_IDLE = 2,
  KickPlayerCoopRequest_Reason_LEECH = 3,
  KickPlayerCoopRequest_Reason_PRIVATE = 4
};
bool KickPlayerCoopRequest_Reason_IsValid(int value);
constexpr KickPlayerCoopRequest_Reason KickPlayerCoopRequest_Reason_Reason_MIN = KickPlayerCoopRequest_Reason_INVALID;
constexpr KickPlayerCoopRequest_Reason KickPlayerCoopRequest_Reason_Reason_MAX = KickPlayerCoopRequest_Reason_PRIVATE;
constexpr int KickPlayerCoopRequest_Reason_Reason_ARRAYSIZE = KickPlayerCoopRequest_Reason_Reason_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KickPlayerCoopRequest_Reason_descriptor();
template<typename T>
inline const std::string& KickPlayerCoopRequest_Reason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KickPlayerCoopRequest_Reason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KickPlayerCoopRequest_Reason_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    KickPlayerCoopRequest_Reason_descriptor(), enum_t_value);
}
inline bool KickPlayerCoopRequest_Reason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KickPlayerCoopRequest_Reason* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<KickPlayerCoopRequest_Reason>(
    KickPlayerCoopRequest_Reason_descriptor(), name, value);
}
enum MissionInfo_Spaceship : int {
  MissionInfo_Spaceship_CHICKEN_ONE = 0,
  MissionInfo_Spaceship_CHICKEN_NINE = 1,
  MissionInfo_Spaceship_CHICKEN_HEAVY = 2,
  MissionInfo_Spaceship_BCR = 3,
  MissionInfo_Spaceship_MILLENIUM_CHICKEN = 4,
  MissionInfo_Spaceship_CORELLIHEN_CORVETTE = 5,
  MissionInfo_Spaceship_GALEGGTICA = 6,
  MissionInfo_Spaceship_CHICKFIANT = 7,
  MissionInfo_Spaceship_VOYEGGER = 8,
  MissionInfo_Spaceship_HENERPRISE = 9
};
bool MissionInfo_Spaceship_IsValid(int value);
constexpr MissionInfo_Spaceship MissionInfo_Spaceship_Spaceship_MIN = MissionInfo_Spaceship_CHICKEN_ONE;
constexpr MissionInfo_Spaceship MissionInfo_Spaceship_Spaceship_MAX = MissionInfo_Spaceship_HENERPRISE;
constexpr int MissionInfo_Spaceship_Spaceship_ARRAYSIZE = MissionInfo_Spaceship_Spaceship_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MissionInfo_Spaceship_descriptor();
template<typename T>
inline const std::string& MissionInfo_Spaceship_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MissionInfo_Spaceship>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MissionInfo_Spaceship_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MissionInfo_Spaceship_descriptor(), enum_t_value);
}
inline bool MissionInfo_Spaceship_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MissionInfo_Spaceship* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MissionInfo_Spaceship>(
    MissionInfo_Spaceship_descriptor(), name, value);
}
enum MissionInfo_Status : int {
  MissionInfo_Status_FUELING = 0,
  MissionInfo_Status_PREPARE_TO_LAUNCH = 5,
  MissionInfo_Status_EXPLORING = 10,
  MissionInfo_Status_RETURNED = 15,
  MissionInfo_Status_ANALYZING = 16,
  MissionInfo_Status_COMPLETE = 20,
  MissionInfo_Status_ARCHIVED = 25
};
bool MissionInfo_Status_IsValid(int value);
constexpr MissionInfo_Status MissionInfo_Status_Status_MIN = MissionInfo_Status_FUELING;
constexpr MissionInfo_Status MissionInfo_Status_Status_MAX = MissionInfo_Status_ARCHIVED;
constexpr int MissionInfo_Status_Status_ARRAYSIZE = MissionInfo_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MissionInfo_Status_descriptor();
template<typename T>
inline const std::string& MissionInfo_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MissionInfo_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MissionInfo_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MissionInfo_Status_descriptor(), enum_t_value);
}
inline bool MissionInfo_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MissionInfo_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MissionInfo_Status>(
    MissionInfo_Status_descriptor(), name, value);
}
enum MissionInfo_DurationType : int {
  MissionInfo_DurationType_SHORT = 0,
  MissionInfo_DurationType_LONG = 1,
  MissionInfo_DurationType_EPIC = 2,
  MissionInfo_DurationType_TUTORIAL = 3
};
bool MissionInfo_DurationType_IsValid(int value);
constexpr MissionInfo_DurationType MissionInfo_DurationType_DurationType_MIN = MissionInfo_DurationType_SHORT;
constexpr MissionInfo_DurationType MissionInfo_DurationType_DurationType_MAX = MissionInfo_DurationType_TUTORIAL;
constexpr int MissionInfo_DurationType_DurationType_ARRAYSIZE = MissionInfo_DurationType_DurationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MissionInfo_DurationType_descriptor();
template<typename T>
inline const std::string& MissionInfo_DurationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MissionInfo_DurationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MissionInfo_DurationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MissionInfo_DurationType_descriptor(), enum_t_value);
}
inline bool MissionInfo_DurationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MissionInfo_DurationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MissionInfo_DurationType>(
    MissionInfo_DurationType_descriptor(), name, value);
}
enum ArtifactSpec_Name : int {
  ArtifactSpec_Name_LUNAR_TOTEM = 0,
  ArtifactSpec_Name_NEODYMIUM_MEDALLION = 3,
  ArtifactSpec_Name_BEAK_OF_MIDAS = 4,
  ArtifactSpec_Name_LIGHT_OF_EGGENDIL = 5,
  ArtifactSpec_Name_DEMETERS_NECKLACE = 6,
  ArtifactSpec_Name_VIAL_MARTIAN_DUST = 7,
  ArtifactSpec_Name_ORNATE_GUSSET = 8,
  ArtifactSpec_Name_THE_CHALICE = 9,
  ArtifactSpec_Name_BOOK_OF_BASAN = 10,
  ArtifactSpec_Name_PHOENIX_FEATHER = 11,
  ArtifactSpec_Name_TUNGSTEN_ANKH = 12,
  ArtifactSpec_Name_AURELIAN_BROOCH = 21,
  ArtifactSpec_Name_CARVED_RAINSTICK = 22,
  ArtifactSpec_Name_PUZZLE_CUBE = 23,
  ArtifactSpec_Name_QUANTUM_METRONOME = 24,
  ArtifactSpec_Name_SHIP_IN_A_BOTTLE = 25,
  ArtifactSpec_Name_TACHYON_DEFLECTOR = 26,
  ArtifactSpec_Name_INTERSTELLAR_COMPASS = 27,
  ArtifactSpec_Name_DILITHIUM_MONOCLE = 28,
  ArtifactSpec_Name_TITANIUM_ACTUATOR = 29,
  ArtifactSpec_Name_MERCURYS_LENS = 30,
  ArtifactSpec_Name_TACHYON_STONE = 1,
  ArtifactSpec_Name_DILITHIUM_STONE = 31,
  ArtifactSpec_Name_SHELL_STONE = 32,
  ArtifactSpec_Name_LUNAR_STONE = 33,
  ArtifactSpec_Name_SOUL_STONE = 34,
  ArtifactSpec_Name_PROPHECY_STONE = 39,
  ArtifactSpec_Name_QUANTUM_STONE = 36,
  ArtifactSpec_Name_TERRA_STONE = 37,
  ArtifactSpec_Name_LIFE_STONE = 38,
  ArtifactSpec_Name_CLARITY_STONE = 40,
  ArtifactSpec_Name_EXTRATERRESTRIAL_ALUMINUM = 13,
  ArtifactSpec_Name_ANCIENT_TUNGSTEN = 14,
  ArtifactSpec_Name_SPACE_ROCKS = 15,
  ArtifactSpec_Name_ALIEN_WOOD = 16,
  ArtifactSpec_Name_GOLD_METEORITE = 17,
  ArtifactSpec_Name_TAU_CETI_GEODE = 18,
  ArtifactSpec_Name_CENTAURIAN_STEEL = 19,
  ArtifactSpec_Name_ERIDANI_FEATHER = 20,
  ArtifactSpec_Name_DRONE_PARTS = 35,
  ArtifactSpec_Name_CELESTIAL_BRONZE = 41,
  ArtifactSpec_Name_LALANDE_HIDE = 42,
  ArtifactSpec_Name_SOLAR_TITANIUM = 43,
  ArtifactSpec_Name_TACHYON_STONE_FRAGMENT = 2,
  ArtifactSpec_Name_DILITHIUM_STONE_FRAGMENT = 44,
  ArtifactSpec_Name_SHELL_STONE_FRAGMENT = 45,
  ArtifactSpec_Name_LUNAR_STONE_FRAGMENT = 46,
  ArtifactSpec_Name_SOUL_STONE_FRAGMENT = 47,
  ArtifactSpec_Name_PROPHECY_STONE_FRAGMENT = 48,
  ArtifactSpec_Name_QUANTUM_STONE_FRAGMENT = 49,
  ArtifactSpec_Name_TERRA_STONE_FRAGMENT = 50,
  ArtifactSpec_Name_LIFE_STONE_FRAGMENT = 51,
  ArtifactSpec_Name_CLARITY_STONE_FRAGMENT = 52,
  ArtifactSpec_Name_UNKNOWN = 10000
};
bool ArtifactSpec_Name_IsValid(int value);
constexpr ArtifactSpec_Name ArtifactSpec_Name_Name_MIN = ArtifactSpec_Name_LUNAR_TOTEM;
constexpr ArtifactSpec_Name ArtifactSpec_Name_Name_MAX = ArtifactSpec_Name_UNKNOWN;
constexpr int ArtifactSpec_Name_Name_ARRAYSIZE = ArtifactSpec_Name_Name_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ArtifactSpec_Name_descriptor();
template<typename T>
inline const std::string& ArtifactSpec_Name_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ArtifactSpec_Name>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ArtifactSpec_Name_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ArtifactSpec_Name_descriptor(), enum_t_value);
}
inline bool ArtifactSpec_Name_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ArtifactSpec_Name* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ArtifactSpec_Name>(
    ArtifactSpec_Name_descriptor(), name, value);
}
enum ArtifactSpec_Level : int {
  ArtifactSpec_Level_INFERIOR = 0,
  ArtifactSpec_Level_LESSER = 1,
  ArtifactSpec_Level_NORMAL = 2,
  ArtifactSpec_Level_GREATER = 3,
  ArtifactSpec_Level_SUPERIOR = 4
};
bool ArtifactSpec_Level_IsValid(int value);
constexpr ArtifactSpec_Level ArtifactSpec_Level_Level_MIN = ArtifactSpec_Level_INFERIOR;
constexpr ArtifactSpec_Level ArtifactSpec_Level_Level_MAX = ArtifactSpec_Level_SUPERIOR;
constexpr int ArtifactSpec_Level_Level_ARRAYSIZE = ArtifactSpec_Level_Level_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ArtifactSpec_Level_descriptor();
template<typename T>
inline const std::string& ArtifactSpec_Level_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ArtifactSpec_Level>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ArtifactSpec_Level_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ArtifactSpec_Level_descriptor(), enum_t_value);
}
inline bool ArtifactSpec_Level_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ArtifactSpec_Level* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ArtifactSpec_Level>(
    ArtifactSpec_Level_descriptor(), name, value);
}
enum ArtifactSpec_Rarity : int {
  ArtifactSpec_Rarity_COMMON = 0,
  ArtifactSpec_Rarity_RARE = 1,
  ArtifactSpec_Rarity_EPIC = 2,
  ArtifactSpec_Rarity_LEGENDARY = 3
};
bool ArtifactSpec_Rarity_IsValid(int value);
constexpr ArtifactSpec_Rarity ArtifactSpec_Rarity_Rarity_MIN = ArtifactSpec_Rarity_COMMON;
constexpr ArtifactSpec_Rarity ArtifactSpec_Rarity_Rarity_MAX = ArtifactSpec_Rarity_LEGENDARY;
constexpr int ArtifactSpec_Rarity_Rarity_ARRAYSIZE = ArtifactSpec_Rarity_Rarity_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ArtifactSpec_Rarity_descriptor();
template<typename T>
inline const std::string& ArtifactSpec_Rarity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ArtifactSpec_Rarity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ArtifactSpec_Rarity_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ArtifactSpec_Rarity_descriptor(), enum_t_value);
}
inline bool ArtifactSpec_Rarity_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ArtifactSpec_Rarity* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ArtifactSpec_Rarity>(
    ArtifactSpec_Rarity_descriptor(), name, value);
}
enum ArtifactSpec_Type : int {
  ArtifactSpec_Type_ARTIFACT = 0,
  ArtifactSpec_Type_STONE = 1,
  ArtifactSpec_Type_INGREDIENT = 2,
  ArtifactSpec_Type_STONE_INGREDIENT = 3
};
bool ArtifactSpec_Type_IsValid(int value);
constexpr ArtifactSpec_Type ArtifactSpec_Type_Type_MIN = ArtifactSpec_Type_ARTIFACT;
constexpr ArtifactSpec_Type ArtifactSpec_Type_Type_MAX = ArtifactSpec_Type_STONE_INGREDIENT;
constexpr int ArtifactSpec_Type_Type_ARRAYSIZE = ArtifactSpec_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ArtifactSpec_Type_descriptor();
template<typename T>
inline const std::string& ArtifactSpec_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ArtifactSpec_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ArtifactSpec_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ArtifactSpec_Type_descriptor(), enum_t_value);
}
inline bool ArtifactSpec_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ArtifactSpec_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ArtifactSpec_Type>(
    ArtifactSpec_Type_descriptor(), name, value);
}
enum SaveBackupResponse_ErrorCodes : int {
  SaveBackupResponse_ErrorCodes_NO_ERROR = 0,
  SaveBackupResponse_ErrorCodes_USER_NOT_FOUND = 1,
  SaveBackupResponse_ErrorCodes_COULD_NOT_OVERWRITE = 2,
  SaveBackupResponse_ErrorCodes_BACKUP_OFFERED = 3,
  SaveBackupResponse_ErrorCodes_BAD_USER_ID = 4
};
bool SaveBackupResponse_ErrorCodes_IsValid(int value);
constexpr SaveBackupResponse_ErrorCodes SaveBackupResponse_ErrorCodes_ErrorCodes_MIN = SaveBackupResponse_ErrorCodes_NO_ERROR;
constexpr SaveBackupResponse_ErrorCodes SaveBackupResponse_ErrorCodes_ErrorCodes_MAX = SaveBackupResponse_ErrorCodes_BAD_USER_ID;
constexpr int SaveBackupResponse_ErrorCodes_ErrorCodes_ARRAYSIZE = SaveBackupResponse_ErrorCodes_ErrorCodes_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SaveBackupResponse_ErrorCodes_descriptor();
template<typename T>
inline const std::string& SaveBackupResponse_ErrorCodes_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SaveBackupResponse_ErrorCodes>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SaveBackupResponse_ErrorCodes_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SaveBackupResponse_ErrorCodes_descriptor(), enum_t_value);
}
inline bool SaveBackupResponse_ErrorCodes_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SaveBackupResponse_ErrorCodes* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SaveBackupResponse_ErrorCodes>(
    SaveBackupResponse_ErrorCodes_descriptor(), name, value);
}
enum ShellSpec_AssetType : int {
  ShellSpec_AssetType_COOP = 1,
  ShellSpec_AssetType_SHACK = 2,
  ShellSpec_AssetType_SUPER_SHACK = 3,
  ShellSpec_AssetType_SHORT_HOUSE = 4,
  ShellSpec_AssetType_THE_STANDARD = 5,
  ShellSpec_AssetType_LONG_HOUSE = 6,
  ShellSpec_AssetType_DOUBLE_DECKER = 7,
  ShellSpec_AssetType_WAREHOUSE = 8,
  ShellSpec_AssetType_CENTER = 9,
  ShellSpec_AssetType_BUNKER = 10,
  ShellSpec_AssetType_EGGKEA = 11,
  ShellSpec_AssetType_HAB_1K = 12,
  ShellSpec_AssetType_HANGAR = 13,
  ShellSpec_AssetType_TOWER = 14,
  ShellSpec_AssetType_HAB_10K = 15,
  ShellSpec_AssetType_EGGTOPIA = 16,
  ShellSpec_AssetType_MONOLITH = 17,
  ShellSpec_AssetType_PLANET_PORTAL = 18,
  ShellSpec_AssetType_CHICKEN_UNIVERSE = 19,
  ShellSpec_AssetType_SILO_0_SMALL = 50,
  ShellSpec_AssetType_SILO_0_MED = 51,
  ShellSpec_AssetType_SILO_0_LARGE = 52,
  ShellSpec_AssetType_SILO_1_SMALL = 53,
  ShellSpec_AssetType_SILO_1_MED = 54,
  ShellSpec_AssetType_SILO_1_LARGE = 55,
  ShellSpec_AssetType_SILO_ALL = 59,
  ShellSpec_AssetType_MAILBOX = 70,
  ShellSpec_AssetType_TROPHY_CASE = 71,
  ShellSpec_AssetType_GROUND = 72,
  ShellSpec_AssetType_HARDSCAPE = 73,
  ShellSpec_AssetType_HYPERLOOP = 74,
  ShellSpec_AssetType_DEPOT_1 = 100,
  ShellSpec_AssetType_DEPOT_2 = 101,
  ShellSpec_AssetType_DEPOT_3 = 102,
  ShellSpec_AssetType_DEPOT_4 = 103,
  ShellSpec_AssetType_DEPOT_5 = 104,
  ShellSpec_AssetType_DEPOT_6 = 105,
  ShellSpec_AssetType_DEPOT_7 = 106,
  ShellSpec_AssetType_LAB_1 = 110,
  ShellSpec_AssetType_LAB_2 = 111,
  ShellSpec_AssetType_LAB_3 = 112,
  ShellSpec_AssetType_LAB_4 = 113,
  ShellSpec_AssetType_LAB_5 = 114,
  ShellSpec_AssetType_LAB_6 = 115,
  ShellSpec_AssetType_HATCHERY_EDIBLE = 120,
  ShellSpec_AssetType_HATCHERY_SUPERFOOD = 121,
  ShellSpec_AssetType_HATCHERY_MEDICAL = 122,
  ShellSpec_AssetType_HATCHERY_ROCKET_FUEL = 123,
  ShellSpec_AssetType_HATCHERY_SUPERMATERIAL = 124,
  ShellSpec_AssetType_HATCHERY_FUSION = 125,
  ShellSpec_AssetType_HATCHERY_QUANTUM = 126,
  ShellSpec_AssetType_HATCHERY_IMMORTALITY = 127,
  ShellSpec_AssetType_HATCHERY_TACHYON = 128,
  ShellSpec_AssetType_HATCHERY_GRAVITON = 129,
  ShellSpec_AssetType_HATCHERY_DILITHIUM = 130,
  ShellSpec_AssetType_HATCHERY_PRODIGY = 131,
  ShellSpec_AssetType_HATCHERY_TERRAFORM = 132,
  ShellSpec_AssetType_HATCHERY_ANTIMATTER = 133,
  ShellSpec_AssetType_HATCHERY_DARK_MATTER = 134,
  ShellSpec_AssetType_HATCHERY_AI = 135,
  ShellSpec_AssetType_HATCHERY_NEBULA = 136,
  ShellSpec_AssetType_HATCHERY_UNIVERSE = 137,
  ShellSpec_AssetType_HATCHERY_ENLIGHTENMENT = 138,
  ShellSpec_AssetType_HATCHERY_CHOCOLATE = 139,
  ShellSpec_AssetType_HATCHERY_EASTER = 140,
  ShellSpec_AssetType_HATCHERY_WATERBALLOON = 141,
  ShellSpec_AssetType_HATCHERY_FIREWORK = 142,
  ShellSpec_AssetType_HATCHERY_PUMPKIN = 143,
  ShellSpec_AssetType_HOA_1 = 170,
  ShellSpec_AssetType_HOA_2 = 171,
  ShellSpec_AssetType_HOA_3 = 172,
  ShellSpec_AssetType_MISSION_CONTROL_1 = 180,
  ShellSpec_AssetType_MISSION_CONTROL_2 = 181,
  ShellSpec_AssetType_MISSION_CONTROL_3 = 182,
  ShellSpec_AssetType_FUEL_TANK_1 = 200,
  ShellSpec_AssetType_FUEL_TANK_2 = 201,
  ShellSpec_AssetType_FUEL_TANK_3 = 202,
  ShellSpec_AssetType_FUEL_TANK_4 = 203,
  ShellSpec_AssetType_HATCHERY_GRAVITON_TOP = 500,
  ShellSpec_AssetType_HATCHERY_NEBULA_MIDDLE = 501,
  ShellSpec_AssetType_HATCHERY_NEBULA_TOP = 502,
  ShellSpec_AssetType_HATCHERY_DARK_MATTER_RING_1 = 505,
  ShellSpec_AssetType_HATCHERY_DARK_MATTER_RING_2 = 506,
  ShellSpec_AssetType_HATCHERY_DARK_MATTER_RING_3 = 507,
  ShellSpec_AssetType_HATCHERY_AI_TOP_1 = 510,
  ShellSpec_AssetType_HATCHERY_AI_TOP_2 = 511,
  ShellSpec_AssetType_HATCHERY_AI_TOP_3 = 512,
  ShellSpec_AssetType_HATCHERY_AI_TOP_4 = 513,
  ShellSpec_AssetType_HATCHERY_UNIVERSE_PROBE = 515,
  ShellSpec_AssetType_HATCHERY_UNIVERSE_BOLT = 516,
  ShellSpec_AssetType_HATCHERY_ENLIGHTENMENT_ORB = 520,
  ShellSpec_AssetType_HYPERLOOP_TRACK = 570,
  ShellSpec_AssetType_MAILBOX_FULL = 600,
  ShellSpec_AssetType_CHICKEN = 1000,
  ShellSpec_AssetType_HAT = 1010,
  ShellSpec_AssetType_UNKNOWN = 9999
};
bool ShellSpec_AssetType_IsValid(int value);
constexpr ShellSpec_AssetType ShellSpec_AssetType_AssetType_MIN = ShellSpec_AssetType_COOP;
constexpr ShellSpec_AssetType ShellSpec_AssetType_AssetType_MAX = ShellSpec_AssetType_UNKNOWN;
constexpr int ShellSpec_AssetType_AssetType_ARRAYSIZE = ShellSpec_AssetType_AssetType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ShellSpec_AssetType_descriptor();
template<typename T>
inline const std::string& ShellSpec_AssetType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ShellSpec_AssetType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ShellSpec_AssetType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ShellSpec_AssetType_descriptor(), enum_t_value);
}
inline bool ShellSpec_AssetType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShellSpec_AssetType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ShellSpec_AssetType>(
    ShellSpec_AssetType_descriptor(), name, value);
}
enum ShellDB_FarmElement : int {
  ShellDB_FarmElement_HEN_HOUSE = 1,
  ShellDB_FarmElement_SILO = 2,
  ShellDB_FarmElement_MAILBOX = 3,
  ShellDB_FarmElement_TROPHY_CASE = 4,
  ShellDB_FarmElement_GROUND = 5,
  ShellDB_FarmElement_HARDSCAPE = 6,
  ShellDB_FarmElement_HYPERLOOP = 7,
  ShellDB_FarmElement_DEPOT = 8,
  ShellDB_FarmElement_LAB = 9,
  ShellDB_FarmElement_HATCHERY = 10,
  ShellDB_FarmElement_HOA = 11,
  ShellDB_FarmElement_MISSION_CONTROL = 12,
  ShellDB_FarmElement_FUEL_TANK = 13,
  ShellDB_FarmElement_CHICKEN = 14,
  ShellDB_FarmElement_HAT = 15,
  ShellDB_FarmElement_UNKNOWN = 99
};
bool ShellDB_FarmElement_IsValid(int value);
constexpr ShellDB_FarmElement ShellDB_FarmElement_FarmElement_MIN = ShellDB_FarmElement_HEN_HOUSE;
constexpr ShellDB_FarmElement ShellDB_FarmElement_FarmElement_MAX = ShellDB_FarmElement_UNKNOWN;
constexpr int ShellDB_FarmElement_FarmElement_ARRAYSIZE = ShellDB_FarmElement_FarmElement_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ShellDB_FarmElement_descriptor();
template<typename T>
inline const std::string& ShellDB_FarmElement_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ShellDB_FarmElement>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ShellDB_FarmElement_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ShellDB_FarmElement_descriptor(), enum_t_value);
}
inline bool ShellDB_FarmElement_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShellDB_FarmElement* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ShellDB_FarmElement>(
    ShellDB_FarmElement_descriptor(), name, value);
}
enum Platform : int {
  IOS = 1,
  DROID = 2
};
bool Platform_IsValid(int value);
constexpr Platform Platform_MIN = IOS;
constexpr Platform Platform_MAX = DROID;
constexpr int Platform_ARRAYSIZE = Platform_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Platform_descriptor();
template<typename T>
inline const std::string& Platform_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Platform>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Platform_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Platform_descriptor(), enum_t_value);
}
inline bool Platform_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Platform* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Platform>(
    Platform_descriptor(), name, value);
}
enum DeviceFormFactor : int {
  PHONE = 1,
  TABLET = 2
};
bool DeviceFormFactor_IsValid(int value);
constexpr DeviceFormFactor DeviceFormFactor_MIN = PHONE;
constexpr DeviceFormFactor DeviceFormFactor_MAX = TABLET;
constexpr int DeviceFormFactor_ARRAYSIZE = DeviceFormFactor_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DeviceFormFactor_descriptor();
template<typename T>
inline const std::string& DeviceFormFactor_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceFormFactor>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceFormFactor_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DeviceFormFactor_descriptor(), enum_t_value);
}
inline bool DeviceFormFactor_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceFormFactor* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DeviceFormFactor>(
    DeviceFormFactor_descriptor(), name, value);
}
enum AdNetwork : int {
  VUNGLE = 0,
  CHARTBOOST = 1,
  AD_COLONY = 2,
  HYPER_MX = 3,
  UNITY = 4,
  FACEBOOK = 5,
  APPLOVIN = 6
};
bool AdNetwork_IsValid(int value);
constexpr AdNetwork AdNetwork_MIN = VUNGLE;
constexpr AdNetwork AdNetwork_MAX = APPLOVIN;
constexpr int AdNetwork_ARRAYSIZE = AdNetwork_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AdNetwork_descriptor();
template<typename T>
inline const std::string& AdNetwork_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AdNetwork>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AdNetwork_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AdNetwork_descriptor(), enum_t_value);
}
inline bool AdNetwork_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AdNetwork* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AdNetwork>(
    AdNetwork_descriptor(), name, value);
}
enum Egg : int {
  EDIBLE = 1,
  SUPERFOOD = 2,
  MEDICAL = 3,
  ROCKET_FUEL = 4,
  SUPER_MATERIAL = 5,
  FUSION = 6,
  QUANTUM = 7,
  IMMORTALITY = 8,
  TACHYON = 9,
  GRAVITON = 10,
  DILITHIUM = 11,
  PRODIGY = 12,
  TERRAFORM = 13,
  ANTIMATTER = 14,
  DARK_MATTER = 15,
  AI = 16,
  NEBULA = 17,
  UNIVERSE = 18,
  ENLIGHTENMENT = 19,
  CHOCOLATE = 100,
  EASTER = 101,
  WATERBALLOON = 102,
  FIREWORK = 103,
  PUMPKIN = 104,
  UNKNOWN = 1000
};
bool Egg_IsValid(int value);
constexpr Egg Egg_MIN = EDIBLE;
constexpr Egg Egg_MAX = UNKNOWN;
constexpr int Egg_ARRAYSIZE = Egg_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Egg_descriptor();
template<typename T>
inline const std::string& Egg_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Egg>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Egg_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Egg_descriptor(), enum_t_value);
}
inline bool Egg_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Egg* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Egg>(
    Egg_descriptor(), name, value);
}
enum FarmType : int {
  EMPTY = 1,
  HOME = 2,
  CONTRACT = 3
};
bool FarmType_IsValid(int value);
constexpr FarmType FarmType_MIN = EMPTY;
constexpr FarmType FarmType_MAX = CONTRACT;
constexpr int FarmType_ARRAYSIZE = FarmType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FarmType_descriptor();
template<typename T>
inline const std::string& FarmType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FarmType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FarmType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FarmType_descriptor(), enum_t_value);
}
inline bool FarmType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FarmType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FarmType>(
    FarmType_descriptor(), name, value);
}
enum GoalType : int {
  EGGS_LAID = 1,
  UNKNOWN_GOAL = 100
};
bool GoalType_IsValid(int value);
constexpr GoalType GoalType_MIN = EGGS_LAID;
constexpr GoalType GoalType_MAX = UNKNOWN_GOAL;
constexpr int GoalType_ARRAYSIZE = GoalType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GoalType_descriptor();
template<typename T>
inline const std::string& GoalType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GoalType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GoalType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GoalType_descriptor(), enum_t_value);
}
inline bool GoalType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GoalType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GoalType>(
    GoalType_descriptor(), name, value);
}
enum RewardType : int {
  CASH = 1,
  GOLD = 2,
  SOUL_EGGS = 3,
  EGGS_OF_PROPHECY = 4,
  EPIC_RESEARCH_ITEM = 5,
  PIGGY_FILL = 6,
  PIGGY_MULTIPLIER = 7,
  PIGGY_LEVEL_BUMP = 8,
  BOOST = 9,
  BOOST_TOKEN = 10,
  ARTIFACT = 11,
  ARTIFACT_CASE = 12,
  CHICKEN = 13,
  SHELL_SCRIPT = 14,
  UNKNOWN_REWARD = 100
};
bool RewardType_IsValid(int value);
constexpr RewardType RewardType_MIN = CASH;
constexpr RewardType RewardType_MAX = UNKNOWN_REWARD;
constexpr int RewardType_ARRAYSIZE = RewardType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RewardType_descriptor();
template<typename T>
inline const std::string& RewardType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RewardType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RewardType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RewardType_descriptor(), enum_t_value);
}
inline bool RewardType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RewardType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RewardType>(
    RewardType_descriptor(), name, value);
}
// ===================================================================

class Backup_Settings final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.Backup.Settings) */ {
 public:
  inline Backup_Settings() : Backup_Settings(nullptr) {}
  ~Backup_Settings() override;
  explicit constexpr Backup_Settings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Backup_Settings(const Backup_Settings& from);
  Backup_Settings(Backup_Settings&& from) noexcept
    : Backup_Settings() {
    *this = ::std::move(from);
  }

  inline Backup_Settings& operator=(const Backup_Settings& from) {
    CopyFrom(from);
    return *this;
  }
  inline Backup_Settings& operator=(Backup_Settings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Backup_Settings& default_instance() {
    return *internal_default_instance();
  }
  static inline const Backup_Settings* internal_default_instance() {
    return reinterpret_cast<const Backup_Settings*>(
               &_Backup_Settings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Backup_Settings& a, Backup_Settings& b) {
    a.Swap(&b);
  }
  inline void Swap(Backup_Settings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Backup_Settings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Backup_Settings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Backup_Settings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Backup_Settings& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Backup_Settings& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Backup_Settings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.Backup.Settings";
  }
  protected:
  explicit Backup_Settings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSfxFieldNumber = 1,
    kMusicFieldNumber = 2,
    kLowBatteryModeFieldNumber = 3,
    kLowPerformanceModeFieldNumber = 4,
    kForceTouchChickenBtnFieldNumber = 9,
    kNotificationsQueriedFieldNumber = 5,
    kNotificationsOnFieldNumber = 6,
    kNotifyDailyGiftFieldNumber = 11,
    kCoppaQueriedFieldNumber = 7,
    kCoppaRestrictedFieldNumber = 8,
    kGdprConsentQueriedFieldNumber = 12,
    kGdprAgeRestrictedFieldNumber = 16,
    kLastDayAgeQueriedFieldNumber = 17,
    kGdprConsentGivenFieldNumber = 13,
    kAgeQueriedFieldNumber = 18,
    kAgeRestrictedFieldNumber = 19,
    kDataCollectionConsentQueriedFieldNumber = 20,
    kDataCollectionConsentGivenFieldNumber = 21,
    kLowPerformanceFieldNumber = 10,
    kAutoStopFuelingFieldNumber = 25,
    kLastBackupTimeFieldNumber = 24,
    kUserAdsEnabledFieldNumber = 14,
    kUserCloudEnabledFieldNumber = 15,
    kUserAnalyticsEnabledFieldNumber = 22,
    kUserPersonalizedAdsEnabledFieldNumber = 23,
  };
  // optional bool sfx = 1;
  bool has_sfx() const;
  private:
  bool _internal_has_sfx() const;
  public:
  void clear_sfx();
  bool sfx() const;
  void set_sfx(bool value);
  private:
  bool _internal_sfx() const;
  void _internal_set_sfx(bool value);
  public:

  // optional bool music = 2;
  bool has_music() const;
  private:
  bool _internal_has_music() const;
  public:
  void clear_music();
  bool music() const;
  void set_music(bool value);
  private:
  bool _internal_music() const;
  void _internal_set_music(bool value);
  public:

  // optional bool low_battery_mode = 3;
  bool has_low_battery_mode() const;
  private:
  bool _internal_has_low_battery_mode() const;
  public:
  void clear_low_battery_mode();
  bool low_battery_mode() const;
  void set_low_battery_mode(bool value);
  private:
  bool _internal_low_battery_mode() const;
  void _internal_set_low_battery_mode(bool value);
  public:

  // optional bool low_performance_mode = 4;
  bool has_low_performance_mode() const;
  private:
  bool _internal_has_low_performance_mode() const;
  public:
  void clear_low_performance_mode();
  bool low_performance_mode() const;
  void set_low_performance_mode(bool value);
  private:
  bool _internal_low_performance_mode() const;
  void _internal_set_low_performance_mode(bool value);
  public:

  // optional bool force_touch_chicken_btn = 9;
  bool has_force_touch_chicken_btn() const;
  private:
  bool _internal_has_force_touch_chicken_btn() const;
  public:
  void clear_force_touch_chicken_btn();
  bool force_touch_chicken_btn() const;
  void set_force_touch_chicken_btn(bool value);
  private:
  bool _internal_force_touch_chicken_btn() const;
  void _internal_set_force_touch_chicken_btn(bool value);
  public:

  // optional bool notifications_queried = 5;
  bool has_notifications_queried() const;
  private:
  bool _internal_has_notifications_queried() const;
  public:
  void clear_notifications_queried();
  bool notifications_queried() const;
  void set_notifications_queried(bool value);
  private:
  bool _internal_notifications_queried() const;
  void _internal_set_notifications_queried(bool value);
  public:

  // optional bool notifications_on = 6;
  bool has_notifications_on() const;
  private:
  bool _internal_has_notifications_on() const;
  public:
  void clear_notifications_on();
  bool notifications_on() const;
  void set_notifications_on(bool value);
  private:
  bool _internal_notifications_on() const;
  void _internal_set_notifications_on(bool value);
  public:

  // optional bool notify_daily_gift = 11;
  bool has_notify_daily_gift() const;
  private:
  bool _internal_has_notify_daily_gift() const;
  public:
  void clear_notify_daily_gift();
  bool notify_daily_gift() const;
  void set_notify_daily_gift(bool value);
  private:
  bool _internal_notify_daily_gift() const;
  void _internal_set_notify_daily_gift(bool value);
  public:

  // optional bool coppa_queried = 7;
  bool has_coppa_queried() const;
  private:
  bool _internal_has_coppa_queried() const;
  public:
  void clear_coppa_queried();
  bool coppa_queried() const;
  void set_coppa_queried(bool value);
  private:
  bool _internal_coppa_queried() const;
  void _internal_set_coppa_queried(bool value);
  public:

  // optional bool coppa_restricted = 8;
  bool has_coppa_restricted() const;
  private:
  bool _internal_has_coppa_restricted() const;
  public:
  void clear_coppa_restricted();
  bool coppa_restricted() const;
  void set_coppa_restricted(bool value);
  private:
  bool _internal_coppa_restricted() const;
  void _internal_set_coppa_restricted(bool value);
  public:

  // optional bool gdpr_consent_queried = 12;
  bool has_gdpr_consent_queried() const;
  private:
  bool _internal_has_gdpr_consent_queried() const;
  public:
  void clear_gdpr_consent_queried();
  bool gdpr_consent_queried() const;
  void set_gdpr_consent_queried(bool value);
  private:
  bool _internal_gdpr_consent_queried() const;
  void _internal_set_gdpr_consent_queried(bool value);
  public:

  // optional bool gdpr_age_restricted = 16;
  bool has_gdpr_age_restricted() const;
  private:
  bool _internal_has_gdpr_age_restricted() const;
  public:
  void clear_gdpr_age_restricted();
  bool gdpr_age_restricted() const;
  void set_gdpr_age_restricted(bool value);
  private:
  bool _internal_gdpr_age_restricted() const;
  void _internal_set_gdpr_age_restricted(bool value);
  public:

  // optional uint32 last_day_age_queried = 17;
  bool has_last_day_age_queried() const;
  private:
  bool _internal_has_last_day_age_queried() const;
  public:
  void clear_last_day_age_queried();
  uint32_t last_day_age_queried() const;
  void set_last_day_age_queried(uint32_t value);
  private:
  uint32_t _internal_last_day_age_queried() const;
  void _internal_set_last_day_age_queried(uint32_t value);
  public:

  // optional bool gdpr_consent_given = 13;
  bool has_gdpr_consent_given() const;
  private:
  bool _internal_has_gdpr_consent_given() const;
  public:
  void clear_gdpr_consent_given();
  bool gdpr_consent_given() const;
  void set_gdpr_consent_given(bool value);
  private:
  bool _internal_gdpr_consent_given() const;
  void _internal_set_gdpr_consent_given(bool value);
  public:

  // optional bool age_queried = 18;
  bool has_age_queried() const;
  private:
  bool _internal_has_age_queried() const;
  public:
  void clear_age_queried();
  bool age_queried() const;
  void set_age_queried(bool value);
  private:
  bool _internal_age_queried() const;
  void _internal_set_age_queried(bool value);
  public:

  // optional bool age_restricted = 19 [default = false];
  bool has_age_restricted() const;
  private:
  bool _internal_has_age_restricted() const;
  public:
  void clear_age_restricted();
  bool age_restricted() const;
  void set_age_restricted(bool value);
  private:
  bool _internal_age_restricted() const;
  void _internal_set_age_restricted(bool value);
  public:

  // optional bool data_collection_consent_queried = 20;
  bool has_data_collection_consent_queried() const;
  private:
  bool _internal_has_data_collection_consent_queried() const;
  public:
  void clear_data_collection_consent_queried();
  bool data_collection_consent_queried() const;
  void set_data_collection_consent_queried(bool value);
  private:
  bool _internal_data_collection_consent_queried() const;
  void _internal_set_data_collection_consent_queried(bool value);
  public:

  // optional bool data_collection_consent_given = 21;
  bool has_data_collection_consent_given() const;
  private:
  bool _internal_has_data_collection_consent_given() const;
  public:
  void clear_data_collection_consent_given();
  bool data_collection_consent_given() const;
  void set_data_collection_consent_given(bool value);
  private:
  bool _internal_data_collection_consent_given() const;
  void _internal_set_data_collection_consent_given(bool value);
  public:

  // optional bool low_performance = 10;
  bool has_low_performance() const;
  private:
  bool _internal_has_low_performance() const;
  public:
  void clear_low_performance();
  bool low_performance() const;
  void set_low_performance(bool value);
  private:
  bool _internal_low_performance() const;
  void _internal_set_low_performance(bool value);
  public:

  // optional bool auto_stop_fueling = 25;
  bool has_auto_stop_fueling() const;
  private:
  bool _internal_has_auto_stop_fueling() const;
  public:
  void clear_auto_stop_fueling();
  bool auto_stop_fueling() const;
  void set_auto_stop_fueling(bool value);
  private:
  bool _internal_auto_stop_fueling() const;
  void _internal_set_auto_stop_fueling(bool value);
  public:

  // optional double last_backup_time = 24;
  bool has_last_backup_time() const;
  private:
  bool _internal_has_last_backup_time() const;
  public:
  void clear_last_backup_time();
  double last_backup_time() const;
  void set_last_backup_time(double value);
  private:
  double _internal_last_backup_time() const;
  void _internal_set_last_backup_time(double value);
  public:

  // optional bool user_ads_enabled = 14 [default = true];
  bool has_user_ads_enabled() const;
  private:
  bool _internal_has_user_ads_enabled() const;
  public:
  void clear_user_ads_enabled();
  bool user_ads_enabled() const;
  void set_user_ads_enabled(bool value);
  private:
  bool _internal_user_ads_enabled() const;
  void _internal_set_user_ads_enabled(bool value);
  public:

  // optional bool user_cloud_enabled = 15 [default = true];
  bool has_user_cloud_enabled() const;
  private:
  bool _internal_has_user_cloud_enabled() const;
  public:
  void clear_user_cloud_enabled();
  bool user_cloud_enabled() const;
  void set_user_cloud_enabled(bool value);
  private:
  bool _internal_user_cloud_enabled() const;
  void _internal_set_user_cloud_enabled(bool value);
  public:

  // optional bool user_analytics_enabled = 22 [default = true];
  bool has_user_analytics_enabled() const;
  private:
  bool _internal_has_user_analytics_enabled() const;
  public:
  void clear_user_analytics_enabled();
  bool user_analytics_enabled() const;
  void set_user_analytics_enabled(bool value);
  private:
  bool _internal_user_analytics_enabled() const;
  void _internal_set_user_analytics_enabled(bool value);
  public:

  // optional bool user_personalized_ads_enabled = 23 [default = true];
  bool has_user_personalized_ads_enabled() const;
  private:
  bool _internal_has_user_personalized_ads_enabled() const;
  public:
  void clear_user_personalized_ads_enabled();
  bool user_personalized_ads_enabled() const;
  void set_user_personalized_ads_enabled(bool value);
  private:
  bool _internal_user_personalized_ads_enabled() const;
  void _internal_set_user_personalized_ads_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ei.Backup.Settings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool sfx_;
  bool music_;
  bool low_battery_mode_;
  bool low_performance_mode_;
  bool force_touch_chicken_btn_;
  bool notifications_queried_;
  bool notifications_on_;
  bool notify_daily_gift_;
  bool coppa_queried_;
  bool coppa_restricted_;
  bool gdpr_consent_queried_;
  bool gdpr_age_restricted_;
  uint32_t last_day_age_queried_;
  bool gdpr_consent_given_;
  bool age_queried_;
  bool age_restricted_;
  bool data_collection_consent_queried_;
  bool data_collection_consent_given_;
  bool low_performance_;
  bool auto_stop_fueling_;
  double last_backup_time_;
  bool user_ads_enabled_;
  bool user_cloud_enabled_;
  bool user_analytics_enabled_;
  bool user_personalized_ads_enabled_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class Backup_Tutorial final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.Backup.Tutorial) */ {
 public:
  inline Backup_Tutorial() : Backup_Tutorial(nullptr) {}
  ~Backup_Tutorial() override;
  explicit constexpr Backup_Tutorial(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Backup_Tutorial(const Backup_Tutorial& from);
  Backup_Tutorial(Backup_Tutorial&& from) noexcept
    : Backup_Tutorial() {
    *this = ::std::move(from);
  }

  inline Backup_Tutorial& operator=(const Backup_Tutorial& from) {
    CopyFrom(from);
    return *this;
  }
  inline Backup_Tutorial& operator=(Backup_Tutorial&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Backup_Tutorial& default_instance() {
    return *internal_default_instance();
  }
  static inline const Backup_Tutorial* internal_default_instance() {
    return reinterpret_cast<const Backup_Tutorial*>(
               &_Backup_Tutorial_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Backup_Tutorial& a, Backup_Tutorial& b) {
    a.Swap(&b);
  }
  inline void Swap(Backup_Tutorial* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Backup_Tutorial* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Backup_Tutorial* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Backup_Tutorial>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Backup_Tutorial& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Backup_Tutorial& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Backup_Tutorial* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.Backup.Tutorial";
  }
  protected:
  explicit Backup_Tutorial(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTutorialShownFieldNumber = 11,
    kIntroShownFieldNumber = 1,
    kClickTutorialShownFieldNumber = 2,
    kBuyHabShownFieldNumber = 3,
    kHireVehicleShownFieldNumber = 4,
    kQNumShownFieldNumber = 5,
    kSNumShownFieldNumber = 6,
    kContractsTabShownFieldNumber = 7,
    kContractInfoShownFieldNumber = 8,
    kJoinCoopShownFieldNumber = 9,
    kSwitchFarmShownFieldNumber = 10,
  };
  // repeated bool tutorial_shown = 11;
  int tutorial_shown_size() const;
  private:
  int _internal_tutorial_shown_size() const;
  public:
  void clear_tutorial_shown();
  private:
  bool _internal_tutorial_shown(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_tutorial_shown() const;
  void _internal_add_tutorial_shown(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_tutorial_shown();
  public:
  bool tutorial_shown(int index) const;
  void set_tutorial_shown(int index, bool value);
  void add_tutorial_shown(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      tutorial_shown() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_tutorial_shown();

  // optional bool intro_shown = 1;
  bool has_intro_shown() const;
  private:
  bool _internal_has_intro_shown() const;
  public:
  void clear_intro_shown();
  bool intro_shown() const;
  void set_intro_shown(bool value);
  private:
  bool _internal_intro_shown() const;
  void _internal_set_intro_shown(bool value);
  public:

  // optional bool click_tutorial_shown = 2;
  bool has_click_tutorial_shown() const;
  private:
  bool _internal_has_click_tutorial_shown() const;
  public:
  void clear_click_tutorial_shown();
  bool click_tutorial_shown() const;
  void set_click_tutorial_shown(bool value);
  private:
  bool _internal_click_tutorial_shown() const;
  void _internal_set_click_tutorial_shown(bool value);
  public:

  // optional bool buy_hab_shown = 3;
  bool has_buy_hab_shown() const;
  private:
  bool _internal_has_buy_hab_shown() const;
  public:
  void clear_buy_hab_shown();
  bool buy_hab_shown() const;
  void set_buy_hab_shown(bool value);
  private:
  bool _internal_buy_hab_shown() const;
  void _internal_set_buy_hab_shown(bool value);
  public:

  // optional bool hire_vehicle_shown = 4;
  bool has_hire_vehicle_shown() const;
  private:
  bool _internal_has_hire_vehicle_shown() const;
  public:
  void clear_hire_vehicle_shown();
  bool hire_vehicle_shown() const;
  void set_hire_vehicle_shown(bool value);
  private:
  bool _internal_hire_vehicle_shown() const;
  void _internal_set_hire_vehicle_shown(bool value);
  public:

  // optional bool q_num_shown = 5;
  bool has_q_num_shown() const;
  private:
  bool _internal_has_q_num_shown() const;
  public:
  void clear_q_num_shown();
  bool q_num_shown() const;
  void set_q_num_shown(bool value);
  private:
  bool _internal_q_num_shown() const;
  void _internal_set_q_num_shown(bool value);
  public:

  // optional bool s_num_shown = 6;
  bool has_s_num_shown() const;
  private:
  bool _internal_has_s_num_shown() const;
  public:
  void clear_s_num_shown();
  bool s_num_shown() const;
  void set_s_num_shown(bool value);
  private:
  bool _internal_s_num_shown() const;
  void _internal_set_s_num_shown(bool value);
  public:

  // optional bool contracts_tab_shown = 7;
  bool has_contracts_tab_shown() const;
  private:
  bool _internal_has_contracts_tab_shown() const;
  public:
  void clear_contracts_tab_shown();
  bool contracts_tab_shown() const;
  void set_contracts_tab_shown(bool value);
  private:
  bool _internal_contracts_tab_shown() const;
  void _internal_set_contracts_tab_shown(bool value);
  public:

  // optional bool contract_info_shown = 8;
  bool has_contract_info_shown() const;
  private:
  bool _internal_has_contract_info_shown() const;
  public:
  void clear_contract_info_shown();
  bool contract_info_shown() const;
  void set_contract_info_shown(bool value);
  private:
  bool _internal_contract_info_shown() const;
  void _internal_set_contract_info_shown(bool value);
  public:

  // optional bool join_coop_shown = 9;
  bool has_join_coop_shown() const;
  private:
  bool _internal_has_join_coop_shown() const;
  public:
  void clear_join_coop_shown();
  bool join_coop_shown() const;
  void set_join_coop_shown(bool value);
  private:
  bool _internal_join_coop_shown() const;
  void _internal_set_join_coop_shown(bool value);
  public:

  // optional bool switch_farm_shown = 10;
  bool has_switch_farm_shown() const;
  private:
  bool _internal_has_switch_farm_shown() const;
  public:
  void clear_switch_farm_shown();
  bool switch_farm_shown() const;
  void set_switch_farm_shown(bool value);
  private:
  bool _internal_switch_farm_shown() const;
  void _internal_set_switch_farm_shown(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ei.Backup.Tutorial)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > tutorial_shown_;
  bool intro_shown_;
  bool click_tutorial_shown_;
  bool buy_hab_shown_;
  bool hire_vehicle_shown_;
  bool q_num_shown_;
  bool s_num_shown_;
  bool contracts_tab_shown_;
  bool contract_info_shown_;
  bool join_coop_shown_;
  bool switch_farm_shown_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class Backup_Stats final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.Backup.Stats) */ {
 public:
  inline Backup_Stats() : Backup_Stats(nullptr) {}
  ~Backup_Stats() override;
  explicit constexpr Backup_Stats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Backup_Stats(const Backup_Stats& from);
  Backup_Stats(Backup_Stats&& from) noexcept
    : Backup_Stats() {
    *this = ::std::move(from);
  }

  inline Backup_Stats& operator=(const Backup_Stats& from) {
    CopyFrom(from);
    return *this;
  }
  inline Backup_Stats& operator=(Backup_Stats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Backup_Stats& default_instance() {
    return *internal_default_instance();
  }
  static inline const Backup_Stats* internal_default_instance() {
    return reinterpret_cast<const Backup_Stats*>(
               &_Backup_Stats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Backup_Stats& a, Backup_Stats& b) {
    a.Swap(&b);
  }
  inline void Swap(Backup_Stats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Backup_Stats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Backup_Stats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Backup_Stats>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Backup_Stats& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Backup_Stats& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Backup_Stats* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.Backup.Stats";
  }
  protected:
  explicit Backup_Stats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEggTotalsOLDFieldNumber = 1,
    kEggTotalsFieldNumber = 8,
    kRefillUsesFieldNumber = 2,
    kVideoDoublerUsesFieldNumber = 3,
    kWarp1UsesFieldNumber = 4,
    kWarp8UsesFieldNumber = 5,
    kDroneTakedownsFieldNumber = 6,
    kUnlimitedChickensUsesFieldNumber = 7,
    kNumPrestigesFieldNumber = 9,
    kDroneTakedownsEliteFieldNumber = 10,
    kNumPiggyBreaksFieldNumber = 11,
    kIapPacksPurchasedFieldNumber = 12,
    kBoostsUsedFieldNumber = 13,
    kTimePiggyFilledRealtimeFieldNumber = 16,
    kTimePiggyFullGametimeFieldNumber = 17,
    kLostPiggyIncrementsFieldNumber = 18,
    kPiggyFullFieldNumber = 14,
    kPiggyFoundFullFieldNumber = 15,
  };
  // repeated uint64 egg_totals_OLD = 1;
  int egg_totals_old_size() const;
  private:
  int _internal_egg_totals_old_size() const;
  public:
  void clear_egg_totals_old();
  private:
  uint64_t _internal_egg_totals_old(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_egg_totals_old() const;
  void _internal_add_egg_totals_old(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_egg_totals_old();
  public:
  uint64_t egg_totals_old(int index) const;
  void set_egg_totals_old(int index, uint64_t value);
  void add_egg_totals_old(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      egg_totals_old() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_egg_totals_old();

  // repeated double egg_totals = 8;
  int egg_totals_size() const;
  private:
  int _internal_egg_totals_size() const;
  public:
  void clear_egg_totals();
  private:
  double _internal_egg_totals(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_egg_totals() const;
  void _internal_add_egg_totals(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_egg_totals();
  public:
  double egg_totals(int index) const;
  void set_egg_totals(int index, double value);
  void add_egg_totals(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      egg_totals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_egg_totals();

  // optional uint64 refill_uses = 2;
  bool has_refill_uses() const;
  private:
  bool _internal_has_refill_uses() const;
  public:
  void clear_refill_uses();
  uint64_t refill_uses() const;
  void set_refill_uses(uint64_t value);
  private:
  uint64_t _internal_refill_uses() const;
  void _internal_set_refill_uses(uint64_t value);
  public:

  // optional uint64 video_doubler_uses = 3;
  bool has_video_doubler_uses() const;
  private:
  bool _internal_has_video_doubler_uses() const;
  public:
  void clear_video_doubler_uses();
  uint64_t video_doubler_uses() const;
  void set_video_doubler_uses(uint64_t value);
  private:
  uint64_t _internal_video_doubler_uses() const;
  void _internal_set_video_doubler_uses(uint64_t value);
  public:

  // optional uint64 warp_1_uses = 4;
  bool has_warp_1_uses() const;
  private:
  bool _internal_has_warp_1_uses() const;
  public:
  void clear_warp_1_uses();
  uint64_t warp_1_uses() const;
  void set_warp_1_uses(uint64_t value);
  private:
  uint64_t _internal_warp_1_uses() const;
  void _internal_set_warp_1_uses(uint64_t value);
  public:

  // optional uint64 warp_8_uses = 5;
  bool has_warp_8_uses() const;
  private:
  bool _internal_has_warp_8_uses() const;
  public:
  void clear_warp_8_uses();
  uint64_t warp_8_uses() const;
  void set_warp_8_uses(uint64_t value);
  private:
  uint64_t _internal_warp_8_uses() const;
  void _internal_set_warp_8_uses(uint64_t value);
  public:

  // optional uint64 drone_takedowns = 6;
  bool has_drone_takedowns() const;
  private:
  bool _internal_has_drone_takedowns() const;
  public:
  void clear_drone_takedowns();
  uint64_t drone_takedowns() const;
  void set_drone_takedowns(uint64_t value);
  private:
  uint64_t _internal_drone_takedowns() const;
  void _internal_set_drone_takedowns(uint64_t value);
  public:

  // optional uint64 unlimited_chickens_uses = 7;
  bool has_unlimited_chickens_uses() const;
  private:
  bool _internal_has_unlimited_chickens_uses() const;
  public:
  void clear_unlimited_chickens_uses();
  uint64_t unlimited_chickens_uses() const;
  void set_unlimited_chickens_uses(uint64_t value);
  private:
  uint64_t _internal_unlimited_chickens_uses() const;
  void _internal_set_unlimited_chickens_uses(uint64_t value);
  public:

  // optional uint64 num_prestiges = 9;
  bool has_num_prestiges() const;
  private:
  bool _internal_has_num_prestiges() const;
  public:
  void clear_num_prestiges();
  uint64_t num_prestiges() const;
  void set_num_prestiges(uint64_t value);
  private:
  uint64_t _internal_num_prestiges() const;
  void _internal_set_num_prestiges(uint64_t value);
  public:

  // optional uint64 drone_takedowns_elite = 10;
  bool has_drone_takedowns_elite() const;
  private:
  bool _internal_has_drone_takedowns_elite() const;
  public:
  void clear_drone_takedowns_elite();
  uint64_t drone_takedowns_elite() const;
  void set_drone_takedowns_elite(uint64_t value);
  private:
  uint64_t _internal_drone_takedowns_elite() const;
  void _internal_set_drone_takedowns_elite(uint64_t value);
  public:

  // optional uint64 num_piggy_breaks = 11;
  bool has_num_piggy_breaks() const;
  private:
  bool _internal_has_num_piggy_breaks() const;
  public:
  void clear_num_piggy_breaks();
  uint64_t num_piggy_breaks() const;
  void set_num_piggy_breaks(uint64_t value);
  private:
  uint64_t _internal_num_piggy_breaks() const;
  void _internal_set_num_piggy_breaks(uint64_t value);
  public:

  // optional uint64 iap_packs_purchased = 12;
  bool has_iap_packs_purchased() const;
  private:
  bool _internal_has_iap_packs_purchased() const;
  public:
  void clear_iap_packs_purchased();
  uint64_t iap_packs_purchased() const;
  void set_iap_packs_purchased(uint64_t value);
  private:
  uint64_t _internal_iap_packs_purchased() const;
  void _internal_set_iap_packs_purchased(uint64_t value);
  public:

  // optional uint64 boosts_used = 13;
  bool has_boosts_used() const;
  private:
  bool _internal_has_boosts_used() const;
  public:
  void clear_boosts_used();
  uint64_t boosts_used() const;
  void set_boosts_used(uint64_t value);
  private:
  uint64_t _internal_boosts_used() const;
  void _internal_set_boosts_used(uint64_t value);
  public:

  // optional double time_piggy_filled_realtime = 16;
  bool has_time_piggy_filled_realtime() const;
  private:
  bool _internal_has_time_piggy_filled_realtime() const;
  public:
  void clear_time_piggy_filled_realtime();
  double time_piggy_filled_realtime() const;
  void set_time_piggy_filled_realtime(double value);
  private:
  double _internal_time_piggy_filled_realtime() const;
  void _internal_set_time_piggy_filled_realtime(double value);
  public:

  // optional double time_piggy_full_gametime = 17;
  bool has_time_piggy_full_gametime() const;
  private:
  bool _internal_has_time_piggy_full_gametime() const;
  public:
  void clear_time_piggy_full_gametime();
  double time_piggy_full_gametime() const;
  void set_time_piggy_full_gametime(double value);
  private:
  double _internal_time_piggy_full_gametime() const;
  void _internal_set_time_piggy_full_gametime(double value);
  public:

  // optional uint64 lost_piggy_increments = 18;
  bool has_lost_piggy_increments() const;
  private:
  bool _internal_has_lost_piggy_increments() const;
  public:
  void clear_lost_piggy_increments();
  uint64_t lost_piggy_increments() const;
  void set_lost_piggy_increments(uint64_t value);
  private:
  uint64_t _internal_lost_piggy_increments() const;
  void _internal_set_lost_piggy_increments(uint64_t value);
  public:

  // optional bool piggy_full = 14;
  bool has_piggy_full() const;
  private:
  bool _internal_has_piggy_full() const;
  public:
  void clear_piggy_full();
  bool piggy_full() const;
  void set_piggy_full(bool value);
  private:
  bool _internal_piggy_full() const;
  void _internal_set_piggy_full(bool value);
  public:

  // optional bool piggy_found_full = 15;
  bool has_piggy_found_full() const;
  private:
  bool _internal_has_piggy_found_full() const;
  public:
  void clear_piggy_found_full();
  bool piggy_found_full() const;
  void set_piggy_found_full(bool value);
  private:
  bool _internal_piggy_found_full() const;
  void _internal_set_piggy_found_full(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ei.Backup.Stats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > egg_totals_old_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > egg_totals_;
  uint64_t refill_uses_;
  uint64_t video_doubler_uses_;
  uint64_t warp_1_uses_;
  uint64_t warp_8_uses_;
  uint64_t drone_takedowns_;
  uint64_t unlimited_chickens_uses_;
  uint64_t num_prestiges_;
  uint64_t drone_takedowns_elite_;
  uint64_t num_piggy_breaks_;
  uint64_t iap_packs_purchased_;
  uint64_t boosts_used_;
  double time_piggy_filled_realtime_;
  double time_piggy_full_gametime_;
  uint64_t lost_piggy_increments_;
  bool piggy_full_;
  bool piggy_found_full_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class Backup_Game final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.Backup.Game) */ {
 public:
  inline Backup_Game() : Backup_Game(nullptr) {}
  ~Backup_Game() override;
  explicit constexpr Backup_Game(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Backup_Game(const Backup_Game& from);
  Backup_Game(Backup_Game&& from) noexcept
    : Backup_Game() {
    *this = ::std::move(from);
  }

  inline Backup_Game& operator=(const Backup_Game& from) {
    CopyFrom(from);
    return *this;
  }
  inline Backup_Game& operator=(Backup_Game&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Backup_Game& default_instance() {
    return *internal_default_instance();
  }
  static inline const Backup_Game* internal_default_instance() {
    return reinterpret_cast<const Backup_Game*>(
               &_Backup_Game_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Backup_Game& a, Backup_Game& b) {
    a.Swap(&b);
  }
  inline void Swap(Backup_Game* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Backup_Game* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Backup_Game* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Backup_Game>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Backup_Game& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Backup_Game& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Backup_Game* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.Backup.Game";
  }
  protected:
  explicit Backup_Game(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEpicResearchFieldNumber = 9,
    kNewsFieldNumber = 11,
    kAchievementsFieldNumber = 15,
    kMaxFarmSizeReachedFieldNumber = 18,
    kEggMedalLevelFieldNumber = 19,
    kBoostsFieldNumber = 30,
    kGoldenEggsEarnedFieldNumber = 2,
    kGoldenEggsSpentFieldNumber = 3,
    kSoulEggsFieldNumber = 4,
    kPrestigeCashEarnedFieldNumber = 5,
    kLifetimeCashEarnedFieldNumber = 6,
    kPiggyBankFieldNumber = 7,
    kNextDailyGiftTimeFieldNumber = 10,
    kLastNewsTimeFieldNumber = 12,
    kCurrentMultiplierFieldNumber = 13,
    kCurrentMultiplierExpirationFieldNumber = 14,
    kPermitLevelFieldNumber = 8,
    kLastDailyGiftCollectedDayFieldNumber = 20,
    kUncliamedGoldenEggsFieldNumber = 16,
    kUnclaimedSoulEggsFieldNumber = 17,
    kEggsOfProphecyFieldNumber = 23,
    kUnclaimedEggsOfProphecyFieldNumber = 24,
    kCurrentFarmFieldNumber = 22,
    kNumDailyGiftsCollectedFieldNumber = 28,
    kLongIdleNotificationThresholdFieldNumber = 26,
    kLongIdleRewardFieldNumber = 27,
    kPiggyFullAlertShownFieldNumber = 31,
    kHyperloopStationFieldNumber = 29,
    kLongIdleNotificationSetFieldNumber = 25,
    kForceEliteContractsFieldNumber = 36,
    kTotalTimeCheatsDetectedFieldNumber = 32,
    kPrestigeSoulBoostCashFieldNumber = 33,
    kSoulEggsDFieldNumber = 34,
    kUnclaimedSoulEggsDFieldNumber = 35,
    kNewPlayerEventEndTimeFieldNumber = 37,
    kShellScriptsEarnedFieldNumber = 38,
    kShellScriptsSpentFieldNumber = 39,
    kUnclaimedShellScriptsFieldNumber = 40,
    kMaxEggReachedFieldNumber = 1,
  };
  // repeated .ei.Backup.ResearchItem epic_research = 9;
  int epic_research_size() const;
  private:
  int _internal_epic_research_size() const;
  public:
  void clear_epic_research();
  ::ei::Backup_ResearchItem* mutable_epic_research(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_ResearchItem >*
      mutable_epic_research();
  private:
  const ::ei::Backup_ResearchItem& _internal_epic_research(int index) const;
  ::ei::Backup_ResearchItem* _internal_add_epic_research();
  public:
  const ::ei::Backup_ResearchItem& epic_research(int index) const;
  ::ei::Backup_ResearchItem* add_epic_research();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_ResearchItem >&
      epic_research() const;

  // repeated .ei.Backup.NewsHeadline news = 11;
  int news_size() const;
  private:
  int _internal_news_size() const;
  public:
  void clear_news();
  ::ei::Backup_NewsHeadline* mutable_news(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_NewsHeadline >*
      mutable_news();
  private:
  const ::ei::Backup_NewsHeadline& _internal_news(int index) const;
  ::ei::Backup_NewsHeadline* _internal_add_news();
  public:
  const ::ei::Backup_NewsHeadline& news(int index) const;
  ::ei::Backup_NewsHeadline* add_news();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_NewsHeadline >&
      news() const;

  // repeated .ei.Backup.AchievementInfo achievements = 15;
  int achievements_size() const;
  private:
  int _internal_achievements_size() const;
  public:
  void clear_achievements();
  ::ei::Backup_AchievementInfo* mutable_achievements(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_AchievementInfo >*
      mutable_achievements();
  private:
  const ::ei::Backup_AchievementInfo& _internal_achievements(int index) const;
  ::ei::Backup_AchievementInfo* _internal_add_achievements();
  public:
  const ::ei::Backup_AchievementInfo& achievements(int index) const;
  ::ei::Backup_AchievementInfo* add_achievements();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_AchievementInfo >&
      achievements() const;

  // repeated uint64 max_farm_size_reached = 18;
  int max_farm_size_reached_size() const;
  private:
  int _internal_max_farm_size_reached_size() const;
  public:
  void clear_max_farm_size_reached();
  private:
  uint64_t _internal_max_farm_size_reached(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_max_farm_size_reached() const;
  void _internal_add_max_farm_size_reached(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_max_farm_size_reached();
  public:
  uint64_t max_farm_size_reached(int index) const;
  void set_max_farm_size_reached(int index, uint64_t value);
  void add_max_farm_size_reached(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      max_farm_size_reached() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_max_farm_size_reached();

  // repeated uint32 egg_medal_level = 19;
  int egg_medal_level_size() const;
  private:
  int _internal_egg_medal_level_size() const;
  public:
  void clear_egg_medal_level();
  private:
  uint32_t _internal_egg_medal_level(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_egg_medal_level() const;
  void _internal_add_egg_medal_level(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_egg_medal_level();
  public:
  uint32_t egg_medal_level(int index) const;
  void set_egg_medal_level(int index, uint32_t value);
  void add_egg_medal_level(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      egg_medal_level() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_egg_medal_level();

  // repeated .ei.Backup.OwnedBoost boosts = 30;
  int boosts_size() const;
  private:
  int _internal_boosts_size() const;
  public:
  void clear_boosts();
  ::ei::Backup_OwnedBoost* mutable_boosts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_OwnedBoost >*
      mutable_boosts();
  private:
  const ::ei::Backup_OwnedBoost& _internal_boosts(int index) const;
  ::ei::Backup_OwnedBoost* _internal_add_boosts();
  public:
  const ::ei::Backup_OwnedBoost& boosts(int index) const;
  ::ei::Backup_OwnedBoost* add_boosts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_OwnedBoost >&
      boosts() const;

  // optional uint64 golden_eggs_earned = 2;
  bool has_golden_eggs_earned() const;
  private:
  bool _internal_has_golden_eggs_earned() const;
  public:
  void clear_golden_eggs_earned();
  uint64_t golden_eggs_earned() const;
  void set_golden_eggs_earned(uint64_t value);
  private:
  uint64_t _internal_golden_eggs_earned() const;
  void _internal_set_golden_eggs_earned(uint64_t value);
  public:

  // optional uint64 golden_eggs_spent = 3;
  bool has_golden_eggs_spent() const;
  private:
  bool _internal_has_golden_eggs_spent() const;
  public:
  void clear_golden_eggs_spent();
  uint64_t golden_eggs_spent() const;
  void set_golden_eggs_spent(uint64_t value);
  private:
  uint64_t _internal_golden_eggs_spent() const;
  void _internal_set_golden_eggs_spent(uint64_t value);
  public:

  // optional uint64 soul_eggs = 4;
  bool has_soul_eggs() const;
  private:
  bool _internal_has_soul_eggs() const;
  public:
  void clear_soul_eggs();
  uint64_t soul_eggs() const;
  void set_soul_eggs(uint64_t value);
  private:
  uint64_t _internal_soul_eggs() const;
  void _internal_set_soul_eggs(uint64_t value);
  public:

  // optional double prestige_cash_earned = 5;
  bool has_prestige_cash_earned() const;
  private:
  bool _internal_has_prestige_cash_earned() const;
  public:
  void clear_prestige_cash_earned();
  double prestige_cash_earned() const;
  void set_prestige_cash_earned(double value);
  private:
  double _internal_prestige_cash_earned() const;
  void _internal_set_prestige_cash_earned(double value);
  public:

  // optional double lifetime_cash_earned = 6;
  bool has_lifetime_cash_earned() const;
  private:
  bool _internal_has_lifetime_cash_earned() const;
  public:
  void clear_lifetime_cash_earned();
  double lifetime_cash_earned() const;
  void set_lifetime_cash_earned(double value);
  private:
  double _internal_lifetime_cash_earned() const;
  void _internal_set_lifetime_cash_earned(double value);
  public:

  // optional uint64 piggy_bank = 7;
  bool has_piggy_bank() const;
  private:
  bool _internal_has_piggy_bank() const;
  public:
  void clear_piggy_bank();
  uint64_t piggy_bank() const;
  void set_piggy_bank(uint64_t value);
  private:
  uint64_t _internal_piggy_bank() const;
  void _internal_set_piggy_bank(uint64_t value);
  public:

  // optional double next_daily_gift_time = 10;
  bool has_next_daily_gift_time() const;
  private:
  bool _internal_has_next_daily_gift_time() const;
  public:
  void clear_next_daily_gift_time();
  double next_daily_gift_time() const;
  void set_next_daily_gift_time(double value);
  private:
  double _internal_next_daily_gift_time() const;
  void _internal_set_next_daily_gift_time(double value);
  public:

  // optional double last_news_time = 12;
  bool has_last_news_time() const;
  private:
  bool _internal_has_last_news_time() const;
  public:
  void clear_last_news_time();
  double last_news_time() const;
  void set_last_news_time(double value);
  private:
  double _internal_last_news_time() const;
  void _internal_set_last_news_time(double value);
  public:

  // optional double current_multiplier = 13;
  bool has_current_multiplier() const;
  private:
  bool _internal_has_current_multiplier() const;
  public:
  void clear_current_multiplier();
  double current_multiplier() const;
  void set_current_multiplier(double value);
  private:
  double _internal_current_multiplier() const;
  void _internal_set_current_multiplier(double value);
  public:

  // optional double current_multiplier_expiration = 14;
  bool has_current_multiplier_expiration() const;
  private:
  bool _internal_has_current_multiplier_expiration() const;
  public:
  void clear_current_multiplier_expiration();
  double current_multiplier_expiration() const;
  void set_current_multiplier_expiration(double value);
  private:
  double _internal_current_multiplier_expiration() const;
  void _internal_set_current_multiplier_expiration(double value);
  public:

  // optional uint32 permit_level = 8;
  bool has_permit_level() const;
  private:
  bool _internal_has_permit_level() const;
  public:
  void clear_permit_level();
  uint32_t permit_level() const;
  void set_permit_level(uint32_t value);
  private:
  uint32_t _internal_permit_level() const;
  void _internal_set_permit_level(uint32_t value);
  public:

  // optional uint32 last_daily_gift_collected_day = 20;
  bool has_last_daily_gift_collected_day() const;
  private:
  bool _internal_has_last_daily_gift_collected_day() const;
  public:
  void clear_last_daily_gift_collected_day();
  uint32_t last_daily_gift_collected_day() const;
  void set_last_daily_gift_collected_day(uint32_t value);
  private:
  uint32_t _internal_last_daily_gift_collected_day() const;
  void _internal_set_last_daily_gift_collected_day(uint32_t value);
  public:

  // optional uint64 uncliamed_golden_eggs = 16;
  bool has_uncliamed_golden_eggs() const;
  private:
  bool _internal_has_uncliamed_golden_eggs() const;
  public:
  void clear_uncliamed_golden_eggs();
  uint64_t uncliamed_golden_eggs() const;
  void set_uncliamed_golden_eggs(uint64_t value);
  private:
  uint64_t _internal_uncliamed_golden_eggs() const;
  void _internal_set_uncliamed_golden_eggs(uint64_t value);
  public:

  // optional uint64 unclaimed_soul_eggs = 17;
  bool has_unclaimed_soul_eggs() const;
  private:
  bool _internal_has_unclaimed_soul_eggs() const;
  public:
  void clear_unclaimed_soul_eggs();
  uint64_t unclaimed_soul_eggs() const;
  void set_unclaimed_soul_eggs(uint64_t value);
  private:
  uint64_t _internal_unclaimed_soul_eggs() const;
  void _internal_set_unclaimed_soul_eggs(uint64_t value);
  public:

  // optional uint64 eggs_of_prophecy = 23;
  bool has_eggs_of_prophecy() const;
  private:
  bool _internal_has_eggs_of_prophecy() const;
  public:
  void clear_eggs_of_prophecy();
  uint64_t eggs_of_prophecy() const;
  void set_eggs_of_prophecy(uint64_t value);
  private:
  uint64_t _internal_eggs_of_prophecy() const;
  void _internal_set_eggs_of_prophecy(uint64_t value);
  public:

  // optional uint64 unclaimed_eggs_of_prophecy = 24;
  bool has_unclaimed_eggs_of_prophecy() const;
  private:
  bool _internal_has_unclaimed_eggs_of_prophecy() const;
  public:
  void clear_unclaimed_eggs_of_prophecy();
  uint64_t unclaimed_eggs_of_prophecy() const;
  void set_unclaimed_eggs_of_prophecy(uint64_t value);
  private:
  uint64_t _internal_unclaimed_eggs_of_prophecy() const;
  void _internal_set_unclaimed_eggs_of_prophecy(uint64_t value);
  public:

  // optional uint32 current_farm = 22 [default = 0];
  bool has_current_farm() const;
  private:
  bool _internal_has_current_farm() const;
  public:
  void clear_current_farm();
  uint32_t current_farm() const;
  void set_current_farm(uint32_t value);
  private:
  uint32_t _internal_current_farm() const;
  void _internal_set_current_farm(uint32_t value);
  public:

  // optional uint32 num_daily_gifts_collected = 28;
  bool has_num_daily_gifts_collected() const;
  private:
  bool _internal_has_num_daily_gifts_collected() const;
  public:
  void clear_num_daily_gifts_collected();
  uint32_t num_daily_gifts_collected() const;
  void set_num_daily_gifts_collected(uint32_t value);
  private:
  uint32_t _internal_num_daily_gifts_collected() const;
  void _internal_set_num_daily_gifts_collected(uint32_t value);
  public:

  // optional double long_idle_notification_threshold = 26;
  bool has_long_idle_notification_threshold() const;
  private:
  bool _internal_has_long_idle_notification_threshold() const;
  public:
  void clear_long_idle_notification_threshold();
  double long_idle_notification_threshold() const;
  void set_long_idle_notification_threshold(double value);
  private:
  double _internal_long_idle_notification_threshold() const;
  void _internal_set_long_idle_notification_threshold(double value);
  public:

  // optional double long_idle_reward = 27;
  bool has_long_idle_reward() const;
  private:
  bool _internal_has_long_idle_reward() const;
  public:
  void clear_long_idle_reward();
  double long_idle_reward() const;
  void set_long_idle_reward(double value);
  private:
  double _internal_long_idle_reward() const;
  void _internal_set_long_idle_reward(double value);
  public:

  // optional bool piggy_full_alert_shown = 31;
  bool has_piggy_full_alert_shown() const;
  private:
  bool _internal_has_piggy_full_alert_shown() const;
  public:
  void clear_piggy_full_alert_shown();
  bool piggy_full_alert_shown() const;
  void set_piggy_full_alert_shown(bool value);
  private:
  bool _internal_piggy_full_alert_shown() const;
  void _internal_set_piggy_full_alert_shown(bool value);
  public:

  // optional bool hyperloop_station = 29;
  bool has_hyperloop_station() const;
  private:
  bool _internal_has_hyperloop_station() const;
  public:
  void clear_hyperloop_station();
  bool hyperloop_station() const;
  void set_hyperloop_station(bool value);
  private:
  bool _internal_hyperloop_station() const;
  void _internal_set_hyperloop_station(bool value);
  public:

  // optional bool long_idle_notification_set = 25;
  bool has_long_idle_notification_set() const;
  private:
  bool _internal_has_long_idle_notification_set() const;
  public:
  void clear_long_idle_notification_set();
  bool long_idle_notification_set() const;
  void set_long_idle_notification_set(bool value);
  private:
  bool _internal_long_idle_notification_set() const;
  void _internal_set_long_idle_notification_set(bool value);
  public:

  // optional bool force_elite_contracts = 36;
  bool has_force_elite_contracts() const;
  private:
  bool _internal_has_force_elite_contracts() const;
  public:
  void clear_force_elite_contracts();
  bool force_elite_contracts() const;
  void set_force_elite_contracts(bool value);
  private:
  bool _internal_force_elite_contracts() const;
  void _internal_set_force_elite_contracts(bool value);
  public:

  // optional uint32 total_time_cheats_detected = 32;
  bool has_total_time_cheats_detected() const;
  private:
  bool _internal_has_total_time_cheats_detected() const;
  public:
  void clear_total_time_cheats_detected();
  uint32_t total_time_cheats_detected() const;
  void set_total_time_cheats_detected(uint32_t value);
  private:
  uint32_t _internal_total_time_cheats_detected() const;
  void _internal_set_total_time_cheats_detected(uint32_t value);
  public:

  // optional double prestige_soul_boost_cash = 33;
  bool has_prestige_soul_boost_cash() const;
  private:
  bool _internal_has_prestige_soul_boost_cash() const;
  public:
  void clear_prestige_soul_boost_cash();
  double prestige_soul_boost_cash() const;
  void set_prestige_soul_boost_cash(double value);
  private:
  double _internal_prestige_soul_boost_cash() const;
  void _internal_set_prestige_soul_boost_cash(double value);
  public:

  // optional double soul_eggs_d = 34;
  bool has_soul_eggs_d() const;
  private:
  bool _internal_has_soul_eggs_d() const;
  public:
  void clear_soul_eggs_d();
  double soul_eggs_d() const;
  void set_soul_eggs_d(double value);
  private:
  double _internal_soul_eggs_d() const;
  void _internal_set_soul_eggs_d(double value);
  public:

  // optional double unclaimed_soul_eggs_d = 35;
  bool has_unclaimed_soul_eggs_d() const;
  private:
  bool _internal_has_unclaimed_soul_eggs_d() const;
  public:
  void clear_unclaimed_soul_eggs_d();
  double unclaimed_soul_eggs_d() const;
  void set_unclaimed_soul_eggs_d(double value);
  private:
  double _internal_unclaimed_soul_eggs_d() const;
  void _internal_set_unclaimed_soul_eggs_d(double value);
  public:

  // optional double new_player_event_end_time = 37;
  bool has_new_player_event_end_time() const;
  private:
  bool _internal_has_new_player_event_end_time() const;
  public:
  void clear_new_player_event_end_time();
  double new_player_event_end_time() const;
  void set_new_player_event_end_time(double value);
  private:
  double _internal_new_player_event_end_time() const;
  void _internal_set_new_player_event_end_time(double value);
  public:

  // optional uint64 shell_scripts_earned = 38;
  bool has_shell_scripts_earned() const;
  private:
  bool _internal_has_shell_scripts_earned() const;
  public:
  void clear_shell_scripts_earned();
  uint64_t shell_scripts_earned() const;
  void set_shell_scripts_earned(uint64_t value);
  private:
  uint64_t _internal_shell_scripts_earned() const;
  void _internal_set_shell_scripts_earned(uint64_t value);
  public:

  // optional uint64 shell_scripts_spent = 39;
  bool has_shell_scripts_spent() const;
  private:
  bool _internal_has_shell_scripts_spent() const;
  public:
  void clear_shell_scripts_spent();
  uint64_t shell_scripts_spent() const;
  void set_shell_scripts_spent(uint64_t value);
  private:
  uint64_t _internal_shell_scripts_spent() const;
  void _internal_set_shell_scripts_spent(uint64_t value);
  public:

  // optional uint64 unclaimed_shell_scripts = 40;
  bool has_unclaimed_shell_scripts() const;
  private:
  bool _internal_has_unclaimed_shell_scripts() const;
  public:
  void clear_unclaimed_shell_scripts();
  uint64_t unclaimed_shell_scripts() const;
  void set_unclaimed_shell_scripts(uint64_t value);
  private:
  uint64_t _internal_unclaimed_shell_scripts() const;
  void _internal_set_unclaimed_shell_scripts(uint64_t value);
  public:

  // optional .ei.Egg max_egg_reached = 1;
  bool has_max_egg_reached() const;
  private:
  bool _internal_has_max_egg_reached() const;
  public:
  void clear_max_egg_reached();
  ::ei::Egg max_egg_reached() const;
  void set_max_egg_reached(::ei::Egg value);
  private:
  ::ei::Egg _internal_max_egg_reached() const;
  void _internal_set_max_egg_reached(::ei::Egg value);
  public:

  // @@protoc_insertion_point(class_scope:ei.Backup.Game)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_ResearchItem > epic_research_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_NewsHeadline > news_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_AchievementInfo > achievements_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > max_farm_size_reached_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > egg_medal_level_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_OwnedBoost > boosts_;
  uint64_t golden_eggs_earned_;
  uint64_t golden_eggs_spent_;
  uint64_t soul_eggs_;
  double prestige_cash_earned_;
  double lifetime_cash_earned_;
  uint64_t piggy_bank_;
  double next_daily_gift_time_;
  double last_news_time_;
  double current_multiplier_;
  double current_multiplier_expiration_;
  uint32_t permit_level_;
  uint32_t last_daily_gift_collected_day_;
  uint64_t uncliamed_golden_eggs_;
  uint64_t unclaimed_soul_eggs_;
  uint64_t eggs_of_prophecy_;
  uint64_t unclaimed_eggs_of_prophecy_;
  uint32_t current_farm_;
  uint32_t num_daily_gifts_collected_;
  double long_idle_notification_threshold_;
  double long_idle_reward_;
  bool piggy_full_alert_shown_;
  bool hyperloop_station_;
  bool long_idle_notification_set_;
  bool force_elite_contracts_;
  uint32_t total_time_cheats_detected_;
  double prestige_soul_boost_cash_;
  double soul_eggs_d_;
  double unclaimed_soul_eggs_d_;
  double new_player_event_end_time_;
  uint64_t shell_scripts_earned_;
  uint64_t shell_scripts_spent_;
  uint64_t unclaimed_shell_scripts_;
  int max_egg_reached_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class Backup_Artifacts final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.Backup.Artifacts) */ {
 public:
  inline Backup_Artifacts() : Backup_Artifacts(nullptr) {}
  ~Backup_Artifacts() override;
  explicit constexpr Backup_Artifacts(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Backup_Artifacts(const Backup_Artifacts& from);
  Backup_Artifacts(Backup_Artifacts&& from) noexcept
    : Backup_Artifacts() {
    *this = ::std::move(from);
  }

  inline Backup_Artifacts& operator=(const Backup_Artifacts& from) {
    CopyFrom(from);
    return *this;
  }
  inline Backup_Artifacts& operator=(Backup_Artifacts&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Backup_Artifacts& default_instance() {
    return *internal_default_instance();
  }
  static inline const Backup_Artifacts* internal_default_instance() {
    return reinterpret_cast<const Backup_Artifacts*>(
               &_Backup_Artifacts_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Backup_Artifacts& a, Backup_Artifacts& b) {
    a.Swap(&b);
  }
  inline void Swap(Backup_Artifacts* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Backup_Artifacts* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Backup_Artifacts* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Backup_Artifacts>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Backup_Artifacts& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Backup_Artifacts& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Backup_Artifacts* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.Backup.Artifacts";
  }
  protected:
  explicit Backup_Artifacts(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTankFuelsFieldNumber = 16,
    kItemBeingInfusedFieldNumber = 2,
    kSpecBeingInfusedFieldNumber = 13,
    kInfusingEggsRequiredFieldNumber = 4,
    kEggsInfusedFieldNumber = 5,
    kLastFueledShipFieldNumber = 9,
    kInfusingFieldNumber = 1,
    kTankFillingEnabledFieldNumber = 14,
    kEnabledFieldNumber = 11,
    kIntroShownFieldNumber = 12,
    kInventoryScoreFieldNumber = 10,
    kTankLevelFieldNumber = 15,
    kFlowPercentageArtifactsFieldNumber = 6,
    kEggTypeInfusingFieldNumber = 3,
    kFuelingEnabledFieldNumber = 7,
    kInfusingEnabledDEPRECATEDFieldNumber = 8,
  };
  // repeated double tank_fuels = 16;
  int tank_fuels_size() const;
  private:
  int _internal_tank_fuels_size() const;
  public:
  void clear_tank_fuels();
  private:
  double _internal_tank_fuels(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_tank_fuels() const;
  void _internal_add_tank_fuels(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_tank_fuels();
  public:
  double tank_fuels(int index) const;
  void set_tank_fuels(int index, double value);
  void add_tank_fuels(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      tank_fuels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_tank_fuels();

  // optional .ei.ArtifactInventoryItem item_being_infused = 2;
  bool has_item_being_infused() const;
  private:
  bool _internal_has_item_being_infused() const;
  public:
  void clear_item_being_infused();
  const ::ei::ArtifactInventoryItem& item_being_infused() const;
  PROTOBUF_NODISCARD ::ei::ArtifactInventoryItem* release_item_being_infused();
  ::ei::ArtifactInventoryItem* mutable_item_being_infused();
  void set_allocated_item_being_infused(::ei::ArtifactInventoryItem* item_being_infused);
  private:
  const ::ei::ArtifactInventoryItem& _internal_item_being_infused() const;
  ::ei::ArtifactInventoryItem* _internal_mutable_item_being_infused();
  public:
  void unsafe_arena_set_allocated_item_being_infused(
      ::ei::ArtifactInventoryItem* item_being_infused);
  ::ei::ArtifactInventoryItem* unsafe_arena_release_item_being_infused();

  // optional .ei.ArtifactSpec spec_being_infused = 13;
  bool has_spec_being_infused() const;
  private:
  bool _internal_has_spec_being_infused() const;
  public:
  void clear_spec_being_infused();
  const ::ei::ArtifactSpec& spec_being_infused() const;
  PROTOBUF_NODISCARD ::ei::ArtifactSpec* release_spec_being_infused();
  ::ei::ArtifactSpec* mutable_spec_being_infused();
  void set_allocated_spec_being_infused(::ei::ArtifactSpec* spec_being_infused);
  private:
  const ::ei::ArtifactSpec& _internal_spec_being_infused() const;
  ::ei::ArtifactSpec* _internal_mutable_spec_being_infused();
  public:
  void unsafe_arena_set_allocated_spec_being_infused(
      ::ei::ArtifactSpec* spec_being_infused);
  ::ei::ArtifactSpec* unsafe_arena_release_spec_being_infused();

  // optional double infusing_eggs_required = 4;
  bool has_infusing_eggs_required() const;
  private:
  bool _internal_has_infusing_eggs_required() const;
  public:
  void clear_infusing_eggs_required();
  double infusing_eggs_required() const;
  void set_infusing_eggs_required(double value);
  private:
  double _internal_infusing_eggs_required() const;
  void _internal_set_infusing_eggs_required(double value);
  public:

  // optional double eggs_infused = 5;
  bool has_eggs_infused() const;
  private:
  bool _internal_has_eggs_infused() const;
  public:
  void clear_eggs_infused();
  double eggs_infused() const;
  void set_eggs_infused(double value);
  private:
  double _internal_eggs_infused() const;
  void _internal_set_eggs_infused(double value);
  public:

  // optional .ei.MissionInfo.Spaceship last_fueled_ship = 9;
  bool has_last_fueled_ship() const;
  private:
  bool _internal_has_last_fueled_ship() const;
  public:
  void clear_last_fueled_ship();
  ::ei::MissionInfo_Spaceship last_fueled_ship() const;
  void set_last_fueled_ship(::ei::MissionInfo_Spaceship value);
  private:
  ::ei::MissionInfo_Spaceship _internal_last_fueled_ship() const;
  void _internal_set_last_fueled_ship(::ei::MissionInfo_Spaceship value);
  public:

  // optional bool infusing = 1;
  bool has_infusing() const;
  private:
  bool _internal_has_infusing() const;
  public:
  void clear_infusing();
  bool infusing() const;
  void set_infusing(bool value);
  private:
  bool _internal_infusing() const;
  void _internal_set_infusing(bool value);
  public:

  // optional bool tank_filling_enabled = 14;
  bool has_tank_filling_enabled() const;
  private:
  bool _internal_has_tank_filling_enabled() const;
  public:
  void clear_tank_filling_enabled();
  bool tank_filling_enabled() const;
  void set_tank_filling_enabled(bool value);
  private:
  bool _internal_tank_filling_enabled() const;
  void _internal_set_tank_filling_enabled(bool value);
  public:

  // optional bool enabled = 11;
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // optional bool intro_shown = 12;
  bool has_intro_shown() const;
  private:
  bool _internal_has_intro_shown() const;
  public:
  void clear_intro_shown();
  bool intro_shown() const;
  void set_intro_shown(bool value);
  private:
  bool _internal_intro_shown() const;
  void _internal_set_intro_shown(bool value);
  public:

  // optional double inventory_score = 10;
  bool has_inventory_score() const;
  private:
  bool _internal_has_inventory_score() const;
  public:
  void clear_inventory_score();
  double inventory_score() const;
  void set_inventory_score(double value);
  private:
  double _internal_inventory_score() const;
  void _internal_set_inventory_score(double value);
  public:

  // optional uint32 tank_level = 15;
  bool has_tank_level() const;
  private:
  bool _internal_has_tank_level() const;
  public:
  void clear_tank_level();
  uint32_t tank_level() const;
  void set_tank_level(uint32_t value);
  private:
  uint32_t _internal_tank_level() const;
  void _internal_set_tank_level(uint32_t value);
  public:

  // optional double flow_percentage_artifacts = 6 [default = 0.5];
  bool has_flow_percentage_artifacts() const;
  private:
  bool _internal_has_flow_percentage_artifacts() const;
  public:
  void clear_flow_percentage_artifacts();
  double flow_percentage_artifacts() const;
  void set_flow_percentage_artifacts(double value);
  private:
  double _internal_flow_percentage_artifacts() const;
  void _internal_set_flow_percentage_artifacts(double value);
  public:

  // optional .ei.Egg egg_type_infusing = 3;
  bool has_egg_type_infusing() const;
  private:
  bool _internal_has_egg_type_infusing() const;
  public:
  void clear_egg_type_infusing();
  ::ei::Egg egg_type_infusing() const;
  void set_egg_type_infusing(::ei::Egg value);
  private:
  ::ei::Egg _internal_egg_type_infusing() const;
  void _internal_set_egg_type_infusing(::ei::Egg value);
  public:

  // optional bool fueling_enabled = 7 [default = true];
  bool has_fueling_enabled() const;
  private:
  bool _internal_has_fueling_enabled() const;
  public:
  void clear_fueling_enabled();
  bool fueling_enabled() const;
  void set_fueling_enabled(bool value);
  private:
  bool _internal_fueling_enabled() const;
  void _internal_set_fueling_enabled(bool value);
  public:

  // optional bool infusing_enabled_DEPRECATED = 8 [default = true];
  bool has_infusing_enabled_deprecated() const;
  private:
  bool _internal_has_infusing_enabled_deprecated() const;
  public:
  void clear_infusing_enabled_deprecated();
  bool infusing_enabled_deprecated() const;
  void set_infusing_enabled_deprecated(bool value);
  private:
  bool _internal_infusing_enabled_deprecated() const;
  void _internal_set_infusing_enabled_deprecated(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ei.Backup.Artifacts)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > tank_fuels_;
  ::ei::ArtifactInventoryItem* item_being_infused_;
  ::ei::ArtifactSpec* spec_being_infused_;
  double infusing_eggs_required_;
  double eggs_infused_;
  int last_fueled_ship_;
  bool infusing_;
  bool tank_filling_enabled_;
  bool enabled_;
  bool intro_shown_;
  double inventory_score_;
  uint32_t tank_level_;
  double flow_percentage_artifacts_;
  int egg_type_infusing_;
  bool fueling_enabled_;
  bool infusing_enabled_deprecated_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class Backup_Shells final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.Backup.Shells) */ {
 public:
  inline Backup_Shells() : Backup_Shells(nullptr) {}
  ~Backup_Shells() override;
  explicit constexpr Backup_Shells(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Backup_Shells(const Backup_Shells& from);
  Backup_Shells(Backup_Shells&& from) noexcept
    : Backup_Shells() {
    *this = ::std::move(from);
  }

  inline Backup_Shells& operator=(const Backup_Shells& from) {
    CopyFrom(from);
    return *this;
  }
  inline Backup_Shells& operator=(Backup_Shells&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Backup_Shells& default_instance() {
    return *internal_default_instance();
  }
  static inline const Backup_Shells* internal_default_instance() {
    return reinterpret_cast<const Backup_Shells*>(
               &_Backup_Shells_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Backup_Shells& a, Backup_Shells& b) {
    a.Swap(&b);
  }
  inline void Swap(Backup_Shells* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Backup_Shells* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Backup_Shells* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Backup_Shells>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Backup_Shells& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Backup_Shells& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Backup_Shells* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.Backup.Shells";
  }
  protected:
  explicit Backup_Shells(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumNewFieldNumber = 3,
    kIntroAlertFieldNumber = 1,
    kContractsIntroAlertFieldNumber = 2,
  };
  // repeated int32 num_new = 3;
  int num_new_size() const;
  private:
  int _internal_num_new_size() const;
  public:
  void clear_num_new();
  private:
  int32_t _internal_num_new(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_num_new() const;
  void _internal_add_num_new(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_num_new();
  public:
  int32_t num_new(int index) const;
  void set_num_new(int index, int32_t value);
  void add_num_new(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      num_new() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_num_new();

  // optional bool intro_alert = 1;
  bool has_intro_alert() const;
  private:
  bool _internal_has_intro_alert() const;
  public:
  void clear_intro_alert();
  bool intro_alert() const;
  void set_intro_alert(bool value);
  private:
  bool _internal_intro_alert() const;
  void _internal_set_intro_alert(bool value);
  public:

  // optional bool contracts_intro_alert = 2;
  bool has_contracts_intro_alert() const;
  private:
  bool _internal_has_contracts_intro_alert() const;
  public:
  void clear_contracts_intro_alert();
  bool contracts_intro_alert() const;
  void set_contracts_intro_alert(bool value);
  private:
  bool _internal_contracts_intro_alert() const;
  void _internal_set_contracts_intro_alert(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ei.Backup.Shells)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > num_new_;
  bool intro_alert_;
  bool contracts_intro_alert_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class Backup_Simulation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.Backup.Simulation) */ {
 public:
  inline Backup_Simulation() : Backup_Simulation(nullptr) {}
  ~Backup_Simulation() override;
  explicit constexpr Backup_Simulation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Backup_Simulation(const Backup_Simulation& from);
  Backup_Simulation(Backup_Simulation&& from) noexcept
    : Backup_Simulation() {
    *this = ::std::move(from);
  }

  inline Backup_Simulation& operator=(const Backup_Simulation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Backup_Simulation& operator=(Backup_Simulation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Backup_Simulation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Backup_Simulation* internal_default_instance() {
    return reinterpret_cast<const Backup_Simulation*>(
               &_Backup_Simulation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Backup_Simulation& a, Backup_Simulation& b) {
    a.Swap(&b);
  }
  inline void Swap(Backup_Simulation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Backup_Simulation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Backup_Simulation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Backup_Simulation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Backup_Simulation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Backup_Simulation& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Backup_Simulation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.Backup.Simulation";
  }
  protected:
  explicit Backup_Simulation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHabsFieldNumber = 12,
    kHabPopulationFieldNumber = 13,
    kHabPopulationIndoundFieldNumber = 14,
    kHabIncubatorPopuplationFieldNumber = 15,
    kVehiclesFieldNumber = 17,
    kCommonResearchFieldNumber = 18,
    kTrainLengthFieldNumber = 21,
    kActiveBoostsFieldNumber = 22,
    kContractIdFieldNumber = 20,
    kCashEarnedFieldNumber = 2,
    kCashSpentFieldNumber = 3,
    kUnclaimedCashFieldNumber = 4,
    kLastStepTimeFieldNumber = 5,
    kNumChickensFieldNumber = 6,
    kNumChickensUnsettledFieldNumber = 7,
    kNumChickensRunningFieldNumber = 8,
    kEggsLaidFieldNumber = 9,
    kEggsPaidForFieldNumber = 10,
    kHatcheryPopulationFieldNumber = 16,
    kSilosOwnedFieldNumber = 11,
    kTimeCheatsDetectedFieldNumber = 23,
    kTimeCheatDebtFieldNumber = 24,
    kBoostTokensReceivedFieldNumber = 25,
    kBoostTokensSpentFieldNumber = 26,
    kUnclaimedBoostTokensFieldNumber = 27,
    kBoostTokensGivenFieldNumber = 28,
    kGametimeUntilNextBoostTokenFieldNumber = 29,
    kEggsShippedFieldNumber = 30,
    kLastCashBoostTimeFieldNumber = 31,
    kEggTypeFieldNumber = 1,
    kFarmTypeFieldNumber = 19,
  };
  // repeated uint32 habs = 12;
  int habs_size() const;
  private:
  int _internal_habs_size() const;
  public:
  void clear_habs();
  private:
  uint32_t _internal_habs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_habs() const;
  void _internal_add_habs(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_habs();
  public:
  uint32_t habs(int index) const;
  void set_habs(int index, uint32_t value);
  void add_habs(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      habs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_habs();

  // repeated uint64 hab_population = 13;
  int hab_population_size() const;
  private:
  int _internal_hab_population_size() const;
  public:
  void clear_hab_population();
  private:
  uint64_t _internal_hab_population(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_hab_population() const;
  void _internal_add_hab_population(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_hab_population();
  public:
  uint64_t hab_population(int index) const;
  void set_hab_population(int index, uint64_t value);
  void add_hab_population(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      hab_population() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_hab_population();

  // repeated uint64 hab_population_indound = 14;
  int hab_population_indound_size() const;
  private:
  int _internal_hab_population_indound_size() const;
  public:
  void clear_hab_population_indound();
  private:
  uint64_t _internal_hab_population_indound(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_hab_population_indound() const;
  void _internal_add_hab_population_indound(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_hab_population_indound();
  public:
  uint64_t hab_population_indound(int index) const;
  void set_hab_population_indound(int index, uint64_t value);
  void add_hab_population_indound(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      hab_population_indound() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_hab_population_indound();

  // repeated double hab_incubator_popuplation = 15;
  int hab_incubator_popuplation_size() const;
  private:
  int _internal_hab_incubator_popuplation_size() const;
  public:
  void clear_hab_incubator_popuplation();
  private:
  double _internal_hab_incubator_popuplation(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_hab_incubator_popuplation() const;
  void _internal_add_hab_incubator_popuplation(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_hab_incubator_popuplation();
  public:
  double hab_incubator_popuplation(int index) const;
  void set_hab_incubator_popuplation(int index, double value);
  void add_hab_incubator_popuplation(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      hab_incubator_popuplation() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_hab_incubator_popuplation();

  // repeated uint32 vehicles = 17;
  int vehicles_size() const;
  private:
  int _internal_vehicles_size() const;
  public:
  void clear_vehicles();
  private:
  uint32_t _internal_vehicles(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_vehicles() const;
  void _internal_add_vehicles(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_vehicles();
  public:
  uint32_t vehicles(int index) const;
  void set_vehicles(int index, uint32_t value);
  void add_vehicles(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      vehicles() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_vehicles();

  // repeated .ei.Backup.ResearchItem common_research = 18;
  int common_research_size() const;
  private:
  int _internal_common_research_size() const;
  public:
  void clear_common_research();
  ::ei::Backup_ResearchItem* mutable_common_research(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_ResearchItem >*
      mutable_common_research();
  private:
  const ::ei::Backup_ResearchItem& _internal_common_research(int index) const;
  ::ei::Backup_ResearchItem* _internal_add_common_research();
  public:
  const ::ei::Backup_ResearchItem& common_research(int index) const;
  ::ei::Backup_ResearchItem* add_common_research();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_ResearchItem >&
      common_research() const;

  // repeated uint32 train_length = 21;
  int train_length_size() const;
  private:
  int _internal_train_length_size() const;
  public:
  void clear_train_length();
  private:
  uint32_t _internal_train_length(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_train_length() const;
  void _internal_add_train_length(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_train_length();
  public:
  uint32_t train_length(int index) const;
  void set_train_length(int index, uint32_t value);
  void add_train_length(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      train_length() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_train_length();

  // repeated .ei.Backup.ActiveBoost active_boosts = 22;
  int active_boosts_size() const;
  private:
  int _internal_active_boosts_size() const;
  public:
  void clear_active_boosts();
  ::ei::Backup_ActiveBoost* mutable_active_boosts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_ActiveBoost >*
      mutable_active_boosts();
  private:
  const ::ei::Backup_ActiveBoost& _internal_active_boosts(int index) const;
  ::ei::Backup_ActiveBoost* _internal_add_active_boosts();
  public:
  const ::ei::Backup_ActiveBoost& active_boosts(int index) const;
  ::ei::Backup_ActiveBoost* add_active_boosts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_ActiveBoost >&
      active_boosts() const;

  // optional string contract_id = 20;
  bool has_contract_id() const;
  private:
  bool _internal_has_contract_id() const;
  public:
  void clear_contract_id();
  const std::string& contract_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* contract_id);
  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(const std::string& value);
  std::string* _internal_mutable_contract_id();
  public:

  // optional double cash_earned = 2;
  bool has_cash_earned() const;
  private:
  bool _internal_has_cash_earned() const;
  public:
  void clear_cash_earned();
  double cash_earned() const;
  void set_cash_earned(double value);
  private:
  double _internal_cash_earned() const;
  void _internal_set_cash_earned(double value);
  public:

  // optional double cash_spent = 3;
  bool has_cash_spent() const;
  private:
  bool _internal_has_cash_spent() const;
  public:
  void clear_cash_spent();
  double cash_spent() const;
  void set_cash_spent(double value);
  private:
  double _internal_cash_spent() const;
  void _internal_set_cash_spent(double value);
  public:

  // optional double unclaimed_cash = 4;
  bool has_unclaimed_cash() const;
  private:
  bool _internal_has_unclaimed_cash() const;
  public:
  void clear_unclaimed_cash();
  double unclaimed_cash() const;
  void set_unclaimed_cash(double value);
  private:
  double _internal_unclaimed_cash() const;
  void _internal_set_unclaimed_cash(double value);
  public:

  // optional double last_step_time = 5;
  bool has_last_step_time() const;
  private:
  bool _internal_has_last_step_time() const;
  public:
  void clear_last_step_time();
  double last_step_time() const;
  void set_last_step_time(double value);
  private:
  double _internal_last_step_time() const;
  void _internal_set_last_step_time(double value);
  public:

  // optional uint64 num_chickens = 6;
  bool has_num_chickens() const;
  private:
  bool _internal_has_num_chickens() const;
  public:
  void clear_num_chickens();
  uint64_t num_chickens() const;
  void set_num_chickens(uint64_t value);
  private:
  uint64_t _internal_num_chickens() const;
  void _internal_set_num_chickens(uint64_t value);
  public:

  // optional uint64 num_chickens_unsettled = 7;
  bool has_num_chickens_unsettled() const;
  private:
  bool _internal_has_num_chickens_unsettled() const;
  public:
  void clear_num_chickens_unsettled();
  uint64_t num_chickens_unsettled() const;
  void set_num_chickens_unsettled(uint64_t value);
  private:
  uint64_t _internal_num_chickens_unsettled() const;
  void _internal_set_num_chickens_unsettled(uint64_t value);
  public:

  // optional uint64 num_chickens_running = 8;
  bool has_num_chickens_running() const;
  private:
  bool _internal_has_num_chickens_running() const;
  public:
  void clear_num_chickens_running();
  uint64_t num_chickens_running() const;
  void set_num_chickens_running(uint64_t value);
  private:
  uint64_t _internal_num_chickens_running() const;
  void _internal_set_num_chickens_running(uint64_t value);
  public:

  // optional double eggs_laid = 9;
  bool has_eggs_laid() const;
  private:
  bool _internal_has_eggs_laid() const;
  public:
  void clear_eggs_laid();
  double eggs_laid() const;
  void set_eggs_laid(double value);
  private:
  double _internal_eggs_laid() const;
  void _internal_set_eggs_laid(double value);
  public:

  // optional double eggs_paid_for = 10;
  bool has_eggs_paid_for() const;
  private:
  bool _internal_has_eggs_paid_for() const;
  public:
  void clear_eggs_paid_for();
  double eggs_paid_for() const;
  void set_eggs_paid_for(double value);
  private:
  double _internal_eggs_paid_for() const;
  void _internal_set_eggs_paid_for(double value);
  public:

  // optional double hatchery_population = 16;
  bool has_hatchery_population() const;
  private:
  bool _internal_has_hatchery_population() const;
  public:
  void clear_hatchery_population();
  double hatchery_population() const;
  void set_hatchery_population(double value);
  private:
  double _internal_hatchery_population() const;
  void _internal_set_hatchery_population(double value);
  public:

  // optional uint32 silos_owned = 11;
  bool has_silos_owned() const;
  private:
  bool _internal_has_silos_owned() const;
  public:
  void clear_silos_owned();
  uint32_t silos_owned() const;
  void set_silos_owned(uint32_t value);
  private:
  uint32_t _internal_silos_owned() const;
  void _internal_set_silos_owned(uint32_t value);
  public:

  // optional uint32 time_cheats_detected = 23;
  bool has_time_cheats_detected() const;
  private:
  bool _internal_has_time_cheats_detected() const;
  public:
  void clear_time_cheats_detected();
  uint32_t time_cheats_detected() const;
  void set_time_cheats_detected(uint32_t value);
  private:
  uint32_t _internal_time_cheats_detected() const;
  void _internal_set_time_cheats_detected(uint32_t value);
  public:

  // optional double time_cheat_debt = 24;
  bool has_time_cheat_debt() const;
  private:
  bool _internal_has_time_cheat_debt() const;
  public:
  void clear_time_cheat_debt();
  double time_cheat_debt() const;
  void set_time_cheat_debt(double value);
  private:
  double _internal_time_cheat_debt() const;
  void _internal_set_time_cheat_debt(double value);
  public:

  // optional uint32 boost_tokens_received = 25;
  bool has_boost_tokens_received() const;
  private:
  bool _internal_has_boost_tokens_received() const;
  public:
  void clear_boost_tokens_received();
  uint32_t boost_tokens_received() const;
  void set_boost_tokens_received(uint32_t value);
  private:
  uint32_t _internal_boost_tokens_received() const;
  void _internal_set_boost_tokens_received(uint32_t value);
  public:

  // optional uint32 boost_tokens_spent = 26;
  bool has_boost_tokens_spent() const;
  private:
  bool _internal_has_boost_tokens_spent() const;
  public:
  void clear_boost_tokens_spent();
  uint32_t boost_tokens_spent() const;
  void set_boost_tokens_spent(uint32_t value);
  private:
  uint32_t _internal_boost_tokens_spent() const;
  void _internal_set_boost_tokens_spent(uint32_t value);
  public:

  // optional uint32 unclaimed_boost_tokens = 27;
  bool has_unclaimed_boost_tokens() const;
  private:
  bool _internal_has_unclaimed_boost_tokens() const;
  public:
  void clear_unclaimed_boost_tokens();
  uint32_t unclaimed_boost_tokens() const;
  void set_unclaimed_boost_tokens(uint32_t value);
  private:
  uint32_t _internal_unclaimed_boost_tokens() const;
  void _internal_set_unclaimed_boost_tokens(uint32_t value);
  public:

  // optional uint32 boost_tokens_given = 28;
  bool has_boost_tokens_given() const;
  private:
  bool _internal_has_boost_tokens_given() const;
  public:
  void clear_boost_tokens_given();
  uint32_t boost_tokens_given() const;
  void set_boost_tokens_given(uint32_t value);
  private:
  uint32_t _internal_boost_tokens_given() const;
  void _internal_set_boost_tokens_given(uint32_t value);
  public:

  // optional double gametime_until_next_boost_token = 29;
  bool has_gametime_until_next_boost_token() const;
  private:
  bool _internal_has_gametime_until_next_boost_token() const;
  public:
  void clear_gametime_until_next_boost_token();
  double gametime_until_next_boost_token() const;
  void set_gametime_until_next_boost_token(double value);
  private:
  double _internal_gametime_until_next_boost_token() const;
  void _internal_set_gametime_until_next_boost_token(double value);
  public:

  // optional double eggs_shipped = 30;
  bool has_eggs_shipped() const;
  private:
  bool _internal_has_eggs_shipped() const;
  public:
  void clear_eggs_shipped();
  double eggs_shipped() const;
  void set_eggs_shipped(double value);
  private:
  double _internal_eggs_shipped() const;
  void _internal_set_eggs_shipped(double value);
  public:

  // optional double last_cash_boost_time = 31;
  bool has_last_cash_boost_time() const;
  private:
  bool _internal_has_last_cash_boost_time() const;
  public:
  void clear_last_cash_boost_time();
  double last_cash_boost_time() const;
  void set_last_cash_boost_time(double value);
  private:
  double _internal_last_cash_boost_time() const;
  void _internal_set_last_cash_boost_time(double value);
  public:

  // optional .ei.Egg egg_type = 1;
  bool has_egg_type() const;
  private:
  bool _internal_has_egg_type() const;
  public:
  void clear_egg_type();
  ::ei::Egg egg_type() const;
  void set_egg_type(::ei::Egg value);
  private:
  ::ei::Egg _internal_egg_type() const;
  void _internal_set_egg_type(::ei::Egg value);
  public:

  // optional .ei.FarmType farm_type = 19;
  bool has_farm_type() const;
  private:
  bool _internal_has_farm_type() const;
  public:
  void clear_farm_type();
  ::ei::FarmType farm_type() const;
  void set_farm_type(::ei::FarmType value);
  private:
  ::ei::FarmType _internal_farm_type() const;
  void _internal_set_farm_type(::ei::FarmType value);
  public:

  // @@protoc_insertion_point(class_scope:ei.Backup.Simulation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > habs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > hab_population_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > hab_population_indound_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > hab_incubator_popuplation_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > vehicles_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_ResearchItem > common_research_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > train_length_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_ActiveBoost > active_boosts_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_id_;
  double cash_earned_;
  double cash_spent_;
  double unclaimed_cash_;
  double last_step_time_;
  uint64_t num_chickens_;
  uint64_t num_chickens_unsettled_;
  uint64_t num_chickens_running_;
  double eggs_laid_;
  double eggs_paid_for_;
  double hatchery_population_;
  uint32_t silos_owned_;
  uint32_t time_cheats_detected_;
  double time_cheat_debt_;
  uint32_t boost_tokens_received_;
  uint32_t boost_tokens_spent_;
  uint32_t unclaimed_boost_tokens_;
  uint32_t boost_tokens_given_;
  double gametime_until_next_boost_token_;
  double eggs_shipped_;
  double last_cash_boost_time_;
  int egg_type_;
  int farm_type_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class Backup_Mission final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.Backup.Mission) */ {
 public:
  inline Backup_Mission() : Backup_Mission(nullptr) {}
  ~Backup_Mission() override;
  explicit constexpr Backup_Mission(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Backup_Mission(const Backup_Mission& from);
  Backup_Mission(Backup_Mission&& from) noexcept
    : Backup_Mission() {
    *this = ::std::move(from);
  }

  inline Backup_Mission& operator=(const Backup_Mission& from) {
    CopyFrom(from);
    return *this;
  }
  inline Backup_Mission& operator=(Backup_Mission&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Backup_Mission& default_instance() {
    return *internal_default_instance();
  }
  static inline const Backup_Mission* internal_default_instance() {
    return reinterpret_cast<const Backup_Mission*>(
               &_Backup_Mission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Backup_Mission& a, Backup_Mission& b) {
    a.Swap(&b);
  }
  inline void Swap(Backup_Mission* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Backup_Mission* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Backup_Mission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Backup_Mission>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Backup_Mission& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Backup_Mission& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Backup_Mission* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.Backup.Mission";
  }
  protected:
  explicit Backup_Mission(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMissionsFieldNumber = 3,
    kCurrentMissionsFieldNumber = 4,
    kCurrentMissionFieldNumber = 1,
    kReferenceValueFieldNumber = 2,
  };
  // repeated .ei.Backup.MissionInfo missions = 3;
  int missions_size() const;
  private:
  int _internal_missions_size() const;
  public:
  void clear_missions();
  ::ei::Backup_MissionInfo* mutable_missions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_MissionInfo >*
      mutable_missions();
  private:
  const ::ei::Backup_MissionInfo& _internal_missions(int index) const;
  ::ei::Backup_MissionInfo* _internal_add_missions();
  public:
  const ::ei::Backup_MissionInfo& missions(int index) const;
  ::ei::Backup_MissionInfo* add_missions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_MissionInfo >&
      missions() const;

  // repeated string current_missions = 4;
  int current_missions_size() const;
  private:
  int _internal_current_missions_size() const;
  public:
  void clear_current_missions();
  const std::string& current_missions(int index) const;
  std::string* mutable_current_missions(int index);
  void set_current_missions(int index, const std::string& value);
  void set_current_missions(int index, std::string&& value);
  void set_current_missions(int index, const char* value);
  void set_current_missions(int index, const char* value, size_t size);
  std::string* add_current_missions();
  void add_current_missions(const std::string& value);
  void add_current_missions(std::string&& value);
  void add_current_missions(const char* value);
  void add_current_missions(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& current_missions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_current_missions();
  private:
  const std::string& _internal_current_missions(int index) const;
  std::string* _internal_add_current_missions();
  public:

  // optional string current_mission = 1;
  bool has_current_mission() const;
  private:
  bool _internal_has_current_mission() const;
  public:
  void clear_current_mission();
  const std::string& current_mission() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_current_mission(ArgT0&& arg0, ArgT... args);
  std::string* mutable_current_mission();
  PROTOBUF_NODISCARD std::string* release_current_mission();
  void set_allocated_current_mission(std::string* current_mission);
  private:
  const std::string& _internal_current_mission() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_mission(const std::string& value);
  std::string* _internal_mutable_current_mission();
  public:

  // optional double reference_value = 2;
  bool has_reference_value() const;
  private:
  bool _internal_has_reference_value() const;
  public:
  void clear_reference_value();
  double reference_value() const;
  void set_reference_value(double value);
  private:
  double _internal_reference_value() const;
  void _internal_set_reference_value(double value);
  public:

  // @@protoc_insertion_point(class_scope:ei.Backup.Mission)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_MissionInfo > missions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> current_missions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_mission_;
  double reference_value_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class Backup_Misc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.Backup.Misc) */ {
 public:
  inline Backup_Misc() : Backup_Misc(nullptr) {}
  ~Backup_Misc() override;
  explicit constexpr Backup_Misc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Backup_Misc(const Backup_Misc& from);
  Backup_Misc(Backup_Misc&& from) noexcept
    : Backup_Misc() {
    *this = ::std::move(from);
  }

  inline Backup_Misc& operator=(const Backup_Misc& from) {
    CopyFrom(from);
    return *this;
  }
  inline Backup_Misc& operator=(Backup_Misc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Backup_Misc& default_instance() {
    return *internal_default_instance();
  }
  static inline const Backup_Misc* internal_default_instance() {
    return reinterpret_cast<const Backup_Misc*>(
               &_Backup_Misc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Backup_Misc& a, Backup_Misc& b) {
    a.Swap(&b);
  }
  inline void Swap(Backup_Misc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Backup_Misc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Backup_Misc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Backup_Misc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Backup_Misc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Backup_Misc& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Backup_Misc* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.Backup.Misc";
  }
  protected:
  explicit Backup_Misc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFriendRankFieldNumber = 6,
    kFriendRankPopFieldNumber = 7,
    kGlobalRankFieldNumber = 8,
    kGlobalRankPopFieldNumber = 9,
    kChickenBtnPrefBigFieldNumber = 1,
    kFreeHatcheryRefillGivenFieldNumber = 2,
    kChallengesAlertFieldNumber = 20,
    kTrophyAlertFieldNumber = 11,
    kArAlertFieldNumber = 12,
    kContractsAlertFieldNumber = 13,
    kCoopAlertFieldNumber = 14,
    kSwitchAlertFieldNumber = 15,
    kEggOfProphecyAlertFieldNumber = 16,
    kBoostTokenAlertFieldNumber = 17,
    kSoulEggAlertFieldNumber = 18,
    kBackupReminderAlertFieldNumber = 19,
    kLastShareFarmValueFieldNumber = 3,
    kLastShareSwarmFarmValueFieldNumber = 4,
    kLastShareSwarmSizeFieldNumber = 5,
    kLastPrestigeAlertSoulEggsDEPRECATEDFieldNumber = 10,
  };
  // optional uint64 friend_rank = 6;
  bool has_friend_rank() const;
  private:
  bool _internal_has_friend_rank() const;
  public:
  void clear_friend_rank();
  uint64_t friend_rank() const;
  void set_friend_rank(uint64_t value);
  private:
  uint64_t _internal_friend_rank() const;
  void _internal_set_friend_rank(uint64_t value);
  public:

  // optional uint64 friend_rank_pop = 7;
  bool has_friend_rank_pop() const;
  private:
  bool _internal_has_friend_rank_pop() const;
  public:
  void clear_friend_rank_pop();
  uint64_t friend_rank_pop() const;
  void set_friend_rank_pop(uint64_t value);
  private:
  uint64_t _internal_friend_rank_pop() const;
  void _internal_set_friend_rank_pop(uint64_t value);
  public:

  // optional uint64 global_rank = 8;
  bool has_global_rank() const;
  private:
  bool _internal_has_global_rank() const;
  public:
  void clear_global_rank();
  uint64_t global_rank() const;
  void set_global_rank(uint64_t value);
  private:
  uint64_t _internal_global_rank() const;
  void _internal_set_global_rank(uint64_t value);
  public:

  // optional uint64 global_rank_pop = 9;
  bool has_global_rank_pop() const;
  private:
  bool _internal_has_global_rank_pop() const;
  public:
  void clear_global_rank_pop();
  uint64_t global_rank_pop() const;
  void set_global_rank_pop(uint64_t value);
  private:
  uint64_t _internal_global_rank_pop() const;
  void _internal_set_global_rank_pop(uint64_t value);
  public:

  // optional bool chicken_btn_pref_big = 1;
  bool has_chicken_btn_pref_big() const;
  private:
  bool _internal_has_chicken_btn_pref_big() const;
  public:
  void clear_chicken_btn_pref_big();
  bool chicken_btn_pref_big() const;
  void set_chicken_btn_pref_big(bool value);
  private:
  bool _internal_chicken_btn_pref_big() const;
  void _internal_set_chicken_btn_pref_big(bool value);
  public:

  // optional bool free_hatchery_refill_given = 2;
  bool has_free_hatchery_refill_given() const;
  private:
  bool _internal_has_free_hatchery_refill_given() const;
  public:
  void clear_free_hatchery_refill_given();
  bool free_hatchery_refill_given() const;
  void set_free_hatchery_refill_given(bool value);
  private:
  bool _internal_free_hatchery_refill_given() const;
  void _internal_set_free_hatchery_refill_given(bool value);
  public:

  // optional bool challenges_alert = 20;
  bool has_challenges_alert() const;
  private:
  bool _internal_has_challenges_alert() const;
  public:
  void clear_challenges_alert();
  bool challenges_alert() const;
  void set_challenges_alert(bool value);
  private:
  bool _internal_challenges_alert() const;
  void _internal_set_challenges_alert(bool value);
  public:

  // optional bool trophy_alert = 11;
  bool has_trophy_alert() const;
  private:
  bool _internal_has_trophy_alert() const;
  public:
  void clear_trophy_alert();
  bool trophy_alert() const;
  void set_trophy_alert(bool value);
  private:
  bool _internal_trophy_alert() const;
  void _internal_set_trophy_alert(bool value);
  public:

  // optional bool ar_alert = 12;
  bool has_ar_alert() const;
  private:
  bool _internal_has_ar_alert() const;
  public:
  void clear_ar_alert();
  bool ar_alert() const;
  void set_ar_alert(bool value);
  private:
  bool _internal_ar_alert() const;
  void _internal_set_ar_alert(bool value);
  public:

  // optional bool contracts_alert = 13;
  bool has_contracts_alert() const;
  private:
  bool _internal_has_contracts_alert() const;
  public:
  void clear_contracts_alert();
  bool contracts_alert() const;
  void set_contracts_alert(bool value);
  private:
  bool _internal_contracts_alert() const;
  void _internal_set_contracts_alert(bool value);
  public:

  // optional bool coop_alert = 14;
  bool has_coop_alert() const;
  private:
  bool _internal_has_coop_alert() const;
  public:
  void clear_coop_alert();
  bool coop_alert() const;
  void set_coop_alert(bool value);
  private:
  bool _internal_coop_alert() const;
  void _internal_set_coop_alert(bool value);
  public:

  // optional bool switch_alert = 15;
  bool has_switch_alert() const;
  private:
  bool _internal_has_switch_alert() const;
  public:
  void clear_switch_alert();
  bool switch_alert() const;
  void set_switch_alert(bool value);
  private:
  bool _internal_switch_alert() const;
  void _internal_set_switch_alert(bool value);
  public:

  // optional bool egg_of_prophecy_alert = 16;
  bool has_egg_of_prophecy_alert() const;
  private:
  bool _internal_has_egg_of_prophecy_alert() const;
  public:
  void clear_egg_of_prophecy_alert();
  bool egg_of_prophecy_alert() const;
  void set_egg_of_prophecy_alert(bool value);
  private:
  bool _internal_egg_of_prophecy_alert() const;
  void _internal_set_egg_of_prophecy_alert(bool value);
  public:

  // optional bool boost_token_alert = 17;
  bool has_boost_token_alert() const;
  private:
  bool _internal_has_boost_token_alert() const;
  public:
  void clear_boost_token_alert();
  bool boost_token_alert() const;
  void set_boost_token_alert(bool value);
  private:
  bool _internal_boost_token_alert() const;
  void _internal_set_boost_token_alert(bool value);
  public:

  // optional bool soul_egg_alert = 18;
  bool has_soul_egg_alert() const;
  private:
  bool _internal_has_soul_egg_alert() const;
  public:
  void clear_soul_egg_alert();
  bool soul_egg_alert() const;
  void set_soul_egg_alert(bool value);
  private:
  bool _internal_soul_egg_alert() const;
  void _internal_set_soul_egg_alert(bool value);
  public:

  // optional bool backup_reminder_alert = 19;
  bool has_backup_reminder_alert() const;
  private:
  bool _internal_has_backup_reminder_alert() const;
  public:
  void clear_backup_reminder_alert();
  bool backup_reminder_alert() const;
  void set_backup_reminder_alert(bool value);
  private:
  bool _internal_backup_reminder_alert() const;
  void _internal_set_backup_reminder_alert(bool value);
  public:

  // optional double last_share_farm_value = 3 [default = 10000000];
  bool has_last_share_farm_value() const;
  private:
  bool _internal_has_last_share_farm_value() const;
  public:
  void clear_last_share_farm_value();
  double last_share_farm_value() const;
  void set_last_share_farm_value(double value);
  private:
  double _internal_last_share_farm_value() const;
  void _internal_set_last_share_farm_value(double value);
  public:

  // optional double last_share_swarm_farm_value = 4 [default = 10000000];
  bool has_last_share_swarm_farm_value() const;
  private:
  bool _internal_has_last_share_swarm_farm_value() const;
  public:
  void clear_last_share_swarm_farm_value();
  double last_share_swarm_farm_value() const;
  void set_last_share_swarm_farm_value(double value);
  private:
  double _internal_last_share_swarm_farm_value() const;
  void _internal_set_last_share_swarm_farm_value(double value);
  public:

  // optional double last_share_swarm_size = 5 [default = 140];
  bool has_last_share_swarm_size() const;
  private:
  bool _internal_has_last_share_swarm_size() const;
  public:
  void clear_last_share_swarm_size();
  double last_share_swarm_size() const;
  void set_last_share_swarm_size(double value);
  private:
  double _internal_last_share_swarm_size() const;
  void _internal_set_last_share_swarm_size(double value);
  public:

  // optional uint64 last_prestige_alert_soul_eggs_DEPRECATED = 10 [default = 45];
  bool has_last_prestige_alert_soul_eggs_deprecated() const;
  private:
  bool _internal_has_last_prestige_alert_soul_eggs_deprecated() const;
  public:
  void clear_last_prestige_alert_soul_eggs_deprecated();
  uint64_t last_prestige_alert_soul_eggs_deprecated() const;
  void set_last_prestige_alert_soul_eggs_deprecated(uint64_t value);
  private:
  uint64_t _internal_last_prestige_alert_soul_eggs_deprecated() const;
  void _internal_set_last_prestige_alert_soul_eggs_deprecated(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.Backup.Misc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t friend_rank_;
  uint64_t friend_rank_pop_;
  uint64_t global_rank_;
  uint64_t global_rank_pop_;
  bool chicken_btn_pref_big_;
  bool free_hatchery_refill_given_;
  bool challenges_alert_;
  bool trophy_alert_;
  bool ar_alert_;
  bool contracts_alert_;
  bool coop_alert_;
  bool switch_alert_;
  bool egg_of_prophecy_alert_;
  bool boost_token_alert_;
  bool soul_egg_alert_;
  bool backup_reminder_alert_;
  double last_share_farm_value_;
  double last_share_swarm_farm_value_;
  double last_share_swarm_size_;
  uint64_t last_prestige_alert_soul_eggs_deprecated_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class Backup_ResearchItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.Backup.ResearchItem) */ {
 public:
  inline Backup_ResearchItem() : Backup_ResearchItem(nullptr) {}
  ~Backup_ResearchItem() override;
  explicit constexpr Backup_ResearchItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Backup_ResearchItem(const Backup_ResearchItem& from);
  Backup_ResearchItem(Backup_ResearchItem&& from) noexcept
    : Backup_ResearchItem() {
    *this = ::std::move(from);
  }

  inline Backup_ResearchItem& operator=(const Backup_ResearchItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline Backup_ResearchItem& operator=(Backup_ResearchItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Backup_ResearchItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const Backup_ResearchItem* internal_default_instance() {
    return reinterpret_cast<const Backup_ResearchItem*>(
               &_Backup_ResearchItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Backup_ResearchItem& a, Backup_ResearchItem& b) {
    a.Swap(&b);
  }
  inline void Swap(Backup_ResearchItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Backup_ResearchItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Backup_ResearchItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Backup_ResearchItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Backup_ResearchItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Backup_ResearchItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Backup_ResearchItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.Backup.ResearchItem";
  }
  protected:
  explicit Backup_ResearchItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kLevelFieldNumber = 2,
  };
  // optional string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional uint32 level = 2;
  bool has_level() const;
  private:
  bool _internal_has_level() const;
  public:
  void clear_level();
  uint32_t level() const;
  void set_level(uint32_t value);
  private:
  uint32_t _internal_level() const;
  void _internal_set_level(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.Backup.ResearchItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  uint32_t level_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class Backup_NewsHeadline final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.Backup.NewsHeadline) */ {
 public:
  inline Backup_NewsHeadline() : Backup_NewsHeadline(nullptr) {}
  ~Backup_NewsHeadline() override;
  explicit constexpr Backup_NewsHeadline(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Backup_NewsHeadline(const Backup_NewsHeadline& from);
  Backup_NewsHeadline(Backup_NewsHeadline&& from) noexcept
    : Backup_NewsHeadline() {
    *this = ::std::move(from);
  }

  inline Backup_NewsHeadline& operator=(const Backup_NewsHeadline& from) {
    CopyFrom(from);
    return *this;
  }
  inline Backup_NewsHeadline& operator=(Backup_NewsHeadline&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Backup_NewsHeadline& default_instance() {
    return *internal_default_instance();
  }
  static inline const Backup_NewsHeadline* internal_default_instance() {
    return reinterpret_cast<const Backup_NewsHeadline*>(
               &_Backup_NewsHeadline_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Backup_NewsHeadline& a, Backup_NewsHeadline& b) {
    a.Swap(&b);
  }
  inline void Swap(Backup_NewsHeadline* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Backup_NewsHeadline* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Backup_NewsHeadline* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Backup_NewsHeadline>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Backup_NewsHeadline& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Backup_NewsHeadline& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Backup_NewsHeadline* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.Backup.NewsHeadline";
  }
  protected:
  explicit Backup_NewsHeadline(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kReadFieldNumber = 2,
  };
  // optional string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional bool read = 2;
  bool has_read() const;
  private:
  bool _internal_has_read() const;
  public:
  void clear_read();
  bool read() const;
  void set_read(bool value);
  private:
  bool _internal_read() const;
  void _internal_set_read(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ei.Backup.NewsHeadline)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  bool read_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class Backup_AchievementInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.Backup.AchievementInfo) */ {
 public:
  inline Backup_AchievementInfo() : Backup_AchievementInfo(nullptr) {}
  ~Backup_AchievementInfo() override;
  explicit constexpr Backup_AchievementInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Backup_AchievementInfo(const Backup_AchievementInfo& from);
  Backup_AchievementInfo(Backup_AchievementInfo&& from) noexcept
    : Backup_AchievementInfo() {
    *this = ::std::move(from);
  }

  inline Backup_AchievementInfo& operator=(const Backup_AchievementInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Backup_AchievementInfo& operator=(Backup_AchievementInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Backup_AchievementInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const Backup_AchievementInfo* internal_default_instance() {
    return reinterpret_cast<const Backup_AchievementInfo*>(
               &_Backup_AchievementInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Backup_AchievementInfo& a, Backup_AchievementInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(Backup_AchievementInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Backup_AchievementInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Backup_AchievementInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Backup_AchievementInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Backup_AchievementInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Backup_AchievementInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Backup_AchievementInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.Backup.AchievementInfo";
  }
  protected:
  explicit Backup_AchievementInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kAchievedFieldNumber = 2,
  };
  // optional string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional bool achieved = 2;
  bool has_achieved() const;
  private:
  bool _internal_has_achieved() const;
  public:
  void clear_achieved();
  bool achieved() const;
  void set_achieved(bool value);
  private:
  bool _internal_achieved() const;
  void _internal_set_achieved(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ei.Backup.AchievementInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  bool achieved_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class Backup_ActiveBoost final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.Backup.ActiveBoost) */ {
 public:
  inline Backup_ActiveBoost() : Backup_ActiveBoost(nullptr) {}
  ~Backup_ActiveBoost() override;
  explicit constexpr Backup_ActiveBoost(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Backup_ActiveBoost(const Backup_ActiveBoost& from);
  Backup_ActiveBoost(Backup_ActiveBoost&& from) noexcept
    : Backup_ActiveBoost() {
    *this = ::std::move(from);
  }

  inline Backup_ActiveBoost& operator=(const Backup_ActiveBoost& from) {
    CopyFrom(from);
    return *this;
  }
  inline Backup_ActiveBoost& operator=(Backup_ActiveBoost&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Backup_ActiveBoost& default_instance() {
    return *internal_default_instance();
  }
  static inline const Backup_ActiveBoost* internal_default_instance() {
    return reinterpret_cast<const Backup_ActiveBoost*>(
               &_Backup_ActiveBoost_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Backup_ActiveBoost& a, Backup_ActiveBoost& b) {
    a.Swap(&b);
  }
  inline void Swap(Backup_ActiveBoost* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Backup_ActiveBoost* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Backup_ActiveBoost* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Backup_ActiveBoost>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Backup_ActiveBoost& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Backup_ActiveBoost& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Backup_ActiveBoost* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.Backup.ActiveBoost";
  }
  protected:
  explicit Backup_ActiveBoost(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoostIdFieldNumber = 1,
    kTimeRemainingFieldNumber = 2,
    kReferenceValueFieldNumber = 3,
  };
  // optional string boost_id = 1;
  bool has_boost_id() const;
  private:
  bool _internal_has_boost_id() const;
  public:
  void clear_boost_id();
  const std::string& boost_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_boost_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_boost_id();
  PROTOBUF_NODISCARD std::string* release_boost_id();
  void set_allocated_boost_id(std::string* boost_id);
  private:
  const std::string& _internal_boost_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_boost_id(const std::string& value);
  std::string* _internal_mutable_boost_id();
  public:

  // optional double time_remaining = 2;
  bool has_time_remaining() const;
  private:
  bool _internal_has_time_remaining() const;
  public:
  void clear_time_remaining();
  double time_remaining() const;
  void set_time_remaining(double value);
  private:
  double _internal_time_remaining() const;
  void _internal_set_time_remaining(double value);
  public:

  // optional double reference_value = 3;
  bool has_reference_value() const;
  private:
  bool _internal_has_reference_value() const;
  public:
  void clear_reference_value();
  double reference_value() const;
  void set_reference_value(double value);
  private:
  double _internal_reference_value() const;
  void _internal_set_reference_value(double value);
  public:

  // @@protoc_insertion_point(class_scope:ei.Backup.ActiveBoost)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr boost_id_;
  double time_remaining_;
  double reference_value_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class Backup_OwnedBoost final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.Backup.OwnedBoost) */ {
 public:
  inline Backup_OwnedBoost() : Backup_OwnedBoost(nullptr) {}
  ~Backup_OwnedBoost() override;
  explicit constexpr Backup_OwnedBoost(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Backup_OwnedBoost(const Backup_OwnedBoost& from);
  Backup_OwnedBoost(Backup_OwnedBoost&& from) noexcept
    : Backup_OwnedBoost() {
    *this = ::std::move(from);
  }

  inline Backup_OwnedBoost& operator=(const Backup_OwnedBoost& from) {
    CopyFrom(from);
    return *this;
  }
  inline Backup_OwnedBoost& operator=(Backup_OwnedBoost&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Backup_OwnedBoost& default_instance() {
    return *internal_default_instance();
  }
  static inline const Backup_OwnedBoost* internal_default_instance() {
    return reinterpret_cast<const Backup_OwnedBoost*>(
               &_Backup_OwnedBoost_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Backup_OwnedBoost& a, Backup_OwnedBoost& b) {
    a.Swap(&b);
  }
  inline void Swap(Backup_OwnedBoost* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Backup_OwnedBoost* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Backup_OwnedBoost* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Backup_OwnedBoost>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Backup_OwnedBoost& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Backup_OwnedBoost& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Backup_OwnedBoost* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.Backup.OwnedBoost";
  }
  protected:
  explicit Backup_OwnedBoost(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoostIdFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // optional string boost_id = 1;
  bool has_boost_id() const;
  private:
  bool _internal_has_boost_id() const;
  public:
  void clear_boost_id();
  const std::string& boost_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_boost_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_boost_id();
  PROTOBUF_NODISCARD std::string* release_boost_id();
  void set_allocated_boost_id(std::string* boost_id);
  private:
  const std::string& _internal_boost_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_boost_id(const std::string& value);
  std::string* _internal_mutable_boost_id();
  public:

  // optional uint32 count = 2;
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.Backup.OwnedBoost)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr boost_id_;
  uint32_t count_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class Backup_MissionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.Backup.MissionInfo) */ {
 public:
  inline Backup_MissionInfo() : Backup_MissionInfo(nullptr) {}
  ~Backup_MissionInfo() override;
  explicit constexpr Backup_MissionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Backup_MissionInfo(const Backup_MissionInfo& from);
  Backup_MissionInfo(Backup_MissionInfo&& from) noexcept
    : Backup_MissionInfo() {
    *this = ::std::move(from);
  }

  inline Backup_MissionInfo& operator=(const Backup_MissionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Backup_MissionInfo& operator=(Backup_MissionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Backup_MissionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const Backup_MissionInfo* internal_default_instance() {
    return reinterpret_cast<const Backup_MissionInfo*>(
               &_Backup_MissionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Backup_MissionInfo& a, Backup_MissionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(Backup_MissionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Backup_MissionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Backup_MissionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Backup_MissionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Backup_MissionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Backup_MissionInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Backup_MissionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.Backup.MissionInfo";
  }
  protected:
  explicit Backup_MissionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kReferenceValueFieldNumber = 3,
    kCompletedFieldNumber = 2,
  };
  // optional string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional double reference_value = 3;
  bool has_reference_value() const;
  private:
  bool _internal_has_reference_value() const;
  public:
  void clear_reference_value();
  double reference_value() const;
  void set_reference_value(double value);
  private:
  double _internal_reference_value() const;
  void _internal_set_reference_value(double value);
  public:

  // optional bool completed = 2;
  bool has_completed() const;
  private:
  bool _internal_has_completed() const;
  public:
  void clear_completed();
  bool completed() const;
  void set_completed(bool value);
  private:
  bool _internal_completed() const;
  void _internal_set_completed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ei.Backup.MissionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  double reference_value_;
  bool completed_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class Backup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.Backup) */ {
 public:
  inline Backup() : Backup(nullptr) {}
  ~Backup() override;
  explicit constexpr Backup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Backup(const Backup& from);
  Backup(Backup&& from) noexcept
    : Backup() {
    *this = ::std::move(from);
  }

  inline Backup& operator=(const Backup& from) {
    CopyFrom(from);
    return *this;
  }
  inline Backup& operator=(Backup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Backup& default_instance() {
    return *internal_default_instance();
  }
  static inline const Backup* internal_default_instance() {
    return reinterpret_cast<const Backup*>(
               &_Backup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Backup& a, Backup& b) {
    a.Swap(&b);
  }
  inline void Swap(Backup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Backup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Backup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Backup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Backup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Backup& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Backup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.Backup";
  }
  protected:
  explicit Backup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Backup_Settings Settings;
  typedef Backup_Tutorial Tutorial;
  typedef Backup_Stats Stats;
  typedef Backup_Game Game;
  typedef Backup_Artifacts Artifacts;
  typedef Backup_Shells Shells;
  typedef Backup_Simulation Simulation;
  typedef Backup_Mission Mission;
  typedef Backup_Misc Misc;
  typedef Backup_ResearchItem ResearchItem;
  typedef Backup_NewsHeadline NewsHeadline;
  typedef Backup_AchievementInfo AchievementInfo;
  typedef Backup_ActiveBoost ActiveBoost;
  typedef Backup_OwnedBoost OwnedBoost;
  typedef Backup_MissionInfo MissionInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kFarmsFieldNumber = 12,
    kReadMailIdsFieldNumber = 23,
    kUserIdFieldNumber = 1,
    kUserNameFieldNumber = 2,
    kGameServicesIdFieldNumber = 16,
    kDeviceIdFieldNumber = 17,
    kEiUserIdFieldNumber = 18,
    kSignatureFieldNumber = 101,
    kSettingsFieldNumber = 4,
    kTutorialFieldNumber = 5,
    kStatsFieldNumber = 6,
    kGameFieldNumber = 7,
    kSimFieldNumber = 8,
    kMissionFieldNumber = 9,
    kMiscFieldNumber = 10,
    kContractsFieldNumber = 13,
    kArtifactsFieldNumber = 14,
    kArtifactsDbFieldNumber = 15,
    kShellDbFieldNumber = 24,
    kShellsFieldNumber = 25,
    kApproxTimeFieldNumber = 3,
    kVersionFieldNumber = 21,
    kForceOfferBackupFieldNumber = 20,
    kForceBackupFieldNumber = 22,
    kChecksumFieldNumber = 100,
  };
  // repeated .ei.Backup.Simulation farms = 12;
  int farms_size() const;
  private:
  int _internal_farms_size() const;
  public:
  void clear_farms();
  ::ei::Backup_Simulation* mutable_farms(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_Simulation >*
      mutable_farms();
  private:
  const ::ei::Backup_Simulation& _internal_farms(int index) const;
  ::ei::Backup_Simulation* _internal_add_farms();
  public:
  const ::ei::Backup_Simulation& farms(int index) const;
  ::ei::Backup_Simulation* add_farms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_Simulation >&
      farms() const;

  // repeated string read_mail_ids = 23;
  int read_mail_ids_size() const;
  private:
  int _internal_read_mail_ids_size() const;
  public:
  void clear_read_mail_ids();
  const std::string& read_mail_ids(int index) const;
  std::string* mutable_read_mail_ids(int index);
  void set_read_mail_ids(int index, const std::string& value);
  void set_read_mail_ids(int index, std::string&& value);
  void set_read_mail_ids(int index, const char* value);
  void set_read_mail_ids(int index, const char* value, size_t size);
  std::string* add_read_mail_ids();
  void add_read_mail_ids(const std::string& value);
  void add_read_mail_ids(std::string&& value);
  void add_read_mail_ids(const char* value);
  void add_read_mail_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& read_mail_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_read_mail_ids();
  private:
  const std::string& _internal_read_mail_ids(int index) const;
  std::string* _internal_add_read_mail_ids();
  public:

  // optional string user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // optional string user_name = 2;
  bool has_user_name() const;
  private:
  bool _internal_has_user_name() const;
  public:
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // optional string game_services_id = 16;
  bool has_game_services_id() const;
  private:
  bool _internal_has_game_services_id() const;
  public:
  void clear_game_services_id();
  const std::string& game_services_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_services_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_services_id();
  PROTOBUF_NODISCARD std::string* release_game_services_id();
  void set_allocated_game_services_id(std::string* game_services_id);
  private:
  const std::string& _internal_game_services_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_services_id(const std::string& value);
  std::string* _internal_mutable_game_services_id();
  public:

  // optional string device_id = 17;
  bool has_device_id() const;
  private:
  bool _internal_has_device_id() const;
  public:
  void clear_device_id();
  const std::string& device_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_id();
  PROTOBUF_NODISCARD std::string* release_device_id();
  void set_allocated_device_id(std::string* device_id);
  private:
  const std::string& _internal_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_id(const std::string& value);
  std::string* _internal_mutable_device_id();
  public:

  // optional string ei_user_id = 18;
  bool has_ei_user_id() const;
  private:
  bool _internal_has_ei_user_id() const;
  public:
  void clear_ei_user_id();
  const std::string& ei_user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ei_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ei_user_id();
  PROTOBUF_NODISCARD std::string* release_ei_user_id();
  void set_allocated_ei_user_id(std::string* ei_user_id);
  private:
  const std::string& _internal_ei_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ei_user_id(const std::string& value);
  std::string* _internal_mutable_ei_user_id();
  public:

  // optional string signature = 101;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // optional .ei.Backup.Settings settings = 4;
  bool has_settings() const;
  private:
  bool _internal_has_settings() const;
  public:
  void clear_settings();
  const ::ei::Backup_Settings& settings() const;
  PROTOBUF_NODISCARD ::ei::Backup_Settings* release_settings();
  ::ei::Backup_Settings* mutable_settings();
  void set_allocated_settings(::ei::Backup_Settings* settings);
  private:
  const ::ei::Backup_Settings& _internal_settings() const;
  ::ei::Backup_Settings* _internal_mutable_settings();
  public:
  void unsafe_arena_set_allocated_settings(
      ::ei::Backup_Settings* settings);
  ::ei::Backup_Settings* unsafe_arena_release_settings();

  // optional .ei.Backup.Tutorial tutorial = 5;
  bool has_tutorial() const;
  private:
  bool _internal_has_tutorial() const;
  public:
  void clear_tutorial();
  const ::ei::Backup_Tutorial& tutorial() const;
  PROTOBUF_NODISCARD ::ei::Backup_Tutorial* release_tutorial();
  ::ei::Backup_Tutorial* mutable_tutorial();
  void set_allocated_tutorial(::ei::Backup_Tutorial* tutorial);
  private:
  const ::ei::Backup_Tutorial& _internal_tutorial() const;
  ::ei::Backup_Tutorial* _internal_mutable_tutorial();
  public:
  void unsafe_arena_set_allocated_tutorial(
      ::ei::Backup_Tutorial* tutorial);
  ::ei::Backup_Tutorial* unsafe_arena_release_tutorial();

  // optional .ei.Backup.Stats stats = 6;
  bool has_stats() const;
  private:
  bool _internal_has_stats() const;
  public:
  void clear_stats();
  const ::ei::Backup_Stats& stats() const;
  PROTOBUF_NODISCARD ::ei::Backup_Stats* release_stats();
  ::ei::Backup_Stats* mutable_stats();
  void set_allocated_stats(::ei::Backup_Stats* stats);
  private:
  const ::ei::Backup_Stats& _internal_stats() const;
  ::ei::Backup_Stats* _internal_mutable_stats();
  public:
  void unsafe_arena_set_allocated_stats(
      ::ei::Backup_Stats* stats);
  ::ei::Backup_Stats* unsafe_arena_release_stats();

  // optional .ei.Backup.Game game = 7;
  bool has_game() const;
  private:
  bool _internal_has_game() const;
  public:
  void clear_game();
  const ::ei::Backup_Game& game() const;
  PROTOBUF_NODISCARD ::ei::Backup_Game* release_game();
  ::ei::Backup_Game* mutable_game();
  void set_allocated_game(::ei::Backup_Game* game);
  private:
  const ::ei::Backup_Game& _internal_game() const;
  ::ei::Backup_Game* _internal_mutable_game();
  public:
  void unsafe_arena_set_allocated_game(
      ::ei::Backup_Game* game);
  ::ei::Backup_Game* unsafe_arena_release_game();

  // optional .ei.Backup.Simulation sim = 8;
  bool has_sim() const;
  private:
  bool _internal_has_sim() const;
  public:
  void clear_sim();
  const ::ei::Backup_Simulation& sim() const;
  PROTOBUF_NODISCARD ::ei::Backup_Simulation* release_sim();
  ::ei::Backup_Simulation* mutable_sim();
  void set_allocated_sim(::ei::Backup_Simulation* sim);
  private:
  const ::ei::Backup_Simulation& _internal_sim() const;
  ::ei::Backup_Simulation* _internal_mutable_sim();
  public:
  void unsafe_arena_set_allocated_sim(
      ::ei::Backup_Simulation* sim);
  ::ei::Backup_Simulation* unsafe_arena_release_sim();

  // optional .ei.Backup.Mission mission = 9;
  bool has_mission() const;
  private:
  bool _internal_has_mission() const;
  public:
  void clear_mission();
  const ::ei::Backup_Mission& mission() const;
  PROTOBUF_NODISCARD ::ei::Backup_Mission* release_mission();
  ::ei::Backup_Mission* mutable_mission();
  void set_allocated_mission(::ei::Backup_Mission* mission);
  private:
  const ::ei::Backup_Mission& _internal_mission() const;
  ::ei::Backup_Mission* _internal_mutable_mission();
  public:
  void unsafe_arena_set_allocated_mission(
      ::ei::Backup_Mission* mission);
  ::ei::Backup_Mission* unsafe_arena_release_mission();

  // optional .ei.Backup.Misc misc = 10;
  bool has_misc() const;
  private:
  bool _internal_has_misc() const;
  public:
  void clear_misc();
  const ::ei::Backup_Misc& misc() const;
  PROTOBUF_NODISCARD ::ei::Backup_Misc* release_misc();
  ::ei::Backup_Misc* mutable_misc();
  void set_allocated_misc(::ei::Backup_Misc* misc);
  private:
  const ::ei::Backup_Misc& _internal_misc() const;
  ::ei::Backup_Misc* _internal_mutable_misc();
  public:
  void unsafe_arena_set_allocated_misc(
      ::ei::Backup_Misc* misc);
  ::ei::Backup_Misc* unsafe_arena_release_misc();

  // optional .ei.MyContracts contracts = 13;
  bool has_contracts() const;
  private:
  bool _internal_has_contracts() const;
  public:
  void clear_contracts();
  const ::ei::MyContracts& contracts() const;
  PROTOBUF_NODISCARD ::ei::MyContracts* release_contracts();
  ::ei::MyContracts* mutable_contracts();
  void set_allocated_contracts(::ei::MyContracts* contracts);
  private:
  const ::ei::MyContracts& _internal_contracts() const;
  ::ei::MyContracts* _internal_mutable_contracts();
  public:
  void unsafe_arena_set_allocated_contracts(
      ::ei::MyContracts* contracts);
  ::ei::MyContracts* unsafe_arena_release_contracts();

  // optional .ei.Backup.Artifacts artifacts = 14;
  bool has_artifacts() const;
  private:
  bool _internal_has_artifacts() const;
  public:
  void clear_artifacts();
  const ::ei::Backup_Artifacts& artifacts() const;
  PROTOBUF_NODISCARD ::ei::Backup_Artifacts* release_artifacts();
  ::ei::Backup_Artifacts* mutable_artifacts();
  void set_allocated_artifacts(::ei::Backup_Artifacts* artifacts);
  private:
  const ::ei::Backup_Artifacts& _internal_artifacts() const;
  ::ei::Backup_Artifacts* _internal_mutable_artifacts();
  public:
  void unsafe_arena_set_allocated_artifacts(
      ::ei::Backup_Artifacts* artifacts);
  ::ei::Backup_Artifacts* unsafe_arena_release_artifacts();

  // optional .ei.ArtifactsDB artifacts_db = 15;
  bool has_artifacts_db() const;
  private:
  bool _internal_has_artifacts_db() const;
  public:
  void clear_artifacts_db();
  const ::ei::ArtifactsDB& artifacts_db() const;
  PROTOBUF_NODISCARD ::ei::ArtifactsDB* release_artifacts_db();
  ::ei::ArtifactsDB* mutable_artifacts_db();
  void set_allocated_artifacts_db(::ei::ArtifactsDB* artifacts_db);
  private:
  const ::ei::ArtifactsDB& _internal_artifacts_db() const;
  ::ei::ArtifactsDB* _internal_mutable_artifacts_db();
  public:
  void unsafe_arena_set_allocated_artifacts_db(
      ::ei::ArtifactsDB* artifacts_db);
  ::ei::ArtifactsDB* unsafe_arena_release_artifacts_db();

  // optional .ei.ShellDB shell_db = 24;
  bool has_shell_db() const;
  private:
  bool _internal_has_shell_db() const;
  public:
  void clear_shell_db();
  const ::ei::ShellDB& shell_db() const;
  PROTOBUF_NODISCARD ::ei::ShellDB* release_shell_db();
  ::ei::ShellDB* mutable_shell_db();
  void set_allocated_shell_db(::ei::ShellDB* shell_db);
  private:
  const ::ei::ShellDB& _internal_shell_db() const;
  ::ei::ShellDB* _internal_mutable_shell_db();
  public:
  void unsafe_arena_set_allocated_shell_db(
      ::ei::ShellDB* shell_db);
  ::ei::ShellDB* unsafe_arena_release_shell_db();

  // optional .ei.Backup.Shells shells = 25;
  bool has_shells() const;
  private:
  bool _internal_has_shells() const;
  public:
  void clear_shells();
  const ::ei::Backup_Shells& shells() const;
  PROTOBUF_NODISCARD ::ei::Backup_Shells* release_shells();
  ::ei::Backup_Shells* mutable_shells();
  void set_allocated_shells(::ei::Backup_Shells* shells);
  private:
  const ::ei::Backup_Shells& _internal_shells() const;
  ::ei::Backup_Shells* _internal_mutable_shells();
  public:
  void unsafe_arena_set_allocated_shells(
      ::ei::Backup_Shells* shells);
  ::ei::Backup_Shells* unsafe_arena_release_shells();

  // optional double approx_time = 3;
  bool has_approx_time() const;
  private:
  bool _internal_has_approx_time() const;
  public:
  void clear_approx_time();
  double approx_time() const;
  void set_approx_time(double value);
  private:
  double _internal_approx_time() const;
  void _internal_set_approx_time(double value);
  public:

  // optional uint32 version = 21 [default = 0];
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // optional bool force_offer_backup = 20;
  bool has_force_offer_backup() const;
  private:
  bool _internal_has_force_offer_backup() const;
  public:
  void clear_force_offer_backup();
  bool force_offer_backup() const;
  void set_force_offer_backup(bool value);
  private:
  bool _internal_force_offer_backup() const;
  void _internal_set_force_offer_backup(bool value);
  public:

  // optional bool force_backup = 22;
  bool has_force_backup() const;
  private:
  bool _internal_has_force_backup() const;
  public:
  void clear_force_backup();
  bool force_backup() const;
  void set_force_backup(bool value);
  private:
  bool _internal_force_backup() const;
  void _internal_set_force_backup(bool value);
  public:

  // optional uint64 checksum = 100;
  bool has_checksum() const;
  private:
  bool _internal_has_checksum() const;
  public:
  void clear_checksum();
  uint64_t checksum() const;
  void set_checksum(uint64_t value);
  private:
  uint64_t _internal_checksum() const;
  void _internal_set_checksum(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.Backup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_Simulation > farms_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> read_mail_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_services_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ei_user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::ei::Backup_Settings* settings_;
  ::ei::Backup_Tutorial* tutorial_;
  ::ei::Backup_Stats* stats_;
  ::ei::Backup_Game* game_;
  ::ei::Backup_Simulation* sim_;
  ::ei::Backup_Mission* mission_;
  ::ei::Backup_Misc* misc_;
  ::ei::MyContracts* contracts_;
  ::ei::Backup_Artifacts* artifacts_;
  ::ei::ArtifactsDB* artifacts_db_;
  ::ei::ShellDB* shell_db_;
  ::ei::Backup_Shells* shells_;
  double approx_time_;
  uint32_t version_;
  bool force_offer_backup_;
  bool force_backup_;
  uint64_t checksum_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class EggIncFirstContactRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.EggIncFirstContactRequest) */ {
 public:
  inline EggIncFirstContactRequest() : EggIncFirstContactRequest(nullptr) {}
  ~EggIncFirstContactRequest() override;
  explicit constexpr EggIncFirstContactRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EggIncFirstContactRequest(const EggIncFirstContactRequest& from);
  EggIncFirstContactRequest(EggIncFirstContactRequest&& from) noexcept
    : EggIncFirstContactRequest() {
    *this = ::std::move(from);
  }

  inline EggIncFirstContactRequest& operator=(const EggIncFirstContactRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EggIncFirstContactRequest& operator=(EggIncFirstContactRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EggIncFirstContactRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EggIncFirstContactRequest* internal_default_instance() {
    return reinterpret_cast<const EggIncFirstContactRequest*>(
               &_EggIncFirstContactRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(EggIncFirstContactRequest& a, EggIncFirstContactRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EggIncFirstContactRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EggIncFirstContactRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EggIncFirstContactRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EggIncFirstContactRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EggIncFirstContactRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EggIncFirstContactRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EggIncFirstContactRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.EggIncFirstContactRequest";
  }
  protected:
  explicit EggIncFirstContactRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kEiUserIdFieldNumber = 4,
    kDeviceIdFieldNumber = 5,
    kUsernameFieldNumber = 6,
    kGameServicesIdFieldNumber = 7,
    kRinfoFieldNumber = 8,
    kClientVersionFieldNumber = 2,
    kPlatformFieldNumber = 3,
  };
  // optional string user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // optional string ei_user_id = 4;
  bool has_ei_user_id() const;
  private:
  bool _internal_has_ei_user_id() const;
  public:
  void clear_ei_user_id();
  const std::string& ei_user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ei_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ei_user_id();
  PROTOBUF_NODISCARD std::string* release_ei_user_id();
  void set_allocated_ei_user_id(std::string* ei_user_id);
  private:
  const std::string& _internal_ei_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ei_user_id(const std::string& value);
  std::string* _internal_mutable_ei_user_id();
  public:

  // optional string device_id = 5;
  bool has_device_id() const;
  private:
  bool _internal_has_device_id() const;
  public:
  void clear_device_id();
  const std::string& device_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_id();
  PROTOBUF_NODISCARD std::string* release_device_id();
  void set_allocated_device_id(std::string* device_id);
  private:
  const std::string& _internal_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_id(const std::string& value);
  std::string* _internal_mutable_device_id();
  public:

  // optional string username = 6;
  bool has_username() const;
  private:
  bool _internal_has_username() const;
  public:
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // optional string game_services_id = 7;
  bool has_game_services_id() const;
  private:
  bool _internal_has_game_services_id() const;
  public:
  void clear_game_services_id();
  const std::string& game_services_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_services_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_services_id();
  PROTOBUF_NODISCARD std::string* release_game_services_id();
  void set_allocated_game_services_id(std::string* game_services_id);
  private:
  const std::string& _internal_game_services_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_services_id(const std::string& value);
  std::string* _internal_mutable_game_services_id();
  public:

  // optional .ei.BasicRequestInfo rinfo = 8;
  bool has_rinfo() const;
  private:
  bool _internal_has_rinfo() const;
  public:
  void clear_rinfo();
  const ::ei::BasicRequestInfo& rinfo() const;
  PROTOBUF_NODISCARD ::ei::BasicRequestInfo* release_rinfo();
  ::ei::BasicRequestInfo* mutable_rinfo();
  void set_allocated_rinfo(::ei::BasicRequestInfo* rinfo);
  private:
  const ::ei::BasicRequestInfo& _internal_rinfo() const;
  ::ei::BasicRequestInfo* _internal_mutable_rinfo();
  public:
  void unsafe_arena_set_allocated_rinfo(
      ::ei::BasicRequestInfo* rinfo);
  ::ei::BasicRequestInfo* unsafe_arena_release_rinfo();

  // optional uint32 client_version = 2;
  bool has_client_version() const;
  private:
  bool _internal_has_client_version() const;
  public:
  void clear_client_version();
  uint32_t client_version() const;
  void set_client_version(uint32_t value);
  private:
  uint32_t _internal_client_version() const;
  void _internal_set_client_version(uint32_t value);
  public:

  // optional .ei.Platform platform = 3;
  bool has_platform() const;
  private:
  bool _internal_has_platform() const;
  public:
  void clear_platform();
  ::ei::Platform platform() const;
  void set_platform(::ei::Platform value);
  private:
  ::ei::Platform _internal_platform() const;
  void _internal_set_platform(::ei::Platform value);
  public:

  // @@protoc_insertion_point(class_scope:ei.EggIncFirstContactRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ei_user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_services_id_;
  ::ei::BasicRequestInfo* rinfo_;
  uint32_t client_version_;
  int platform_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class EggIncFirstContactResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.EggIncFirstContactResponse) */ {
 public:
  inline EggIncFirstContactResponse() : EggIncFirstContactResponse(nullptr) {}
  ~EggIncFirstContactResponse() override;
  explicit constexpr EggIncFirstContactResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EggIncFirstContactResponse(const EggIncFirstContactResponse& from);
  EggIncFirstContactResponse(EggIncFirstContactResponse&& from) noexcept
    : EggIncFirstContactResponse() {
    *this = ::std::move(from);
  }

  inline EggIncFirstContactResponse& operator=(const EggIncFirstContactResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EggIncFirstContactResponse& operator=(EggIncFirstContactResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EggIncFirstContactResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EggIncFirstContactResponse* internal_default_instance() {
    return reinterpret_cast<const EggIncFirstContactResponse*>(
               &_EggIncFirstContactResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(EggIncFirstContactResponse& a, EggIncFirstContactResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EggIncFirstContactResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EggIncFirstContactResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EggIncFirstContactResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EggIncFirstContactResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EggIncFirstContactResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EggIncFirstContactResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EggIncFirstContactResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.EggIncFirstContactResponse";
  }
  protected:
  explicit EggIncFirstContactResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef EggIncFirstContactResponse_ErrorCodes ErrorCodes;
  static constexpr ErrorCodes NO_ERROR =
    EggIncFirstContactResponse_ErrorCodes_NO_ERROR;
  static constexpr ErrorCodes EXISTING_USER_W_GAMER_ID =
    EggIncFirstContactResponse_ErrorCodes_EXISTING_USER_W_GAMER_ID;
  static constexpr ErrorCodes USER_NOT_FOUND =
    EggIncFirstContactResponse_ErrorCodes_USER_NOT_FOUND;
  static constexpr ErrorCodes BACKUP_CONFLICT =
    EggIncFirstContactResponse_ErrorCodes_BACKUP_CONFLICT;
  static inline bool ErrorCodes_IsValid(int value) {
    return EggIncFirstContactResponse_ErrorCodes_IsValid(value);
  }
  static constexpr ErrorCodes ErrorCodes_MIN =
    EggIncFirstContactResponse_ErrorCodes_ErrorCodes_MIN;
  static constexpr ErrorCodes ErrorCodes_MAX =
    EggIncFirstContactResponse_ErrorCodes_ErrorCodes_MAX;
  static constexpr int ErrorCodes_ARRAYSIZE =
    EggIncFirstContactResponse_ErrorCodes_ErrorCodes_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ErrorCodes_descriptor() {
    return EggIncFirstContactResponse_ErrorCodes_descriptor();
  }
  template<typename T>
  static inline const std::string& ErrorCodes_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ErrorCodes>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ErrorCodes_Name.");
    return EggIncFirstContactResponse_ErrorCodes_Name(enum_t_value);
  }
  static inline bool ErrorCodes_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ErrorCodes* value) {
    return EggIncFirstContactResponse_ErrorCodes_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIdsTransferredFieldNumber = 3,
    kEiUserIdFieldNumber = 2,
    kErrorMessageFieldNumber = 5,
    kBackupFieldNumber = 1,
    kErrorCodeFieldNumber = 4,
  };
  // repeated string ids_transferred = 3;
  int ids_transferred_size() const;
  private:
  int _internal_ids_transferred_size() const;
  public:
  void clear_ids_transferred();
  const std::string& ids_transferred(int index) const;
  std::string* mutable_ids_transferred(int index);
  void set_ids_transferred(int index, const std::string& value);
  void set_ids_transferred(int index, std::string&& value);
  void set_ids_transferred(int index, const char* value);
  void set_ids_transferred(int index, const char* value, size_t size);
  std::string* add_ids_transferred();
  void add_ids_transferred(const std::string& value);
  void add_ids_transferred(std::string&& value);
  void add_ids_transferred(const char* value);
  void add_ids_transferred(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ids_transferred() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ids_transferred();
  private:
  const std::string& _internal_ids_transferred(int index) const;
  std::string* _internal_add_ids_transferred();
  public:

  // optional string ei_user_id = 2;
  bool has_ei_user_id() const;
  private:
  bool _internal_has_ei_user_id() const;
  public:
  void clear_ei_user_id();
  const std::string& ei_user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ei_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ei_user_id();
  PROTOBUF_NODISCARD std::string* release_ei_user_id();
  void set_allocated_ei_user_id(std::string* ei_user_id);
  private:
  const std::string& _internal_ei_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ei_user_id(const std::string& value);
  std::string* _internal_mutable_ei_user_id();
  public:

  // optional string error_message = 5;
  bool has_error_message() const;
  private:
  bool _internal_has_error_message() const;
  public:
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // optional .ei.Backup backup = 1;
  bool has_backup() const;
  private:
  bool _internal_has_backup() const;
  public:
  void clear_backup();
  const ::ei::Backup& backup() const;
  PROTOBUF_NODISCARD ::ei::Backup* release_backup();
  ::ei::Backup* mutable_backup();
  void set_allocated_backup(::ei::Backup* backup);
  private:
  const ::ei::Backup& _internal_backup() const;
  ::ei::Backup* _internal_mutable_backup();
  public:
  void unsafe_arena_set_allocated_backup(
      ::ei::Backup* backup);
  ::ei::Backup* unsafe_arena_release_backup();

  // optional uint32 error_code = 4 [default = 0];
  bool has_error_code() const;
  private:
  bool _internal_has_error_code() const;
  public:
  void clear_error_code();
  uint32_t error_code() const;
  void set_error_code(uint32_t value);
  private:
  uint32_t _internal_error_code() const;
  void _internal_set_error_code(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.EggIncFirstContactResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ids_transferred_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ei_user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  ::ei::Backup* backup_;
  uint32_t error_code_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class EggIncAdConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.EggIncAdConfig) */ {
 public:
  inline EggIncAdConfig() : EggIncAdConfig(nullptr) {}
  ~EggIncAdConfig() override;
  explicit constexpr EggIncAdConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EggIncAdConfig(const EggIncAdConfig& from);
  EggIncAdConfig(EggIncAdConfig&& from) noexcept
    : EggIncAdConfig() {
    *this = ::std::move(from);
  }

  inline EggIncAdConfig& operator=(const EggIncAdConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline EggIncAdConfig& operator=(EggIncAdConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EggIncAdConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const EggIncAdConfig* internal_default_instance() {
    return reinterpret_cast<const EggIncAdConfig*>(
               &_EggIncAdConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(EggIncAdConfig& a, EggIncAdConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(EggIncAdConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EggIncAdConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EggIncAdConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EggIncAdConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EggIncAdConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EggIncAdConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EggIncAdConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.EggIncAdConfig";
  }
  protected:
  explicit EggIncAdConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNetworkPriorityFieldNumber = 1,
  };
  // repeated .ei.AdNetwork network_priority = 1;
  int network_priority_size() const;
  private:
  int _internal_network_priority_size() const;
  public:
  void clear_network_priority();
  private:
  ::ei::AdNetwork _internal_network_priority(int index) const;
  void _internal_add_network_priority(::ei::AdNetwork value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_network_priority();
  public:
  ::ei::AdNetwork network_priority(int index) const;
  void set_network_priority(int index, ::ei::AdNetwork value);
  void add_network_priority(::ei::AdNetwork value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& network_priority() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_network_priority();

  // @@protoc_insertion_point(class_scope:ei.EggIncAdConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> network_priority_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class DailyGiftInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.DailyGiftInfo) */ {
 public:
  inline DailyGiftInfo() : DailyGiftInfo(nullptr) {}
  ~DailyGiftInfo() override;
  explicit constexpr DailyGiftInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DailyGiftInfo(const DailyGiftInfo& from);
  DailyGiftInfo(DailyGiftInfo&& from) noexcept
    : DailyGiftInfo() {
    *this = ::std::move(from);
  }

  inline DailyGiftInfo& operator=(const DailyGiftInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DailyGiftInfo& operator=(DailyGiftInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DailyGiftInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DailyGiftInfo* internal_default_instance() {
    return reinterpret_cast<const DailyGiftInfo*>(
               &_DailyGiftInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(DailyGiftInfo& a, DailyGiftInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DailyGiftInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DailyGiftInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DailyGiftInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DailyGiftInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DailyGiftInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DailyGiftInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DailyGiftInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.DailyGiftInfo";
  }
  protected:
  explicit DailyGiftInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecondsToNextDayFieldNumber = 2,
    kCurrentDayFieldNumber = 1,
  };
  // optional double seconds_to_next_day = 2;
  bool has_seconds_to_next_day() const;
  private:
  bool _internal_has_seconds_to_next_day() const;
  public:
  void clear_seconds_to_next_day();
  double seconds_to_next_day() const;
  void set_seconds_to_next_day(double value);
  private:
  double _internal_seconds_to_next_day() const;
  void _internal_set_seconds_to_next_day(double value);
  public:

  // optional uint32 current_day = 1;
  bool has_current_day() const;
  private:
  bool _internal_has_current_day() const;
  public:
  void clear_current_day();
  uint32_t current_day() const;
  void set_current_day(uint32_t value);
  private:
  uint32_t _internal_current_day() const;
  void _internal_set_current_day(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.DailyGiftInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double seconds_to_next_day_;
  uint32_t current_day_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class SalesInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.SalesInfoRequest) */ {
 public:
  inline SalesInfoRequest() : SalesInfoRequest(nullptr) {}
  ~SalesInfoRequest() override;
  explicit constexpr SalesInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SalesInfoRequest(const SalesInfoRequest& from);
  SalesInfoRequest(SalesInfoRequest&& from) noexcept
    : SalesInfoRequest() {
    *this = ::std::move(from);
  }

  inline SalesInfoRequest& operator=(const SalesInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SalesInfoRequest& operator=(SalesInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SalesInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SalesInfoRequest* internal_default_instance() {
    return reinterpret_cast<const SalesInfoRequest*>(
               &_SalesInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SalesInfoRequest& a, SalesInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SalesInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SalesInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SalesInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SalesInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SalesInfoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SalesInfoRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SalesInfoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.SalesInfoRequest";
  }
  protected:
  explicit SalesInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kSecondsFullRealtimeFieldNumber = 4,
    kPiggyFullFieldNumber = 2,
    kPiggyFoundFullFieldNumber = 3,
    kLostIncrementsFieldNumber = 7,
    kSecondsFullGametimeFieldNumber = 5,
    kCurrentClientVersionFieldNumber = 10,
  };
  // optional string user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // optional double seconds_full_realtime = 4;
  bool has_seconds_full_realtime() const;
  private:
  bool _internal_has_seconds_full_realtime() const;
  public:
  void clear_seconds_full_realtime();
  double seconds_full_realtime() const;
  void set_seconds_full_realtime(double value);
  private:
  double _internal_seconds_full_realtime() const;
  void _internal_set_seconds_full_realtime(double value);
  public:

  // optional bool piggy_full = 2;
  bool has_piggy_full() const;
  private:
  bool _internal_has_piggy_full() const;
  public:
  void clear_piggy_full();
  bool piggy_full() const;
  void set_piggy_full(bool value);
  private:
  bool _internal_piggy_full() const;
  void _internal_set_piggy_full(bool value);
  public:

  // optional bool piggy_found_full = 3;
  bool has_piggy_found_full() const;
  private:
  bool _internal_has_piggy_found_full() const;
  public:
  void clear_piggy_found_full();
  bool piggy_found_full() const;
  void set_piggy_found_full(bool value);
  private:
  bool _internal_piggy_found_full() const;
  void _internal_set_piggy_found_full(bool value);
  public:

  // optional uint32 lost_increments = 7;
  bool has_lost_increments() const;
  private:
  bool _internal_has_lost_increments() const;
  public:
  void clear_lost_increments();
  uint32_t lost_increments() const;
  void set_lost_increments(uint32_t value);
  private:
  uint32_t _internal_lost_increments() const;
  void _internal_set_lost_increments(uint32_t value);
  public:

  // optional double seconds_full_gametime = 5;
  bool has_seconds_full_gametime() const;
  private:
  bool _internal_has_seconds_full_gametime() const;
  public:
  void clear_seconds_full_gametime();
  double seconds_full_gametime() const;
  void set_seconds_full_gametime(double value);
  private:
  double _internal_seconds_full_gametime() const;
  void _internal_set_seconds_full_gametime(double value);
  public:

  // optional uint32 current_client_version = 10;
  bool has_current_client_version() const;
  private:
  bool _internal_has_current_client_version() const;
  public:
  void clear_current_client_version();
  uint32_t current_client_version() const;
  void set_current_client_version(uint32_t value);
  private:
  uint32_t _internal_current_client_version() const;
  void _internal_set_current_client_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.SalesInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  double seconds_full_realtime_;
  bool piggy_full_;
  bool piggy_found_full_;
  uint32_t lost_increments_;
  double seconds_full_gametime_;
  uint32_t current_client_version_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class IAPSaleEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.IAPSaleEntry) */ {
 public:
  inline IAPSaleEntry() : IAPSaleEntry(nullptr) {}
  ~IAPSaleEntry() override;
  explicit constexpr IAPSaleEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IAPSaleEntry(const IAPSaleEntry& from);
  IAPSaleEntry(IAPSaleEntry&& from) noexcept
    : IAPSaleEntry() {
    *this = ::std::move(from);
  }

  inline IAPSaleEntry& operator=(const IAPSaleEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline IAPSaleEntry& operator=(IAPSaleEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IAPSaleEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const IAPSaleEntry* internal_default_instance() {
    return reinterpret_cast<const IAPSaleEntry*>(
               &_IAPSaleEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(IAPSaleEntry& a, IAPSaleEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(IAPSaleEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IAPSaleEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IAPSaleEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IAPSaleEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IAPSaleEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IAPSaleEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IAPSaleEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.IAPSaleEntry";
  }
  protected:
  explicit IAPSaleEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductIdFieldNumber = 1,
    kDiscountStringFieldNumber = 3,
    kSaleIdFieldNumber = 4,
    kSecondsRemainingFieldNumber = 2,
  };
  // optional string product_id = 1;
  bool has_product_id() const;
  private:
  bool _internal_has_product_id() const;
  public:
  void clear_product_id();
  const std::string& product_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_product_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_product_id();
  PROTOBUF_NODISCARD std::string* release_product_id();
  void set_allocated_product_id(std::string* product_id);
  private:
  const std::string& _internal_product_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_product_id(const std::string& value);
  std::string* _internal_mutable_product_id();
  public:

  // optional string discount_string = 3;
  bool has_discount_string() const;
  private:
  bool _internal_has_discount_string() const;
  public:
  void clear_discount_string();
  const std::string& discount_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_discount_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_discount_string();
  PROTOBUF_NODISCARD std::string* release_discount_string();
  void set_allocated_discount_string(std::string* discount_string);
  private:
  const std::string& _internal_discount_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_discount_string(const std::string& value);
  std::string* _internal_mutable_discount_string();
  public:

  // optional string sale_id = 4;
  bool has_sale_id() const;
  private:
  bool _internal_has_sale_id() const;
  public:
  void clear_sale_id();
  const std::string& sale_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sale_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sale_id();
  PROTOBUF_NODISCARD std::string* release_sale_id();
  void set_allocated_sale_id(std::string* sale_id);
  private:
  const std::string& _internal_sale_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sale_id(const std::string& value);
  std::string* _internal_mutable_sale_id();
  public:

  // optional double seconds_remaining = 2;
  bool has_seconds_remaining() const;
  private:
  bool _internal_has_seconds_remaining() const;
  public:
  void clear_seconds_remaining();
  double seconds_remaining() const;
  void set_seconds_remaining(double value);
  private:
  double _internal_seconds_remaining() const;
  void _internal_set_seconds_remaining(double value);
  public:

  // @@protoc_insertion_point(class_scope:ei.IAPSaleEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr product_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr discount_string_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sale_id_;
  double seconds_remaining_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class SalesInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.SalesInfo) */ {
 public:
  inline SalesInfo() : SalesInfo(nullptr) {}
  ~SalesInfo() override;
  explicit constexpr SalesInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SalesInfo(const SalesInfo& from);
  SalesInfo(SalesInfo&& from) noexcept
    : SalesInfo() {
    *this = ::std::move(from);
  }

  inline SalesInfo& operator=(const SalesInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SalesInfo& operator=(SalesInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SalesInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SalesInfo* internal_default_instance() {
    return reinterpret_cast<const SalesInfo*>(
               &_SalesInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SalesInfo& a, SalesInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SalesInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SalesInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SalesInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SalesInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SalesInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SalesInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SalesInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.SalesInfo";
  }
  protected:
  explicit SalesInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSalesFieldNumber = 1,
  };
  // repeated .ei.IAPSaleEntry sales = 1;
  int sales_size() const;
  private:
  int _internal_sales_size() const;
  public:
  void clear_sales();
  ::ei::IAPSaleEntry* mutable_sales(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::IAPSaleEntry >*
      mutable_sales();
  private:
  const ::ei::IAPSaleEntry& _internal_sales(int index) const;
  ::ei::IAPSaleEntry* _internal_add_sales();
  public:
  const ::ei::IAPSaleEntry& sales(int index) const;
  ::ei::IAPSaleEntry* add_sales();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::IAPSaleEntry >&
      sales() const;

  // @@protoc_insertion_point(class_scope:ei.SalesInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::IAPSaleEntry > sales_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class EggIncEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.EggIncEvent) */ {
 public:
  inline EggIncEvent() : EggIncEvent(nullptr) {}
  ~EggIncEvent() override;
  explicit constexpr EggIncEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EggIncEvent(const EggIncEvent& from);
  EggIncEvent(EggIncEvent&& from) noexcept
    : EggIncEvent() {
    *this = ::std::move(from);
  }

  inline EggIncEvent& operator=(const EggIncEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline EggIncEvent& operator=(EggIncEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EggIncEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const EggIncEvent* internal_default_instance() {
    return reinterpret_cast<const EggIncEvent*>(
               &_EggIncEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(EggIncEvent& a, EggIncEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(EggIncEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EggIncEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EggIncEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EggIncEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EggIncEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EggIncEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EggIncEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.EggIncEvent";
  }
  protected:
  explicit EggIncEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifierFieldNumber = 1,
    kTypeFieldNumber = 3,
    kSubtitleFieldNumber = 5,
    kSecondsRemainingFieldNumber = 2,
    kMultiplierFieldNumber = 4,
    kStartTimeFieldNumber = 6,
    kDurationFieldNumber = 7,
  };
  // optional string identifier = 1;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  PROTOBUF_NODISCARD std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // optional string type = 3;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional string subtitle = 5;
  bool has_subtitle() const;
  private:
  bool _internal_has_subtitle() const;
  public:
  void clear_subtitle();
  const std::string& subtitle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subtitle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subtitle();
  PROTOBUF_NODISCARD std::string* release_subtitle();
  void set_allocated_subtitle(std::string* subtitle);
  private:
  const std::string& _internal_subtitle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subtitle(const std::string& value);
  std::string* _internal_mutable_subtitle();
  public:

  // optional double seconds_remaining = 2;
  bool has_seconds_remaining() const;
  private:
  bool _internal_has_seconds_remaining() const;
  public:
  void clear_seconds_remaining();
  double seconds_remaining() const;
  void set_seconds_remaining(double value);
  private:
  double _internal_seconds_remaining() const;
  void _internal_set_seconds_remaining(double value);
  public:

  // optional double multiplier = 4;
  bool has_multiplier() const;
  private:
  bool _internal_has_multiplier() const;
  public:
  void clear_multiplier();
  double multiplier() const;
  void set_multiplier(double value);
  private:
  double _internal_multiplier() const;
  void _internal_set_multiplier(double value);
  public:

  // optional double start_time = 6;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  double start_time() const;
  void set_start_time(double value);
  private:
  double _internal_start_time() const;
  void _internal_set_start_time(double value);
  public:

  // optional double duration = 7;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  double duration() const;
  void set_duration(double value);
  private:
  double _internal_duration() const;
  void _internal_set_duration(double value);
  public:

  // @@protoc_insertion_point(class_scope:ei.EggIncEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subtitle_;
  double seconds_remaining_;
  double multiplier_;
  double start_time_;
  double duration_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class EggIncCurrentEvents final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.EggIncCurrentEvents) */ {
 public:
  inline EggIncCurrentEvents() : EggIncCurrentEvents(nullptr) {}
  ~EggIncCurrentEvents() override;
  explicit constexpr EggIncCurrentEvents(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EggIncCurrentEvents(const EggIncCurrentEvents& from);
  EggIncCurrentEvents(EggIncCurrentEvents&& from) noexcept
    : EggIncCurrentEvents() {
    *this = ::std::move(from);
  }

  inline EggIncCurrentEvents& operator=(const EggIncCurrentEvents& from) {
    CopyFrom(from);
    return *this;
  }
  inline EggIncCurrentEvents& operator=(EggIncCurrentEvents&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EggIncCurrentEvents& default_instance() {
    return *internal_default_instance();
  }
  static inline const EggIncCurrentEvents* internal_default_instance() {
    return reinterpret_cast<const EggIncCurrentEvents*>(
               &_EggIncCurrentEvents_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(EggIncCurrentEvents& a, EggIncCurrentEvents& b) {
    a.Swap(&b);
  }
  inline void Swap(EggIncCurrentEvents* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EggIncCurrentEvents* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EggIncCurrentEvents* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EggIncCurrentEvents>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EggIncCurrentEvents& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EggIncCurrentEvents& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EggIncCurrentEvents* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.EggIncCurrentEvents";
  }
  protected:
  explicit EggIncCurrentEvents(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 1,
  };
  // repeated .ei.EggIncEvent events = 1;
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::ei::EggIncEvent* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::EggIncEvent >*
      mutable_events();
  private:
  const ::ei::EggIncEvent& _internal_events(int index) const;
  ::ei::EggIncEvent* _internal_add_events();
  public:
  const ::ei::EggIncEvent& events(int index) const;
  ::ei::EggIncEvent* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::EggIncEvent >&
      events() const;

  // @@protoc_insertion_point(class_scope:ei.EggIncCurrentEvents)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::EggIncEvent > events_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class DeviceInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.DeviceInfo) */ {
 public:
  inline DeviceInfo() : DeviceInfo(nullptr) {}
  ~DeviceInfo() override;
  explicit constexpr DeviceInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceInfo(const DeviceInfo& from);
  DeviceInfo(DeviceInfo&& from) noexcept
    : DeviceInfo() {
    *this = ::std::move(from);
  }

  inline DeviceInfo& operator=(const DeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceInfo& operator=(DeviceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceInfo* internal_default_instance() {
    return reinterpret_cast<const DeviceInfo*>(
               &_DeviceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(DeviceInfo& a, DeviceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeviceInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.DeviceInfo";
  }
  protected:
  explicit DeviceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceIdFieldNumber = 1,
    kPlatformFieldNumber = 2,
    kFormFactorFieldNumber = 3,
    kDeviceNameFieldNumber = 4,
    kPlatformVersionFieldNumber = 5,
    kLocaleCountryFieldNumber = 6,
    kLocaleLanguageFieldNumber = 7,
    kGpuVendorFieldNumber = 8,
    kGpuModelFieldNumber = 9,
    kDeviceBucketFieldNumber = 10,
    kAdvertisingIdFieldNumber = 13,
    kScreenWidthFieldNumber = 11,
    kScreenHeightFieldNumber = 12,
  };
  // optional string device_id = 1;
  bool has_device_id() const;
  private:
  bool _internal_has_device_id() const;
  public:
  void clear_device_id();
  const std::string& device_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_id();
  PROTOBUF_NODISCARD std::string* release_device_id();
  void set_allocated_device_id(std::string* device_id);
  private:
  const std::string& _internal_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_id(const std::string& value);
  std::string* _internal_mutable_device_id();
  public:

  // optional string platform = 2;
  bool has_platform() const;
  private:
  bool _internal_has_platform() const;
  public:
  void clear_platform();
  const std::string& platform() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_platform(ArgT0&& arg0, ArgT... args);
  std::string* mutable_platform();
  PROTOBUF_NODISCARD std::string* release_platform();
  void set_allocated_platform(std::string* platform);
  private:
  const std::string& _internal_platform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform(const std::string& value);
  std::string* _internal_mutable_platform();
  public:

  // optional string form_factor = 3;
  bool has_form_factor() const;
  private:
  bool _internal_has_form_factor() const;
  public:
  void clear_form_factor();
  const std::string& form_factor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_form_factor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_form_factor();
  PROTOBUF_NODISCARD std::string* release_form_factor();
  void set_allocated_form_factor(std::string* form_factor);
  private:
  const std::string& _internal_form_factor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_form_factor(const std::string& value);
  std::string* _internal_mutable_form_factor();
  public:

  // optional string device_name = 4;
  bool has_device_name() const;
  private:
  bool _internal_has_device_name() const;
  public:
  void clear_device_name();
  const std::string& device_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_name();
  PROTOBUF_NODISCARD std::string* release_device_name();
  void set_allocated_device_name(std::string* device_name);
  private:
  const std::string& _internal_device_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_name(const std::string& value);
  std::string* _internal_mutable_device_name();
  public:

  // optional string platform_version = 5;
  bool has_platform_version() const;
  private:
  bool _internal_has_platform_version() const;
  public:
  void clear_platform_version();
  const std::string& platform_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_platform_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_platform_version();
  PROTOBUF_NODISCARD std::string* release_platform_version();
  void set_allocated_platform_version(std::string* platform_version);
  private:
  const std::string& _internal_platform_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform_version(const std::string& value);
  std::string* _internal_mutable_platform_version();
  public:

  // optional string locale_country = 6;
  bool has_locale_country() const;
  private:
  bool _internal_has_locale_country() const;
  public:
  void clear_locale_country();
  const std::string& locale_country() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_locale_country(ArgT0&& arg0, ArgT... args);
  std::string* mutable_locale_country();
  PROTOBUF_NODISCARD std::string* release_locale_country();
  void set_allocated_locale_country(std::string* locale_country);
  private:
  const std::string& _internal_locale_country() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locale_country(const std::string& value);
  std::string* _internal_mutable_locale_country();
  public:

  // optional string locale_language = 7;
  bool has_locale_language() const;
  private:
  bool _internal_has_locale_language() const;
  public:
  void clear_locale_language();
  const std::string& locale_language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_locale_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_locale_language();
  PROTOBUF_NODISCARD std::string* release_locale_language();
  void set_allocated_locale_language(std::string* locale_language);
  private:
  const std::string& _internal_locale_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locale_language(const std::string& value);
  std::string* _internal_mutable_locale_language();
  public:

  // optional string gpu_vendor = 8;
  bool has_gpu_vendor() const;
  private:
  bool _internal_has_gpu_vendor() const;
  public:
  void clear_gpu_vendor();
  const std::string& gpu_vendor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gpu_vendor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gpu_vendor();
  PROTOBUF_NODISCARD std::string* release_gpu_vendor();
  void set_allocated_gpu_vendor(std::string* gpu_vendor);
  private:
  const std::string& _internal_gpu_vendor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gpu_vendor(const std::string& value);
  std::string* _internal_mutable_gpu_vendor();
  public:

  // optional string gpu_model = 9;
  bool has_gpu_model() const;
  private:
  bool _internal_has_gpu_model() const;
  public:
  void clear_gpu_model();
  const std::string& gpu_model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gpu_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gpu_model();
  PROTOBUF_NODISCARD std::string* release_gpu_model();
  void set_allocated_gpu_model(std::string* gpu_model);
  private:
  const std::string& _internal_gpu_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gpu_model(const std::string& value);
  std::string* _internal_mutable_gpu_model();
  public:

  // optional string device_bucket = 10;
  bool has_device_bucket() const;
  private:
  bool _internal_has_device_bucket() const;
  public:
  void clear_device_bucket();
  const std::string& device_bucket() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_bucket(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_bucket();
  PROTOBUF_NODISCARD std::string* release_device_bucket();
  void set_allocated_device_bucket(std::string* device_bucket);
  private:
  const std::string& _internal_device_bucket() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_bucket(const std::string& value);
  std::string* _internal_mutable_device_bucket();
  public:

  // optional string advertising_id = 13;
  bool has_advertising_id() const;
  private:
  bool _internal_has_advertising_id() const;
  public:
  void clear_advertising_id();
  const std::string& advertising_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_advertising_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_advertising_id();
  PROTOBUF_NODISCARD std::string* release_advertising_id();
  void set_allocated_advertising_id(std::string* advertising_id);
  private:
  const std::string& _internal_advertising_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_advertising_id(const std::string& value);
  std::string* _internal_mutable_advertising_id();
  public:

  // optional uint32 screen_width = 11;
  bool has_screen_width() const;
  private:
  bool _internal_has_screen_width() const;
  public:
  void clear_screen_width();
  uint32_t screen_width() const;
  void set_screen_width(uint32_t value);
  private:
  uint32_t _internal_screen_width() const;
  void _internal_set_screen_width(uint32_t value);
  public:

  // optional uint32 screen_height = 12;
  bool has_screen_height() const;
  private:
  bool _internal_has_screen_height() const;
  public:
  void clear_screen_height();
  uint32_t screen_height() const;
  void set_screen_height(uint32_t value);
  private:
  uint32_t _internal_screen_height() const;
  void _internal_set_screen_height(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.DeviceInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr form_factor_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr locale_country_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr locale_language_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gpu_vendor_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gpu_model_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_bucket_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr advertising_id_;
  uint32_t screen_width_;
  uint32_t screen_height_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class AppInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.AppInfo) */ {
 public:
  inline AppInfo() : AppInfo(nullptr) {}
  ~AppInfo() override;
  explicit constexpr AppInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppInfo(const AppInfo& from);
  AppInfo(AppInfo&& from) noexcept
    : AppInfo() {
    *this = ::std::move(from);
  }

  inline AppInfo& operator=(const AppInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppInfo& operator=(AppInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppInfo* internal_default_instance() {
    return reinterpret_cast<const AppInfo*>(
               &_AppInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(AppInfo& a, AppInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AppInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.AppInfo";
  }
  protected:
  explicit AppInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionStrFieldNumber = 1,
    kSaleIdFieldNumber = 28,
    kSessionsFieldNumber = 2,
    kNumPrestigesFieldNumber = 3,
    kSoulEggsFieldNumber = 4,
    kGoldEarnedFieldNumber = 6,
    kCurrentEggFieldNumber = 5,
    kCurrentMissionFieldNumber = 8,
    kGoldSpentFieldNumber = 7,
    kNumPiggyBreaksFieldNumber = 10,
    kPiggySizeFieldNumber = 9,
    kPermitLevelFieldNumber = 12,
    kIapPacksPurchasedFieldNumber = 11,
    kUnlimitedChickensUsesFieldNumber = 13,
    kRefillUsesFieldNumber = 14,
    kVideoDoublerUsesFieldNumber = 15,
    kShortWarpUsesFieldNumber = 16,
    kLongWarpUsesFieldNumber = 17,
    kDroneTakedownsFieldNumber = 18,
    kDroneTakedownsEliteFieldNumber = 19,
    kEggLevelFieldNumber = 21,
    kStruggleFactorFieldNumber = 22,
    kTimePiggyFullRealtimeFieldNumber = 25,
    kTimePiggyFullGametimeFieldNumber = 26,
    kLostPiggyIncrementsFieldNumber = 27,
    kVerifiedPiggyBreaksFieldNumber = 29,
    kTrophiesUnlockedFieldNumber = 20,
    kPiggyFullFieldNumber = 23,
    kPiggyFoundFullFieldNumber = 24,
  };
  // optional string version_str = 1;
  bool has_version_str() const;
  private:
  bool _internal_has_version_str() const;
  public:
  void clear_version_str();
  const std::string& version_str() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version_str(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version_str();
  PROTOBUF_NODISCARD std::string* release_version_str();
  void set_allocated_version_str(std::string* version_str);
  private:
  const std::string& _internal_version_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version_str(const std::string& value);
  std::string* _internal_mutable_version_str();
  public:

  // optional string sale_id = 28;
  bool has_sale_id() const;
  private:
  bool _internal_has_sale_id() const;
  public:
  void clear_sale_id();
  const std::string& sale_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sale_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sale_id();
  PROTOBUF_NODISCARD std::string* release_sale_id();
  void set_allocated_sale_id(std::string* sale_id);
  private:
  const std::string& _internal_sale_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sale_id(const std::string& value);
  std::string* _internal_mutable_sale_id();
  public:

  // optional uint32 sessions = 2;
  bool has_sessions() const;
  private:
  bool _internal_has_sessions() const;
  public:
  void clear_sessions();
  uint32_t sessions() const;
  void set_sessions(uint32_t value);
  private:
  uint32_t _internal_sessions() const;
  void _internal_set_sessions(uint32_t value);
  public:

  // optional uint32 num_prestiges = 3;
  bool has_num_prestiges() const;
  private:
  bool _internal_has_num_prestiges() const;
  public:
  void clear_num_prestiges();
  uint32_t num_prestiges() const;
  void set_num_prestiges(uint32_t value);
  private:
  uint32_t _internal_num_prestiges() const;
  void _internal_set_num_prestiges(uint32_t value);
  public:

  // optional uint64 soul_eggs = 4;
  bool has_soul_eggs() const;
  private:
  bool _internal_has_soul_eggs() const;
  public:
  void clear_soul_eggs();
  uint64_t soul_eggs() const;
  void set_soul_eggs(uint64_t value);
  private:
  uint64_t _internal_soul_eggs() const;
  void _internal_set_soul_eggs(uint64_t value);
  public:

  // optional uint64 gold_earned = 6;
  bool has_gold_earned() const;
  private:
  bool _internal_has_gold_earned() const;
  public:
  void clear_gold_earned();
  uint64_t gold_earned() const;
  void set_gold_earned(uint64_t value);
  private:
  uint64_t _internal_gold_earned() const;
  void _internal_set_gold_earned(uint64_t value);
  public:

  // optional uint32 current_egg = 5;
  bool has_current_egg() const;
  private:
  bool _internal_has_current_egg() const;
  public:
  void clear_current_egg();
  uint32_t current_egg() const;
  void set_current_egg(uint32_t value);
  private:
  uint32_t _internal_current_egg() const;
  void _internal_set_current_egg(uint32_t value);
  public:

  // optional uint32 current_mission = 8;
  bool has_current_mission() const;
  private:
  bool _internal_has_current_mission() const;
  public:
  void clear_current_mission();
  uint32_t current_mission() const;
  void set_current_mission(uint32_t value);
  private:
  uint32_t _internal_current_mission() const;
  void _internal_set_current_mission(uint32_t value);
  public:

  // optional uint64 gold_spent = 7;
  bool has_gold_spent() const;
  private:
  bool _internal_has_gold_spent() const;
  public:
  void clear_gold_spent();
  uint64_t gold_spent() const;
  void set_gold_spent(uint64_t value);
  private:
  uint64_t _internal_gold_spent() const;
  void _internal_set_gold_spent(uint64_t value);
  public:

  // optional uint64 num_piggy_breaks = 10;
  bool has_num_piggy_breaks() const;
  private:
  bool _internal_has_num_piggy_breaks() const;
  public:
  void clear_num_piggy_breaks();
  uint64_t num_piggy_breaks() const;
  void set_num_piggy_breaks(uint64_t value);
  private:
  uint64_t _internal_num_piggy_breaks() const;
  void _internal_set_num_piggy_breaks(uint64_t value);
  public:

  // optional uint32 piggy_size = 9;
  bool has_piggy_size() const;
  private:
  bool _internal_has_piggy_size() const;
  public:
  void clear_piggy_size();
  uint32_t piggy_size() const;
  void set_piggy_size(uint32_t value);
  private:
  uint32_t _internal_piggy_size() const;
  void _internal_set_piggy_size(uint32_t value);
  public:

  // optional uint32 permit_level = 12;
  bool has_permit_level() const;
  private:
  bool _internal_has_permit_level() const;
  public:
  void clear_permit_level();
  uint32_t permit_level() const;
  void set_permit_level(uint32_t value);
  private:
  uint32_t _internal_permit_level() const;
  void _internal_set_permit_level(uint32_t value);
  public:

  // optional uint64 iap_packs_purchased = 11;
  bool has_iap_packs_purchased() const;
  private:
  bool _internal_has_iap_packs_purchased() const;
  public:
  void clear_iap_packs_purchased();
  uint64_t iap_packs_purchased() const;
  void set_iap_packs_purchased(uint64_t value);
  private:
  uint64_t _internal_iap_packs_purchased() const;
  void _internal_set_iap_packs_purchased(uint64_t value);
  public:

  // optional uint64 unlimited_chickens_uses = 13;
  bool has_unlimited_chickens_uses() const;
  private:
  bool _internal_has_unlimited_chickens_uses() const;
  public:
  void clear_unlimited_chickens_uses();
  uint64_t unlimited_chickens_uses() const;
  void set_unlimited_chickens_uses(uint64_t value);
  private:
  uint64_t _internal_unlimited_chickens_uses() const;
  void _internal_set_unlimited_chickens_uses(uint64_t value);
  public:

  // optional uint64 refill_uses = 14;
  bool has_refill_uses() const;
  private:
  bool _internal_has_refill_uses() const;
  public:
  void clear_refill_uses();
  uint64_t refill_uses() const;
  void set_refill_uses(uint64_t value);
  private:
  uint64_t _internal_refill_uses() const;
  void _internal_set_refill_uses(uint64_t value);
  public:

  // optional uint64 video_doubler_uses = 15;
  bool has_video_doubler_uses() const;
  private:
  bool _internal_has_video_doubler_uses() const;
  public:
  void clear_video_doubler_uses();
  uint64_t video_doubler_uses() const;
  void set_video_doubler_uses(uint64_t value);
  private:
  uint64_t _internal_video_doubler_uses() const;
  void _internal_set_video_doubler_uses(uint64_t value);
  public:

  // optional uint64 short_warp_uses = 16;
  bool has_short_warp_uses() const;
  private:
  bool _internal_has_short_warp_uses() const;
  public:
  void clear_short_warp_uses();
  uint64_t short_warp_uses() const;
  void set_short_warp_uses(uint64_t value);
  private:
  uint64_t _internal_short_warp_uses() const;
  void _internal_set_short_warp_uses(uint64_t value);
  public:

  // optional uint64 long_warp_uses = 17;
  bool has_long_warp_uses() const;
  private:
  bool _internal_has_long_warp_uses() const;
  public:
  void clear_long_warp_uses();
  uint64_t long_warp_uses() const;
  void set_long_warp_uses(uint64_t value);
  private:
  uint64_t _internal_long_warp_uses() const;
  void _internal_set_long_warp_uses(uint64_t value);
  public:

  // optional uint64 drone_takedowns = 18;
  bool has_drone_takedowns() const;
  private:
  bool _internal_has_drone_takedowns() const;
  public:
  void clear_drone_takedowns();
  uint64_t drone_takedowns() const;
  void set_drone_takedowns(uint64_t value);
  private:
  uint64_t _internal_drone_takedowns() const;
  void _internal_set_drone_takedowns(uint64_t value);
  public:

  // optional uint64 drone_takedowns_elite = 19;
  bool has_drone_takedowns_elite() const;
  private:
  bool _internal_has_drone_takedowns_elite() const;
  public:
  void clear_drone_takedowns_elite();
  uint64_t drone_takedowns_elite() const;
  void set_drone_takedowns_elite(uint64_t value);
  private:
  uint64_t _internal_drone_takedowns_elite() const;
  void _internal_set_drone_takedowns_elite(uint64_t value);
  public:

  // optional float egg_level = 21;
  bool has_egg_level() const;
  private:
  bool _internal_has_egg_level() const;
  public:
  void clear_egg_level();
  float egg_level() const;
  void set_egg_level(float value);
  private:
  float _internal_egg_level() const;
  void _internal_set_egg_level(float value);
  public:

  // optional float struggle_factor = 22;
  bool has_struggle_factor() const;
  private:
  bool _internal_has_struggle_factor() const;
  public:
  void clear_struggle_factor();
  float struggle_factor() const;
  void set_struggle_factor(float value);
  private:
  float _internal_struggle_factor() const;
  void _internal_set_struggle_factor(float value);
  public:

  // optional double time_piggy_full_realtime = 25;
  bool has_time_piggy_full_realtime() const;
  private:
  bool _internal_has_time_piggy_full_realtime() const;
  public:
  void clear_time_piggy_full_realtime();
  double time_piggy_full_realtime() const;
  void set_time_piggy_full_realtime(double value);
  private:
  double _internal_time_piggy_full_realtime() const;
  void _internal_set_time_piggy_full_realtime(double value);
  public:

  // optional double time_piggy_full_gametime = 26;
  bool has_time_piggy_full_gametime() const;
  private:
  bool _internal_has_time_piggy_full_gametime() const;
  public:
  void clear_time_piggy_full_gametime();
  double time_piggy_full_gametime() const;
  void set_time_piggy_full_gametime(double value);
  private:
  double _internal_time_piggy_full_gametime() const;
  void _internal_set_time_piggy_full_gametime(double value);
  public:

  // optional uint64 lost_piggy_increments = 27;
  bool has_lost_piggy_increments() const;
  private:
  bool _internal_has_lost_piggy_increments() const;
  public:
  void clear_lost_piggy_increments();
  uint64_t lost_piggy_increments() const;
  void set_lost_piggy_increments(uint64_t value);
  private:
  uint64_t _internal_lost_piggy_increments() const;
  void _internal_set_lost_piggy_increments(uint64_t value);
  public:

  // optional uint64 verified_piggy_breaks = 29;
  bool has_verified_piggy_breaks() const;
  private:
  bool _internal_has_verified_piggy_breaks() const;
  public:
  void clear_verified_piggy_breaks();
  uint64_t verified_piggy_breaks() const;
  void set_verified_piggy_breaks(uint64_t value);
  private:
  uint64_t _internal_verified_piggy_breaks() const;
  void _internal_set_verified_piggy_breaks(uint64_t value);
  public:

  // optional bool trophies_unlocked = 20;
  bool has_trophies_unlocked() const;
  private:
  bool _internal_has_trophies_unlocked() const;
  public:
  void clear_trophies_unlocked();
  bool trophies_unlocked() const;
  void set_trophies_unlocked(bool value);
  private:
  bool _internal_trophies_unlocked() const;
  void _internal_set_trophies_unlocked(bool value);
  public:

  // optional bool piggy_full = 23;
  bool has_piggy_full() const;
  private:
  bool _internal_has_piggy_full() const;
  public:
  void clear_piggy_full();
  bool piggy_full() const;
  void set_piggy_full(bool value);
  private:
  bool _internal_piggy_full() const;
  void _internal_set_piggy_full(bool value);
  public:

  // optional bool piggy_found_full = 24;
  bool has_piggy_found_full() const;
  private:
  bool _internal_has_piggy_found_full() const;
  public:
  void clear_piggy_found_full();
  bool piggy_found_full() const;
  void set_piggy_found_full(bool value);
  private:
  bool _internal_piggy_found_full() const;
  void _internal_set_piggy_found_full(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ei.AppInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_str_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sale_id_;
  uint32_t sessions_;
  uint32_t num_prestiges_;
  uint64_t soul_eggs_;
  uint64_t gold_earned_;
  uint32_t current_egg_;
  uint32_t current_mission_;
  uint64_t gold_spent_;
  uint64_t num_piggy_breaks_;
  uint32_t piggy_size_;
  uint32_t permit_level_;
  uint64_t iap_packs_purchased_;
  uint64_t unlimited_chickens_uses_;
  uint64_t refill_uses_;
  uint64_t video_doubler_uses_;
  uint64_t short_warp_uses_;
  uint64_t long_warp_uses_;
  uint64_t drone_takedowns_;
  uint64_t drone_takedowns_elite_;
  float egg_level_;
  float struggle_factor_;
  double time_piggy_full_realtime_;
  double time_piggy_full_gametime_;
  uint64_t lost_piggy_increments_;
  uint64_t verified_piggy_breaks_;
  bool trophies_unlocked_;
  bool piggy_full_;
  bool piggy_found_full_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ActionKeyValuePair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ActionKeyValuePair) */ {
 public:
  inline ActionKeyValuePair() : ActionKeyValuePair(nullptr) {}
  ~ActionKeyValuePair() override;
  explicit constexpr ActionKeyValuePair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionKeyValuePair(const ActionKeyValuePair& from);
  ActionKeyValuePair(ActionKeyValuePair&& from) noexcept
    : ActionKeyValuePair() {
    *this = ::std::move(from);
  }

  inline ActionKeyValuePair& operator=(const ActionKeyValuePair& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionKeyValuePair& operator=(ActionKeyValuePair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionKeyValuePair& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionKeyValuePair* internal_default_instance() {
    return reinterpret_cast<const ActionKeyValuePair*>(
               &_ActionKeyValuePair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ActionKeyValuePair& a, ActionKeyValuePair& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionKeyValuePair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionKeyValuePair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionKeyValuePair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionKeyValuePair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionKeyValuePair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ActionKeyValuePair& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionKeyValuePair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ActionKeyValuePair";
  }
  protected:
  explicit ActionKeyValuePair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // required string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // required string value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:ei.ActionKeyValuePair)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class GenericAction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.GenericAction) */ {
 public:
  inline GenericAction() : GenericAction(nullptr) {}
  ~GenericAction() override;
  explicit constexpr GenericAction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenericAction(const GenericAction& from);
  GenericAction(GenericAction&& from) noexcept
    : GenericAction() {
    *this = ::std::move(from);
  }

  inline GenericAction& operator=(const GenericAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericAction& operator=(GenericAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenericAction& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenericAction* internal_default_instance() {
    return reinterpret_cast<const GenericAction*>(
               &_GenericAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(GenericAction& a, GenericAction& b) {
    a.Swap(&b);
  }
  inline void Swap(GenericAction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenericAction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenericAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenericAction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenericAction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GenericAction& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenericAction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.GenericAction";
  }
  protected:
  explicit GenericAction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 4,
    kUserIdFieldNumber = 1,
    kActionNameFieldNumber = 3,
    kAdvertisingIdFieldNumber = 7,
    kAppFieldNumber = 5,
    kDeviceFieldNumber = 6,
    kApproxTimeFieldNumber = 8,
    kApproxTimeDEPFieldNumber = 2,
  };
  // repeated .ei.ActionKeyValuePair data = 4;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::ei::ActionKeyValuePair* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ActionKeyValuePair >*
      mutable_data();
  private:
  const ::ei::ActionKeyValuePair& _internal_data(int index) const;
  ::ei::ActionKeyValuePair* _internal_add_data();
  public:
  const ::ei::ActionKeyValuePair& data(int index) const;
  ::ei::ActionKeyValuePair* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ActionKeyValuePair >&
      data() const;

  // optional string user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // optional string action_name = 3;
  bool has_action_name() const;
  private:
  bool _internal_has_action_name() const;
  public:
  void clear_action_name();
  const std::string& action_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_action_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_action_name();
  PROTOBUF_NODISCARD std::string* release_action_name();
  void set_allocated_action_name(std::string* action_name);
  private:
  const std::string& _internal_action_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action_name(const std::string& value);
  std::string* _internal_mutable_action_name();
  public:

  // optional string advertising_id = 7;
  bool has_advertising_id() const;
  private:
  bool _internal_has_advertising_id() const;
  public:
  void clear_advertising_id();
  const std::string& advertising_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_advertising_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_advertising_id();
  PROTOBUF_NODISCARD std::string* release_advertising_id();
  void set_allocated_advertising_id(std::string* advertising_id);
  private:
  const std::string& _internal_advertising_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_advertising_id(const std::string& value);
  std::string* _internal_mutable_advertising_id();
  public:

  // optional .ei.AppInfo app = 5;
  bool has_app() const;
  private:
  bool _internal_has_app() const;
  public:
  void clear_app();
  const ::ei::AppInfo& app() const;
  PROTOBUF_NODISCARD ::ei::AppInfo* release_app();
  ::ei::AppInfo* mutable_app();
  void set_allocated_app(::ei::AppInfo* app);
  private:
  const ::ei::AppInfo& _internal_app() const;
  ::ei::AppInfo* _internal_mutable_app();
  public:
  void unsafe_arena_set_allocated_app(
      ::ei::AppInfo* app);
  ::ei::AppInfo* unsafe_arena_release_app();

  // optional .ei.DeviceInfo device = 6;
  bool has_device() const;
  private:
  bool _internal_has_device() const;
  public:
  void clear_device();
  const ::ei::DeviceInfo& device() const;
  PROTOBUF_NODISCARD ::ei::DeviceInfo* release_device();
  ::ei::DeviceInfo* mutable_device();
  void set_allocated_device(::ei::DeviceInfo* device);
  private:
  const ::ei::DeviceInfo& _internal_device() const;
  ::ei::DeviceInfo* _internal_mutable_device();
  public:
  void unsafe_arena_set_allocated_device(
      ::ei::DeviceInfo* device);
  ::ei::DeviceInfo* unsafe_arena_release_device();

  // optional double approx_time = 8;
  bool has_approx_time() const;
  private:
  bool _internal_has_approx_time() const;
  public:
  void clear_approx_time();
  double approx_time() const;
  void set_approx_time(double value);
  private:
  double _internal_approx_time() const;
  void _internal_set_approx_time(double value);
  public:

  // optional float approx_time_DEP = 2;
  bool has_approx_time_dep() const;
  private:
  bool _internal_has_approx_time_dep() const;
  public:
  void clear_approx_time_dep();
  float approx_time_dep() const;
  void set_approx_time_dep(float value);
  private:
  float _internal_approx_time_dep() const;
  void _internal_set_approx_time_dep(float value);
  public:

  // @@protoc_insertion_point(class_scope:ei.GenericAction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ActionKeyValuePair > data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr action_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr advertising_id_;
  ::ei::AppInfo* app_;
  ::ei::DeviceInfo* device_;
  double approx_time_;
  float approx_time_dep_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class GenericActionBatchRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.GenericActionBatchRequest) */ {
 public:
  inline GenericActionBatchRequest() : GenericActionBatchRequest(nullptr) {}
  ~GenericActionBatchRequest() override;
  explicit constexpr GenericActionBatchRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenericActionBatchRequest(const GenericActionBatchRequest& from);
  GenericActionBatchRequest(GenericActionBatchRequest&& from) noexcept
    : GenericActionBatchRequest() {
    *this = ::std::move(from);
  }

  inline GenericActionBatchRequest& operator=(const GenericActionBatchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericActionBatchRequest& operator=(GenericActionBatchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenericActionBatchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenericActionBatchRequest* internal_default_instance() {
    return reinterpret_cast<const GenericActionBatchRequest*>(
               &_GenericActionBatchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(GenericActionBatchRequest& a, GenericActionBatchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GenericActionBatchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenericActionBatchRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenericActionBatchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenericActionBatchRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenericActionBatchRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GenericActionBatchRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenericActionBatchRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.GenericActionBatchRequest";
  }
  protected:
  explicit GenericActionBatchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionsFieldNumber = 2,
    kRinfoFieldNumber = 1,
  };
  // repeated .ei.GenericAction actions = 2;
  int actions_size() const;
  private:
  int _internal_actions_size() const;
  public:
  void clear_actions();
  ::ei::GenericAction* mutable_actions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::GenericAction >*
      mutable_actions();
  private:
  const ::ei::GenericAction& _internal_actions(int index) const;
  ::ei::GenericAction* _internal_add_actions();
  public:
  const ::ei::GenericAction& actions(int index) const;
  ::ei::GenericAction* add_actions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::GenericAction >&
      actions() const;

  // optional .ei.BasicRequestInfo rinfo = 1;
  bool has_rinfo() const;
  private:
  bool _internal_has_rinfo() const;
  public:
  void clear_rinfo();
  const ::ei::BasicRequestInfo& rinfo() const;
  PROTOBUF_NODISCARD ::ei::BasicRequestInfo* release_rinfo();
  ::ei::BasicRequestInfo* mutable_rinfo();
  void set_allocated_rinfo(::ei::BasicRequestInfo* rinfo);
  private:
  const ::ei::BasicRequestInfo& _internal_rinfo() const;
  ::ei::BasicRequestInfo* _internal_mutable_rinfo();
  public:
  void unsafe_arena_set_allocated_rinfo(
      ::ei::BasicRequestInfo* rinfo);
  ::ei::BasicRequestInfo* unsafe_arena_release_rinfo();

  // @@protoc_insertion_point(class_scope:ei.GenericActionBatchRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::GenericAction > actions_;
  ::ei::BasicRequestInfo* rinfo_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class VerifyPurchaseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.VerifyPurchaseRequest) */ {
 public:
  inline VerifyPurchaseRequest() : VerifyPurchaseRequest(nullptr) {}
  ~VerifyPurchaseRequest() override;
  explicit constexpr VerifyPurchaseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerifyPurchaseRequest(const VerifyPurchaseRequest& from);
  VerifyPurchaseRequest(VerifyPurchaseRequest&& from) noexcept
    : VerifyPurchaseRequest() {
    *this = ::std::move(from);
  }

  inline VerifyPurchaseRequest& operator=(const VerifyPurchaseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerifyPurchaseRequest& operator=(VerifyPurchaseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerifyPurchaseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerifyPurchaseRequest* internal_default_instance() {
    return reinterpret_cast<const VerifyPurchaseRequest*>(
               &_VerifyPurchaseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(VerifyPurchaseRequest& a, VerifyPurchaseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VerifyPurchaseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerifyPurchaseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerifyPurchaseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerifyPurchaseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerifyPurchaseRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VerifyPurchaseRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerifyPurchaseRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.VerifyPurchaseRequest";
  }
  protected:
  explicit VerifyPurchaseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSkuFieldNumber = 1,
    kTransactionIdFieldNumber = 2,
    kReceiptFieldNumber = 3,
    kPlatformFieldNumber = 4,
    kLogFieldNumber = 5,
    kRinfoFieldNumber = 6,
    kSandboxFieldNumber = 7,
  };
  // optional string sku = 1;
  bool has_sku() const;
  private:
  bool _internal_has_sku() const;
  public:
  void clear_sku();
  const std::string& sku() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sku(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sku();
  PROTOBUF_NODISCARD std::string* release_sku();
  void set_allocated_sku(std::string* sku);
  private:
  const std::string& _internal_sku() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sku(const std::string& value);
  std::string* _internal_mutable_sku();
  public:

  // optional string transaction_id = 2;
  bool has_transaction_id() const;
  private:
  bool _internal_has_transaction_id() const;
  public:
  void clear_transaction_id();
  const std::string& transaction_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transaction_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transaction_id();
  PROTOBUF_NODISCARD std::string* release_transaction_id();
  void set_allocated_transaction_id(std::string* transaction_id);
  private:
  const std::string& _internal_transaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transaction_id(const std::string& value);
  std::string* _internal_mutable_transaction_id();
  public:

  // optional string receipt = 3;
  bool has_receipt() const;
  private:
  bool _internal_has_receipt() const;
  public:
  void clear_receipt();
  const std::string& receipt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_receipt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_receipt();
  PROTOBUF_NODISCARD std::string* release_receipt();
  void set_allocated_receipt(std::string* receipt);
  private:
  const std::string& _internal_receipt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receipt(const std::string& value);
  std::string* _internal_mutable_receipt();
  public:

  // optional string platform = 4;
  bool has_platform() const;
  private:
  bool _internal_has_platform() const;
  public:
  void clear_platform();
  const std::string& platform() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_platform(ArgT0&& arg0, ArgT... args);
  std::string* mutable_platform();
  PROTOBUF_NODISCARD std::string* release_platform();
  void set_allocated_platform(std::string* platform);
  private:
  const std::string& _internal_platform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform(const std::string& value);
  std::string* _internal_mutable_platform();
  public:

  // optional .ei.GenericAction log = 5;
  bool has_log() const;
  private:
  bool _internal_has_log() const;
  public:
  void clear_log();
  const ::ei::GenericAction& log() const;
  PROTOBUF_NODISCARD ::ei::GenericAction* release_log();
  ::ei::GenericAction* mutable_log();
  void set_allocated_log(::ei::GenericAction* log);
  private:
  const ::ei::GenericAction& _internal_log() const;
  ::ei::GenericAction* _internal_mutable_log();
  public:
  void unsafe_arena_set_allocated_log(
      ::ei::GenericAction* log);
  ::ei::GenericAction* unsafe_arena_release_log();

  // optional .ei.BasicRequestInfo rinfo = 6;
  bool has_rinfo() const;
  private:
  bool _internal_has_rinfo() const;
  public:
  void clear_rinfo();
  const ::ei::BasicRequestInfo& rinfo() const;
  PROTOBUF_NODISCARD ::ei::BasicRequestInfo* release_rinfo();
  ::ei::BasicRequestInfo* mutable_rinfo();
  void set_allocated_rinfo(::ei::BasicRequestInfo* rinfo);
  private:
  const ::ei::BasicRequestInfo& _internal_rinfo() const;
  ::ei::BasicRequestInfo* _internal_mutable_rinfo();
  public:
  void unsafe_arena_set_allocated_rinfo(
      ::ei::BasicRequestInfo* rinfo);
  ::ei::BasicRequestInfo* unsafe_arena_release_rinfo();

  // optional bool sandbox = 7;
  bool has_sandbox() const;
  private:
  bool _internal_has_sandbox() const;
  public:
  void clear_sandbox();
  bool sandbox() const;
  void set_sandbox(bool value);
  private:
  bool _internal_sandbox() const;
  void _internal_set_sandbox(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ei.VerifyPurchaseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sku_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transaction_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receipt_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_;
  ::ei::GenericAction* log_;
  ::ei::BasicRequestInfo* rinfo_;
  bool sandbox_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class VerifyPurchaseResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.VerifyPurchaseResponse) */ {
 public:
  inline VerifyPurchaseResponse() : VerifyPurchaseResponse(nullptr) {}
  ~VerifyPurchaseResponse() override;
  explicit constexpr VerifyPurchaseResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerifyPurchaseResponse(const VerifyPurchaseResponse& from);
  VerifyPurchaseResponse(VerifyPurchaseResponse&& from) noexcept
    : VerifyPurchaseResponse() {
    *this = ::std::move(from);
  }

  inline VerifyPurchaseResponse& operator=(const VerifyPurchaseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerifyPurchaseResponse& operator=(VerifyPurchaseResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerifyPurchaseResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerifyPurchaseResponse* internal_default_instance() {
    return reinterpret_cast<const VerifyPurchaseResponse*>(
               &_VerifyPurchaseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(VerifyPurchaseResponse& a, VerifyPurchaseResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(VerifyPurchaseResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerifyPurchaseResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerifyPurchaseResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerifyPurchaseResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerifyPurchaseResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VerifyPurchaseResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerifyPurchaseResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.VerifyPurchaseResponse";
  }
  protected:
  explicit VerifyPurchaseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kVerifiedFieldNumber = 1,
  };
  // optional string message = 2;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // optional bool verified = 1;
  bool has_verified() const;
  private:
  bool _internal_has_verified() const;
  public:
  void clear_verified();
  bool verified() const;
  void set_verified(bool value);
  private:
  bool _internal_verified() const;
  void _internal_set_verified(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ei.VerifyPurchaseResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  bool verified_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class CurrencyFlowLog final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.CurrencyFlowLog) */ {
 public:
  inline CurrencyFlowLog() : CurrencyFlowLog(nullptr) {}
  ~CurrencyFlowLog() override;
  explicit constexpr CurrencyFlowLog(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CurrencyFlowLog(const CurrencyFlowLog& from);
  CurrencyFlowLog(CurrencyFlowLog&& from) noexcept
    : CurrencyFlowLog() {
    *this = ::std::move(from);
  }

  inline CurrencyFlowLog& operator=(const CurrencyFlowLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline CurrencyFlowLog& operator=(CurrencyFlowLog&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CurrencyFlowLog& default_instance() {
    return *internal_default_instance();
  }
  static inline const CurrencyFlowLog* internal_default_instance() {
    return reinterpret_cast<const CurrencyFlowLog*>(
               &_CurrencyFlowLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(CurrencyFlowLog& a, CurrencyFlowLog& b) {
    a.Swap(&b);
  }
  inline void Swap(CurrencyFlowLog* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CurrencyFlowLog* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CurrencyFlowLog* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CurrencyFlowLog>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CurrencyFlowLog& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CurrencyFlowLog& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CurrencyFlowLog* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.CurrencyFlowLog";
  }
  protected:
  explicit CurrencyFlowLog(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kLocationFieldNumber = 5,
    kVersionFieldNumber = 6,
    kPlatformFieldNumber = 7,
    kApproxTimeFieldNumber = 2,
    kAmountFieldNumber = 4,
    kCurrencyFieldNumber = 3,
  };
  // optional string user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // optional string location = 5;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // optional string version = 6;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // optional string platform = 7;
  bool has_platform() const;
  private:
  bool _internal_has_platform() const;
  public:
  void clear_platform();
  const std::string& platform() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_platform(ArgT0&& arg0, ArgT... args);
  std::string* mutable_platform();
  PROTOBUF_NODISCARD std::string* release_platform();
  void set_allocated_platform(std::string* platform);
  private:
  const std::string& _internal_platform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform(const std::string& value);
  std::string* _internal_mutable_platform();
  public:

  // optional double approx_time = 2;
  bool has_approx_time() const;
  private:
  bool _internal_has_approx_time() const;
  public:
  void clear_approx_time();
  double approx_time() const;
  void set_approx_time(double value);
  private:
  double _internal_approx_time() const;
  void _internal_set_approx_time(double value);
  public:

  // optional int64 amount = 4;
  bool has_amount() const;
  private:
  bool _internal_has_amount() const;
  public:
  void clear_amount();
  int64_t amount() const;
  void set_amount(int64_t value);
  private:
  int64_t _internal_amount() const;
  void _internal_set_amount(int64_t value);
  public:

  // optional .ei.RewardType currency = 3;
  bool has_currency() const;
  private:
  bool _internal_has_currency() const;
  public:
  void clear_currency();
  ::ei::RewardType currency() const;
  void set_currency(::ei::RewardType value);
  private:
  ::ei::RewardType _internal_currency() const;
  void _internal_set_currency(::ei::RewardType value);
  public:

  // @@protoc_insertion_point(class_scope:ei.CurrencyFlowLog)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_;
  double approx_time_;
  int64_t amount_;
  int currency_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class CurrencyFlowBatchRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.CurrencyFlowBatchRequest) */ {
 public:
  inline CurrencyFlowBatchRequest() : CurrencyFlowBatchRequest(nullptr) {}
  ~CurrencyFlowBatchRequest() override;
  explicit constexpr CurrencyFlowBatchRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CurrencyFlowBatchRequest(const CurrencyFlowBatchRequest& from);
  CurrencyFlowBatchRequest(CurrencyFlowBatchRequest&& from) noexcept
    : CurrencyFlowBatchRequest() {
    *this = ::std::move(from);
  }

  inline CurrencyFlowBatchRequest& operator=(const CurrencyFlowBatchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CurrencyFlowBatchRequest& operator=(CurrencyFlowBatchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CurrencyFlowBatchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CurrencyFlowBatchRequest* internal_default_instance() {
    return reinterpret_cast<const CurrencyFlowBatchRequest*>(
               &_CurrencyFlowBatchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(CurrencyFlowBatchRequest& a, CurrencyFlowBatchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CurrencyFlowBatchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CurrencyFlowBatchRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CurrencyFlowBatchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CurrencyFlowBatchRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CurrencyFlowBatchRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CurrencyFlowBatchRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CurrencyFlowBatchRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.CurrencyFlowBatchRequest";
  }
  protected:
  explicit CurrencyFlowBatchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogsFieldNumber = 1,
    kRinfoFieldNumber = 2,
  };
  // repeated .ei.CurrencyFlowLog logs = 1;
  int logs_size() const;
  private:
  int _internal_logs_size() const;
  public:
  void clear_logs();
  ::ei::CurrencyFlowLog* mutable_logs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::CurrencyFlowLog >*
      mutable_logs();
  private:
  const ::ei::CurrencyFlowLog& _internal_logs(int index) const;
  ::ei::CurrencyFlowLog* _internal_add_logs();
  public:
  const ::ei::CurrencyFlowLog& logs(int index) const;
  ::ei::CurrencyFlowLog* add_logs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::CurrencyFlowLog >&
      logs() const;

  // optional .ei.BasicRequestInfo rinfo = 2;
  bool has_rinfo() const;
  private:
  bool _internal_has_rinfo() const;
  public:
  void clear_rinfo();
  const ::ei::BasicRequestInfo& rinfo() const;
  PROTOBUF_NODISCARD ::ei::BasicRequestInfo* release_rinfo();
  ::ei::BasicRequestInfo* mutable_rinfo();
  void set_allocated_rinfo(::ei::BasicRequestInfo* rinfo);
  private:
  const ::ei::BasicRequestInfo& _internal_rinfo() const;
  ::ei::BasicRequestInfo* _internal_mutable_rinfo();
  public:
  void unsafe_arena_set_allocated_rinfo(
      ::ei::BasicRequestInfo* rinfo);
  ::ei::BasicRequestInfo* unsafe_arena_release_rinfo();

  // @@protoc_insertion_point(class_scope:ei.CurrencyFlowBatchRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::CurrencyFlowLog > logs_;
  ::ei::BasicRequestInfo* rinfo_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class Reward final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.Reward) */ {
 public:
  inline Reward() : Reward(nullptr) {}
  ~Reward() override;
  explicit constexpr Reward(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Reward(const Reward& from);
  Reward(Reward&& from) noexcept
    : Reward() {
    *this = ::std::move(from);
  }

  inline Reward& operator=(const Reward& from) {
    CopyFrom(from);
    return *this;
  }
  inline Reward& operator=(Reward&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Reward& default_instance() {
    return *internal_default_instance();
  }
  static inline const Reward* internal_default_instance() {
    return reinterpret_cast<const Reward*>(
               &_Reward_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(Reward& a, Reward& b) {
    a.Swap(&b);
  }
  inline void Swap(Reward* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Reward* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Reward* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Reward>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Reward& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Reward& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Reward* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.Reward";
  }
  protected:
  explicit Reward(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRewardSubTypeFieldNumber = 2,
    kRewardAmountFieldNumber = 3,
    kRewardTypeFieldNumber = 1,
  };
  // optional string reward_sub_type = 2;
  bool has_reward_sub_type() const;
  private:
  bool _internal_has_reward_sub_type() const;
  public:
  void clear_reward_sub_type();
  const std::string& reward_sub_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reward_sub_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reward_sub_type();
  PROTOBUF_NODISCARD std::string* release_reward_sub_type();
  void set_allocated_reward_sub_type(std::string* reward_sub_type);
  private:
  const std::string& _internal_reward_sub_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reward_sub_type(const std::string& value);
  std::string* _internal_mutable_reward_sub_type();
  public:

  // optional double reward_amount = 3;
  bool has_reward_amount() const;
  private:
  bool _internal_has_reward_amount() const;
  public:
  void clear_reward_amount();
  double reward_amount() const;
  void set_reward_amount(double value);
  private:
  double _internal_reward_amount() const;
  void _internal_set_reward_amount(double value);
  public:

  // optional .ei.RewardType reward_type = 1;
  bool has_reward_type() const;
  private:
  bool _internal_has_reward_type() const;
  public:
  void clear_reward_type();
  ::ei::RewardType reward_type() const;
  void set_reward_type(::ei::RewardType value);
  private:
  ::ei::RewardType _internal_reward_type() const;
  void _internal_set_reward_type(::ei::RewardType value);
  public:

  // @@protoc_insertion_point(class_scope:ei.Reward)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reward_sub_type_;
  double reward_amount_;
  int reward_type_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class Contract_Goal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.Contract.Goal) */ {
 public:
  inline Contract_Goal() : Contract_Goal(nullptr) {}
  ~Contract_Goal() override;
  explicit constexpr Contract_Goal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Contract_Goal(const Contract_Goal& from);
  Contract_Goal(Contract_Goal&& from) noexcept
    : Contract_Goal() {
    *this = ::std::move(from);
  }

  inline Contract_Goal& operator=(const Contract_Goal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Contract_Goal& operator=(Contract_Goal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Contract_Goal& default_instance() {
    return *internal_default_instance();
  }
  static inline const Contract_Goal* internal_default_instance() {
    return reinterpret_cast<const Contract_Goal*>(
               &_Contract_Goal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(Contract_Goal& a, Contract_Goal& b) {
    a.Swap(&b);
  }
  inline void Swap(Contract_Goal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Contract_Goal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Contract_Goal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Contract_Goal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Contract_Goal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Contract_Goal& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Contract_Goal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.Contract.Goal";
  }
  protected:
  explicit Contract_Goal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRewardSubTypeFieldNumber = 4,
    kTargetAmountFieldNumber = 2,
    kRewardAmountFieldNumber = 5,
    kTargetSoulEggsFieldNumber = 6,
    kTypeFieldNumber = 1,
    kRewardTypeFieldNumber = 3,
  };
  // optional string reward_sub_type = 4;
  bool has_reward_sub_type() const;
  private:
  bool _internal_has_reward_sub_type() const;
  public:
  void clear_reward_sub_type();
  const std::string& reward_sub_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reward_sub_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reward_sub_type();
  PROTOBUF_NODISCARD std::string* release_reward_sub_type();
  void set_allocated_reward_sub_type(std::string* reward_sub_type);
  private:
  const std::string& _internal_reward_sub_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reward_sub_type(const std::string& value);
  std::string* _internal_mutable_reward_sub_type();
  public:

  // optional double target_amount = 2;
  bool has_target_amount() const;
  private:
  bool _internal_has_target_amount() const;
  public:
  void clear_target_amount();
  double target_amount() const;
  void set_target_amount(double value);
  private:
  double _internal_target_amount() const;
  void _internal_set_target_amount(double value);
  public:

  // optional double reward_amount = 5;
  bool has_reward_amount() const;
  private:
  bool _internal_has_reward_amount() const;
  public:
  void clear_reward_amount();
  double reward_amount() const;
  void set_reward_amount(double value);
  private:
  double _internal_reward_amount() const;
  void _internal_set_reward_amount(double value);
  public:

  // optional double target_soul_eggs = 6;
  bool has_target_soul_eggs() const;
  private:
  bool _internal_has_target_soul_eggs() const;
  public:
  void clear_target_soul_eggs();
  double target_soul_eggs() const;
  void set_target_soul_eggs(double value);
  private:
  double _internal_target_soul_eggs() const;
  void _internal_set_target_soul_eggs(double value);
  public:

  // optional .ei.GoalType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::ei::GoalType type() const;
  void set_type(::ei::GoalType value);
  private:
  ::ei::GoalType _internal_type() const;
  void _internal_set_type(::ei::GoalType value);
  public:

  // optional .ei.RewardType reward_type = 3;
  bool has_reward_type() const;
  private:
  bool _internal_has_reward_type() const;
  public:
  void clear_reward_type();
  ::ei::RewardType reward_type() const;
  void set_reward_type(::ei::RewardType value);
  private:
  ::ei::RewardType _internal_reward_type() const;
  void _internal_set_reward_type(::ei::RewardType value);
  public:

  // @@protoc_insertion_point(class_scope:ei.Contract.Goal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reward_sub_type_;
  double target_amount_;
  double reward_amount_;
  double target_soul_eggs_;
  int type_;
  int reward_type_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class Contract_GoalSet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.Contract.GoalSet) */ {
 public:
  inline Contract_GoalSet() : Contract_GoalSet(nullptr) {}
  ~Contract_GoalSet() override;
  explicit constexpr Contract_GoalSet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Contract_GoalSet(const Contract_GoalSet& from);
  Contract_GoalSet(Contract_GoalSet&& from) noexcept
    : Contract_GoalSet() {
    *this = ::std::move(from);
  }

  inline Contract_GoalSet& operator=(const Contract_GoalSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline Contract_GoalSet& operator=(Contract_GoalSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Contract_GoalSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const Contract_GoalSet* internal_default_instance() {
    return reinterpret_cast<const Contract_GoalSet*>(
               &_Contract_GoalSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(Contract_GoalSet& a, Contract_GoalSet& b) {
    a.Swap(&b);
  }
  inline void Swap(Contract_GoalSet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Contract_GoalSet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Contract_GoalSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Contract_GoalSet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Contract_GoalSet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Contract_GoalSet& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Contract_GoalSet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.Contract.GoalSet";
  }
  protected:
  explicit Contract_GoalSet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGoalsFieldNumber = 1,
  };
  // repeated .ei.Contract.Goal goals = 1;
  int goals_size() const;
  private:
  int _internal_goals_size() const;
  public:
  void clear_goals();
  ::ei::Contract_Goal* mutable_goals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Contract_Goal >*
      mutable_goals();
  private:
  const ::ei::Contract_Goal& _internal_goals(int index) const;
  ::ei::Contract_Goal* _internal_add_goals();
  public:
  const ::ei::Contract_Goal& goals(int index) const;
  ::ei::Contract_Goal* add_goals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Contract_Goal >&
      goals() const;

  // @@protoc_insertion_point(class_scope:ei.Contract.GoalSet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Contract_Goal > goals_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class Contract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.Contract) */ {
 public:
  inline Contract() : Contract(nullptr) {}
  ~Contract() override;
  explicit constexpr Contract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Contract(const Contract& from);
  Contract(Contract&& from) noexcept
    : Contract() {
    *this = ::std::move(from);
  }

  inline Contract& operator=(const Contract& from) {
    CopyFrom(from);
    return *this;
  }
  inline Contract& operator=(Contract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Contract& default_instance() {
    return *internal_default_instance();
  }
  static inline const Contract* internal_default_instance() {
    return reinterpret_cast<const Contract*>(
               &_Contract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(Contract& a, Contract& b) {
    a.Swap(&b);
  }
  inline void Swap(Contract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Contract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Contract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Contract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Contract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Contract& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Contract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.Contract";
  }
  protected:
  explicit Contract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Contract_Goal Goal;
  typedef Contract_GoalSet GoalSet;

  // accessors -------------------------------------------------------

  enum : int {
    kGoalsFieldNumber = 3,
    kGoalSetsFieldNumber = 16,
    kIdentifierFieldNumber = 1,
    kNameFieldNumber = 9,
    kDescriptionFieldNumber = 10,
    kExpirationTimeFieldNumber = 6,
    kMaxCoopSizeFieldNumber = 5,
    kCoopAllowedFieldNumber = 4,
    kDebugFieldNumber = 11,
    kLengthSecondsFieldNumber = 7,
    kMaxSoulEggsFieldNumber = 13,
    kMaxBoostsFieldNumber = 12,
    kMinClientVersionFieldNumber = 14,
    kStartTimeFieldNumber = 17,
    kEggFieldNumber = 2,
    kMinutesPerTokenFieldNumber = 15,
    kChickenRunCooldownMinutesFieldNumber = 18,
  };
  // repeated .ei.Contract.Goal goals = 3;
  int goals_size() const;
  private:
  int _internal_goals_size() const;
  public:
  void clear_goals();
  ::ei::Contract_Goal* mutable_goals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Contract_Goal >*
      mutable_goals();
  private:
  const ::ei::Contract_Goal& _internal_goals(int index) const;
  ::ei::Contract_Goal* _internal_add_goals();
  public:
  const ::ei::Contract_Goal& goals(int index) const;
  ::ei::Contract_Goal* add_goals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Contract_Goal >&
      goals() const;

  // repeated .ei.Contract.GoalSet goal_sets = 16;
  int goal_sets_size() const;
  private:
  int _internal_goal_sets_size() const;
  public:
  void clear_goal_sets();
  ::ei::Contract_GoalSet* mutable_goal_sets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Contract_GoalSet >*
      mutable_goal_sets();
  private:
  const ::ei::Contract_GoalSet& _internal_goal_sets(int index) const;
  ::ei::Contract_GoalSet* _internal_add_goal_sets();
  public:
  const ::ei::Contract_GoalSet& goal_sets(int index) const;
  ::ei::Contract_GoalSet* add_goal_sets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Contract_GoalSet >&
      goal_sets() const;

  // optional string identifier = 1;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  PROTOBUF_NODISCARD std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // optional string name = 9;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string description = 10;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional double expiration_time = 6;
  bool has_expiration_time() const;
  private:
  bool _internal_has_expiration_time() const;
  public:
  void clear_expiration_time();
  double expiration_time() const;
  void set_expiration_time(double value);
  private:
  double _internal_expiration_time() const;
  void _internal_set_expiration_time(double value);
  public:

  // optional uint32 max_coop_size = 5;
  bool has_max_coop_size() const;
  private:
  bool _internal_has_max_coop_size() const;
  public:
  void clear_max_coop_size();
  uint32_t max_coop_size() const;
  void set_max_coop_size(uint32_t value);
  private:
  uint32_t _internal_max_coop_size() const;
  void _internal_set_max_coop_size(uint32_t value);
  public:

  // optional bool coop_allowed = 4;
  bool has_coop_allowed() const;
  private:
  bool _internal_has_coop_allowed() const;
  public:
  void clear_coop_allowed();
  bool coop_allowed() const;
  void set_coop_allowed(bool value);
  private:
  bool _internal_coop_allowed() const;
  void _internal_set_coop_allowed(bool value);
  public:

  // optional bool debug = 11;
  bool has_debug() const;
  private:
  bool _internal_has_debug() const;
  public:
  void clear_debug();
  bool debug() const;
  void set_debug(bool value);
  private:
  bool _internal_debug() const;
  void _internal_set_debug(bool value);
  public:

  // optional double length_seconds = 7;
  bool has_length_seconds() const;
  private:
  bool _internal_has_length_seconds() const;
  public:
  void clear_length_seconds();
  double length_seconds() const;
  void set_length_seconds(double value);
  private:
  double _internal_length_seconds() const;
  void _internal_set_length_seconds(double value);
  public:

  // optional double max_soul_eggs = 13;
  bool has_max_soul_eggs() const;
  private:
  bool _internal_has_max_soul_eggs() const;
  public:
  void clear_max_soul_eggs();
  double max_soul_eggs() const;
  void set_max_soul_eggs(double value);
  private:
  double _internal_max_soul_eggs() const;
  void _internal_set_max_soul_eggs(double value);
  public:

  // optional uint32 max_boosts = 12;
  bool has_max_boosts() const;
  private:
  bool _internal_has_max_boosts() const;
  public:
  void clear_max_boosts();
  uint32_t max_boosts() const;
  void set_max_boosts(uint32_t value);
  private:
  uint32_t _internal_max_boosts() const;
  void _internal_set_max_boosts(uint32_t value);
  public:

  // optional uint32 min_client_version = 14;
  bool has_min_client_version() const;
  private:
  bool _internal_has_min_client_version() const;
  public:
  void clear_min_client_version();
  uint32_t min_client_version() const;
  void set_min_client_version(uint32_t value);
  private:
  uint32_t _internal_min_client_version() const;
  void _internal_set_min_client_version(uint32_t value);
  public:

  // optional double start_time = 17;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  double start_time() const;
  void set_start_time(double value);
  private:
  double _internal_start_time() const;
  void _internal_set_start_time(double value);
  public:

  // optional .ei.Egg egg = 2;
  bool has_egg() const;
  private:
  bool _internal_has_egg() const;
  public:
  void clear_egg();
  ::ei::Egg egg() const;
  void set_egg(::ei::Egg value);
  private:
  ::ei::Egg _internal_egg() const;
  void _internal_set_egg(::ei::Egg value);
  public:

  // optional double minutes_per_token = 15 [default = 60];
  bool has_minutes_per_token() const;
  private:
  bool _internal_has_minutes_per_token() const;
  public:
  void clear_minutes_per_token();
  double minutes_per_token() const;
  void set_minutes_per_token(double value);
  private:
  double _internal_minutes_per_token() const;
  void _internal_set_minutes_per_token(double value);
  public:

  // optional double chicken_run_cooldown_minutes = 18 [default = 60];
  bool has_chicken_run_cooldown_minutes() const;
  private:
  bool _internal_has_chicken_run_cooldown_minutes() const;
  public:
  void clear_chicken_run_cooldown_minutes();
  double chicken_run_cooldown_minutes() const;
  void set_chicken_run_cooldown_minutes(double value);
  private:
  double _internal_chicken_run_cooldown_minutes() const;
  void _internal_set_chicken_run_cooldown_minutes(double value);
  public:

  // @@protoc_insertion_point(class_scope:ei.Contract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Contract_Goal > goals_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Contract_GoalSet > goal_sets_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  double expiration_time_;
  uint32_t max_coop_size_;
  bool coop_allowed_;
  bool debug_;
  double length_seconds_;
  double max_soul_eggs_;
  uint32_t max_boosts_;
  uint32_t min_client_version_;
  double start_time_;
  int egg_;
  double minutes_per_token_;
  double chicken_run_cooldown_minutes_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class BasicRequestInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.BasicRequestInfo) */ {
 public:
  inline BasicRequestInfo() : BasicRequestInfo(nullptr) {}
  ~BasicRequestInfo() override;
  explicit constexpr BasicRequestInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BasicRequestInfo(const BasicRequestInfo& from);
  BasicRequestInfo(BasicRequestInfo&& from) noexcept
    : BasicRequestInfo() {
    *this = ::std::move(from);
  }

  inline BasicRequestInfo& operator=(const BasicRequestInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BasicRequestInfo& operator=(BasicRequestInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BasicRequestInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BasicRequestInfo* internal_default_instance() {
    return reinterpret_cast<const BasicRequestInfo*>(
               &_BasicRequestInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(BasicRequestInfo& a, BasicRequestInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(BasicRequestInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BasicRequestInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BasicRequestInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BasicRequestInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BasicRequestInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BasicRequestInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BasicRequestInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.BasicRequestInfo";
  }
  protected:
  explicit BasicRequestInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEiUserIdFieldNumber = 1,
    kVersionFieldNumber = 3,
    kBuildFieldNumber = 4,
    kPlatformFieldNumber = 5,
    kCountryFieldNumber = 6,
    kLanguageFieldNumber = 7,
    kClientVersionFieldNumber = 2,
    kDebugFieldNumber = 8,
  };
  // optional string ei_user_id = 1;
  bool has_ei_user_id() const;
  private:
  bool _internal_has_ei_user_id() const;
  public:
  void clear_ei_user_id();
  const std::string& ei_user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ei_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ei_user_id();
  PROTOBUF_NODISCARD std::string* release_ei_user_id();
  void set_allocated_ei_user_id(std::string* ei_user_id);
  private:
  const std::string& _internal_ei_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ei_user_id(const std::string& value);
  std::string* _internal_mutable_ei_user_id();
  public:

  // optional string version = 3;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // optional string build = 4;
  bool has_build() const;
  private:
  bool _internal_has_build() const;
  public:
  void clear_build();
  const std::string& build() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_build(ArgT0&& arg0, ArgT... args);
  std::string* mutable_build();
  PROTOBUF_NODISCARD std::string* release_build();
  void set_allocated_build(std::string* build);
  private:
  const std::string& _internal_build() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_build(const std::string& value);
  std::string* _internal_mutable_build();
  public:

  // optional string platform = 5;
  bool has_platform() const;
  private:
  bool _internal_has_platform() const;
  public:
  void clear_platform();
  const std::string& platform() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_platform(ArgT0&& arg0, ArgT... args);
  std::string* mutable_platform();
  PROTOBUF_NODISCARD std::string* release_platform();
  void set_allocated_platform(std::string* platform);
  private:
  const std::string& _internal_platform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform(const std::string& value);
  std::string* _internal_mutable_platform();
  public:

  // optional string country = 6;
  bool has_country() const;
  private:
  bool _internal_has_country() const;
  public:
  void clear_country();
  const std::string& country() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_country(ArgT0&& arg0, ArgT... args);
  std::string* mutable_country();
  PROTOBUF_NODISCARD std::string* release_country();
  void set_allocated_country(std::string* country);
  private:
  const std::string& _internal_country() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country(const std::string& value);
  std::string* _internal_mutable_country();
  public:

  // optional string language = 7;
  bool has_language() const;
  private:
  bool _internal_has_language() const;
  public:
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // optional uint32 client_version = 2;
  bool has_client_version() const;
  private:
  bool _internal_has_client_version() const;
  public:
  void clear_client_version();
  uint32_t client_version() const;
  void set_client_version(uint32_t value);
  private:
  uint32_t _internal_client_version() const;
  void _internal_set_client_version(uint32_t value);
  public:

  // optional bool debug = 8;
  bool has_debug() const;
  private:
  bool _internal_has_debug() const;
  public:
  void clear_debug();
  bool debug() const;
  void set_debug(bool value);
  private:
  bool _internal_debug() const;
  void _internal_set_debug(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ei.BasicRequestInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ei_user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr build_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr country_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
  uint32_t client_version_;
  bool debug_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ContractsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ContractsRequest) */ {
 public:
  inline ContractsRequest() : ContractsRequest(nullptr) {}
  ~ContractsRequest() override;
  explicit constexpr ContractsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContractsRequest(const ContractsRequest& from);
  ContractsRequest(ContractsRequest&& from) noexcept
    : ContractsRequest() {
    *this = ::std::move(from);
  }

  inline ContractsRequest& operator=(const ContractsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractsRequest& operator=(ContractsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractsRequest* internal_default_instance() {
    return reinterpret_cast<const ContractsRequest*>(
               &_ContractsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(ContractsRequest& a, ContractsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContractsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContractsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ContractsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ContractsRequest";
  }
  protected:
  explicit ContractsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSoulEggsFieldNumber = 1,
    kClientVersionFieldNumber = 5,
  };
  // optional double soul_eggs = 1;
  bool has_soul_eggs() const;
  private:
  bool _internal_has_soul_eggs() const;
  public:
  void clear_soul_eggs();
  double soul_eggs() const;
  void set_soul_eggs(double value);
  private:
  double _internal_soul_eggs() const;
  void _internal_set_soul_eggs(double value);
  public:

  // optional uint32 client_version = 5;
  bool has_client_version() const;
  private:
  bool _internal_has_client_version() const;
  public:
  void clear_client_version();
  uint32_t client_version() const;
  void set_client_version(uint32_t value);
  private:
  uint32_t _internal_client_version() const;
  void _internal_set_client_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ContractsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double soul_eggs_;
  uint32_t client_version_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ContractsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ContractsResponse) */ {
 public:
  inline ContractsResponse() : ContractsResponse(nullptr) {}
  ~ContractsResponse() override;
  explicit constexpr ContractsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContractsResponse(const ContractsResponse& from);
  ContractsResponse(ContractsResponse&& from) noexcept
    : ContractsResponse() {
    *this = ::std::move(from);
  }

  inline ContractsResponse& operator=(const ContractsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractsResponse& operator=(ContractsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractsResponse* internal_default_instance() {
    return reinterpret_cast<const ContractsResponse*>(
               &_ContractsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(ContractsResponse& a, ContractsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContractsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContractsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ContractsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ContractsResponse";
  }
  protected:
  explicit ContractsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractsFieldNumber = 1,
    kWarningMessageFieldNumber = 4,
    kServerTimeFieldNumber = 2,
    kMaxEopFieldNumber = 3,
  };
  // repeated .ei.Contract contracts = 1;
  int contracts_size() const;
  private:
  int _internal_contracts_size() const;
  public:
  void clear_contracts();
  ::ei::Contract* mutable_contracts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Contract >*
      mutable_contracts();
  private:
  const ::ei::Contract& _internal_contracts(int index) const;
  ::ei::Contract* _internal_add_contracts();
  public:
  const ::ei::Contract& contracts(int index) const;
  ::ei::Contract* add_contracts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Contract >&
      contracts() const;

  // optional string warning_message = 4;
  bool has_warning_message() const;
  private:
  bool _internal_has_warning_message() const;
  public:
  void clear_warning_message();
  const std::string& warning_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_warning_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_warning_message();
  PROTOBUF_NODISCARD std::string* release_warning_message();
  void set_allocated_warning_message(std::string* warning_message);
  private:
  const std::string& _internal_warning_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_warning_message(const std::string& value);
  std::string* _internal_mutable_warning_message();
  public:

  // optional double server_time = 2;
  bool has_server_time() const;
  private:
  bool _internal_has_server_time() const;
  public:
  void clear_server_time();
  double server_time() const;
  void set_server_time(double value);
  private:
  double _internal_server_time() const;
  void _internal_set_server_time(double value);
  public:

  // optional uint32 max_eop = 3 [default = 1000];
  bool has_max_eop() const;
  private:
  bool _internal_has_max_eop() const;
  public:
  void clear_max_eop();
  uint32_t max_eop() const;
  void set_max_eop(uint32_t value);
  private:
  uint32_t _internal_max_eop() const;
  void _internal_set_max_eop(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ContractsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Contract > contracts_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr warning_message_;
  double server_time_;
  uint32_t max_eop_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ContractCoopStatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ContractCoopStatusRequest) */ {
 public:
  inline ContractCoopStatusRequest() : ContractCoopStatusRequest(nullptr) {}
  ~ContractCoopStatusRequest() override;
  explicit constexpr ContractCoopStatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContractCoopStatusRequest(const ContractCoopStatusRequest& from);
  ContractCoopStatusRequest(ContractCoopStatusRequest&& from) noexcept
    : ContractCoopStatusRequest() {
    *this = ::std::move(from);
  }

  inline ContractCoopStatusRequest& operator=(const ContractCoopStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractCoopStatusRequest& operator=(ContractCoopStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractCoopStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractCoopStatusRequest* internal_default_instance() {
    return reinterpret_cast<const ContractCoopStatusRequest*>(
               &_ContractCoopStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(ContractCoopStatusRequest& a, ContractCoopStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractCoopStatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractCoopStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractCoopStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContractCoopStatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContractCoopStatusRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ContractCoopStatusRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractCoopStatusRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ContractCoopStatusRequest";
  }
  protected:
  explicit ContractCoopStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdentifierFieldNumber = 1,
    kCoopIdentifierFieldNumber = 2,
    kUserIdFieldNumber = 3,
    kRinfoFieldNumber = 5,
    kClientVersionFieldNumber = 4,
  };
  // optional string contract_identifier = 1;
  bool has_contract_identifier() const;
  private:
  bool _internal_has_contract_identifier() const;
  public:
  void clear_contract_identifier();
  const std::string& contract_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_identifier();
  PROTOBUF_NODISCARD std::string* release_contract_identifier();
  void set_allocated_contract_identifier(std::string* contract_identifier);
  private:
  const std::string& _internal_contract_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_identifier(const std::string& value);
  std::string* _internal_mutable_contract_identifier();
  public:

  // optional string coop_identifier = 2;
  bool has_coop_identifier() const;
  private:
  bool _internal_has_coop_identifier() const;
  public:
  void clear_coop_identifier();
  const std::string& coop_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_coop_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_coop_identifier();
  PROTOBUF_NODISCARD std::string* release_coop_identifier();
  void set_allocated_coop_identifier(std::string* coop_identifier);
  private:
  const std::string& _internal_coop_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_coop_identifier(const std::string& value);
  std::string* _internal_mutable_coop_identifier();
  public:

  // optional string user_id = 3;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // optional .ei.BasicRequestInfo rinfo = 5;
  bool has_rinfo() const;
  private:
  bool _internal_has_rinfo() const;
  public:
  void clear_rinfo();
  const ::ei::BasicRequestInfo& rinfo() const;
  PROTOBUF_NODISCARD ::ei::BasicRequestInfo* release_rinfo();
  ::ei::BasicRequestInfo* mutable_rinfo();
  void set_allocated_rinfo(::ei::BasicRequestInfo* rinfo);
  private:
  const ::ei::BasicRequestInfo& _internal_rinfo() const;
  ::ei::BasicRequestInfo* _internal_mutable_rinfo();
  public:
  void unsafe_arena_set_allocated_rinfo(
      ::ei::BasicRequestInfo* rinfo);
  ::ei::BasicRequestInfo* unsafe_arena_release_rinfo();

  // optional uint32 client_version = 4;
  bool has_client_version() const;
  private:
  bool _internal_has_client_version() const;
  public:
  void clear_client_version();
  uint32_t client_version() const;
  void set_client_version(uint32_t value);
  private:
  uint32_t _internal_client_version() const;
  void _internal_set_client_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ContractCoopStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr coop_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::ei::BasicRequestInfo* rinfo_;
  uint32_t client_version_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class FarmProductionParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.FarmProductionParams) */ {
 public:
  inline FarmProductionParams() : FarmProductionParams(nullptr) {}
  ~FarmProductionParams() override;
  explicit constexpr FarmProductionParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FarmProductionParams(const FarmProductionParams& from);
  FarmProductionParams(FarmProductionParams&& from) noexcept
    : FarmProductionParams() {
    *this = ::std::move(from);
  }

  inline FarmProductionParams& operator=(const FarmProductionParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline FarmProductionParams& operator=(FarmProductionParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FarmProductionParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const FarmProductionParams* internal_default_instance() {
    return reinterpret_cast<const FarmProductionParams*>(
               &_FarmProductionParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(FarmProductionParams& a, FarmProductionParams& b) {
    a.Swap(&b);
  }
  inline void Swap(FarmProductionParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FarmProductionParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FarmProductionParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FarmProductionParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FarmProductionParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FarmProductionParams& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FarmProductionParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.FarmProductionParams";
  }
  protected:
  explicit FarmProductionParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFarmPopulationFieldNumber = 1,
    kFarmCapacityFieldNumber = 2,
    kElrFieldNumber = 3,
    kIhrFieldNumber = 4,
    kSrFieldNumber = 5,
    kDeliveredFieldNumber = 6,
  };
  // optional double farm_population = 1;
  bool has_farm_population() const;
  private:
  bool _internal_has_farm_population() const;
  public:
  void clear_farm_population();
  double farm_population() const;
  void set_farm_population(double value);
  private:
  double _internal_farm_population() const;
  void _internal_set_farm_population(double value);
  public:

  // optional double farm_capacity = 2;
  bool has_farm_capacity() const;
  private:
  bool _internal_has_farm_capacity() const;
  public:
  void clear_farm_capacity();
  double farm_capacity() const;
  void set_farm_capacity(double value);
  private:
  double _internal_farm_capacity() const;
  void _internal_set_farm_capacity(double value);
  public:

  // optional double elr = 3;
  bool has_elr() const;
  private:
  bool _internal_has_elr() const;
  public:
  void clear_elr();
  double elr() const;
  void set_elr(double value);
  private:
  double _internal_elr() const;
  void _internal_set_elr(double value);
  public:

  // optional double ihr = 4;
  bool has_ihr() const;
  private:
  bool _internal_has_ihr() const;
  public:
  void clear_ihr();
  double ihr() const;
  void set_ihr(double value);
  private:
  double _internal_ihr() const;
  void _internal_set_ihr(double value);
  public:

  // optional double sr = 5;
  bool has_sr() const;
  private:
  bool _internal_has_sr() const;
  public:
  void clear_sr();
  double sr() const;
  void set_sr(double value);
  private:
  double _internal_sr() const;
  void _internal_set_sr(double value);
  public:

  // optional double delivered = 6;
  bool has_delivered() const;
  private:
  bool _internal_has_delivered() const;
  public:
  void clear_delivered();
  double delivered() const;
  void set_delivered(double value);
  private:
  double _internal_delivered() const;
  void _internal_set_delivered(double value);
  public:

  // @@protoc_insertion_point(class_scope:ei.FarmProductionParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double farm_population_;
  double farm_capacity_;
  double elr_;
  double ihr_;
  double sr_;
  double delivered_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class PlayerFarmInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.PlayerFarmInfo) */ {
 public:
  inline PlayerFarmInfo() : PlayerFarmInfo(nullptr) {}
  ~PlayerFarmInfo() override;
  explicit constexpr PlayerFarmInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerFarmInfo(const PlayerFarmInfo& from);
  PlayerFarmInfo(PlayerFarmInfo&& from) noexcept
    : PlayerFarmInfo() {
    *this = ::std::move(from);
  }

  inline PlayerFarmInfo& operator=(const PlayerFarmInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerFarmInfo& operator=(PlayerFarmInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerFarmInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerFarmInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerFarmInfo*>(
               &_PlayerFarmInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(PlayerFarmInfo& a, PlayerFarmInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerFarmInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerFarmInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerFarmInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerFarmInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerFarmInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerFarmInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerFarmInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.PlayerFarmInfo";
  }
  protected:
  explicit PlayerFarmInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEggMedalLevelFieldNumber = 5,
    kEpicResearchFieldNumber = 6,
    kHabsFieldNumber = 9,
    kHabPopulationFieldNumber = 10,
    kVehiclesFieldNumber = 11,
    kTrainLengthFieldNumber = 12,
    kCommonResearchFieldNumber = 14,
    kActiveBoostsFieldNumber = 15,
    kEquippedArtifactsFieldNumber = 17,
    kHabCapacityFieldNumber = 21,
    kFarmAppearanceFieldNumber = 19,
    kSoulEggsFieldNumber = 1,
    kEggsOfProphecyFieldNumber = 2,
    kPermitLevelFieldNumber = 3,
    kHyperloopStationFieldNumber = 4,
    kCashOnHandFieldNumber = 8,
    kSilosOwnedFieldNumber = 13,
    kBoostTokensOnHandFieldNumber = 16,
    kArtifactInventoryScoreFieldNumber = 18,
    kClientVersionFieldNumber = 20,
    kEggTypeFieldNumber = 7,
  };
  // repeated uint32 egg_medal_level = 5;
  int egg_medal_level_size() const;
  private:
  int _internal_egg_medal_level_size() const;
  public:
  void clear_egg_medal_level();
  private:
  uint32_t _internal_egg_medal_level(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_egg_medal_level() const;
  void _internal_add_egg_medal_level(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_egg_medal_level();
  public:
  uint32_t egg_medal_level(int index) const;
  void set_egg_medal_level(int index, uint32_t value);
  void add_egg_medal_level(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      egg_medal_level() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_egg_medal_level();

  // repeated .ei.Backup.ResearchItem epic_research = 6;
  int epic_research_size() const;
  private:
  int _internal_epic_research_size() const;
  public:
  void clear_epic_research();
  ::ei::Backup_ResearchItem* mutable_epic_research(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_ResearchItem >*
      mutable_epic_research();
  private:
  const ::ei::Backup_ResearchItem& _internal_epic_research(int index) const;
  ::ei::Backup_ResearchItem* _internal_add_epic_research();
  public:
  const ::ei::Backup_ResearchItem& epic_research(int index) const;
  ::ei::Backup_ResearchItem* add_epic_research();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_ResearchItem >&
      epic_research() const;

  // repeated uint32 habs = 9;
  int habs_size() const;
  private:
  int _internal_habs_size() const;
  public:
  void clear_habs();
  private:
  uint32_t _internal_habs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_habs() const;
  void _internal_add_habs(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_habs();
  public:
  uint32_t habs(int index) const;
  void set_habs(int index, uint32_t value);
  void add_habs(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      habs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_habs();

  // repeated uint64 hab_population = 10;
  int hab_population_size() const;
  private:
  int _internal_hab_population_size() const;
  public:
  void clear_hab_population();
  private:
  uint64_t _internal_hab_population(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_hab_population() const;
  void _internal_add_hab_population(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_hab_population();
  public:
  uint64_t hab_population(int index) const;
  void set_hab_population(int index, uint64_t value);
  void add_hab_population(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      hab_population() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_hab_population();

  // repeated uint32 vehicles = 11;
  int vehicles_size() const;
  private:
  int _internal_vehicles_size() const;
  public:
  void clear_vehicles();
  private:
  uint32_t _internal_vehicles(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_vehicles() const;
  void _internal_add_vehicles(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_vehicles();
  public:
  uint32_t vehicles(int index) const;
  void set_vehicles(int index, uint32_t value);
  void add_vehicles(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      vehicles() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_vehicles();

  // repeated uint32 train_length = 12;
  int train_length_size() const;
  private:
  int _internal_train_length_size() const;
  public:
  void clear_train_length();
  private:
  uint32_t _internal_train_length(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_train_length() const;
  void _internal_add_train_length(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_train_length();
  public:
  uint32_t train_length(int index) const;
  void set_train_length(int index, uint32_t value);
  void add_train_length(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      train_length() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_train_length();

  // repeated .ei.Backup.ResearchItem common_research = 14;
  int common_research_size() const;
  private:
  int _internal_common_research_size() const;
  public:
  void clear_common_research();
  ::ei::Backup_ResearchItem* mutable_common_research(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_ResearchItem >*
      mutable_common_research();
  private:
  const ::ei::Backup_ResearchItem& _internal_common_research(int index) const;
  ::ei::Backup_ResearchItem* _internal_add_common_research();
  public:
  const ::ei::Backup_ResearchItem& common_research(int index) const;
  ::ei::Backup_ResearchItem* add_common_research();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_ResearchItem >&
      common_research() const;

  // repeated .ei.Backup.ActiveBoost active_boosts = 15;
  int active_boosts_size() const;
  private:
  int _internal_active_boosts_size() const;
  public:
  void clear_active_boosts();
  ::ei::Backup_ActiveBoost* mutable_active_boosts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_ActiveBoost >*
      mutable_active_boosts();
  private:
  const ::ei::Backup_ActiveBoost& _internal_active_boosts(int index) const;
  ::ei::Backup_ActiveBoost* _internal_add_active_boosts();
  public:
  const ::ei::Backup_ActiveBoost& active_boosts(int index) const;
  ::ei::Backup_ActiveBoost* add_active_boosts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_ActiveBoost >&
      active_boosts() const;

  // repeated .ei.CompleteArtifact equipped_artifacts = 17;
  int equipped_artifacts_size() const;
  private:
  int _internal_equipped_artifacts_size() const;
  public:
  void clear_equipped_artifacts();
  ::ei::CompleteArtifact* mutable_equipped_artifacts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::CompleteArtifact >*
      mutable_equipped_artifacts();
  private:
  const ::ei::CompleteArtifact& _internal_equipped_artifacts(int index) const;
  ::ei::CompleteArtifact* _internal_add_equipped_artifacts();
  public:
  const ::ei::CompleteArtifact& equipped_artifacts(int index) const;
  ::ei::CompleteArtifact* add_equipped_artifacts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::CompleteArtifact >&
      equipped_artifacts() const;

  // repeated uint64 hab_capacity = 21;
  int hab_capacity_size() const;
  private:
  int _internal_hab_capacity_size() const;
  public:
  void clear_hab_capacity();
  private:
  uint64_t _internal_hab_capacity(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_hab_capacity() const;
  void _internal_add_hab_capacity(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_hab_capacity();
  public:
  uint64_t hab_capacity(int index) const;
  void set_hab_capacity(int index, uint64_t value);
  void add_hab_capacity(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      hab_capacity() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_hab_capacity();

  // optional .ei.ShellDB.FarmConfiguration farm_appearance = 19;
  bool has_farm_appearance() const;
  private:
  bool _internal_has_farm_appearance() const;
  public:
  void clear_farm_appearance();
  const ::ei::ShellDB_FarmConfiguration& farm_appearance() const;
  PROTOBUF_NODISCARD ::ei::ShellDB_FarmConfiguration* release_farm_appearance();
  ::ei::ShellDB_FarmConfiguration* mutable_farm_appearance();
  void set_allocated_farm_appearance(::ei::ShellDB_FarmConfiguration* farm_appearance);
  private:
  const ::ei::ShellDB_FarmConfiguration& _internal_farm_appearance() const;
  ::ei::ShellDB_FarmConfiguration* _internal_mutable_farm_appearance();
  public:
  void unsafe_arena_set_allocated_farm_appearance(
      ::ei::ShellDB_FarmConfiguration* farm_appearance);
  ::ei::ShellDB_FarmConfiguration* unsafe_arena_release_farm_appearance();

  // optional double soul_eggs = 1;
  bool has_soul_eggs() const;
  private:
  bool _internal_has_soul_eggs() const;
  public:
  void clear_soul_eggs();
  double soul_eggs() const;
  void set_soul_eggs(double value);
  private:
  double _internal_soul_eggs() const;
  void _internal_set_soul_eggs(double value);
  public:

  // optional uint64 eggs_of_prophecy = 2;
  bool has_eggs_of_prophecy() const;
  private:
  bool _internal_has_eggs_of_prophecy() const;
  public:
  void clear_eggs_of_prophecy();
  uint64_t eggs_of_prophecy() const;
  void set_eggs_of_prophecy(uint64_t value);
  private:
  uint64_t _internal_eggs_of_prophecy() const;
  void _internal_set_eggs_of_prophecy(uint64_t value);
  public:

  // optional uint32 permit_level = 3;
  bool has_permit_level() const;
  private:
  bool _internal_has_permit_level() const;
  public:
  void clear_permit_level();
  uint32_t permit_level() const;
  void set_permit_level(uint32_t value);
  private:
  uint32_t _internal_permit_level() const;
  void _internal_set_permit_level(uint32_t value);
  public:

  // optional bool hyperloop_station = 4;
  bool has_hyperloop_station() const;
  private:
  bool _internal_has_hyperloop_station() const;
  public:
  void clear_hyperloop_station();
  bool hyperloop_station() const;
  void set_hyperloop_station(bool value);
  private:
  bool _internal_hyperloop_station() const;
  void _internal_set_hyperloop_station(bool value);
  public:

  // optional double cash_on_hand = 8;
  bool has_cash_on_hand() const;
  private:
  bool _internal_has_cash_on_hand() const;
  public:
  void clear_cash_on_hand();
  double cash_on_hand() const;
  void set_cash_on_hand(double value);
  private:
  double _internal_cash_on_hand() const;
  void _internal_set_cash_on_hand(double value);
  public:

  // optional uint32 silos_owned = 13;
  bool has_silos_owned() const;
  private:
  bool _internal_has_silos_owned() const;
  public:
  void clear_silos_owned();
  uint32_t silos_owned() const;
  void set_silos_owned(uint32_t value);
  private:
  uint32_t _internal_silos_owned() const;
  void _internal_set_silos_owned(uint32_t value);
  public:

  // optional uint32 boost_tokens_on_hand = 16;
  bool has_boost_tokens_on_hand() const;
  private:
  bool _internal_has_boost_tokens_on_hand() const;
  public:
  void clear_boost_tokens_on_hand();
  uint32_t boost_tokens_on_hand() const;
  void set_boost_tokens_on_hand(uint32_t value);
  private:
  uint32_t _internal_boost_tokens_on_hand() const;
  void _internal_set_boost_tokens_on_hand(uint32_t value);
  public:

  // optional uint64 artifact_inventory_score = 18;
  bool has_artifact_inventory_score() const;
  private:
  bool _internal_has_artifact_inventory_score() const;
  public:
  void clear_artifact_inventory_score();
  uint64_t artifact_inventory_score() const;
  void set_artifact_inventory_score(uint64_t value);
  private:
  uint64_t _internal_artifact_inventory_score() const;
  void _internal_set_artifact_inventory_score(uint64_t value);
  public:

  // optional uint32 client_version = 20;
  bool has_client_version() const;
  private:
  bool _internal_has_client_version() const;
  public:
  void clear_client_version();
  uint32_t client_version() const;
  void set_client_version(uint32_t value);
  private:
  uint32_t _internal_client_version() const;
  void _internal_set_client_version(uint32_t value);
  public:

  // optional .ei.Egg egg_type = 7;
  bool has_egg_type() const;
  private:
  bool _internal_has_egg_type() const;
  public:
  void clear_egg_type();
  ::ei::Egg egg_type() const;
  void set_egg_type(::ei::Egg value);
  private:
  ::ei::Egg _internal_egg_type() const;
  void _internal_set_egg_type(::ei::Egg value);
  public:

  // @@protoc_insertion_point(class_scope:ei.PlayerFarmInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > egg_medal_level_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_ResearchItem > epic_research_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > habs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > hab_population_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > vehicles_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > train_length_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_ResearchItem > common_research_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_ActiveBoost > active_boosts_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::CompleteArtifact > equipped_artifacts_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > hab_capacity_;
  ::ei::ShellDB_FarmConfiguration* farm_appearance_;
  double soul_eggs_;
  uint64_t eggs_of_prophecy_;
  uint32_t permit_level_;
  bool hyperloop_station_;
  double cash_on_hand_;
  uint32_t silos_owned_;
  uint32_t boost_tokens_on_hand_;
  uint64_t artifact_inventory_score_;
  uint32_t client_version_;
  int egg_type_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ContractCoopStatusResponse_ContributionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ContractCoopStatusResponse.ContributionInfo) */ {
 public:
  inline ContractCoopStatusResponse_ContributionInfo() : ContractCoopStatusResponse_ContributionInfo(nullptr) {}
  ~ContractCoopStatusResponse_ContributionInfo() override;
  explicit constexpr ContractCoopStatusResponse_ContributionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContractCoopStatusResponse_ContributionInfo(const ContractCoopStatusResponse_ContributionInfo& from);
  ContractCoopStatusResponse_ContributionInfo(ContractCoopStatusResponse_ContributionInfo&& from) noexcept
    : ContractCoopStatusResponse_ContributionInfo() {
    *this = ::std::move(from);
  }

  inline ContractCoopStatusResponse_ContributionInfo& operator=(const ContractCoopStatusResponse_ContributionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractCoopStatusResponse_ContributionInfo& operator=(ContractCoopStatusResponse_ContributionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractCoopStatusResponse_ContributionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractCoopStatusResponse_ContributionInfo* internal_default_instance() {
    return reinterpret_cast<const ContractCoopStatusResponse_ContributionInfo*>(
               &_ContractCoopStatusResponse_ContributionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(ContractCoopStatusResponse_ContributionInfo& a, ContractCoopStatusResponse_ContributionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractCoopStatusResponse_ContributionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractCoopStatusResponse_ContributionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractCoopStatusResponse_ContributionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContractCoopStatusResponse_ContributionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContractCoopStatusResponse_ContributionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ContractCoopStatusResponse_ContributionInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractCoopStatusResponse_ContributionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ContractCoopStatusResponse.ContributionInfo";
  }
  protected:
  explicit ContractCoopStatusResponse_ContributionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBuffHistoryFieldNumber = 13,
    kUserIdFieldNumber = 1,
    kUserNameFieldNumber = 2,
    kPushIdFieldNumber = 9,
    kContractIdentifierFieldNumber = 19,
    kProductionParamsFieldNumber = 15,
    kFarmInfoFieldNumber = 18,
    kContributionAmountFieldNumber = 3,
    kContributionRateFieldNumber = 6,
    kRankChangeFieldNumber = 8,
    kBanVotesFieldNumber = 10,
    kSoulPowerFieldNumber = 11,
    kActiveFieldNumber = 4,
    kLeechFieldNumber = 16,
    kTimeCheatDetectedFieldNumber = 7,
    kAutojoinedFieldNumber = 17,
    kBoostTokensFieldNumber = 12,
    kChickenRunCooldownFieldNumber = 20,
    kBoostTokensSpentFieldNumber = 14,
    kPlatformFieldNumber = 5,
  };
  // repeated .ei.CoopBuffState buff_history = 13;
  int buff_history_size() const;
  private:
  int _internal_buff_history_size() const;
  public:
  void clear_buff_history();
  ::ei::CoopBuffState* mutable_buff_history(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::CoopBuffState >*
      mutable_buff_history();
  private:
  const ::ei::CoopBuffState& _internal_buff_history(int index) const;
  ::ei::CoopBuffState* _internal_add_buff_history();
  public:
  const ::ei::CoopBuffState& buff_history(int index) const;
  ::ei::CoopBuffState* add_buff_history();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::CoopBuffState >&
      buff_history() const;

  // optional string user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // optional string user_name = 2;
  bool has_user_name() const;
  private:
  bool _internal_has_user_name() const;
  public:
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // optional string push_id = 9;
  bool has_push_id() const;
  private:
  bool _internal_has_push_id() const;
  public:
  void clear_push_id();
  const std::string& push_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_push_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_push_id();
  PROTOBUF_NODISCARD std::string* release_push_id();
  void set_allocated_push_id(std::string* push_id);
  private:
  const std::string& _internal_push_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_push_id(const std::string& value);
  std::string* _internal_mutable_push_id();
  public:

  // optional string contract_identifier = 19;
  bool has_contract_identifier() const;
  private:
  bool _internal_has_contract_identifier() const;
  public:
  void clear_contract_identifier();
  const std::string& contract_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_identifier();
  PROTOBUF_NODISCARD std::string* release_contract_identifier();
  void set_allocated_contract_identifier(std::string* contract_identifier);
  private:
  const std::string& _internal_contract_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_identifier(const std::string& value);
  std::string* _internal_mutable_contract_identifier();
  public:

  // optional .ei.FarmProductionParams production_params = 15;
  bool has_production_params() const;
  private:
  bool _internal_has_production_params() const;
  public:
  void clear_production_params();
  const ::ei::FarmProductionParams& production_params() const;
  PROTOBUF_NODISCARD ::ei::FarmProductionParams* release_production_params();
  ::ei::FarmProductionParams* mutable_production_params();
  void set_allocated_production_params(::ei::FarmProductionParams* production_params);
  private:
  const ::ei::FarmProductionParams& _internal_production_params() const;
  ::ei::FarmProductionParams* _internal_mutable_production_params();
  public:
  void unsafe_arena_set_allocated_production_params(
      ::ei::FarmProductionParams* production_params);
  ::ei::FarmProductionParams* unsafe_arena_release_production_params();

  // optional .ei.PlayerFarmInfo farm_info = 18;
  bool has_farm_info() const;
  private:
  bool _internal_has_farm_info() const;
  public:
  void clear_farm_info();
  const ::ei::PlayerFarmInfo& farm_info() const;
  PROTOBUF_NODISCARD ::ei::PlayerFarmInfo* release_farm_info();
  ::ei::PlayerFarmInfo* mutable_farm_info();
  void set_allocated_farm_info(::ei::PlayerFarmInfo* farm_info);
  private:
  const ::ei::PlayerFarmInfo& _internal_farm_info() const;
  ::ei::PlayerFarmInfo* _internal_mutable_farm_info();
  public:
  void unsafe_arena_set_allocated_farm_info(
      ::ei::PlayerFarmInfo* farm_info);
  ::ei::PlayerFarmInfo* unsafe_arena_release_farm_info();

  // optional double contribution_amount = 3;
  bool has_contribution_amount() const;
  private:
  bool _internal_has_contribution_amount() const;
  public:
  void clear_contribution_amount();
  double contribution_amount() const;
  void set_contribution_amount(double value);
  private:
  double _internal_contribution_amount() const;
  void _internal_set_contribution_amount(double value);
  public:

  // optional double contribution_rate = 6;
  bool has_contribution_rate() const;
  private:
  bool _internal_has_contribution_rate() const;
  public:
  void clear_contribution_rate();
  double contribution_rate() const;
  void set_contribution_rate(double value);
  private:
  double _internal_contribution_rate() const;
  void _internal_set_contribution_rate(double value);
  public:

  // optional int32 rank_change = 8;
  bool has_rank_change() const;
  private:
  bool _internal_has_rank_change() const;
  public:
  void clear_rank_change();
  int32_t rank_change() const;
  void set_rank_change(int32_t value);
  private:
  int32_t _internal_rank_change() const;
  void _internal_set_rank_change(int32_t value);
  public:

  // optional uint32 ban_votes = 10;
  bool has_ban_votes() const;
  private:
  bool _internal_has_ban_votes() const;
  public:
  void clear_ban_votes();
  uint32_t ban_votes() const;
  void set_ban_votes(uint32_t value);
  private:
  uint32_t _internal_ban_votes() const;
  void _internal_set_ban_votes(uint32_t value);
  public:

  // optional double soul_power = 11;
  bool has_soul_power() const;
  private:
  bool _internal_has_soul_power() const;
  public:
  void clear_soul_power();
  double soul_power() const;
  void set_soul_power(double value);
  private:
  double _internal_soul_power() const;
  void _internal_set_soul_power(double value);
  public:

  // optional bool active = 4;
  bool has_active() const;
  private:
  bool _internal_has_active() const;
  public:
  void clear_active();
  bool active() const;
  void set_active(bool value);
  private:
  bool _internal_active() const;
  void _internal_set_active(bool value);
  public:

  // optional bool leech = 16;
  bool has_leech() const;
  private:
  bool _internal_has_leech() const;
  public:
  void clear_leech();
  bool leech() const;
  void set_leech(bool value);
  private:
  bool _internal_leech() const;
  void _internal_set_leech(bool value);
  public:

  // optional bool time_cheat_detected = 7;
  bool has_time_cheat_detected() const;
  private:
  bool _internal_has_time_cheat_detected() const;
  public:
  void clear_time_cheat_detected();
  bool time_cheat_detected() const;
  void set_time_cheat_detected(bool value);
  private:
  bool _internal_time_cheat_detected() const;
  void _internal_set_time_cheat_detected(bool value);
  public:

  // optional bool autojoined = 17;
  bool has_autojoined() const;
  private:
  bool _internal_has_autojoined() const;
  public:
  void clear_autojoined();
  bool autojoined() const;
  void set_autojoined(bool value);
  private:
  bool _internal_autojoined() const;
  void _internal_set_autojoined(bool value);
  public:

  // optional uint32 boost_tokens = 12;
  bool has_boost_tokens() const;
  private:
  bool _internal_has_boost_tokens() const;
  public:
  void clear_boost_tokens();
  uint32_t boost_tokens() const;
  void set_boost_tokens(uint32_t value);
  private:
  uint32_t _internal_boost_tokens() const;
  void _internal_set_boost_tokens(uint32_t value);
  public:

  // optional double chicken_run_cooldown = 20;
  bool has_chicken_run_cooldown() const;
  private:
  bool _internal_has_chicken_run_cooldown() const;
  public:
  void clear_chicken_run_cooldown();
  double chicken_run_cooldown() const;
  void set_chicken_run_cooldown(double value);
  private:
  double _internal_chicken_run_cooldown() const;
  void _internal_set_chicken_run_cooldown(double value);
  public:

  // optional uint32 boost_tokens_spent = 14;
  bool has_boost_tokens_spent() const;
  private:
  bool _internal_has_boost_tokens_spent() const;
  public:
  void clear_boost_tokens_spent();
  uint32_t boost_tokens_spent() const;
  void set_boost_tokens_spent(uint32_t value);
  private:
  uint32_t _internal_boost_tokens_spent() const;
  void _internal_set_boost_tokens_spent(uint32_t value);
  public:

  // optional .ei.Platform platform = 5;
  bool has_platform() const;
  private:
  bool _internal_has_platform() const;
  public:
  void clear_platform();
  ::ei::Platform platform() const;
  void set_platform(::ei::Platform value);
  private:
  ::ei::Platform _internal_platform() const;
  void _internal_set_platform(::ei::Platform value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ContractCoopStatusResponse.ContributionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::CoopBuffState > buff_history_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr push_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_identifier_;
  ::ei::FarmProductionParams* production_params_;
  ::ei::PlayerFarmInfo* farm_info_;
  double contribution_amount_;
  double contribution_rate_;
  int32_t rank_change_;
  uint32_t ban_votes_;
  double soul_power_;
  bool active_;
  bool leech_;
  bool time_cheat_detected_;
  bool autojoined_;
  uint32_t boost_tokens_;
  double chicken_run_cooldown_;
  uint32_t boost_tokens_spent_;
  int platform_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ContractCoopStatusResponse_CoopGift final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ContractCoopStatusResponse.CoopGift) */ {
 public:
  inline ContractCoopStatusResponse_CoopGift() : ContractCoopStatusResponse_CoopGift(nullptr) {}
  ~ContractCoopStatusResponse_CoopGift() override;
  explicit constexpr ContractCoopStatusResponse_CoopGift(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContractCoopStatusResponse_CoopGift(const ContractCoopStatusResponse_CoopGift& from);
  ContractCoopStatusResponse_CoopGift(ContractCoopStatusResponse_CoopGift&& from) noexcept
    : ContractCoopStatusResponse_CoopGift() {
    *this = ::std::move(from);
  }

  inline ContractCoopStatusResponse_CoopGift& operator=(const ContractCoopStatusResponse_CoopGift& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractCoopStatusResponse_CoopGift& operator=(ContractCoopStatusResponse_CoopGift&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractCoopStatusResponse_CoopGift& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractCoopStatusResponse_CoopGift* internal_default_instance() {
    return reinterpret_cast<const ContractCoopStatusResponse_CoopGift*>(
               &_ContractCoopStatusResponse_CoopGift_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(ContractCoopStatusResponse_CoopGift& a, ContractCoopStatusResponse_CoopGift& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractCoopStatusResponse_CoopGift* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractCoopStatusResponse_CoopGift* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractCoopStatusResponse_CoopGift* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContractCoopStatusResponse_CoopGift>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContractCoopStatusResponse_CoopGift& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ContractCoopStatusResponse_CoopGift& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractCoopStatusResponse_CoopGift* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ContractCoopStatusResponse.CoopGift";
  }
  protected:
  explicit ContractCoopStatusResponse_CoopGift(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kUserNameFieldNumber = 3,
    kAmountFieldNumber = 2,
  };
  // optional string user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // optional string user_name = 3;
  bool has_user_name() const;
  private:
  bool _internal_has_user_name() const;
  public:
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // optional uint32 amount = 2;
  bool has_amount() const;
  private:
  bool _internal_has_amount() const;
  public:
  void clear_amount();
  uint32_t amount() const;
  void set_amount(uint32_t value);
  private:
  uint32_t _internal_amount() const;
  void _internal_set_amount(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ContractCoopStatusResponse.CoopGift)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
  uint32_t amount_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ContractCoopStatusResponse_ChickenRun final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ContractCoopStatusResponse.ChickenRun) */ {
 public:
  inline ContractCoopStatusResponse_ChickenRun() : ContractCoopStatusResponse_ChickenRun(nullptr) {}
  ~ContractCoopStatusResponse_ChickenRun() override;
  explicit constexpr ContractCoopStatusResponse_ChickenRun(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContractCoopStatusResponse_ChickenRun(const ContractCoopStatusResponse_ChickenRun& from);
  ContractCoopStatusResponse_ChickenRun(ContractCoopStatusResponse_ChickenRun&& from) noexcept
    : ContractCoopStatusResponse_ChickenRun() {
    *this = ::std::move(from);
  }

  inline ContractCoopStatusResponse_ChickenRun& operator=(const ContractCoopStatusResponse_ChickenRun& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractCoopStatusResponse_ChickenRun& operator=(ContractCoopStatusResponse_ChickenRun&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractCoopStatusResponse_ChickenRun& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractCoopStatusResponse_ChickenRun* internal_default_instance() {
    return reinterpret_cast<const ContractCoopStatusResponse_ChickenRun*>(
               &_ContractCoopStatusResponse_ChickenRun_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(ContractCoopStatusResponse_ChickenRun& a, ContractCoopStatusResponse_ChickenRun& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractCoopStatusResponse_ChickenRun* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractCoopStatusResponse_ChickenRun* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractCoopStatusResponse_ChickenRun* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContractCoopStatusResponse_ChickenRun>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContractCoopStatusResponse_ChickenRun& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ContractCoopStatusResponse_ChickenRun& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractCoopStatusResponse_ChickenRun* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ContractCoopStatusResponse.ChickenRun";
  }
  protected:
  explicit ContractCoopStatusResponse_ChickenRun(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kUserNameFieldNumber = 3,
    kAmountFieldNumber = 2,
  };
  // optional string user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // optional string user_name = 3;
  bool has_user_name() const;
  private:
  bool _internal_has_user_name() const;
  public:
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // optional uint64 amount = 2;
  bool has_amount() const;
  private:
  bool _internal_has_amount() const;
  public:
  void clear_amount();
  uint64_t amount() const;
  void set_amount(uint64_t value);
  private:
  uint64_t _internal_amount() const;
  void _internal_set_amount(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ContractCoopStatusResponse.ChickenRun)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
  uint64_t amount_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ContractCoopStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ContractCoopStatusResponse) */ {
 public:
  inline ContractCoopStatusResponse() : ContractCoopStatusResponse(nullptr) {}
  ~ContractCoopStatusResponse() override;
  explicit constexpr ContractCoopStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContractCoopStatusResponse(const ContractCoopStatusResponse& from);
  ContractCoopStatusResponse(ContractCoopStatusResponse&& from) noexcept
    : ContractCoopStatusResponse() {
    *this = ::std::move(from);
  }

  inline ContractCoopStatusResponse& operator=(const ContractCoopStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractCoopStatusResponse& operator=(ContractCoopStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractCoopStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractCoopStatusResponse* internal_default_instance() {
    return reinterpret_cast<const ContractCoopStatusResponse*>(
               &_ContractCoopStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(ContractCoopStatusResponse& a, ContractCoopStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractCoopStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractCoopStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractCoopStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContractCoopStatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContractCoopStatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ContractCoopStatusResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractCoopStatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ContractCoopStatusResponse";
  }
  protected:
  explicit ContractCoopStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ContractCoopStatusResponse_ContributionInfo ContributionInfo;
  typedef ContractCoopStatusResponse_CoopGift CoopGift;
  typedef ContractCoopStatusResponse_ChickenRun ChickenRun;

  typedef ContractCoopStatusResponse_MemberStatus MemberStatus;
  static constexpr MemberStatus VALID =
    ContractCoopStatusResponse_MemberStatus_VALID;
  static constexpr MemberStatus KICKED_INACTIVE =
    ContractCoopStatusResponse_MemberStatus_KICKED_INACTIVE;
  static constexpr MemberStatus KICKED_PRIVATE =
    ContractCoopStatusResponse_MemberStatus_KICKED_PRIVATE;
  static constexpr MemberStatus KICKED_CHEATS =
    ContractCoopStatusResponse_MemberStatus_KICKED_CHEATS;
  static constexpr MemberStatus KICKED_LEECH =
    ContractCoopStatusResponse_MemberStatus_KICKED_LEECH;
  static inline bool MemberStatus_IsValid(int value) {
    return ContractCoopStatusResponse_MemberStatus_IsValid(value);
  }
  static constexpr MemberStatus MemberStatus_MIN =
    ContractCoopStatusResponse_MemberStatus_MemberStatus_MIN;
  static constexpr MemberStatus MemberStatus_MAX =
    ContractCoopStatusResponse_MemberStatus_MemberStatus_MAX;
  static constexpr int MemberStatus_ARRAYSIZE =
    ContractCoopStatusResponse_MemberStatus_MemberStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MemberStatus_descriptor() {
    return ContractCoopStatusResponse_MemberStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& MemberStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MemberStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MemberStatus_Name.");
    return ContractCoopStatusResponse_MemberStatus_Name(enum_t_value);
  }
  static inline bool MemberStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MemberStatus* value) {
    return ContractCoopStatusResponse_MemberStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kContributorsFieldNumber = 4,
    kGiftsFieldNumber = 11,
    kChickenRunsFieldNumber = 13,
    kContractIdentifierFieldNumber = 1,
    kCoopIdentifierFieldNumber = 3,
    kCreatorIdFieldNumber = 9,
    kTotalAmountFieldNumber = 2,
    kSecondsRemainingFieldNumber = 5,
    kGracePeriodSecondsRemainingFieldNumber = 7,
    kLocalTimestampFieldNumber = 12,
    kAutoGeneratedFieldNumber = 8,
    kPublicFieldNumber = 10,
    kAllMembersReportingFieldNumber = 6,
  };
  // repeated .ei.ContractCoopStatusResponse.ContributionInfo contributors = 4;
  int contributors_size() const;
  private:
  int _internal_contributors_size() const;
  public:
  void clear_contributors();
  ::ei::ContractCoopStatusResponse_ContributionInfo* mutable_contributors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ContractCoopStatusResponse_ContributionInfo >*
      mutable_contributors();
  private:
  const ::ei::ContractCoopStatusResponse_ContributionInfo& _internal_contributors(int index) const;
  ::ei::ContractCoopStatusResponse_ContributionInfo* _internal_add_contributors();
  public:
  const ::ei::ContractCoopStatusResponse_ContributionInfo& contributors(int index) const;
  ::ei::ContractCoopStatusResponse_ContributionInfo* add_contributors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ContractCoopStatusResponse_ContributionInfo >&
      contributors() const;

  // repeated .ei.ContractCoopStatusResponse.CoopGift gifts = 11;
  int gifts_size() const;
  private:
  int _internal_gifts_size() const;
  public:
  void clear_gifts();
  ::ei::ContractCoopStatusResponse_CoopGift* mutable_gifts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ContractCoopStatusResponse_CoopGift >*
      mutable_gifts();
  private:
  const ::ei::ContractCoopStatusResponse_CoopGift& _internal_gifts(int index) const;
  ::ei::ContractCoopStatusResponse_CoopGift* _internal_add_gifts();
  public:
  const ::ei::ContractCoopStatusResponse_CoopGift& gifts(int index) const;
  ::ei::ContractCoopStatusResponse_CoopGift* add_gifts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ContractCoopStatusResponse_CoopGift >&
      gifts() const;

  // repeated .ei.ContractCoopStatusResponse.ChickenRun chicken_runs = 13;
  int chicken_runs_size() const;
  private:
  int _internal_chicken_runs_size() const;
  public:
  void clear_chicken_runs();
  ::ei::ContractCoopStatusResponse_ChickenRun* mutable_chicken_runs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ContractCoopStatusResponse_ChickenRun >*
      mutable_chicken_runs();
  private:
  const ::ei::ContractCoopStatusResponse_ChickenRun& _internal_chicken_runs(int index) const;
  ::ei::ContractCoopStatusResponse_ChickenRun* _internal_add_chicken_runs();
  public:
  const ::ei::ContractCoopStatusResponse_ChickenRun& chicken_runs(int index) const;
  ::ei::ContractCoopStatusResponse_ChickenRun* add_chicken_runs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ContractCoopStatusResponse_ChickenRun >&
      chicken_runs() const;

  // optional string contract_identifier = 1;
  bool has_contract_identifier() const;
  private:
  bool _internal_has_contract_identifier() const;
  public:
  void clear_contract_identifier();
  const std::string& contract_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_identifier();
  PROTOBUF_NODISCARD std::string* release_contract_identifier();
  void set_allocated_contract_identifier(std::string* contract_identifier);
  private:
  const std::string& _internal_contract_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_identifier(const std::string& value);
  std::string* _internal_mutable_contract_identifier();
  public:

  // optional string coop_identifier = 3;
  bool has_coop_identifier() const;
  private:
  bool _internal_has_coop_identifier() const;
  public:
  void clear_coop_identifier();
  const std::string& coop_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_coop_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_coop_identifier();
  PROTOBUF_NODISCARD std::string* release_coop_identifier();
  void set_allocated_coop_identifier(std::string* coop_identifier);
  private:
  const std::string& _internal_coop_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_coop_identifier(const std::string& value);
  std::string* _internal_mutable_coop_identifier();
  public:

  // optional string creator_id = 9;
  bool has_creator_id() const;
  private:
  bool _internal_has_creator_id() const;
  public:
  void clear_creator_id();
  const std::string& creator_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creator_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creator_id();
  PROTOBUF_NODISCARD std::string* release_creator_id();
  void set_allocated_creator_id(std::string* creator_id);
  private:
  const std::string& _internal_creator_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator_id(const std::string& value);
  std::string* _internal_mutable_creator_id();
  public:

  // optional double total_amount = 2;
  bool has_total_amount() const;
  private:
  bool _internal_has_total_amount() const;
  public:
  void clear_total_amount();
  double total_amount() const;
  void set_total_amount(double value);
  private:
  double _internal_total_amount() const;
  void _internal_set_total_amount(double value);
  public:

  // optional double seconds_remaining = 5;
  bool has_seconds_remaining() const;
  private:
  bool _internal_has_seconds_remaining() const;
  public:
  void clear_seconds_remaining();
  double seconds_remaining() const;
  void set_seconds_remaining(double value);
  private:
  double _internal_seconds_remaining() const;
  void _internal_set_seconds_remaining(double value);
  public:

  // optional double grace_period_seconds_remaining = 7;
  bool has_grace_period_seconds_remaining() const;
  private:
  bool _internal_has_grace_period_seconds_remaining() const;
  public:
  void clear_grace_period_seconds_remaining();
  double grace_period_seconds_remaining() const;
  void set_grace_period_seconds_remaining(double value);
  private:
  double _internal_grace_period_seconds_remaining() const;
  void _internal_set_grace_period_seconds_remaining(double value);
  public:

  // optional double local_timestamp = 12;
  bool has_local_timestamp() const;
  private:
  bool _internal_has_local_timestamp() const;
  public:
  void clear_local_timestamp();
  double local_timestamp() const;
  void set_local_timestamp(double value);
  private:
  double _internal_local_timestamp() const;
  void _internal_set_local_timestamp(double value);
  public:

  // optional bool auto_generated = 8;
  bool has_auto_generated() const;
  private:
  bool _internal_has_auto_generated() const;
  public:
  void clear_auto_generated();
  bool auto_generated() const;
  void set_auto_generated(bool value);
  private:
  bool _internal_auto_generated() const;
  void _internal_set_auto_generated(bool value);
  public:

  // optional bool public = 10;
  bool has_public_() const;
  private:
  bool _internal_has_public_() const;
  public:
  void clear_public_();
  bool public_() const;
  void set_public_(bool value);
  private:
  bool _internal_public_() const;
  void _internal_set_public_(bool value);
  public:

  // optional bool all_members_reporting = 6;
  bool has_all_members_reporting() const;
  private:
  bool _internal_has_all_members_reporting() const;
  public:
  void clear_all_members_reporting();
  bool all_members_reporting() const;
  void set_all_members_reporting(bool value);
  private:
  bool _internal_all_members_reporting() const;
  void _internal_set_all_members_reporting(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ContractCoopStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ContractCoopStatusResponse_ContributionInfo > contributors_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ContractCoopStatusResponse_CoopGift > gifts_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ContractCoopStatusResponse_ChickenRun > chicken_runs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr coop_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creator_id_;
  double total_amount_;
  double seconds_remaining_;
  double grace_period_seconds_remaining_;
  double local_timestamp_;
  bool auto_generated_;
  bool public__;
  bool all_members_reporting_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class LocalContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.LocalContract) */ {
 public:
  inline LocalContract() : LocalContract(nullptr) {}
  ~LocalContract() override;
  explicit constexpr LocalContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocalContract(const LocalContract& from);
  LocalContract(LocalContract&& from) noexcept
    : LocalContract() {
    *this = ::std::move(from);
  }

  inline LocalContract& operator=(const LocalContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalContract& operator=(LocalContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocalContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocalContract* internal_default_instance() {
    return reinterpret_cast<const LocalContract*>(
               &_LocalContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(LocalContract& a, LocalContract& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocalContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocalContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocalContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocalContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LocalContract& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocalContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.LocalContract";
  }
  protected:
  explicit LocalContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoopIdentifierFieldNumber = 2,
    kCoopUserIdFieldNumber = 13,
    kContractFieldNumber = 1,
    kTimeAcceptedFieldNumber = 3,
    kCoopSharedEndTimeFieldNumber = 5,
    kLastAmountWhenRewardGivenFieldNumber = 6,
    kAcceptedFieldNumber = 7,
    kCancelledFieldNumber = 4,
    kNewFieldNumber = 8,
    kCoopContributionFinalizedFieldNumber = 10,
    kBoostsUsedFieldNumber = 12,
    kCoopGracePeriodEndTimeFieldNumber = 9,
    kCoopLastUploadedContributionFieldNumber = 11,
    kNumGoalsAchievedFieldNumber = 14,
    kLeagueFieldNumber = 15,
    kLastNagTimeFieldNumber = 16,
    kCoopShareFarmFieldNumber = 17,
  };
  // optional string coop_identifier = 2;
  bool has_coop_identifier() const;
  private:
  bool _internal_has_coop_identifier() const;
  public:
  void clear_coop_identifier();
  const std::string& coop_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_coop_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_coop_identifier();
  PROTOBUF_NODISCARD std::string* release_coop_identifier();
  void set_allocated_coop_identifier(std::string* coop_identifier);
  private:
  const std::string& _internal_coop_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_coop_identifier(const std::string& value);
  std::string* _internal_mutable_coop_identifier();
  public:

  // optional string coop_user_id = 13;
  bool has_coop_user_id() const;
  private:
  bool _internal_has_coop_user_id() const;
  public:
  void clear_coop_user_id();
  const std::string& coop_user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_coop_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_coop_user_id();
  PROTOBUF_NODISCARD std::string* release_coop_user_id();
  void set_allocated_coop_user_id(std::string* coop_user_id);
  private:
  const std::string& _internal_coop_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_coop_user_id(const std::string& value);
  std::string* _internal_mutable_coop_user_id();
  public:

  // optional .ei.Contract contract = 1;
  bool has_contract() const;
  private:
  bool _internal_has_contract() const;
  public:
  void clear_contract();
  const ::ei::Contract& contract() const;
  PROTOBUF_NODISCARD ::ei::Contract* release_contract();
  ::ei::Contract* mutable_contract();
  void set_allocated_contract(::ei::Contract* contract);
  private:
  const ::ei::Contract& _internal_contract() const;
  ::ei::Contract* _internal_mutable_contract();
  public:
  void unsafe_arena_set_allocated_contract(
      ::ei::Contract* contract);
  ::ei::Contract* unsafe_arena_release_contract();

  // optional double time_accepted = 3;
  bool has_time_accepted() const;
  private:
  bool _internal_has_time_accepted() const;
  public:
  void clear_time_accepted();
  double time_accepted() const;
  void set_time_accepted(double value);
  private:
  double _internal_time_accepted() const;
  void _internal_set_time_accepted(double value);
  public:

  // optional double coop_shared_end_time = 5;
  bool has_coop_shared_end_time() const;
  private:
  bool _internal_has_coop_shared_end_time() const;
  public:
  void clear_coop_shared_end_time();
  double coop_shared_end_time() const;
  void set_coop_shared_end_time(double value);
  private:
  double _internal_coop_shared_end_time() const;
  void _internal_set_coop_shared_end_time(double value);
  public:

  // optional double last_amount_when_reward_given = 6;
  bool has_last_amount_when_reward_given() const;
  private:
  bool _internal_has_last_amount_when_reward_given() const;
  public:
  void clear_last_amount_when_reward_given();
  double last_amount_when_reward_given() const;
  void set_last_amount_when_reward_given(double value);
  private:
  double _internal_last_amount_when_reward_given() const;
  void _internal_set_last_amount_when_reward_given(double value);
  public:

  // optional bool accepted = 7;
  bool has_accepted() const;
  private:
  bool _internal_has_accepted() const;
  public:
  void clear_accepted();
  bool accepted() const;
  void set_accepted(bool value);
  private:
  bool _internal_accepted() const;
  void _internal_set_accepted(bool value);
  public:

  // optional bool cancelled = 4;
  bool has_cancelled() const;
  private:
  bool _internal_has_cancelled() const;
  public:
  void clear_cancelled();
  bool cancelled() const;
  void set_cancelled(bool value);
  private:
  bool _internal_cancelled() const;
  void _internal_set_cancelled(bool value);
  public:

  // optional bool new = 8;
  bool has_new_() const;
  private:
  bool _internal_has_new_() const;
  public:
  void clear_new_();
  bool new_() const;
  void set_new_(bool value);
  private:
  bool _internal_new_() const;
  void _internal_set_new_(bool value);
  public:

  // optional bool coop_contribution_finalized = 10;
  bool has_coop_contribution_finalized() const;
  private:
  bool _internal_has_coop_contribution_finalized() const;
  public:
  void clear_coop_contribution_finalized();
  bool coop_contribution_finalized() const;
  void set_coop_contribution_finalized(bool value);
  private:
  bool _internal_coop_contribution_finalized() const;
  void _internal_set_coop_contribution_finalized(bool value);
  public:

  // optional uint32 boosts_used = 12;
  bool has_boosts_used() const;
  private:
  bool _internal_has_boosts_used() const;
  public:
  void clear_boosts_used();
  uint32_t boosts_used() const;
  void set_boosts_used(uint32_t value);
  private:
  uint32_t _internal_boosts_used() const;
  void _internal_set_boosts_used(uint32_t value);
  public:

  // optional double coop_grace_period_end_time = 9;
  bool has_coop_grace_period_end_time() const;
  private:
  bool _internal_has_coop_grace_period_end_time() const;
  public:
  void clear_coop_grace_period_end_time();
  double coop_grace_period_end_time() const;
  void set_coop_grace_period_end_time(double value);
  private:
  double _internal_coop_grace_period_end_time() const;
  void _internal_set_coop_grace_period_end_time(double value);
  public:

  // optional double coop_last_uploaded_contribution = 11;
  bool has_coop_last_uploaded_contribution() const;
  private:
  bool _internal_has_coop_last_uploaded_contribution() const;
  public:
  void clear_coop_last_uploaded_contribution();
  double coop_last_uploaded_contribution() const;
  void set_coop_last_uploaded_contribution(double value);
  private:
  double _internal_coop_last_uploaded_contribution() const;
  void _internal_set_coop_last_uploaded_contribution(double value);
  public:

  // optional uint32 num_goals_achieved = 14;
  bool has_num_goals_achieved() const;
  private:
  bool _internal_has_num_goals_achieved() const;
  public:
  void clear_num_goals_achieved();
  uint32_t num_goals_achieved() const;
  void set_num_goals_achieved(uint32_t value);
  private:
  uint32_t _internal_num_goals_achieved() const;
  void _internal_set_num_goals_achieved(uint32_t value);
  public:

  // optional uint32 league = 15;
  bool has_league() const;
  private:
  bool _internal_has_league() const;
  public:
  void clear_league();
  uint32_t league() const;
  void set_league(uint32_t value);
  private:
  uint32_t _internal_league() const;
  void _internal_set_league(uint32_t value);
  public:

  // optional double last_nag_time = 16;
  bool has_last_nag_time() const;
  private:
  bool _internal_has_last_nag_time() const;
  public:
  void clear_last_nag_time();
  double last_nag_time() const;
  void set_last_nag_time(double value);
  private:
  double _internal_last_nag_time() const;
  void _internal_set_last_nag_time(double value);
  public:

  // optional bool coop_share_farm = 17;
  bool has_coop_share_farm() const;
  private:
  bool _internal_has_coop_share_farm() const;
  public:
  void clear_coop_share_farm();
  bool coop_share_farm() const;
  void set_coop_share_farm(bool value);
  private:
  bool _internal_coop_share_farm() const;
  void _internal_set_coop_share_farm(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ei.LocalContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr coop_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr coop_user_id_;
  ::ei::Contract* contract_;
  double time_accepted_;
  double coop_shared_end_time_;
  double last_amount_when_reward_given_;
  bool accepted_;
  bool cancelled_;
  bool new__;
  bool coop_contribution_finalized_;
  uint32_t boosts_used_;
  double coop_grace_period_end_time_;
  double coop_last_uploaded_contribution_;
  uint32_t num_goals_achieved_;
  uint32_t league_;
  double last_nag_time_;
  bool coop_share_farm_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class MyContracts final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.MyContracts) */ {
 public:
  inline MyContracts() : MyContracts(nullptr) {}
  ~MyContracts() override;
  explicit constexpr MyContracts(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MyContracts(const MyContracts& from);
  MyContracts(MyContracts&& from) noexcept
    : MyContracts() {
    *this = ::std::move(from);
  }

  inline MyContracts& operator=(const MyContracts& from) {
    CopyFrom(from);
    return *this;
  }
  inline MyContracts& operator=(MyContracts&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MyContracts& default_instance() {
    return *internal_default_instance();
  }
  static inline const MyContracts* internal_default_instance() {
    return reinterpret_cast<const MyContracts*>(
               &_MyContracts_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(MyContracts& a, MyContracts& b) {
    a.Swap(&b);
  }
  inline void Swap(MyContracts* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MyContracts* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MyContracts* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MyContracts>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MyContracts& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MyContracts& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MyContracts* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.MyContracts";
  }
  protected:
  explicit MyContracts(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractsFieldNumber = 1,
    kArchiveFieldNumber = 2,
    kContractIdsSeenFieldNumber = 3,
    kCurrentCoopStatusesFieldNumber = 4,
  };
  // repeated .ei.LocalContract contracts = 1;
  int contracts_size() const;
  private:
  int _internal_contracts_size() const;
  public:
  void clear_contracts();
  ::ei::LocalContract* mutable_contracts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::LocalContract >*
      mutable_contracts();
  private:
  const ::ei::LocalContract& _internal_contracts(int index) const;
  ::ei::LocalContract* _internal_add_contracts();
  public:
  const ::ei::LocalContract& contracts(int index) const;
  ::ei::LocalContract* add_contracts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::LocalContract >&
      contracts() const;

  // repeated .ei.LocalContract archive = 2;
  int archive_size() const;
  private:
  int _internal_archive_size() const;
  public:
  void clear_archive();
  ::ei::LocalContract* mutable_archive(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::LocalContract >*
      mutable_archive();
  private:
  const ::ei::LocalContract& _internal_archive(int index) const;
  ::ei::LocalContract* _internal_add_archive();
  public:
  const ::ei::LocalContract& archive(int index) const;
  ::ei::LocalContract* add_archive();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::LocalContract >&
      archive() const;

  // repeated string contract_ids_seen = 3;
  int contract_ids_seen_size() const;
  private:
  int _internal_contract_ids_seen_size() const;
  public:
  void clear_contract_ids_seen();
  const std::string& contract_ids_seen(int index) const;
  std::string* mutable_contract_ids_seen(int index);
  void set_contract_ids_seen(int index, const std::string& value);
  void set_contract_ids_seen(int index, std::string&& value);
  void set_contract_ids_seen(int index, const char* value);
  void set_contract_ids_seen(int index, const char* value, size_t size);
  std::string* add_contract_ids_seen();
  void add_contract_ids_seen(const std::string& value);
  void add_contract_ids_seen(std::string&& value);
  void add_contract_ids_seen(const char* value);
  void add_contract_ids_seen(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& contract_ids_seen() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_contract_ids_seen();
  private:
  const std::string& _internal_contract_ids_seen(int index) const;
  std::string* _internal_add_contract_ids_seen();
  public:

  // repeated .ei.ContractCoopStatusResponse current_coop_statuses = 4;
  int current_coop_statuses_size() const;
  private:
  int _internal_current_coop_statuses_size() const;
  public:
  void clear_current_coop_statuses();
  ::ei::ContractCoopStatusResponse* mutable_current_coop_statuses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ContractCoopStatusResponse >*
      mutable_current_coop_statuses();
  private:
  const ::ei::ContractCoopStatusResponse& _internal_current_coop_statuses(int index) const;
  ::ei::ContractCoopStatusResponse* _internal_add_current_coop_statuses();
  public:
  const ::ei::ContractCoopStatusResponse& current_coop_statuses(int index) const;
  ::ei::ContractCoopStatusResponse* add_current_coop_statuses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ContractCoopStatusResponse >&
      current_coop_statuses() const;

  // @@protoc_insertion_point(class_scope:ei.MyContracts)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::LocalContract > contracts_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::LocalContract > archive_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> contract_ids_seen_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ContractCoopStatusResponse > current_coop_statuses_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class QueryCoopRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.QueryCoopRequest) */ {
 public:
  inline QueryCoopRequest() : QueryCoopRequest(nullptr) {}
  ~QueryCoopRequest() override;
  explicit constexpr QueryCoopRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryCoopRequest(const QueryCoopRequest& from);
  QueryCoopRequest(QueryCoopRequest&& from) noexcept
    : QueryCoopRequest() {
    *this = ::std::move(from);
  }

  inline QueryCoopRequest& operator=(const QueryCoopRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryCoopRequest& operator=(QueryCoopRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryCoopRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryCoopRequest* internal_default_instance() {
    return reinterpret_cast<const QueryCoopRequest*>(
               &_QueryCoopRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(QueryCoopRequest& a, QueryCoopRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryCoopRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryCoopRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryCoopRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryCoopRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryCoopRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QueryCoopRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryCoopRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.QueryCoopRequest";
  }
  protected:
  explicit QueryCoopRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdentifierFieldNumber = 1,
    kCoopIdentifierFieldNumber = 2,
    kRinfoFieldNumber = 5,
    kClientVersionFieldNumber = 3,
    kLeagueFieldNumber = 4,
  };
  // optional string contract_identifier = 1;
  bool has_contract_identifier() const;
  private:
  bool _internal_has_contract_identifier() const;
  public:
  void clear_contract_identifier();
  const std::string& contract_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_identifier();
  PROTOBUF_NODISCARD std::string* release_contract_identifier();
  void set_allocated_contract_identifier(std::string* contract_identifier);
  private:
  const std::string& _internal_contract_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_identifier(const std::string& value);
  std::string* _internal_mutable_contract_identifier();
  public:

  // optional string coop_identifier = 2;
  bool has_coop_identifier() const;
  private:
  bool _internal_has_coop_identifier() const;
  public:
  void clear_coop_identifier();
  const std::string& coop_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_coop_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_coop_identifier();
  PROTOBUF_NODISCARD std::string* release_coop_identifier();
  void set_allocated_coop_identifier(std::string* coop_identifier);
  private:
  const std::string& _internal_coop_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_coop_identifier(const std::string& value);
  std::string* _internal_mutable_coop_identifier();
  public:

  // optional .ei.BasicRequestInfo rinfo = 5;
  bool has_rinfo() const;
  private:
  bool _internal_has_rinfo() const;
  public:
  void clear_rinfo();
  const ::ei::BasicRequestInfo& rinfo() const;
  PROTOBUF_NODISCARD ::ei::BasicRequestInfo* release_rinfo();
  ::ei::BasicRequestInfo* mutable_rinfo();
  void set_allocated_rinfo(::ei::BasicRequestInfo* rinfo);
  private:
  const ::ei::BasicRequestInfo& _internal_rinfo() const;
  ::ei::BasicRequestInfo* _internal_mutable_rinfo();
  public:
  void unsafe_arena_set_allocated_rinfo(
      ::ei::BasicRequestInfo* rinfo);
  ::ei::BasicRequestInfo* unsafe_arena_release_rinfo();

  // optional uint32 client_version = 3;
  bool has_client_version() const;
  private:
  bool _internal_has_client_version() const;
  public:
  void clear_client_version();
  uint32_t client_version() const;
  void set_client_version(uint32_t value);
  private:
  uint32_t _internal_client_version() const;
  void _internal_set_client_version(uint32_t value);
  public:

  // optional uint32 league = 4;
  bool has_league() const;
  private:
  bool _internal_has_league() const;
  public:
  void clear_league();
  uint32_t league() const;
  void set_league(uint32_t value);
  private:
  uint32_t _internal_league() const;
  void _internal_set_league(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.QueryCoopRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr coop_identifier_;
  ::ei::BasicRequestInfo* rinfo_;
  uint32_t client_version_;
  uint32_t league_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class QueryCoopResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.QueryCoopResponse) */ {
 public:
  inline QueryCoopResponse() : QueryCoopResponse(nullptr) {}
  ~QueryCoopResponse() override;
  explicit constexpr QueryCoopResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryCoopResponse(const QueryCoopResponse& from);
  QueryCoopResponse(QueryCoopResponse&& from) noexcept
    : QueryCoopResponse() {
    *this = ::std::move(from);
  }

  inline QueryCoopResponse& operator=(const QueryCoopResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryCoopResponse& operator=(QueryCoopResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryCoopResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryCoopResponse* internal_default_instance() {
    return reinterpret_cast<const QueryCoopResponse*>(
               &_QueryCoopResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(QueryCoopResponse& a, QueryCoopResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryCoopResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryCoopResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryCoopResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryCoopResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryCoopResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QueryCoopResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryCoopResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.QueryCoopResponse";
  }
  protected:
  explicit QueryCoopResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExistsFieldNumber = 1,
    kFullFieldNumber = 2,
    kExpiredFieldNumber = 5,
    kDifferentLeagueFieldNumber = 4,
    kBannedFieldNumber = 3,
  };
  // optional bool exists = 1;
  bool has_exists() const;
  private:
  bool _internal_has_exists() const;
  public:
  void clear_exists();
  bool exists() const;
  void set_exists(bool value);
  private:
  bool _internal_exists() const;
  void _internal_set_exists(bool value);
  public:

  // optional bool full = 2;
  bool has_full() const;
  private:
  bool _internal_has_full() const;
  public:
  void clear_full();
  bool full() const;
  void set_full(bool value);
  private:
  bool _internal_full() const;
  void _internal_set_full(bool value);
  public:

  // optional bool expired = 5;
  bool has_expired() const;
  private:
  bool _internal_has_expired() const;
  public:
  void clear_expired();
  bool expired() const;
  void set_expired(bool value);
  private:
  bool _internal_expired() const;
  void _internal_set_expired(bool value);
  public:

  // optional bool different_league = 4;
  bool has_different_league() const;
  private:
  bool _internal_has_different_league() const;
  public:
  void clear_different_league();
  bool different_league() const;
  void set_different_league(bool value);
  private:
  bool _internal_different_league() const;
  void _internal_set_different_league(bool value);
  public:

  // optional bool banned = 3;
  bool has_banned() const;
  private:
  bool _internal_has_banned() const;
  public:
  void clear_banned();
  bool banned() const;
  void set_banned(bool value);
  private:
  bool _internal_banned() const;
  void _internal_set_banned(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ei.QueryCoopResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool exists_;
  bool full_;
  bool expired_;
  bool different_league_;
  bool banned_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class CreateCoopRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.CreateCoopRequest) */ {
 public:
  inline CreateCoopRequest() : CreateCoopRequest(nullptr) {}
  ~CreateCoopRequest() override;
  explicit constexpr CreateCoopRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateCoopRequest(const CreateCoopRequest& from);
  CreateCoopRequest(CreateCoopRequest&& from) noexcept
    : CreateCoopRequest() {
    *this = ::std::move(from);
  }

  inline CreateCoopRequest& operator=(const CreateCoopRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateCoopRequest& operator=(CreateCoopRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateCoopRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateCoopRequest* internal_default_instance() {
    return reinterpret_cast<const CreateCoopRequest*>(
               &_CreateCoopRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(CreateCoopRequest& a, CreateCoopRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateCoopRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateCoopRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateCoopRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateCoopRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateCoopRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateCoopRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateCoopRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.CreateCoopRequest";
  }
  protected:
  explicit CreateCoopRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdentifierFieldNumber = 1,
    kCoopIdentifierFieldNumber = 2,
    kUserIdFieldNumber = 4,
    kUserNameFieldNumber = 5,
    kRinfoFieldNumber = 10,
    kSecondsRemainingFieldNumber = 3,
    kSoulPowerFieldNumber = 8,
    kClientVersionFieldNumber = 7,
    kLeagueFieldNumber = 9,
    kEopFieldNumber = 11,
    kPlatformFieldNumber = 6,
  };
  // optional string contract_identifier = 1;
  bool has_contract_identifier() const;
  private:
  bool _internal_has_contract_identifier() const;
  public:
  void clear_contract_identifier();
  const std::string& contract_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_identifier();
  PROTOBUF_NODISCARD std::string* release_contract_identifier();
  void set_allocated_contract_identifier(std::string* contract_identifier);
  private:
  const std::string& _internal_contract_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_identifier(const std::string& value);
  std::string* _internal_mutable_contract_identifier();
  public:

  // optional string coop_identifier = 2;
  bool has_coop_identifier() const;
  private:
  bool _internal_has_coop_identifier() const;
  public:
  void clear_coop_identifier();
  const std::string& coop_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_coop_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_coop_identifier();
  PROTOBUF_NODISCARD std::string* release_coop_identifier();
  void set_allocated_coop_identifier(std::string* coop_identifier);
  private:
  const std::string& _internal_coop_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_coop_identifier(const std::string& value);
  std::string* _internal_mutable_coop_identifier();
  public:

  // optional string user_id = 4;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // optional string user_name = 5;
  bool has_user_name() const;
  private:
  bool _internal_has_user_name() const;
  public:
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // optional .ei.BasicRequestInfo rinfo = 10;
  bool has_rinfo() const;
  private:
  bool _internal_has_rinfo() const;
  public:
  void clear_rinfo();
  const ::ei::BasicRequestInfo& rinfo() const;
  PROTOBUF_NODISCARD ::ei::BasicRequestInfo* release_rinfo();
  ::ei::BasicRequestInfo* mutable_rinfo();
  void set_allocated_rinfo(::ei::BasicRequestInfo* rinfo);
  private:
  const ::ei::BasicRequestInfo& _internal_rinfo() const;
  ::ei::BasicRequestInfo* _internal_mutable_rinfo();
  public:
  void unsafe_arena_set_allocated_rinfo(
      ::ei::BasicRequestInfo* rinfo);
  ::ei::BasicRequestInfo* unsafe_arena_release_rinfo();

  // optional double seconds_remaining = 3;
  bool has_seconds_remaining() const;
  private:
  bool _internal_has_seconds_remaining() const;
  public:
  void clear_seconds_remaining();
  double seconds_remaining() const;
  void set_seconds_remaining(double value);
  private:
  double _internal_seconds_remaining() const;
  void _internal_set_seconds_remaining(double value);
  public:

  // optional double soul_power = 8;
  bool has_soul_power() const;
  private:
  bool _internal_has_soul_power() const;
  public:
  void clear_soul_power();
  double soul_power() const;
  void set_soul_power(double value);
  private:
  double _internal_soul_power() const;
  void _internal_set_soul_power(double value);
  public:

  // optional uint32 client_version = 7;
  bool has_client_version() const;
  private:
  bool _internal_has_client_version() const;
  public:
  void clear_client_version();
  uint32_t client_version() const;
  void set_client_version(uint32_t value);
  private:
  uint32_t _internal_client_version() const;
  void _internal_set_client_version(uint32_t value);
  public:

  // optional uint32 league = 9;
  bool has_league() const;
  private:
  bool _internal_has_league() const;
  public:
  void clear_league();
  uint32_t league() const;
  void set_league(uint32_t value);
  private:
  uint32_t _internal_league() const;
  void _internal_set_league(uint32_t value);
  public:

  // optional double eop = 11;
  bool has_eop() const;
  private:
  bool _internal_has_eop() const;
  public:
  void clear_eop();
  double eop() const;
  void set_eop(double value);
  private:
  double _internal_eop() const;
  void _internal_set_eop(double value);
  public:

  // optional .ei.Platform platform = 6;
  bool has_platform() const;
  private:
  bool _internal_has_platform() const;
  public:
  void clear_platform();
  ::ei::Platform platform() const;
  void set_platform(::ei::Platform value);
  private:
  ::ei::Platform _internal_platform() const;
  void _internal_set_platform(::ei::Platform value);
  public:

  // @@protoc_insertion_point(class_scope:ei.CreateCoopRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr coop_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
  ::ei::BasicRequestInfo* rinfo_;
  double seconds_remaining_;
  double soul_power_;
  uint32_t client_version_;
  uint32_t league_;
  double eop_;
  int platform_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class CreateCoopResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.CreateCoopResponse) */ {
 public:
  inline CreateCoopResponse() : CreateCoopResponse(nullptr) {}
  ~CreateCoopResponse() override;
  explicit constexpr CreateCoopResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateCoopResponse(const CreateCoopResponse& from);
  CreateCoopResponse(CreateCoopResponse&& from) noexcept
    : CreateCoopResponse() {
    *this = ::std::move(from);
  }

  inline CreateCoopResponse& operator=(const CreateCoopResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateCoopResponse& operator=(CreateCoopResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateCoopResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateCoopResponse* internal_default_instance() {
    return reinterpret_cast<const CreateCoopResponse*>(
               &_CreateCoopResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(CreateCoopResponse& a, CreateCoopResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateCoopResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateCoopResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateCoopResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateCoopResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateCoopResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateCoopResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateCoopResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.CreateCoopResponse";
  }
  protected:
  explicit CreateCoopResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // optional string message = 2;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // optional bool success = 1;
  bool has_success() const;
  private:
  bool _internal_has_success() const;
  public:
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ei.CreateCoopResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  bool success_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class JoinCoopRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.JoinCoopRequest) */ {
 public:
  inline JoinCoopRequest() : JoinCoopRequest(nullptr) {}
  ~JoinCoopRequest() override;
  explicit constexpr JoinCoopRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinCoopRequest(const JoinCoopRequest& from);
  JoinCoopRequest(JoinCoopRequest&& from) noexcept
    : JoinCoopRequest() {
    *this = ::std::move(from);
  }

  inline JoinCoopRequest& operator=(const JoinCoopRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinCoopRequest& operator=(JoinCoopRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinCoopRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinCoopRequest* internal_default_instance() {
    return reinterpret_cast<const JoinCoopRequest*>(
               &_JoinCoopRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(JoinCoopRequest& a, JoinCoopRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinCoopRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinCoopRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinCoopRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinCoopRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JoinCoopRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const JoinCoopRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinCoopRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.JoinCoopRequest";
  }
  protected:
  explicit JoinCoopRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdentifierFieldNumber = 1,
    kCoopIdentifierFieldNumber = 2,
    kUserIdFieldNumber = 3,
    kUserNameFieldNumber = 4,
    kRinfoFieldNumber = 10,
    kSoulPowerFieldNumber = 8,
    kClientVersionFieldNumber = 7,
    kLeagueFieldNumber = 9,
    kSecondsRemainingFieldNumber = 11,
    kEopFieldNumber = 12,
    kPlatformFieldNumber = 5,
  };
  // optional string contract_identifier = 1;
  bool has_contract_identifier() const;
  private:
  bool _internal_has_contract_identifier() const;
  public:
  void clear_contract_identifier();
  const std::string& contract_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_identifier();
  PROTOBUF_NODISCARD std::string* release_contract_identifier();
  void set_allocated_contract_identifier(std::string* contract_identifier);
  private:
  const std::string& _internal_contract_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_identifier(const std::string& value);
  std::string* _internal_mutable_contract_identifier();
  public:

  // optional string coop_identifier = 2;
  bool has_coop_identifier() const;
  private:
  bool _internal_has_coop_identifier() const;
  public:
  void clear_coop_identifier();
  const std::string& coop_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_coop_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_coop_identifier();
  PROTOBUF_NODISCARD std::string* release_coop_identifier();
  void set_allocated_coop_identifier(std::string* coop_identifier);
  private:
  const std::string& _internal_coop_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_coop_identifier(const std::string& value);
  std::string* _internal_mutable_coop_identifier();
  public:

  // optional string user_id = 3;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // optional string user_name = 4;
  bool has_user_name() const;
  private:
  bool _internal_has_user_name() const;
  public:
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // optional .ei.BasicRequestInfo rinfo = 10;
  bool has_rinfo() const;
  private:
  bool _internal_has_rinfo() const;
  public:
  void clear_rinfo();
  const ::ei::BasicRequestInfo& rinfo() const;
  PROTOBUF_NODISCARD ::ei::BasicRequestInfo* release_rinfo();
  ::ei::BasicRequestInfo* mutable_rinfo();
  void set_allocated_rinfo(::ei::BasicRequestInfo* rinfo);
  private:
  const ::ei::BasicRequestInfo& _internal_rinfo() const;
  ::ei::BasicRequestInfo* _internal_mutable_rinfo();
  public:
  void unsafe_arena_set_allocated_rinfo(
      ::ei::BasicRequestInfo* rinfo);
  ::ei::BasicRequestInfo* unsafe_arena_release_rinfo();

  // optional double soul_power = 8;
  bool has_soul_power() const;
  private:
  bool _internal_has_soul_power() const;
  public:
  void clear_soul_power();
  double soul_power() const;
  void set_soul_power(double value);
  private:
  double _internal_soul_power() const;
  void _internal_set_soul_power(double value);
  public:

  // optional uint32 client_version = 7;
  bool has_client_version() const;
  private:
  bool _internal_has_client_version() const;
  public:
  void clear_client_version();
  uint32_t client_version() const;
  void set_client_version(uint32_t value);
  private:
  uint32_t _internal_client_version() const;
  void _internal_set_client_version(uint32_t value);
  public:

  // optional uint32 league = 9;
  bool has_league() const;
  private:
  bool _internal_has_league() const;
  public:
  void clear_league();
  uint32_t league() const;
  void set_league(uint32_t value);
  private:
  uint32_t _internal_league() const;
  void _internal_set_league(uint32_t value);
  public:

  // optional double seconds_remaining = 11;
  bool has_seconds_remaining() const;
  private:
  bool _internal_has_seconds_remaining() const;
  public:
  void clear_seconds_remaining();
  double seconds_remaining() const;
  void set_seconds_remaining(double value);
  private:
  double _internal_seconds_remaining() const;
  void _internal_set_seconds_remaining(double value);
  public:

  // optional double eop = 12;
  bool has_eop() const;
  private:
  bool _internal_has_eop() const;
  public:
  void clear_eop();
  double eop() const;
  void set_eop(double value);
  private:
  double _internal_eop() const;
  void _internal_set_eop(double value);
  public:

  // optional .ei.Platform platform = 5;
  bool has_platform() const;
  private:
  bool _internal_has_platform() const;
  public:
  void clear_platform();
  ::ei::Platform platform() const;
  void set_platform(::ei::Platform value);
  private:
  ::ei::Platform _internal_platform() const;
  void _internal_set_platform(::ei::Platform value);
  public:

  // @@protoc_insertion_point(class_scope:ei.JoinCoopRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr coop_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
  ::ei::BasicRequestInfo* rinfo_;
  double soul_power_;
  uint32_t client_version_;
  uint32_t league_;
  double seconds_remaining_;
  double eop_;
  int platform_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class JoinCoopResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.JoinCoopResponse) */ {
 public:
  inline JoinCoopResponse() : JoinCoopResponse(nullptr) {}
  ~JoinCoopResponse() override;
  explicit constexpr JoinCoopResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinCoopResponse(const JoinCoopResponse& from);
  JoinCoopResponse(JoinCoopResponse&& from) noexcept
    : JoinCoopResponse() {
    *this = ::std::move(from);
  }

  inline JoinCoopResponse& operator=(const JoinCoopResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinCoopResponse& operator=(JoinCoopResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinCoopResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinCoopResponse* internal_default_instance() {
    return reinterpret_cast<const JoinCoopResponse*>(
               &_JoinCoopResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(JoinCoopResponse& a, JoinCoopResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinCoopResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinCoopResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinCoopResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinCoopResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JoinCoopResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const JoinCoopResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinCoopResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.JoinCoopResponse";
  }
  protected:
  explicit JoinCoopResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kCoopIdentifierFieldNumber = 5,
    kSecondsRemainingFieldNumber = 3,
    kSuccessFieldNumber = 1,
    kBannedFieldNumber = 4,
    kNumMembersFieldNumber = 7,
    kMatchPercentFieldNumber = 6,
  };
  // optional string message = 2;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // optional string coop_identifier = 5;
  bool has_coop_identifier() const;
  private:
  bool _internal_has_coop_identifier() const;
  public:
  void clear_coop_identifier();
  const std::string& coop_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_coop_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_coop_identifier();
  PROTOBUF_NODISCARD std::string* release_coop_identifier();
  void set_allocated_coop_identifier(std::string* coop_identifier);
  private:
  const std::string& _internal_coop_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_coop_identifier(const std::string& value);
  std::string* _internal_mutable_coop_identifier();
  public:

  // optional double seconds_remaining = 3;
  bool has_seconds_remaining() const;
  private:
  bool _internal_has_seconds_remaining() const;
  public:
  void clear_seconds_remaining();
  double seconds_remaining() const;
  void set_seconds_remaining(double value);
  private:
  double _internal_seconds_remaining() const;
  void _internal_set_seconds_remaining(double value);
  public:

  // optional bool success = 1;
  bool has_success() const;
  private:
  bool _internal_has_success() const;
  public:
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // optional bool banned = 4;
  bool has_banned() const;
  private:
  bool _internal_has_banned() const;
  public:
  void clear_banned();
  bool banned() const;
  void set_banned(bool value);
  private:
  bool _internal_banned() const;
  void _internal_set_banned(bool value);
  public:

  // optional uint32 num_members = 7;
  bool has_num_members() const;
  private:
  bool _internal_has_num_members() const;
  public:
  void clear_num_members();
  uint32_t num_members() const;
  void set_num_members(uint32_t value);
  private:
  uint32_t _internal_num_members() const;
  void _internal_set_num_members(uint32_t value);
  public:

  // optional double match_percent = 6;
  bool has_match_percent() const;
  private:
  bool _internal_has_match_percent() const;
  public:
  void clear_match_percent();
  double match_percent() const;
  void set_match_percent(double value);
  private:
  double _internal_match_percent() const;
  void _internal_set_match_percent(double value);
  public:

  // @@protoc_insertion_point(class_scope:ei.JoinCoopResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr coop_identifier_;
  double seconds_remaining_;
  bool success_;
  bool banned_;
  uint32_t num_members_;
  double match_percent_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class AutoJoinCoopRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.AutoJoinCoopRequest) */ {
 public:
  inline AutoJoinCoopRequest() : AutoJoinCoopRequest(nullptr) {}
  ~AutoJoinCoopRequest() override;
  explicit constexpr AutoJoinCoopRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutoJoinCoopRequest(const AutoJoinCoopRequest& from);
  AutoJoinCoopRequest(AutoJoinCoopRequest&& from) noexcept
    : AutoJoinCoopRequest() {
    *this = ::std::move(from);
  }

  inline AutoJoinCoopRequest& operator=(const AutoJoinCoopRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutoJoinCoopRequest& operator=(AutoJoinCoopRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AutoJoinCoopRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutoJoinCoopRequest* internal_default_instance() {
    return reinterpret_cast<const AutoJoinCoopRequest*>(
               &_AutoJoinCoopRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(AutoJoinCoopRequest& a, AutoJoinCoopRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AutoJoinCoopRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutoJoinCoopRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutoJoinCoopRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutoJoinCoopRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AutoJoinCoopRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AutoJoinCoopRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AutoJoinCoopRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.AutoJoinCoopRequest";
  }
  protected:
  explicit AutoJoinCoopRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdentifierFieldNumber = 1,
    kUserIdFieldNumber = 2,
    kUserNameFieldNumber = 3,
    kRinfoFieldNumber = 9,
    kSoulPowerFieldNumber = 4,
    kSecondsRemainingFieldNumber = 5,
    kClientVersionFieldNumber = 7,
    kLeagueFieldNumber = 8,
    kEopFieldNumber = 10,
    kPlatformFieldNumber = 6,
  };
  // optional string contract_identifier = 1;
  bool has_contract_identifier() const;
  private:
  bool _internal_has_contract_identifier() const;
  public:
  void clear_contract_identifier();
  const std::string& contract_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_identifier();
  PROTOBUF_NODISCARD std::string* release_contract_identifier();
  void set_allocated_contract_identifier(std::string* contract_identifier);
  private:
  const std::string& _internal_contract_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_identifier(const std::string& value);
  std::string* _internal_mutable_contract_identifier();
  public:

  // optional string user_id = 2;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // optional string user_name = 3;
  bool has_user_name() const;
  private:
  bool _internal_has_user_name() const;
  public:
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // optional .ei.BasicRequestInfo rinfo = 9;
  bool has_rinfo() const;
  private:
  bool _internal_has_rinfo() const;
  public:
  void clear_rinfo();
  const ::ei::BasicRequestInfo& rinfo() const;
  PROTOBUF_NODISCARD ::ei::BasicRequestInfo* release_rinfo();
  ::ei::BasicRequestInfo* mutable_rinfo();
  void set_allocated_rinfo(::ei::BasicRequestInfo* rinfo);
  private:
  const ::ei::BasicRequestInfo& _internal_rinfo() const;
  ::ei::BasicRequestInfo* _internal_mutable_rinfo();
  public:
  void unsafe_arena_set_allocated_rinfo(
      ::ei::BasicRequestInfo* rinfo);
  ::ei::BasicRequestInfo* unsafe_arena_release_rinfo();

  // optional double soul_power = 4;
  bool has_soul_power() const;
  private:
  bool _internal_has_soul_power() const;
  public:
  void clear_soul_power();
  double soul_power() const;
  void set_soul_power(double value);
  private:
  double _internal_soul_power() const;
  void _internal_set_soul_power(double value);
  public:

  // optional double seconds_remaining = 5;
  bool has_seconds_remaining() const;
  private:
  bool _internal_has_seconds_remaining() const;
  public:
  void clear_seconds_remaining();
  double seconds_remaining() const;
  void set_seconds_remaining(double value);
  private:
  double _internal_seconds_remaining() const;
  void _internal_set_seconds_remaining(double value);
  public:

  // optional uint32 client_version = 7;
  bool has_client_version() const;
  private:
  bool _internal_has_client_version() const;
  public:
  void clear_client_version();
  uint32_t client_version() const;
  void set_client_version(uint32_t value);
  private:
  uint32_t _internal_client_version() const;
  void _internal_set_client_version(uint32_t value);
  public:

  // optional uint32 league = 8;
  bool has_league() const;
  private:
  bool _internal_has_league() const;
  public:
  void clear_league();
  uint32_t league() const;
  void set_league(uint32_t value);
  private:
  uint32_t _internal_league() const;
  void _internal_set_league(uint32_t value);
  public:

  // optional double eop = 10;
  bool has_eop() const;
  private:
  bool _internal_has_eop() const;
  public:
  void clear_eop();
  double eop() const;
  void set_eop(double value);
  private:
  double _internal_eop() const;
  void _internal_set_eop(double value);
  public:

  // optional .ei.Platform platform = 6;
  bool has_platform() const;
  private:
  bool _internal_has_platform() const;
  public:
  void clear_platform();
  ::ei::Platform platform() const;
  void set_platform(::ei::Platform value);
  private:
  ::ei::Platform _internal_platform() const;
  void _internal_set_platform(::ei::Platform value);
  public:

  // @@protoc_insertion_point(class_scope:ei.AutoJoinCoopRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
  ::ei::BasicRequestInfo* rinfo_;
  double soul_power_;
  double seconds_remaining_;
  uint32_t client_version_;
  uint32_t league_;
  double eop_;
  int platform_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class UpdateCoopPermissionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.UpdateCoopPermissionsRequest) */ {
 public:
  inline UpdateCoopPermissionsRequest() : UpdateCoopPermissionsRequest(nullptr) {}
  ~UpdateCoopPermissionsRequest() override;
  explicit constexpr UpdateCoopPermissionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateCoopPermissionsRequest(const UpdateCoopPermissionsRequest& from);
  UpdateCoopPermissionsRequest(UpdateCoopPermissionsRequest&& from) noexcept
    : UpdateCoopPermissionsRequest() {
    *this = ::std::move(from);
  }

  inline UpdateCoopPermissionsRequest& operator=(const UpdateCoopPermissionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateCoopPermissionsRequest& operator=(UpdateCoopPermissionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateCoopPermissionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateCoopPermissionsRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateCoopPermissionsRequest*>(
               &_UpdateCoopPermissionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(UpdateCoopPermissionsRequest& a, UpdateCoopPermissionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateCoopPermissionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateCoopPermissionsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateCoopPermissionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateCoopPermissionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateCoopPermissionsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateCoopPermissionsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateCoopPermissionsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.UpdateCoopPermissionsRequest";
  }
  protected:
  explicit UpdateCoopPermissionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdentifierFieldNumber = 1,
    kCoopIdentifierFieldNumber = 2,
    kRequestingUserIdFieldNumber = 3,
    kRinfoFieldNumber = 6,
    kPublicFieldNumber = 4,
    kClientVersionFieldNumber = 5,
  };
  // optional string contract_identifier = 1;
  bool has_contract_identifier() const;
  private:
  bool _internal_has_contract_identifier() const;
  public:
  void clear_contract_identifier();
  const std::string& contract_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_identifier();
  PROTOBUF_NODISCARD std::string* release_contract_identifier();
  void set_allocated_contract_identifier(std::string* contract_identifier);
  private:
  const std::string& _internal_contract_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_identifier(const std::string& value);
  std::string* _internal_mutable_contract_identifier();
  public:

  // optional string coop_identifier = 2;
  bool has_coop_identifier() const;
  private:
  bool _internal_has_coop_identifier() const;
  public:
  void clear_coop_identifier();
  const std::string& coop_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_coop_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_coop_identifier();
  PROTOBUF_NODISCARD std::string* release_coop_identifier();
  void set_allocated_coop_identifier(std::string* coop_identifier);
  private:
  const std::string& _internal_coop_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_coop_identifier(const std::string& value);
  std::string* _internal_mutable_coop_identifier();
  public:

  // optional string requesting_user_id = 3;
  bool has_requesting_user_id() const;
  private:
  bool _internal_has_requesting_user_id() const;
  public:
  void clear_requesting_user_id();
  const std::string& requesting_user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_requesting_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_requesting_user_id();
  PROTOBUF_NODISCARD std::string* release_requesting_user_id();
  void set_allocated_requesting_user_id(std::string* requesting_user_id);
  private:
  const std::string& _internal_requesting_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requesting_user_id(const std::string& value);
  std::string* _internal_mutable_requesting_user_id();
  public:

  // optional .ei.BasicRequestInfo rinfo = 6;
  bool has_rinfo() const;
  private:
  bool _internal_has_rinfo() const;
  public:
  void clear_rinfo();
  const ::ei::BasicRequestInfo& rinfo() const;
  PROTOBUF_NODISCARD ::ei::BasicRequestInfo* release_rinfo();
  ::ei::BasicRequestInfo* mutable_rinfo();
  void set_allocated_rinfo(::ei::BasicRequestInfo* rinfo);
  private:
  const ::ei::BasicRequestInfo& _internal_rinfo() const;
  ::ei::BasicRequestInfo* _internal_mutable_rinfo();
  public:
  void unsafe_arena_set_allocated_rinfo(
      ::ei::BasicRequestInfo* rinfo);
  ::ei::BasicRequestInfo* unsafe_arena_release_rinfo();

  // optional bool public = 4;
  bool has_public_() const;
  private:
  bool _internal_has_public_() const;
  public:
  void clear_public_();
  bool public_() const;
  void set_public_(bool value);
  private:
  bool _internal_public_() const;
  void _internal_set_public_(bool value);
  public:

  // optional uint32 client_version = 5;
  bool has_client_version() const;
  private:
  bool _internal_has_client_version() const;
  public:
  void clear_client_version();
  uint32_t client_version() const;
  void set_client_version(uint32_t value);
  private:
  uint32_t _internal_client_version() const;
  void _internal_set_client_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.UpdateCoopPermissionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr coop_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr requesting_user_id_;
  ::ei::BasicRequestInfo* rinfo_;
  bool public__;
  uint32_t client_version_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class UpdateCoopPermissionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.UpdateCoopPermissionsResponse) */ {
 public:
  inline UpdateCoopPermissionsResponse() : UpdateCoopPermissionsResponse(nullptr) {}
  ~UpdateCoopPermissionsResponse() override;
  explicit constexpr UpdateCoopPermissionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateCoopPermissionsResponse(const UpdateCoopPermissionsResponse& from);
  UpdateCoopPermissionsResponse(UpdateCoopPermissionsResponse&& from) noexcept
    : UpdateCoopPermissionsResponse() {
    *this = ::std::move(from);
  }

  inline UpdateCoopPermissionsResponse& operator=(const UpdateCoopPermissionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateCoopPermissionsResponse& operator=(UpdateCoopPermissionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateCoopPermissionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateCoopPermissionsResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateCoopPermissionsResponse*>(
               &_UpdateCoopPermissionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(UpdateCoopPermissionsResponse& a, UpdateCoopPermissionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateCoopPermissionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateCoopPermissionsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateCoopPermissionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateCoopPermissionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateCoopPermissionsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateCoopPermissionsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateCoopPermissionsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.UpdateCoopPermissionsResponse";
  }
  protected:
  explicit UpdateCoopPermissionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // optional string message = 2;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // optional bool success = 1;
  bool has_success() const;
  private:
  bool _internal_has_success() const;
  public:
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ei.UpdateCoopPermissionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  bool success_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class LeaveCoopRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.LeaveCoopRequest) */ {
 public:
  inline LeaveCoopRequest() : LeaveCoopRequest(nullptr) {}
  ~LeaveCoopRequest() override;
  explicit constexpr LeaveCoopRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaveCoopRequest(const LeaveCoopRequest& from);
  LeaveCoopRequest(LeaveCoopRequest&& from) noexcept
    : LeaveCoopRequest() {
    *this = ::std::move(from);
  }

  inline LeaveCoopRequest& operator=(const LeaveCoopRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaveCoopRequest& operator=(LeaveCoopRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaveCoopRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaveCoopRequest* internal_default_instance() {
    return reinterpret_cast<const LeaveCoopRequest*>(
               &_LeaveCoopRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(LeaveCoopRequest& a, LeaveCoopRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaveCoopRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaveCoopRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaveCoopRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaveCoopRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeaveCoopRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LeaveCoopRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaveCoopRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.LeaveCoopRequest";
  }
  protected:
  explicit LeaveCoopRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdentifierFieldNumber = 1,
    kCoopIdentifierFieldNumber = 2,
    kPlayerIdentifierFieldNumber = 3,
    kRinfoFieldNumber = 8,
    kClientVersionFieldNumber = 7,
  };
  // optional string contract_identifier = 1;
  bool has_contract_identifier() const;
  private:
  bool _internal_has_contract_identifier() const;
  public:
  void clear_contract_identifier();
  const std::string& contract_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_identifier();
  PROTOBUF_NODISCARD std::string* release_contract_identifier();
  void set_allocated_contract_identifier(std::string* contract_identifier);
  private:
  const std::string& _internal_contract_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_identifier(const std::string& value);
  std::string* _internal_mutable_contract_identifier();
  public:

  // optional string coop_identifier = 2;
  bool has_coop_identifier() const;
  private:
  bool _internal_has_coop_identifier() const;
  public:
  void clear_coop_identifier();
  const std::string& coop_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_coop_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_coop_identifier();
  PROTOBUF_NODISCARD std::string* release_coop_identifier();
  void set_allocated_coop_identifier(std::string* coop_identifier);
  private:
  const std::string& _internal_coop_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_coop_identifier(const std::string& value);
  std::string* _internal_mutable_coop_identifier();
  public:

  // optional string player_identifier = 3;
  bool has_player_identifier() const;
  private:
  bool _internal_has_player_identifier() const;
  public:
  void clear_player_identifier();
  const std::string& player_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_player_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_player_identifier();
  PROTOBUF_NODISCARD std::string* release_player_identifier();
  void set_allocated_player_identifier(std::string* player_identifier);
  private:
  const std::string& _internal_player_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_identifier(const std::string& value);
  std::string* _internal_mutable_player_identifier();
  public:

  // optional .ei.BasicRequestInfo rinfo = 8;
  bool has_rinfo() const;
  private:
  bool _internal_has_rinfo() const;
  public:
  void clear_rinfo();
  const ::ei::BasicRequestInfo& rinfo() const;
  PROTOBUF_NODISCARD ::ei::BasicRequestInfo* release_rinfo();
  ::ei::BasicRequestInfo* mutable_rinfo();
  void set_allocated_rinfo(::ei::BasicRequestInfo* rinfo);
  private:
  const ::ei::BasicRequestInfo& _internal_rinfo() const;
  ::ei::BasicRequestInfo* _internal_mutable_rinfo();
  public:
  void unsafe_arena_set_allocated_rinfo(
      ::ei::BasicRequestInfo* rinfo);
  ::ei::BasicRequestInfo* unsafe_arena_release_rinfo();

  // optional uint32 client_version = 7;
  bool has_client_version() const;
  private:
  bool _internal_has_client_version() const;
  public:
  void clear_client_version();
  uint32_t client_version() const;
  void set_client_version(uint32_t value);
  private:
  uint32_t _internal_client_version() const;
  void _internal_set_client_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.LeaveCoopRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr coop_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr player_identifier_;
  ::ei::BasicRequestInfo* rinfo_;
  uint32_t client_version_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class GiftPlayerCoopRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.GiftPlayerCoopRequest) */ {
 public:
  inline GiftPlayerCoopRequest() : GiftPlayerCoopRequest(nullptr) {}
  ~GiftPlayerCoopRequest() override;
  explicit constexpr GiftPlayerCoopRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GiftPlayerCoopRequest(const GiftPlayerCoopRequest& from);
  GiftPlayerCoopRequest(GiftPlayerCoopRequest&& from) noexcept
    : GiftPlayerCoopRequest() {
    *this = ::std::move(from);
  }

  inline GiftPlayerCoopRequest& operator=(const GiftPlayerCoopRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GiftPlayerCoopRequest& operator=(GiftPlayerCoopRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GiftPlayerCoopRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GiftPlayerCoopRequest* internal_default_instance() {
    return reinterpret_cast<const GiftPlayerCoopRequest*>(
               &_GiftPlayerCoopRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(GiftPlayerCoopRequest& a, GiftPlayerCoopRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GiftPlayerCoopRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GiftPlayerCoopRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GiftPlayerCoopRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GiftPlayerCoopRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GiftPlayerCoopRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GiftPlayerCoopRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GiftPlayerCoopRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.GiftPlayerCoopRequest";
  }
  protected:
  explicit GiftPlayerCoopRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdentifierFieldNumber = 1,
    kCoopIdentifierFieldNumber = 2,
    kPlayerIdentifierFieldNumber = 3,
    kRequestingUserIdFieldNumber = 4,
    kRequestingUserNameFieldNumber = 6,
    kRinfoFieldNumber = 8,
    kAmountFieldNumber = 5,
    kClientVersionFieldNumber = 7,
  };
  // optional string contract_identifier = 1;
  bool has_contract_identifier() const;
  private:
  bool _internal_has_contract_identifier() const;
  public:
  void clear_contract_identifier();
  const std::string& contract_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_identifier();
  PROTOBUF_NODISCARD std::string* release_contract_identifier();
  void set_allocated_contract_identifier(std::string* contract_identifier);
  private:
  const std::string& _internal_contract_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_identifier(const std::string& value);
  std::string* _internal_mutable_contract_identifier();
  public:

  // optional string coop_identifier = 2;
  bool has_coop_identifier() const;
  private:
  bool _internal_has_coop_identifier() const;
  public:
  void clear_coop_identifier();
  const std::string& coop_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_coop_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_coop_identifier();
  PROTOBUF_NODISCARD std::string* release_coop_identifier();
  void set_allocated_coop_identifier(std::string* coop_identifier);
  private:
  const std::string& _internal_coop_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_coop_identifier(const std::string& value);
  std::string* _internal_mutable_coop_identifier();
  public:

  // optional string player_identifier = 3;
  bool has_player_identifier() const;
  private:
  bool _internal_has_player_identifier() const;
  public:
  void clear_player_identifier();
  const std::string& player_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_player_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_player_identifier();
  PROTOBUF_NODISCARD std::string* release_player_identifier();
  void set_allocated_player_identifier(std::string* player_identifier);
  private:
  const std::string& _internal_player_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_identifier(const std::string& value);
  std::string* _internal_mutable_player_identifier();
  public:

  // optional string requesting_user_id = 4;
  bool has_requesting_user_id() const;
  private:
  bool _internal_has_requesting_user_id() const;
  public:
  void clear_requesting_user_id();
  const std::string& requesting_user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_requesting_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_requesting_user_id();
  PROTOBUF_NODISCARD std::string* release_requesting_user_id();
  void set_allocated_requesting_user_id(std::string* requesting_user_id);
  private:
  const std::string& _internal_requesting_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requesting_user_id(const std::string& value);
  std::string* _internal_mutable_requesting_user_id();
  public:

  // optional string requesting_user_name = 6;
  bool has_requesting_user_name() const;
  private:
  bool _internal_has_requesting_user_name() const;
  public:
  void clear_requesting_user_name();
  const std::string& requesting_user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_requesting_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_requesting_user_name();
  PROTOBUF_NODISCARD std::string* release_requesting_user_name();
  void set_allocated_requesting_user_name(std::string* requesting_user_name);
  private:
  const std::string& _internal_requesting_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requesting_user_name(const std::string& value);
  std::string* _internal_mutable_requesting_user_name();
  public:

  // optional .ei.BasicRequestInfo rinfo = 8;
  bool has_rinfo() const;
  private:
  bool _internal_has_rinfo() const;
  public:
  void clear_rinfo();
  const ::ei::BasicRequestInfo& rinfo() const;
  PROTOBUF_NODISCARD ::ei::BasicRequestInfo* release_rinfo();
  ::ei::BasicRequestInfo* mutable_rinfo();
  void set_allocated_rinfo(::ei::BasicRequestInfo* rinfo);
  private:
  const ::ei::BasicRequestInfo& _internal_rinfo() const;
  ::ei::BasicRequestInfo* _internal_mutable_rinfo();
  public:
  void unsafe_arena_set_allocated_rinfo(
      ::ei::BasicRequestInfo* rinfo);
  ::ei::BasicRequestInfo* unsafe_arena_release_rinfo();

  // optional uint32 amount = 5;
  bool has_amount() const;
  private:
  bool _internal_has_amount() const;
  public:
  void clear_amount();
  uint32_t amount() const;
  void set_amount(uint32_t value);
  private:
  uint32_t _internal_amount() const;
  void _internal_set_amount(uint32_t value);
  public:

  // optional uint32 client_version = 7;
  bool has_client_version() const;
  private:
  bool _internal_has_client_version() const;
  public:
  void clear_client_version();
  uint32_t client_version() const;
  void set_client_version(uint32_t value);
  private:
  uint32_t _internal_client_version() const;
  void _internal_set_client_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.GiftPlayerCoopRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr coop_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr player_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr requesting_user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr requesting_user_name_;
  ::ei::BasicRequestInfo* rinfo_;
  uint32_t amount_;
  uint32_t client_version_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class SendChickenRunCoopRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.SendChickenRunCoopRequest) */ {
 public:
  inline SendChickenRunCoopRequest() : SendChickenRunCoopRequest(nullptr) {}
  ~SendChickenRunCoopRequest() override;
  explicit constexpr SendChickenRunCoopRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendChickenRunCoopRequest(const SendChickenRunCoopRequest& from);
  SendChickenRunCoopRequest(SendChickenRunCoopRequest&& from) noexcept
    : SendChickenRunCoopRequest() {
    *this = ::std::move(from);
  }

  inline SendChickenRunCoopRequest& operator=(const SendChickenRunCoopRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendChickenRunCoopRequest& operator=(SendChickenRunCoopRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendChickenRunCoopRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendChickenRunCoopRequest* internal_default_instance() {
    return reinterpret_cast<const SendChickenRunCoopRequest*>(
               &_SendChickenRunCoopRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(SendChickenRunCoopRequest& a, SendChickenRunCoopRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SendChickenRunCoopRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendChickenRunCoopRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendChickenRunCoopRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendChickenRunCoopRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendChickenRunCoopRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SendChickenRunCoopRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendChickenRunCoopRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.SendChickenRunCoopRequest";
  }
  protected:
  explicit SendChickenRunCoopRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdentifierFieldNumber = 1,
    kCoopIdentifierFieldNumber = 2,
    kPlayerIdentifierFieldNumber = 3,
    kRequestingUserIdFieldNumber = 4,
    kRequestingUserNameFieldNumber = 6,
    kRinfoFieldNumber = 8,
    kFarmPopFieldNumber = 5,
    kClientVersionFieldNumber = 7,
  };
  // optional string contract_identifier = 1;
  bool has_contract_identifier() const;
  private:
  bool _internal_has_contract_identifier() const;
  public:
  void clear_contract_identifier();
  const std::string& contract_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_identifier();
  PROTOBUF_NODISCARD std::string* release_contract_identifier();
  void set_allocated_contract_identifier(std::string* contract_identifier);
  private:
  const std::string& _internal_contract_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_identifier(const std::string& value);
  std::string* _internal_mutable_contract_identifier();
  public:

  // optional string coop_identifier = 2;
  bool has_coop_identifier() const;
  private:
  bool _internal_has_coop_identifier() const;
  public:
  void clear_coop_identifier();
  const std::string& coop_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_coop_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_coop_identifier();
  PROTOBUF_NODISCARD std::string* release_coop_identifier();
  void set_allocated_coop_identifier(std::string* coop_identifier);
  private:
  const std::string& _internal_coop_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_coop_identifier(const std::string& value);
  std::string* _internal_mutable_coop_identifier();
  public:

  // optional string player_identifier = 3;
  bool has_player_identifier() const;
  private:
  bool _internal_has_player_identifier() const;
  public:
  void clear_player_identifier();
  const std::string& player_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_player_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_player_identifier();
  PROTOBUF_NODISCARD std::string* release_player_identifier();
  void set_allocated_player_identifier(std::string* player_identifier);
  private:
  const std::string& _internal_player_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_identifier(const std::string& value);
  std::string* _internal_mutable_player_identifier();
  public:

  // optional string requesting_user_id = 4;
  bool has_requesting_user_id() const;
  private:
  bool _internal_has_requesting_user_id() const;
  public:
  void clear_requesting_user_id();
  const std::string& requesting_user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_requesting_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_requesting_user_id();
  PROTOBUF_NODISCARD std::string* release_requesting_user_id();
  void set_allocated_requesting_user_id(std::string* requesting_user_id);
  private:
  const std::string& _internal_requesting_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requesting_user_id(const std::string& value);
  std::string* _internal_mutable_requesting_user_id();
  public:

  // optional string requesting_user_name = 6;
  bool has_requesting_user_name() const;
  private:
  bool _internal_has_requesting_user_name() const;
  public:
  void clear_requesting_user_name();
  const std::string& requesting_user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_requesting_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_requesting_user_name();
  PROTOBUF_NODISCARD std::string* release_requesting_user_name();
  void set_allocated_requesting_user_name(std::string* requesting_user_name);
  private:
  const std::string& _internal_requesting_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requesting_user_name(const std::string& value);
  std::string* _internal_mutable_requesting_user_name();
  public:

  // optional .ei.BasicRequestInfo rinfo = 8;
  bool has_rinfo() const;
  private:
  bool _internal_has_rinfo() const;
  public:
  void clear_rinfo();
  const ::ei::BasicRequestInfo& rinfo() const;
  PROTOBUF_NODISCARD ::ei::BasicRequestInfo* release_rinfo();
  ::ei::BasicRequestInfo* mutable_rinfo();
  void set_allocated_rinfo(::ei::BasicRequestInfo* rinfo);
  private:
  const ::ei::BasicRequestInfo& _internal_rinfo() const;
  ::ei::BasicRequestInfo* _internal_mutable_rinfo();
  public:
  void unsafe_arena_set_allocated_rinfo(
      ::ei::BasicRequestInfo* rinfo);
  ::ei::BasicRequestInfo* unsafe_arena_release_rinfo();

  // optional uint64 farm_pop = 5;
  bool has_farm_pop() const;
  private:
  bool _internal_has_farm_pop() const;
  public:
  void clear_farm_pop();
  uint64_t farm_pop() const;
  void set_farm_pop(uint64_t value);
  private:
  uint64_t _internal_farm_pop() const;
  void _internal_set_farm_pop(uint64_t value);
  public:

  // optional uint32 client_version = 7;
  bool has_client_version() const;
  private:
  bool _internal_has_client_version() const;
  public:
  void clear_client_version();
  uint32_t client_version() const;
  void set_client_version(uint32_t value);
  private:
  uint32_t _internal_client_version() const;
  void _internal_set_client_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.SendChickenRunCoopRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr coop_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr player_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr requesting_user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr requesting_user_name_;
  ::ei::BasicRequestInfo* rinfo_;
  uint64_t farm_pop_;
  uint32_t client_version_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class KickPlayerCoopRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.KickPlayerCoopRequest) */ {
 public:
  inline KickPlayerCoopRequest() : KickPlayerCoopRequest(nullptr) {}
  ~KickPlayerCoopRequest() override;
  explicit constexpr KickPlayerCoopRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KickPlayerCoopRequest(const KickPlayerCoopRequest& from);
  KickPlayerCoopRequest(KickPlayerCoopRequest&& from) noexcept
    : KickPlayerCoopRequest() {
    *this = ::std::move(from);
  }

  inline KickPlayerCoopRequest& operator=(const KickPlayerCoopRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline KickPlayerCoopRequest& operator=(KickPlayerCoopRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KickPlayerCoopRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const KickPlayerCoopRequest* internal_default_instance() {
    return reinterpret_cast<const KickPlayerCoopRequest*>(
               &_KickPlayerCoopRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(KickPlayerCoopRequest& a, KickPlayerCoopRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(KickPlayerCoopRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KickPlayerCoopRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KickPlayerCoopRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KickPlayerCoopRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KickPlayerCoopRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const KickPlayerCoopRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KickPlayerCoopRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.KickPlayerCoopRequest";
  }
  protected:
  explicit KickPlayerCoopRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef KickPlayerCoopRequest_Reason Reason;
  static constexpr Reason INVALID =
    KickPlayerCoopRequest_Reason_INVALID;
  static constexpr Reason CHEATER =
    KickPlayerCoopRequest_Reason_CHEATER;
  static constexpr Reason IDLE =
    KickPlayerCoopRequest_Reason_IDLE;
  static constexpr Reason LEECH =
    KickPlayerCoopRequest_Reason_LEECH;
  static constexpr Reason PRIVATE =
    KickPlayerCoopRequest_Reason_PRIVATE;
  static inline bool Reason_IsValid(int value) {
    return KickPlayerCoopRequest_Reason_IsValid(value);
  }
  static constexpr Reason Reason_MIN =
    KickPlayerCoopRequest_Reason_Reason_MIN;
  static constexpr Reason Reason_MAX =
    KickPlayerCoopRequest_Reason_Reason_MAX;
  static constexpr int Reason_ARRAYSIZE =
    KickPlayerCoopRequest_Reason_Reason_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Reason_descriptor() {
    return KickPlayerCoopRequest_Reason_descriptor();
  }
  template<typename T>
  static inline const std::string& Reason_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Reason>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Reason_Name.");
    return KickPlayerCoopRequest_Reason_Name(enum_t_value);
  }
  static inline bool Reason_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Reason* value) {
    return KickPlayerCoopRequest_Reason_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdentifierFieldNumber = 1,
    kCoopIdentifierFieldNumber = 2,
    kPlayerIdentifierFieldNumber = 3,
    kRequestingUserIdFieldNumber = 4,
    kRinfoFieldNumber = 8,
    kClientVersionFieldNumber = 7,
    kReasonFieldNumber = 9,
  };
  // optional string contract_identifier = 1;
  bool has_contract_identifier() const;
  private:
  bool _internal_has_contract_identifier() const;
  public:
  void clear_contract_identifier();
  const std::string& contract_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_identifier();
  PROTOBUF_NODISCARD std::string* release_contract_identifier();
  void set_allocated_contract_identifier(std::string* contract_identifier);
  private:
  const std::string& _internal_contract_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_identifier(const std::string& value);
  std::string* _internal_mutable_contract_identifier();
  public:

  // optional string coop_identifier = 2;
  bool has_coop_identifier() const;
  private:
  bool _internal_has_coop_identifier() const;
  public:
  void clear_coop_identifier();
  const std::string& coop_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_coop_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_coop_identifier();
  PROTOBUF_NODISCARD std::string* release_coop_identifier();
  void set_allocated_coop_identifier(std::string* coop_identifier);
  private:
  const std::string& _internal_coop_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_coop_identifier(const std::string& value);
  std::string* _internal_mutable_coop_identifier();
  public:

  // optional string player_identifier = 3;
  bool has_player_identifier() const;
  private:
  bool _internal_has_player_identifier() const;
  public:
  void clear_player_identifier();
  const std::string& player_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_player_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_player_identifier();
  PROTOBUF_NODISCARD std::string* release_player_identifier();
  void set_allocated_player_identifier(std::string* player_identifier);
  private:
  const std::string& _internal_player_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_identifier(const std::string& value);
  std::string* _internal_mutable_player_identifier();
  public:

  // optional string requesting_user_id = 4;
  bool has_requesting_user_id() const;
  private:
  bool _internal_has_requesting_user_id() const;
  public:
  void clear_requesting_user_id();
  const std::string& requesting_user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_requesting_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_requesting_user_id();
  PROTOBUF_NODISCARD std::string* release_requesting_user_id();
  void set_allocated_requesting_user_id(std::string* requesting_user_id);
  private:
  const std::string& _internal_requesting_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requesting_user_id(const std::string& value);
  std::string* _internal_mutable_requesting_user_id();
  public:

  // optional .ei.BasicRequestInfo rinfo = 8;
  bool has_rinfo() const;
  private:
  bool _internal_has_rinfo() const;
  public:
  void clear_rinfo();
  const ::ei::BasicRequestInfo& rinfo() const;
  PROTOBUF_NODISCARD ::ei::BasicRequestInfo* release_rinfo();
  ::ei::BasicRequestInfo* mutable_rinfo();
  void set_allocated_rinfo(::ei::BasicRequestInfo* rinfo);
  private:
  const ::ei::BasicRequestInfo& _internal_rinfo() const;
  ::ei::BasicRequestInfo* _internal_mutable_rinfo();
  public:
  void unsafe_arena_set_allocated_rinfo(
      ::ei::BasicRequestInfo* rinfo);
  ::ei::BasicRequestInfo* unsafe_arena_release_rinfo();

  // optional uint32 client_version = 7;
  bool has_client_version() const;
  private:
  bool _internal_has_client_version() const;
  public:
  void clear_client_version();
  uint32_t client_version() const;
  void set_client_version(uint32_t value);
  private:
  uint32_t _internal_client_version() const;
  void _internal_set_client_version(uint32_t value);
  public:

  // optional .ei.KickPlayerCoopRequest.Reason reason = 9;
  bool has_reason() const;
  private:
  bool _internal_has_reason() const;
  public:
  void clear_reason();
  ::ei::KickPlayerCoopRequest_Reason reason() const;
  void set_reason(::ei::KickPlayerCoopRequest_Reason value);
  private:
  ::ei::KickPlayerCoopRequest_Reason _internal_reason() const;
  void _internal_set_reason(::ei::KickPlayerCoopRequest_Reason value);
  public:

  // @@protoc_insertion_point(class_scope:ei.KickPlayerCoopRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr coop_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr player_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr requesting_user_id_;
  ::ei::BasicRequestInfo* rinfo_;
  uint32_t client_version_;
  int reason_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ContractCoopStatusUpdateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ContractCoopStatusUpdateRequest) */ {
 public:
  inline ContractCoopStatusUpdateRequest() : ContractCoopStatusUpdateRequest(nullptr) {}
  ~ContractCoopStatusUpdateRequest() override;
  explicit constexpr ContractCoopStatusUpdateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContractCoopStatusUpdateRequest(const ContractCoopStatusUpdateRequest& from);
  ContractCoopStatusUpdateRequest(ContractCoopStatusUpdateRequest&& from) noexcept
    : ContractCoopStatusUpdateRequest() {
    *this = ::std::move(from);
  }

  inline ContractCoopStatusUpdateRequest& operator=(const ContractCoopStatusUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractCoopStatusUpdateRequest& operator=(ContractCoopStatusUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractCoopStatusUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractCoopStatusUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const ContractCoopStatusUpdateRequest*>(
               &_ContractCoopStatusUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(ContractCoopStatusUpdateRequest& a, ContractCoopStatusUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractCoopStatusUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractCoopStatusUpdateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractCoopStatusUpdateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContractCoopStatusUpdateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContractCoopStatusUpdateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ContractCoopStatusUpdateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractCoopStatusUpdateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ContractCoopStatusUpdateRequest";
  }
  protected:
  explicit ContractCoopStatusUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kContractIdentifierFieldNumber = 2,
    kCoopIdentifierFieldNumber = 3,
    kPushUserIdFieldNumber = 8,
    kRinfoFieldNumber = 12,
    kProductionParamsFieldNumber = 14,
    kFarmInfoFieldNumber = 16,
    kAmountFieldNumber = 4,
    kRateFieldNumber = 5,
    kSoulPowerFieldNumber = 7,
    kTimeCheatsDetectedFieldNumber = 6,
    kBoostTokensFieldNumber = 9,
    kBoostTokensSpentFieldNumber = 13,
    kEopFieldNumber = 15,
    kEggLayingRateBuffFieldNumber = 10,
    kEarningsBuffFieldNumber = 11,
  };
  // optional string user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // optional string contract_identifier = 2;
  bool has_contract_identifier() const;
  private:
  bool _internal_has_contract_identifier() const;
  public:
  void clear_contract_identifier();
  const std::string& contract_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_identifier();
  PROTOBUF_NODISCARD std::string* release_contract_identifier();
  void set_allocated_contract_identifier(std::string* contract_identifier);
  private:
  const std::string& _internal_contract_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_identifier(const std::string& value);
  std::string* _internal_mutable_contract_identifier();
  public:

  // optional string coop_identifier = 3;
  bool has_coop_identifier() const;
  private:
  bool _internal_has_coop_identifier() const;
  public:
  void clear_coop_identifier();
  const std::string& coop_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_coop_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_coop_identifier();
  PROTOBUF_NODISCARD std::string* release_coop_identifier();
  void set_allocated_coop_identifier(std::string* coop_identifier);
  private:
  const std::string& _internal_coop_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_coop_identifier(const std::string& value);
  std::string* _internal_mutable_coop_identifier();
  public:

  // optional string push_user_id = 8;
  bool has_push_user_id() const;
  private:
  bool _internal_has_push_user_id() const;
  public:
  void clear_push_user_id();
  const std::string& push_user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_push_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_push_user_id();
  PROTOBUF_NODISCARD std::string* release_push_user_id();
  void set_allocated_push_user_id(std::string* push_user_id);
  private:
  const std::string& _internal_push_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_push_user_id(const std::string& value);
  std::string* _internal_mutable_push_user_id();
  public:

  // optional .ei.BasicRequestInfo rinfo = 12;
  bool has_rinfo() const;
  private:
  bool _internal_has_rinfo() const;
  public:
  void clear_rinfo();
  const ::ei::BasicRequestInfo& rinfo() const;
  PROTOBUF_NODISCARD ::ei::BasicRequestInfo* release_rinfo();
  ::ei::BasicRequestInfo* mutable_rinfo();
  void set_allocated_rinfo(::ei::BasicRequestInfo* rinfo);
  private:
  const ::ei::BasicRequestInfo& _internal_rinfo() const;
  ::ei::BasicRequestInfo* _internal_mutable_rinfo();
  public:
  void unsafe_arena_set_allocated_rinfo(
      ::ei::BasicRequestInfo* rinfo);
  ::ei::BasicRequestInfo* unsafe_arena_release_rinfo();

  // optional .ei.FarmProductionParams production_params = 14;
  bool has_production_params() const;
  private:
  bool _internal_has_production_params() const;
  public:
  void clear_production_params();
  const ::ei::FarmProductionParams& production_params() const;
  PROTOBUF_NODISCARD ::ei::FarmProductionParams* release_production_params();
  ::ei::FarmProductionParams* mutable_production_params();
  void set_allocated_production_params(::ei::FarmProductionParams* production_params);
  private:
  const ::ei::FarmProductionParams& _internal_production_params() const;
  ::ei::FarmProductionParams* _internal_mutable_production_params();
  public:
  void unsafe_arena_set_allocated_production_params(
      ::ei::FarmProductionParams* production_params);
  ::ei::FarmProductionParams* unsafe_arena_release_production_params();

  // optional .ei.PlayerFarmInfo farm_info = 16;
  bool has_farm_info() const;
  private:
  bool _internal_has_farm_info() const;
  public:
  void clear_farm_info();
  const ::ei::PlayerFarmInfo& farm_info() const;
  PROTOBUF_NODISCARD ::ei::PlayerFarmInfo* release_farm_info();
  ::ei::PlayerFarmInfo* mutable_farm_info();
  void set_allocated_farm_info(::ei::PlayerFarmInfo* farm_info);
  private:
  const ::ei::PlayerFarmInfo& _internal_farm_info() const;
  ::ei::PlayerFarmInfo* _internal_mutable_farm_info();
  public:
  void unsafe_arena_set_allocated_farm_info(
      ::ei::PlayerFarmInfo* farm_info);
  ::ei::PlayerFarmInfo* unsafe_arena_release_farm_info();

  // optional double amount = 4;
  bool has_amount() const;
  private:
  bool _internal_has_amount() const;
  public:
  void clear_amount();
  double amount() const;
  void set_amount(double value);
  private:
  double _internal_amount() const;
  void _internal_set_amount(double value);
  public:

  // optional double rate = 5;
  bool has_rate() const;
  private:
  bool _internal_has_rate() const;
  public:
  void clear_rate();
  double rate() const;
  void set_rate(double value);
  private:
  double _internal_rate() const;
  void _internal_set_rate(double value);
  public:

  // optional double soul_power = 7;
  bool has_soul_power() const;
  private:
  bool _internal_has_soul_power() const;
  public:
  void clear_soul_power();
  double soul_power() const;
  void set_soul_power(double value);
  private:
  double _internal_soul_power() const;
  void _internal_set_soul_power(double value);
  public:

  // optional uint32 time_cheats_detected = 6;
  bool has_time_cheats_detected() const;
  private:
  bool _internal_has_time_cheats_detected() const;
  public:
  void clear_time_cheats_detected();
  uint32_t time_cheats_detected() const;
  void set_time_cheats_detected(uint32_t value);
  private:
  uint32_t _internal_time_cheats_detected() const;
  void _internal_set_time_cheats_detected(uint32_t value);
  public:

  // optional uint32 boost_tokens = 9;
  bool has_boost_tokens() const;
  private:
  bool _internal_has_boost_tokens() const;
  public:
  void clear_boost_tokens();
  uint32_t boost_tokens() const;
  void set_boost_tokens(uint32_t value);
  private:
  uint32_t _internal_boost_tokens() const;
  void _internal_set_boost_tokens(uint32_t value);
  public:

  // optional uint32 boost_tokens_spent = 13;
  bool has_boost_tokens_spent() const;
  private:
  bool _internal_has_boost_tokens_spent() const;
  public:
  void clear_boost_tokens_spent();
  uint32_t boost_tokens_spent() const;
  void set_boost_tokens_spent(uint32_t value);
  private:
  uint32_t _internal_boost_tokens_spent() const;
  void _internal_set_boost_tokens_spent(uint32_t value);
  public:

  // optional uint32 eop = 15;
  bool has_eop() const;
  private:
  bool _internal_has_eop() const;
  public:
  void clear_eop();
  uint32_t eop() const;
  void set_eop(uint32_t value);
  private:
  uint32_t _internal_eop() const;
  void _internal_set_eop(uint32_t value);
  public:

  // optional double egg_laying_rate_buff = 10 [default = 1];
  bool has_egg_laying_rate_buff() const;
  private:
  bool _internal_has_egg_laying_rate_buff() const;
  public:
  void clear_egg_laying_rate_buff();
  double egg_laying_rate_buff() const;
  void set_egg_laying_rate_buff(double value);
  private:
  double _internal_egg_laying_rate_buff() const;
  void _internal_set_egg_laying_rate_buff(double value);
  public:

  // optional double earnings_buff = 11 [default = 1];
  bool has_earnings_buff() const;
  private:
  bool _internal_has_earnings_buff() const;
  public:
  void clear_earnings_buff();
  double earnings_buff() const;
  void set_earnings_buff(double value);
  private:
  double _internal_earnings_buff() const;
  void _internal_set_earnings_buff(double value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ContractCoopStatusUpdateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr coop_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr push_user_id_;
  ::ei::BasicRequestInfo* rinfo_;
  ::ei::FarmProductionParams* production_params_;
  ::ei::PlayerFarmInfo* farm_info_;
  double amount_;
  double rate_;
  double soul_power_;
  uint32_t time_cheats_detected_;
  uint32_t boost_tokens_;
  uint32_t boost_tokens_spent_;
  uint32_t eop_;
  double egg_laying_rate_buff_;
  double earnings_buff_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ContractCoopStatusUpdateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ContractCoopStatusUpdateResponse) */ {
 public:
  inline ContractCoopStatusUpdateResponse() : ContractCoopStatusUpdateResponse(nullptr) {}
  ~ContractCoopStatusUpdateResponse() override;
  explicit constexpr ContractCoopStatusUpdateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContractCoopStatusUpdateResponse(const ContractCoopStatusUpdateResponse& from);
  ContractCoopStatusUpdateResponse(ContractCoopStatusUpdateResponse&& from) noexcept
    : ContractCoopStatusUpdateResponse() {
    *this = ::std::move(from);
  }

  inline ContractCoopStatusUpdateResponse& operator=(const ContractCoopStatusUpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractCoopStatusUpdateResponse& operator=(ContractCoopStatusUpdateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractCoopStatusUpdateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractCoopStatusUpdateResponse* internal_default_instance() {
    return reinterpret_cast<const ContractCoopStatusUpdateResponse*>(
               &_ContractCoopStatusUpdateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(ContractCoopStatusUpdateResponse& a, ContractCoopStatusUpdateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractCoopStatusUpdateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractCoopStatusUpdateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractCoopStatusUpdateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContractCoopStatusUpdateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContractCoopStatusUpdateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ContractCoopStatusUpdateResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractCoopStatusUpdateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ContractCoopStatusUpdateResponse";
  }
  protected:
  explicit ContractCoopStatusUpdateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFinalizedFieldNumber = 1,
    kExistsFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // optional bool finalized = 1;
  bool has_finalized() const;
  private:
  bool _internal_has_finalized() const;
  public:
  void clear_finalized();
  bool finalized() const;
  void set_finalized(bool value);
  private:
  bool _internal_finalized() const;
  void _internal_set_finalized(bool value);
  public:

  // optional bool exists = 2;
  bool has_exists() const;
  private:
  bool _internal_has_exists() const;
  public:
  void clear_exists();
  bool exists() const;
  void set_exists(bool value);
  private:
  bool _internal_exists() const;
  void _internal_set_exists(bool value);
  public:

  // optional .ei.ContractCoopStatusResponse.MemberStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::ei::ContractCoopStatusResponse_MemberStatus status() const;
  void set_status(::ei::ContractCoopStatusResponse_MemberStatus value);
  private:
  ::ei::ContractCoopStatusResponse_MemberStatus _internal_status() const;
  void _internal_set_status(::ei::ContractCoopStatusResponse_MemberStatus value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ContractCoopStatusUpdateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool finalized_;
  bool exists_;
  int status_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class CoopBuffState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.CoopBuffState) */ {
 public:
  inline CoopBuffState() : CoopBuffState(nullptr) {}
  ~CoopBuffState() override;
  explicit constexpr CoopBuffState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CoopBuffState(const CoopBuffState& from);
  CoopBuffState(CoopBuffState&& from) noexcept
    : CoopBuffState() {
    *this = ::std::move(from);
  }

  inline CoopBuffState& operator=(const CoopBuffState& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoopBuffState& operator=(CoopBuffState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CoopBuffState& default_instance() {
    return *internal_default_instance();
  }
  static inline const CoopBuffState* internal_default_instance() {
    return reinterpret_cast<const CoopBuffState*>(
               &_CoopBuffState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(CoopBuffState& a, CoopBuffState& b) {
    a.Swap(&b);
  }
  inline void Swap(CoopBuffState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CoopBuffState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CoopBuffState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CoopBuffState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CoopBuffState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CoopBuffState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoopBuffState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.CoopBuffState";
  }
  protected:
  explicit CoopBuffState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerTimestampFieldNumber = 3,
    kEggLayingRateFieldNumber = 1,
    kEarningsFieldNumber = 2,
  };
  // optional double server_timestamp = 3;
  bool has_server_timestamp() const;
  private:
  bool _internal_has_server_timestamp() const;
  public:
  void clear_server_timestamp();
  double server_timestamp() const;
  void set_server_timestamp(double value);
  private:
  double _internal_server_timestamp() const;
  void _internal_set_server_timestamp(double value);
  public:

  // optional double egg_laying_rate = 1 [default = 1];
  bool has_egg_laying_rate() const;
  private:
  bool _internal_has_egg_laying_rate() const;
  public:
  void clear_egg_laying_rate();
  double egg_laying_rate() const;
  void set_egg_laying_rate(double value);
  private:
  double _internal_egg_laying_rate() const;
  void _internal_set_egg_laying_rate(double value);
  public:

  // optional double earnings = 2 [default = 1];
  bool has_earnings() const;
  private:
  bool _internal_has_earnings() const;
  public:
  void clear_earnings();
  double earnings() const;
  void set_earnings(double value);
  private:
  double _internal_earnings() const;
  void _internal_set_earnings(double value);
  public:

  // @@protoc_insertion_point(class_scope:ei.CoopBuffState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double server_timestamp_;
  double egg_laying_rate_;
  double earnings_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class CoopBuffHistory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.CoopBuffHistory) */ {
 public:
  inline CoopBuffHistory() : CoopBuffHistory(nullptr) {}
  ~CoopBuffHistory() override;
  explicit constexpr CoopBuffHistory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CoopBuffHistory(const CoopBuffHistory& from);
  CoopBuffHistory(CoopBuffHistory&& from) noexcept
    : CoopBuffHistory() {
    *this = ::std::move(from);
  }

  inline CoopBuffHistory& operator=(const CoopBuffHistory& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoopBuffHistory& operator=(CoopBuffHistory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CoopBuffHistory& default_instance() {
    return *internal_default_instance();
  }
  static inline const CoopBuffHistory* internal_default_instance() {
    return reinterpret_cast<const CoopBuffHistory*>(
               &_CoopBuffHistory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(CoopBuffHistory& a, CoopBuffHistory& b) {
    a.Swap(&b);
  }
  inline void Swap(CoopBuffHistory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CoopBuffHistory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CoopBuffHistory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CoopBuffHistory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CoopBuffHistory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CoopBuffHistory& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoopBuffHistory* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.CoopBuffHistory";
  }
  protected:
  explicit CoopBuffHistory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHistoryFieldNumber = 1,
  };
  // repeated .ei.CoopBuffState history = 1;
  int history_size() const;
  private:
  int _internal_history_size() const;
  public:
  void clear_history();
  ::ei::CoopBuffState* mutable_history(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::CoopBuffState >*
      mutable_history();
  private:
  const ::ei::CoopBuffState& _internal_history(int index) const;
  ::ei::CoopBuffState* _internal_add_history();
  public:
  const ::ei::CoopBuffState& history(int index) const;
  ::ei::CoopBuffState* add_history();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::CoopBuffState >&
      history() const;

  // @@protoc_insertion_point(class_scope:ei.CoopBuffHistory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::CoopBuffState > history_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class CoopChickenRunEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.CoopChickenRunEntry) */ {
 public:
  inline CoopChickenRunEntry() : CoopChickenRunEntry(nullptr) {}
  ~CoopChickenRunEntry() override;
  explicit constexpr CoopChickenRunEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CoopChickenRunEntry(const CoopChickenRunEntry& from);
  CoopChickenRunEntry(CoopChickenRunEntry&& from) noexcept
    : CoopChickenRunEntry() {
    *this = ::std::move(from);
  }

  inline CoopChickenRunEntry& operator=(const CoopChickenRunEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoopChickenRunEntry& operator=(CoopChickenRunEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CoopChickenRunEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const CoopChickenRunEntry* internal_default_instance() {
    return reinterpret_cast<const CoopChickenRunEntry*>(
               &_CoopChickenRunEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(CoopChickenRunEntry& a, CoopChickenRunEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(CoopChickenRunEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CoopChickenRunEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CoopChickenRunEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CoopChickenRunEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CoopChickenRunEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CoopChickenRunEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoopChickenRunEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.CoopChickenRunEntry";
  }
  protected:
  explicit CoopChickenRunEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kServerTimestampFieldNumber = 2,
  };
  // optional string user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // optional double server_timestamp = 2;
  bool has_server_timestamp() const;
  private:
  bool _internal_has_server_timestamp() const;
  public:
  void clear_server_timestamp();
  double server_timestamp() const;
  void set_server_timestamp(double value);
  private:
  double _internal_server_timestamp() const;
  void _internal_set_server_timestamp(double value);
  public:

  // @@protoc_insertion_point(class_scope:ei.CoopChickenRunEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  double server_timestamp_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class CoopLastChickenRunTimes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.CoopLastChickenRunTimes) */ {
 public:
  inline CoopLastChickenRunTimes() : CoopLastChickenRunTimes(nullptr) {}
  ~CoopLastChickenRunTimes() override;
  explicit constexpr CoopLastChickenRunTimes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CoopLastChickenRunTimes(const CoopLastChickenRunTimes& from);
  CoopLastChickenRunTimes(CoopLastChickenRunTimes&& from) noexcept
    : CoopLastChickenRunTimes() {
    *this = ::std::move(from);
  }

  inline CoopLastChickenRunTimes& operator=(const CoopLastChickenRunTimes& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoopLastChickenRunTimes& operator=(CoopLastChickenRunTimes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CoopLastChickenRunTimes& default_instance() {
    return *internal_default_instance();
  }
  static inline const CoopLastChickenRunTimes* internal_default_instance() {
    return reinterpret_cast<const CoopLastChickenRunTimes*>(
               &_CoopLastChickenRunTimes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(CoopLastChickenRunTimes& a, CoopLastChickenRunTimes& b) {
    a.Swap(&b);
  }
  inline void Swap(CoopLastChickenRunTimes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CoopLastChickenRunTimes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CoopLastChickenRunTimes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CoopLastChickenRunTimes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CoopLastChickenRunTimes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CoopLastChickenRunTimes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoopLastChickenRunTimes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.CoopLastChickenRunTimes";
  }
  protected:
  explicit CoopLastChickenRunTimes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 3,
  };
  // repeated .ei.CoopChickenRunEntry entries = 3;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::ei::CoopChickenRunEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::CoopChickenRunEntry >*
      mutable_entries();
  private:
  const ::ei::CoopChickenRunEntry& _internal_entries(int index) const;
  ::ei::CoopChickenRunEntry* _internal_add_entries();
  public:
  const ::ei::CoopChickenRunEntry& entries(int index) const;
  ::ei::CoopChickenRunEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::CoopChickenRunEntry >&
      entries() const;

  // @@protoc_insertion_point(class_scope:ei.CoopLastChickenRunTimes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::CoopChickenRunEntry > entries_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class UserDataInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.UserDataInfoRequest) */ {
 public:
  inline UserDataInfoRequest() : UserDataInfoRequest(nullptr) {}
  ~UserDataInfoRequest() override;
  explicit constexpr UserDataInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserDataInfoRequest(const UserDataInfoRequest& from);
  UserDataInfoRequest(UserDataInfoRequest&& from) noexcept
    : UserDataInfoRequest() {
    *this = ::std::move(from);
  }

  inline UserDataInfoRequest& operator=(const UserDataInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserDataInfoRequest& operator=(UserDataInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserDataInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserDataInfoRequest* internal_default_instance() {
    return reinterpret_cast<const UserDataInfoRequest*>(
               &_UserDataInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(UserDataInfoRequest& a, UserDataInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserDataInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserDataInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserDataInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserDataInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserDataInfoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserDataInfoRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserDataInfoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.UserDataInfoRequest";
  }
  protected:
  explicit UserDataInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kDeviceIdFieldNumber = 2,
    kRinfoFieldNumber = 4,
    kBackupChecksumFieldNumber = 3,
  };
  // optional string user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // optional string device_id = 2;
  bool has_device_id() const;
  private:
  bool _internal_has_device_id() const;
  public:
  void clear_device_id();
  const std::string& device_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_id();
  PROTOBUF_NODISCARD std::string* release_device_id();
  void set_allocated_device_id(std::string* device_id);
  private:
  const std::string& _internal_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_id(const std::string& value);
  std::string* _internal_mutable_device_id();
  public:

  // optional .ei.BasicRequestInfo rinfo = 4;
  bool has_rinfo() const;
  private:
  bool _internal_has_rinfo() const;
  public:
  void clear_rinfo();
  const ::ei::BasicRequestInfo& rinfo() const;
  PROTOBUF_NODISCARD ::ei::BasicRequestInfo* release_rinfo();
  ::ei::BasicRequestInfo* mutable_rinfo();
  void set_allocated_rinfo(::ei::BasicRequestInfo* rinfo);
  private:
  const ::ei::BasicRequestInfo& _internal_rinfo() const;
  ::ei::BasicRequestInfo* _internal_mutable_rinfo();
  public:
  void unsafe_arena_set_allocated_rinfo(
      ::ei::BasicRequestInfo* rinfo);
  ::ei::BasicRequestInfo* unsafe_arena_release_rinfo();

  // optional uint64 backup_checksum = 3;
  bool has_backup_checksum() const;
  private:
  bool _internal_has_backup_checksum() const;
  public:
  void clear_backup_checksum();
  uint64_t backup_checksum() const;
  void set_backup_checksum(uint64_t value);
  private:
  uint64_t _internal_backup_checksum() const;
  void _internal_set_backup_checksum(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.UserDataInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_id_;
  ::ei::BasicRequestInfo* rinfo_;
  uint64_t backup_checksum_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class UserDataInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.UserDataInfoResponse) */ {
 public:
  inline UserDataInfoResponse() : UserDataInfoResponse(nullptr) {}
  ~UserDataInfoResponse() override;
  explicit constexpr UserDataInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserDataInfoResponse(const UserDataInfoResponse& from);
  UserDataInfoResponse(UserDataInfoResponse&& from) noexcept
    : UserDataInfoResponse() {
    *this = ::std::move(from);
  }

  inline UserDataInfoResponse& operator=(const UserDataInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserDataInfoResponse& operator=(UserDataInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserDataInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserDataInfoResponse* internal_default_instance() {
    return reinterpret_cast<const UserDataInfoResponse*>(
               &_UserDataInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(UserDataInfoResponse& a, UserDataInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UserDataInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserDataInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserDataInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserDataInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserDataInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserDataInfoResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserDataInfoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.UserDataInfoResponse";
  }
  protected:
  explicit UserDataInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoopMembershipsFieldNumber = 3,
    kBackupChecksumFieldNumber = 1,
    kBackupTotalCashFieldNumber = 2,
  };
  // repeated string coop_memberships = 3;
  int coop_memberships_size() const;
  private:
  int _internal_coop_memberships_size() const;
  public:
  void clear_coop_memberships();
  const std::string& coop_memberships(int index) const;
  std::string* mutable_coop_memberships(int index);
  void set_coop_memberships(int index, const std::string& value);
  void set_coop_memberships(int index, std::string&& value);
  void set_coop_memberships(int index, const char* value);
  void set_coop_memberships(int index, const char* value, size_t size);
  std::string* add_coop_memberships();
  void add_coop_memberships(const std::string& value);
  void add_coop_memberships(std::string&& value);
  void add_coop_memberships(const char* value);
  void add_coop_memberships(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& coop_memberships() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_coop_memberships();
  private:
  const std::string& _internal_coop_memberships(int index) const;
  std::string* _internal_add_coop_memberships();
  public:

  // optional uint64 backup_checksum = 1;
  bool has_backup_checksum() const;
  private:
  bool _internal_has_backup_checksum() const;
  public:
  void clear_backup_checksum();
  uint64_t backup_checksum() const;
  void set_backup_checksum(uint64_t value);
  private:
  uint64_t _internal_backup_checksum() const;
  void _internal_set_backup_checksum(uint64_t value);
  public:

  // optional double backup_total_cash = 2;
  bool has_backup_total_cash() const;
  private:
  bool _internal_has_backup_total_cash() const;
  public:
  void clear_backup_total_cash();
  double backup_total_cash() const;
  void set_backup_total_cash(double value);
  private:
  double _internal_backup_total_cash() const;
  void _internal_set_backup_total_cash(double value);
  public:

  // @@protoc_insertion_point(class_scope:ei.UserDataInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> coop_memberships_;
  uint64_t backup_checksum_;
  double backup_total_cash_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ClearAllUserDataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ClearAllUserDataRequest) */ {
 public:
  inline ClearAllUserDataRequest() : ClearAllUserDataRequest(nullptr) {}
  ~ClearAllUserDataRequest() override;
  explicit constexpr ClearAllUserDataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClearAllUserDataRequest(const ClearAllUserDataRequest& from);
  ClearAllUserDataRequest(ClearAllUserDataRequest&& from) noexcept
    : ClearAllUserDataRequest() {
    *this = ::std::move(from);
  }

  inline ClearAllUserDataRequest& operator=(const ClearAllUserDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearAllUserDataRequest& operator=(ClearAllUserDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClearAllUserDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearAllUserDataRequest* internal_default_instance() {
    return reinterpret_cast<const ClearAllUserDataRequest*>(
               &_ClearAllUserDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(ClearAllUserDataRequest& a, ClearAllUserDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ClearAllUserDataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearAllUserDataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearAllUserDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClearAllUserDataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClearAllUserDataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ClearAllUserDataRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClearAllUserDataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ClearAllUserDataRequest";
  }
  protected:
  explicit ClearAllUserDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kDeviceIdFieldNumber = 2,
    kRinfoFieldNumber = 4,
    kBackupChecksumFieldNumber = 3,
  };
  // optional string user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // optional string device_id = 2;
  bool has_device_id() const;
  private:
  bool _internal_has_device_id() const;
  public:
  void clear_device_id();
  const std::string& device_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_id();
  PROTOBUF_NODISCARD std::string* release_device_id();
  void set_allocated_device_id(std::string* device_id);
  private:
  const std::string& _internal_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_id(const std::string& value);
  std::string* _internal_mutable_device_id();
  public:

  // optional .ei.BasicRequestInfo rinfo = 4;
  bool has_rinfo() const;
  private:
  bool _internal_has_rinfo() const;
  public:
  void clear_rinfo();
  const ::ei::BasicRequestInfo& rinfo() const;
  PROTOBUF_NODISCARD ::ei::BasicRequestInfo* release_rinfo();
  ::ei::BasicRequestInfo* mutable_rinfo();
  void set_allocated_rinfo(::ei::BasicRequestInfo* rinfo);
  private:
  const ::ei::BasicRequestInfo& _internal_rinfo() const;
  ::ei::BasicRequestInfo* _internal_mutable_rinfo();
  public:
  void unsafe_arena_set_allocated_rinfo(
      ::ei::BasicRequestInfo* rinfo);
  ::ei::BasicRequestInfo* unsafe_arena_release_rinfo();

  // optional uint64 backup_checksum = 3;
  bool has_backup_checksum() const;
  private:
  bool _internal_has_backup_checksum() const;
  public:
  void clear_backup_checksum();
  uint64_t backup_checksum() const;
  void set_backup_checksum(uint64_t value);
  private:
  uint64_t _internal_backup_checksum() const;
  void _internal_set_backup_checksum(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ClearAllUserDataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_id_;
  ::ei::BasicRequestInfo* rinfo_;
  uint64_t backup_checksum_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ServerGift final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ServerGift) */ {
 public:
  inline ServerGift() : ServerGift(nullptr) {}
  ~ServerGift() override;
  explicit constexpr ServerGift(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerGift(const ServerGift& from);
  ServerGift(ServerGift&& from) noexcept
    : ServerGift() {
    *this = ::std::move(from);
  }

  inline ServerGift& operator=(const ServerGift& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerGift& operator=(ServerGift&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerGift& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerGift* internal_default_instance() {
    return reinterpret_cast<const ServerGift*>(
               &_ServerGift_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(ServerGift& a, ServerGift& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerGift* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerGift* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerGift* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerGift>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerGift& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServerGift& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerGift* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ServerGift";
  }
  protected:
  explicit ServerGift(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kRewardSubTypeFieldNumber = 4,
    kRewardAmountFieldNumber = 5,
    kRewardTypeFieldNumber = 3,
  };
  // optional string user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // optional string reward_sub_type = 4;
  bool has_reward_sub_type() const;
  private:
  bool _internal_has_reward_sub_type() const;
  public:
  void clear_reward_sub_type();
  const std::string& reward_sub_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reward_sub_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reward_sub_type();
  PROTOBUF_NODISCARD std::string* release_reward_sub_type();
  void set_allocated_reward_sub_type(std::string* reward_sub_type);
  private:
  const std::string& _internal_reward_sub_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reward_sub_type(const std::string& value);
  std::string* _internal_mutable_reward_sub_type();
  public:

  // optional double reward_amount = 5;
  bool has_reward_amount() const;
  private:
  bool _internal_has_reward_amount() const;
  public:
  void clear_reward_amount();
  double reward_amount() const;
  void set_reward_amount(double value);
  private:
  double _internal_reward_amount() const;
  void _internal_set_reward_amount(double value);
  public:

  // optional .ei.RewardType reward_type = 3;
  bool has_reward_type() const;
  private:
  bool _internal_has_reward_type() const;
  public:
  void clear_reward_type();
  ::ei::RewardType reward_type() const;
  void set_reward_type(::ei::RewardType value);
  private:
  ::ei::RewardType _internal_reward_type() const;
  void _internal_set_reward_type(::ei::RewardType value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ServerGift)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reward_sub_type_;
  double reward_amount_;
  int reward_type_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class LiveConfig_BoostsConfig_ItemConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.LiveConfig.BoostsConfig.ItemConfig) */ {
 public:
  inline LiveConfig_BoostsConfig_ItemConfig() : LiveConfig_BoostsConfig_ItemConfig(nullptr) {}
  ~LiveConfig_BoostsConfig_ItemConfig() override;
  explicit constexpr LiveConfig_BoostsConfig_ItemConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LiveConfig_BoostsConfig_ItemConfig(const LiveConfig_BoostsConfig_ItemConfig& from);
  LiveConfig_BoostsConfig_ItemConfig(LiveConfig_BoostsConfig_ItemConfig&& from) noexcept
    : LiveConfig_BoostsConfig_ItemConfig() {
    *this = ::std::move(from);
  }

  inline LiveConfig_BoostsConfig_ItemConfig& operator=(const LiveConfig_BoostsConfig_ItemConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline LiveConfig_BoostsConfig_ItemConfig& operator=(LiveConfig_BoostsConfig_ItemConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LiveConfig_BoostsConfig_ItemConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const LiveConfig_BoostsConfig_ItemConfig* internal_default_instance() {
    return reinterpret_cast<const LiveConfig_BoostsConfig_ItemConfig*>(
               &_LiveConfig_BoostsConfig_ItemConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(LiveConfig_BoostsConfig_ItemConfig& a, LiveConfig_BoostsConfig_ItemConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(LiveConfig_BoostsConfig_ItemConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LiveConfig_BoostsConfig_ItemConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LiveConfig_BoostsConfig_ItemConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LiveConfig_BoostsConfig_ItemConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LiveConfig_BoostsConfig_ItemConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LiveConfig_BoostsConfig_ItemConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LiveConfig_BoostsConfig_ItemConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.LiveConfig.BoostsConfig.ItemConfig";
  }
  protected:
  explicit LiveConfig_BoostsConfig_ItemConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoostIdFieldNumber = 1,
    kPriceFieldNumber = 2,
    kTokenPriceFieldNumber = 3,
    kSeRequiredFieldNumber = 4,
  };
  // optional string boost_id = 1;
  bool has_boost_id() const;
  private:
  bool _internal_has_boost_id() const;
  public:
  void clear_boost_id();
  const std::string& boost_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_boost_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_boost_id();
  PROTOBUF_NODISCARD std::string* release_boost_id();
  void set_allocated_boost_id(std::string* boost_id);
  private:
  const std::string& _internal_boost_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_boost_id(const std::string& value);
  std::string* _internal_mutable_boost_id();
  public:

  // optional uint32 price = 2;
  bool has_price() const;
  private:
  bool _internal_has_price() const;
  public:
  void clear_price();
  uint32_t price() const;
  void set_price(uint32_t value);
  private:
  uint32_t _internal_price() const;
  void _internal_set_price(uint32_t value);
  public:

  // optional uint32 token_price = 3;
  bool has_token_price() const;
  private:
  bool _internal_has_token_price() const;
  public:
  void clear_token_price();
  uint32_t token_price() const;
  void set_token_price(uint32_t value);
  private:
  uint32_t _internal_token_price() const;
  void _internal_set_token_price(uint32_t value);
  public:

  // optional double se_required = 4;
  bool has_se_required() const;
  private:
  bool _internal_has_se_required() const;
  public:
  void clear_se_required();
  double se_required() const;
  void set_se_required(double value);
  private:
  double _internal_se_required() const;
  void _internal_set_se_required(double value);
  public:

  // @@protoc_insertion_point(class_scope:ei.LiveConfig.BoostsConfig.ItemConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr boost_id_;
  uint32_t price_;
  uint32_t token_price_;
  double se_required_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class LiveConfig_BoostsConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.LiveConfig.BoostsConfig) */ {
 public:
  inline LiveConfig_BoostsConfig() : LiveConfig_BoostsConfig(nullptr) {}
  ~LiveConfig_BoostsConfig() override;
  explicit constexpr LiveConfig_BoostsConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LiveConfig_BoostsConfig(const LiveConfig_BoostsConfig& from);
  LiveConfig_BoostsConfig(LiveConfig_BoostsConfig&& from) noexcept
    : LiveConfig_BoostsConfig() {
    *this = ::std::move(from);
  }

  inline LiveConfig_BoostsConfig& operator=(const LiveConfig_BoostsConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline LiveConfig_BoostsConfig& operator=(LiveConfig_BoostsConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LiveConfig_BoostsConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const LiveConfig_BoostsConfig* internal_default_instance() {
    return reinterpret_cast<const LiveConfig_BoostsConfig*>(
               &_LiveConfig_BoostsConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(LiveConfig_BoostsConfig& a, LiveConfig_BoostsConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(LiveConfig_BoostsConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LiveConfig_BoostsConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LiveConfig_BoostsConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LiveConfig_BoostsConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LiveConfig_BoostsConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LiveConfig_BoostsConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LiveConfig_BoostsConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.LiveConfig.BoostsConfig";
  }
  protected:
  explicit LiveConfig_BoostsConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LiveConfig_BoostsConfig_ItemConfig ItemConfig;

  // accessors -------------------------------------------------------

  enum : int {
    kItemConfigsFieldNumber = 1,
    kCashBoostCooloffTimeFieldNumber = 2,
  };
  // repeated .ei.LiveConfig.BoostsConfig.ItemConfig item_configs = 1;
  int item_configs_size() const;
  private:
  int _internal_item_configs_size() const;
  public:
  void clear_item_configs();
  ::ei::LiveConfig_BoostsConfig_ItemConfig* mutable_item_configs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::LiveConfig_BoostsConfig_ItemConfig >*
      mutable_item_configs();
  private:
  const ::ei::LiveConfig_BoostsConfig_ItemConfig& _internal_item_configs(int index) const;
  ::ei::LiveConfig_BoostsConfig_ItemConfig* _internal_add_item_configs();
  public:
  const ::ei::LiveConfig_BoostsConfig_ItemConfig& item_configs(int index) const;
  ::ei::LiveConfig_BoostsConfig_ItemConfig* add_item_configs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::LiveConfig_BoostsConfig_ItemConfig >&
      item_configs() const;

  // optional double cash_boost_cooloff_time = 2;
  bool has_cash_boost_cooloff_time() const;
  private:
  bool _internal_has_cash_boost_cooloff_time() const;
  public:
  void clear_cash_boost_cooloff_time();
  double cash_boost_cooloff_time() const;
  void set_cash_boost_cooloff_time(double value);
  private:
  double _internal_cash_boost_cooloff_time() const;
  void _internal_set_cash_boost_cooloff_time(double value);
  public:

  // @@protoc_insertion_point(class_scope:ei.LiveConfig.BoostsConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::LiveConfig_BoostsConfig_ItemConfig > item_configs_;
  double cash_boost_cooloff_time_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class LiveConfig_GiftConfig_GiftValueConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.LiveConfig.GiftConfig.GiftValueConfig) */ {
 public:
  inline LiveConfig_GiftConfig_GiftValueConfig() : LiveConfig_GiftConfig_GiftValueConfig(nullptr) {}
  ~LiveConfig_GiftConfig_GiftValueConfig() override;
  explicit constexpr LiveConfig_GiftConfig_GiftValueConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LiveConfig_GiftConfig_GiftValueConfig(const LiveConfig_GiftConfig_GiftValueConfig& from);
  LiveConfig_GiftConfig_GiftValueConfig(LiveConfig_GiftConfig_GiftValueConfig&& from) noexcept
    : LiveConfig_GiftConfig_GiftValueConfig() {
    *this = ::std::move(from);
  }

  inline LiveConfig_GiftConfig_GiftValueConfig& operator=(const LiveConfig_GiftConfig_GiftValueConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline LiveConfig_GiftConfig_GiftValueConfig& operator=(LiveConfig_GiftConfig_GiftValueConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LiveConfig_GiftConfig_GiftValueConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const LiveConfig_GiftConfig_GiftValueConfig* internal_default_instance() {
    return reinterpret_cast<const LiveConfig_GiftConfig_GiftValueConfig*>(
               &_LiveConfig_GiftConfig_GiftValueConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(LiveConfig_GiftConfig_GiftValueConfig& a, LiveConfig_GiftConfig_GiftValueConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(LiveConfig_GiftConfig_GiftValueConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LiveConfig_GiftConfig_GiftValueConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LiveConfig_GiftConfig_GiftValueConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LiveConfig_GiftConfig_GiftValueConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LiveConfig_GiftConfig_GiftValueConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LiveConfig_GiftConfig_GiftValueConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LiveConfig_GiftConfig_GiftValueConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.LiveConfig.GiftConfig.GiftValueConfig";
  }
  protected:
  explicit LiveConfig_GiftConfig_GiftValueConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGiftIdFieldNumber = 1,
    kRandMinFieldNumber = 2,
    kRandMaxFieldNumber = 3,
    kAmountFieldNumber = 4,
    kVideoMinFieldNumber = 5,
    kVideoMaxFieldNumber = 6,
  };
  // optional string gift_id = 1;
  bool has_gift_id() const;
  private:
  bool _internal_has_gift_id() const;
  public:
  void clear_gift_id();
  const std::string& gift_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gift_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gift_id();
  PROTOBUF_NODISCARD std::string* release_gift_id();
  void set_allocated_gift_id(std::string* gift_id);
  private:
  const std::string& _internal_gift_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gift_id(const std::string& value);
  std::string* _internal_mutable_gift_id();
  public:

  // optional double rand_min = 2;
  bool has_rand_min() const;
  private:
  bool _internal_has_rand_min() const;
  public:
  void clear_rand_min();
  double rand_min() const;
  void set_rand_min(double value);
  private:
  double _internal_rand_min() const;
  void _internal_set_rand_min(double value);
  public:

  // optional double rand_max = 3;
  bool has_rand_max() const;
  private:
  bool _internal_has_rand_max() const;
  public:
  void clear_rand_max();
  double rand_max() const;
  void set_rand_max(double value);
  private:
  double _internal_rand_max() const;
  void _internal_set_rand_max(double value);
  public:

  // optional double amount = 4;
  bool has_amount() const;
  private:
  bool _internal_has_amount() const;
  public:
  void clear_amount();
  double amount() const;
  void set_amount(double value);
  private:
  double _internal_amount() const;
  void _internal_set_amount(double value);
  public:

  // optional double video_min = 5;
  bool has_video_min() const;
  private:
  bool _internal_has_video_min() const;
  public:
  void clear_video_min();
  double video_min() const;
  void set_video_min(double value);
  private:
  double _internal_video_min() const;
  void _internal_set_video_min(double value);
  public:

  // optional double video_max = 6;
  bool has_video_max() const;
  private:
  bool _internal_has_video_max() const;
  public:
  void clear_video_max();
  double video_max() const;
  void set_video_max(double value);
  private:
  double _internal_video_max() const;
  void _internal_set_video_max(double value);
  public:

  // @@protoc_insertion_point(class_scope:ei.LiveConfig.GiftConfig.GiftValueConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gift_id_;
  double rand_min_;
  double rand_max_;
  double amount_;
  double video_min_;
  double video_max_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class LiveConfig_GiftConfig_GiftMuConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.LiveConfig.GiftConfig.GiftMuConfig) */ {
 public:
  inline LiveConfig_GiftConfig_GiftMuConfig() : LiveConfig_GiftConfig_GiftMuConfig(nullptr) {}
  ~LiveConfig_GiftConfig_GiftMuConfig() override;
  explicit constexpr LiveConfig_GiftConfig_GiftMuConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LiveConfig_GiftConfig_GiftMuConfig(const LiveConfig_GiftConfig_GiftMuConfig& from);
  LiveConfig_GiftConfig_GiftMuConfig(LiveConfig_GiftConfig_GiftMuConfig&& from) noexcept
    : LiveConfig_GiftConfig_GiftMuConfig() {
    *this = ::std::move(from);
  }

  inline LiveConfig_GiftConfig_GiftMuConfig& operator=(const LiveConfig_GiftConfig_GiftMuConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline LiveConfig_GiftConfig_GiftMuConfig& operator=(LiveConfig_GiftConfig_GiftMuConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LiveConfig_GiftConfig_GiftMuConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const LiveConfig_GiftConfig_GiftMuConfig* internal_default_instance() {
    return reinterpret_cast<const LiveConfig_GiftConfig_GiftMuConfig*>(
               &_LiveConfig_GiftConfig_GiftMuConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(LiveConfig_GiftConfig_GiftMuConfig& a, LiveConfig_GiftConfig_GiftMuConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(LiveConfig_GiftConfig_GiftMuConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LiveConfig_GiftConfig_GiftMuConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LiveConfig_GiftConfig_GiftMuConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LiveConfig_GiftConfig_GiftMuConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LiveConfig_GiftConfig_GiftMuConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LiveConfig_GiftConfig_GiftMuConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LiveConfig_GiftConfig_GiftMuConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.LiveConfig.GiftConfig.GiftMuConfig";
  }
  protected:
  explicit LiveConfig_GiftConfig_GiftMuConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinSpentFieldNumber = 1,
    kMaxSpentFieldNumber = 2,
    kOverallMultFieldNumber = 3,
  };
  // optional double min_spent = 1;
  bool has_min_spent() const;
  private:
  bool _internal_has_min_spent() const;
  public:
  void clear_min_spent();
  double min_spent() const;
  void set_min_spent(double value);
  private:
  double _internal_min_spent() const;
  void _internal_set_min_spent(double value);
  public:

  // optional double max_spent = 2;
  bool has_max_spent() const;
  private:
  bool _internal_has_max_spent() const;
  public:
  void clear_max_spent();
  double max_spent() const;
  void set_max_spent(double value);
  private:
  double _internal_max_spent() const;
  void _internal_set_max_spent(double value);
  public:

  // optional double overall_mult = 3;
  bool has_overall_mult() const;
  private:
  bool _internal_has_overall_mult() const;
  public:
  void clear_overall_mult();
  double overall_mult() const;
  void set_overall_mult(double value);
  private:
  double _internal_overall_mult() const;
  void _internal_set_overall_mult(double value);
  public:

  // @@protoc_insertion_point(class_scope:ei.LiveConfig.GiftConfig.GiftMuConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double min_spent_;
  double max_spent_;
  double overall_mult_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class LiveConfig_GiftConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.LiveConfig.GiftConfig) */ {
 public:
  inline LiveConfig_GiftConfig() : LiveConfig_GiftConfig(nullptr) {}
  ~LiveConfig_GiftConfig() override;
  explicit constexpr LiveConfig_GiftConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LiveConfig_GiftConfig(const LiveConfig_GiftConfig& from);
  LiveConfig_GiftConfig(LiveConfig_GiftConfig&& from) noexcept
    : LiveConfig_GiftConfig() {
    *this = ::std::move(from);
  }

  inline LiveConfig_GiftConfig& operator=(const LiveConfig_GiftConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline LiveConfig_GiftConfig& operator=(LiveConfig_GiftConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LiveConfig_GiftConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const LiveConfig_GiftConfig* internal_default_instance() {
    return reinterpret_cast<const LiveConfig_GiftConfig*>(
               &_LiveConfig_GiftConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(LiveConfig_GiftConfig& a, LiveConfig_GiftConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(LiveConfig_GiftConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LiveConfig_GiftConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LiveConfig_GiftConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LiveConfig_GiftConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LiveConfig_GiftConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LiveConfig_GiftConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LiveConfig_GiftConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.LiveConfig.GiftConfig";
  }
  protected:
  explicit LiveConfig_GiftConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LiveConfig_GiftConfig_GiftValueConfig GiftValueConfig;
  typedef LiveConfig_GiftConfig_GiftMuConfig GiftMuConfig;

  // accessors -------------------------------------------------------

  enum : int {
    kGiftConfigsFieldNumber = 9,
    kRandomGiftMuConfigFieldNumber = 15,
    kVideoGiftMuConfigFieldNumber = 16,
    kPackageIntervalFieldNumber = 1,
    kVideoOfferIntervalFieldNumber = 2,
    kVideoOfferIntervalContractFieldNumber = 3,
    kVideoOfferIntervalPiggyFullFieldNumber = 4,
    kVideoOfferIntervalPiggyExtraFullFieldNumber = 5,
    kPackageIntervalContractFieldNumber = 6,
    kPackageIntervalPiggyFullFieldNumber = 7,
    kPackageIntervalPiggyExtraFullFieldNumber = 8,
    kGiftMuMinSpentFieldNumber = 10,
    kGiftMuMaxSpentFieldNumber = 11,
    kGiftMuOverallMultFieldNumber = 12,
    kVideoResetOnIdleFieldNumber = 14,
    kPackageResetOnIdleFieldNumber = 13,
  };
  // repeated .ei.LiveConfig.GiftConfig.GiftValueConfig gift_configs = 9;
  int gift_configs_size() const;
  private:
  int _internal_gift_configs_size() const;
  public:
  void clear_gift_configs();
  ::ei::LiveConfig_GiftConfig_GiftValueConfig* mutable_gift_configs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::LiveConfig_GiftConfig_GiftValueConfig >*
      mutable_gift_configs();
  private:
  const ::ei::LiveConfig_GiftConfig_GiftValueConfig& _internal_gift_configs(int index) const;
  ::ei::LiveConfig_GiftConfig_GiftValueConfig* _internal_add_gift_configs();
  public:
  const ::ei::LiveConfig_GiftConfig_GiftValueConfig& gift_configs(int index) const;
  ::ei::LiveConfig_GiftConfig_GiftValueConfig* add_gift_configs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::LiveConfig_GiftConfig_GiftValueConfig >&
      gift_configs() const;

  // optional .ei.LiveConfig.GiftConfig.GiftMuConfig random_gift_mu_config = 15;
  bool has_random_gift_mu_config() const;
  private:
  bool _internal_has_random_gift_mu_config() const;
  public:
  void clear_random_gift_mu_config();
  const ::ei::LiveConfig_GiftConfig_GiftMuConfig& random_gift_mu_config() const;
  PROTOBUF_NODISCARD ::ei::LiveConfig_GiftConfig_GiftMuConfig* release_random_gift_mu_config();
  ::ei::LiveConfig_GiftConfig_GiftMuConfig* mutable_random_gift_mu_config();
  void set_allocated_random_gift_mu_config(::ei::LiveConfig_GiftConfig_GiftMuConfig* random_gift_mu_config);
  private:
  const ::ei::LiveConfig_GiftConfig_GiftMuConfig& _internal_random_gift_mu_config() const;
  ::ei::LiveConfig_GiftConfig_GiftMuConfig* _internal_mutable_random_gift_mu_config();
  public:
  void unsafe_arena_set_allocated_random_gift_mu_config(
      ::ei::LiveConfig_GiftConfig_GiftMuConfig* random_gift_mu_config);
  ::ei::LiveConfig_GiftConfig_GiftMuConfig* unsafe_arena_release_random_gift_mu_config();

  // optional .ei.LiveConfig.GiftConfig.GiftMuConfig video_gift_mu_config = 16;
  bool has_video_gift_mu_config() const;
  private:
  bool _internal_has_video_gift_mu_config() const;
  public:
  void clear_video_gift_mu_config();
  const ::ei::LiveConfig_GiftConfig_GiftMuConfig& video_gift_mu_config() const;
  PROTOBUF_NODISCARD ::ei::LiveConfig_GiftConfig_GiftMuConfig* release_video_gift_mu_config();
  ::ei::LiveConfig_GiftConfig_GiftMuConfig* mutable_video_gift_mu_config();
  void set_allocated_video_gift_mu_config(::ei::LiveConfig_GiftConfig_GiftMuConfig* video_gift_mu_config);
  private:
  const ::ei::LiveConfig_GiftConfig_GiftMuConfig& _internal_video_gift_mu_config() const;
  ::ei::LiveConfig_GiftConfig_GiftMuConfig* _internal_mutable_video_gift_mu_config();
  public:
  void unsafe_arena_set_allocated_video_gift_mu_config(
      ::ei::LiveConfig_GiftConfig_GiftMuConfig* video_gift_mu_config);
  ::ei::LiveConfig_GiftConfig_GiftMuConfig* unsafe_arena_release_video_gift_mu_config();

  // optional double package_interval = 1;
  bool has_package_interval() const;
  private:
  bool _internal_has_package_interval() const;
  public:
  void clear_package_interval();
  double package_interval() const;
  void set_package_interval(double value);
  private:
  double _internal_package_interval() const;
  void _internal_set_package_interval(double value);
  public:

  // optional double video_offer_interval = 2;
  bool has_video_offer_interval() const;
  private:
  bool _internal_has_video_offer_interval() const;
  public:
  void clear_video_offer_interval();
  double video_offer_interval() const;
  void set_video_offer_interval(double value);
  private:
  double _internal_video_offer_interval() const;
  void _internal_set_video_offer_interval(double value);
  public:

  // optional double video_offer_interval_contract = 3;
  bool has_video_offer_interval_contract() const;
  private:
  bool _internal_has_video_offer_interval_contract() const;
  public:
  void clear_video_offer_interval_contract();
  double video_offer_interval_contract() const;
  void set_video_offer_interval_contract(double value);
  private:
  double _internal_video_offer_interval_contract() const;
  void _internal_set_video_offer_interval_contract(double value);
  public:

  // optional double video_offer_interval_piggy_full = 4;
  bool has_video_offer_interval_piggy_full() const;
  private:
  bool _internal_has_video_offer_interval_piggy_full() const;
  public:
  void clear_video_offer_interval_piggy_full();
  double video_offer_interval_piggy_full() const;
  void set_video_offer_interval_piggy_full(double value);
  private:
  double _internal_video_offer_interval_piggy_full() const;
  void _internal_set_video_offer_interval_piggy_full(double value);
  public:

  // optional double video_offer_interval_piggy_extra_full = 5;
  bool has_video_offer_interval_piggy_extra_full() const;
  private:
  bool _internal_has_video_offer_interval_piggy_extra_full() const;
  public:
  void clear_video_offer_interval_piggy_extra_full();
  double video_offer_interval_piggy_extra_full() const;
  void set_video_offer_interval_piggy_extra_full(double value);
  private:
  double _internal_video_offer_interval_piggy_extra_full() const;
  void _internal_set_video_offer_interval_piggy_extra_full(double value);
  public:

  // optional double package_interval_contract = 6;
  bool has_package_interval_contract() const;
  private:
  bool _internal_has_package_interval_contract() const;
  public:
  void clear_package_interval_contract();
  double package_interval_contract() const;
  void set_package_interval_contract(double value);
  private:
  double _internal_package_interval_contract() const;
  void _internal_set_package_interval_contract(double value);
  public:

  // optional double package_interval_piggy_full = 7;
  bool has_package_interval_piggy_full() const;
  private:
  bool _internal_has_package_interval_piggy_full() const;
  public:
  void clear_package_interval_piggy_full();
  double package_interval_piggy_full() const;
  void set_package_interval_piggy_full(double value);
  private:
  double _internal_package_interval_piggy_full() const;
  void _internal_set_package_interval_piggy_full(double value);
  public:

  // optional double package_interval_piggy_extra_full = 8;
  bool has_package_interval_piggy_extra_full() const;
  private:
  bool _internal_has_package_interval_piggy_extra_full() const;
  public:
  void clear_package_interval_piggy_extra_full();
  double package_interval_piggy_extra_full() const;
  void set_package_interval_piggy_extra_full(double value);
  private:
  double _internal_package_interval_piggy_extra_full() const;
  void _internal_set_package_interval_piggy_extra_full(double value);
  public:

  // optional double gift_mu_min_spent = 10;
  bool has_gift_mu_min_spent() const;
  private:
  bool _internal_has_gift_mu_min_spent() const;
  public:
  void clear_gift_mu_min_spent();
  double gift_mu_min_spent() const;
  void set_gift_mu_min_spent(double value);
  private:
  double _internal_gift_mu_min_spent() const;
  void _internal_set_gift_mu_min_spent(double value);
  public:

  // optional double gift_mu_max_spent = 11;
  bool has_gift_mu_max_spent() const;
  private:
  bool _internal_has_gift_mu_max_spent() const;
  public:
  void clear_gift_mu_max_spent();
  double gift_mu_max_spent() const;
  void set_gift_mu_max_spent(double value);
  private:
  double _internal_gift_mu_max_spent() const;
  void _internal_set_gift_mu_max_spent(double value);
  public:

  // optional double gift_mu_overall_mult = 12;
  bool has_gift_mu_overall_mult() const;
  private:
  bool _internal_has_gift_mu_overall_mult() const;
  public:
  void clear_gift_mu_overall_mult();
  double gift_mu_overall_mult() const;
  void set_gift_mu_overall_mult(double value);
  private:
  double _internal_gift_mu_overall_mult() const;
  void _internal_set_gift_mu_overall_mult(double value);
  public:

  // optional bool video_reset_on_idle = 14;
  bool has_video_reset_on_idle() const;
  private:
  bool _internal_has_video_reset_on_idle() const;
  public:
  void clear_video_reset_on_idle();
  bool video_reset_on_idle() const;
  void set_video_reset_on_idle(bool value);
  private:
  bool _internal_video_reset_on_idle() const;
  void _internal_set_video_reset_on_idle(bool value);
  public:

  // optional bool package_reset_on_idle = 13;
  bool has_package_reset_on_idle() const;
  private:
  bool _internal_has_package_reset_on_idle() const;
  public:
  void clear_package_reset_on_idle();
  bool package_reset_on_idle() const;
  void set_package_reset_on_idle(bool value);
  private:
  bool _internal_package_reset_on_idle() const;
  void _internal_set_package_reset_on_idle(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ei.LiveConfig.GiftConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::LiveConfig_GiftConfig_GiftValueConfig > gift_configs_;
  ::ei::LiveConfig_GiftConfig_GiftMuConfig* random_gift_mu_config_;
  ::ei::LiveConfig_GiftConfig_GiftMuConfig* video_gift_mu_config_;
  double package_interval_;
  double video_offer_interval_;
  double video_offer_interval_contract_;
  double video_offer_interval_piggy_full_;
  double video_offer_interval_piggy_extra_full_;
  double package_interval_contract_;
  double package_interval_piggy_full_;
  double package_interval_piggy_extra_full_;
  double gift_mu_min_spent_;
  double gift_mu_max_spent_;
  double gift_mu_overall_mult_;
  bool video_reset_on_idle_;
  bool package_reset_on_idle_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class LiveConfig_MiscConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.LiveConfig.MiscConfig) */ {
 public:
  inline LiveConfig_MiscConfig() : LiveConfig_MiscConfig(nullptr) {}
  ~LiveConfig_MiscConfig() override;
  explicit constexpr LiveConfig_MiscConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LiveConfig_MiscConfig(const LiveConfig_MiscConfig& from);
  LiveConfig_MiscConfig(LiveConfig_MiscConfig&& from) noexcept
    : LiveConfig_MiscConfig() {
    *this = ::std::move(from);
  }

  inline LiveConfig_MiscConfig& operator=(const LiveConfig_MiscConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline LiveConfig_MiscConfig& operator=(LiveConfig_MiscConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LiveConfig_MiscConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const LiveConfig_MiscConfig* internal_default_instance() {
    return reinterpret_cast<const LiveConfig_MiscConfig*>(
               &_LiveConfig_MiscConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(LiveConfig_MiscConfig& a, LiveConfig_MiscConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(LiveConfig_MiscConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LiveConfig_MiscConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LiveConfig_MiscConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LiveConfig_MiscConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LiveConfig_MiscConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LiveConfig_MiscConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LiveConfig_MiscConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.LiveConfig.MiscConfig";
  }
  protected:
  explicit LiveConfig_MiscConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAskToTrackMessageFieldNumber = 3,
    kAskToTrackMinSoulEggsFieldNumber = 2,
    kAskToTrackFieldNumber = 1,
    kAskToTrackShowPreDialogFieldNumber = 4,
    kAskToTrackAfterPrivacyFieldNumber = 5,
    kShellsIntroTicketsFieldNumber = 7,
    kChickenRunBoostPercentageFieldNumber = 6,
    kShellsMaxFreeChickenConfigsFieldNumber = 8,
    kShellsIntroAlertThresholdFieldNumber = 9,
  };
  // optional string ask_to_track_message = 3;
  bool has_ask_to_track_message() const;
  private:
  bool _internal_has_ask_to_track_message() const;
  public:
  void clear_ask_to_track_message();
  const std::string& ask_to_track_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ask_to_track_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ask_to_track_message();
  PROTOBUF_NODISCARD std::string* release_ask_to_track_message();
  void set_allocated_ask_to_track_message(std::string* ask_to_track_message);
  private:
  const std::string& _internal_ask_to_track_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ask_to_track_message(const std::string& value);
  std::string* _internal_mutable_ask_to_track_message();
  public:

  // optional double ask_to_track_min_soul_eggs = 2;
  bool has_ask_to_track_min_soul_eggs() const;
  private:
  bool _internal_has_ask_to_track_min_soul_eggs() const;
  public:
  void clear_ask_to_track_min_soul_eggs();
  double ask_to_track_min_soul_eggs() const;
  void set_ask_to_track_min_soul_eggs(double value);
  private:
  double _internal_ask_to_track_min_soul_eggs() const;
  void _internal_set_ask_to_track_min_soul_eggs(double value);
  public:

  // optional bool ask_to_track = 1;
  bool has_ask_to_track() const;
  private:
  bool _internal_has_ask_to_track() const;
  public:
  void clear_ask_to_track();
  bool ask_to_track() const;
  void set_ask_to_track(bool value);
  private:
  bool _internal_ask_to_track() const;
  void _internal_set_ask_to_track(bool value);
  public:

  // optional bool ask_to_track_show_pre_dialog = 4;
  bool has_ask_to_track_show_pre_dialog() const;
  private:
  bool _internal_has_ask_to_track_show_pre_dialog() const;
  public:
  void clear_ask_to_track_show_pre_dialog();
  bool ask_to_track_show_pre_dialog() const;
  void set_ask_to_track_show_pre_dialog(bool value);
  private:
  bool _internal_ask_to_track_show_pre_dialog() const;
  void _internal_set_ask_to_track_show_pre_dialog(bool value);
  public:

  // optional bool ask_to_track_after_privacy = 5;
  bool has_ask_to_track_after_privacy() const;
  private:
  bool _internal_has_ask_to_track_after_privacy() const;
  public:
  void clear_ask_to_track_after_privacy();
  bool ask_to_track_after_privacy() const;
  void set_ask_to_track_after_privacy(bool value);
  private:
  bool _internal_ask_to_track_after_privacy() const;
  void _internal_set_ask_to_track_after_privacy(bool value);
  public:

  // optional uint32 shells_intro_tickets = 7;
  bool has_shells_intro_tickets() const;
  private:
  bool _internal_has_shells_intro_tickets() const;
  public:
  void clear_shells_intro_tickets();
  uint32_t shells_intro_tickets() const;
  void set_shells_intro_tickets(uint32_t value);
  private:
  uint32_t _internal_shells_intro_tickets() const;
  void _internal_set_shells_intro_tickets(uint32_t value);
  public:

  // optional double chicken_run_boost_percentage = 6;
  bool has_chicken_run_boost_percentage() const;
  private:
  bool _internal_has_chicken_run_boost_percentage() const;
  public:
  void clear_chicken_run_boost_percentage();
  double chicken_run_boost_percentage() const;
  void set_chicken_run_boost_percentage(double value);
  private:
  double _internal_chicken_run_boost_percentage() const;
  void _internal_set_chicken_run_boost_percentage(double value);
  public:

  // optional uint32 shells_max_free_chicken_configs = 8;
  bool has_shells_max_free_chicken_configs() const;
  private:
  bool _internal_has_shells_max_free_chicken_configs() const;
  public:
  void clear_shells_max_free_chicken_configs();
  uint32_t shells_max_free_chicken_configs() const;
  void set_shells_max_free_chicken_configs(uint32_t value);
  private:
  uint32_t _internal_shells_max_free_chicken_configs() const;
  void _internal_set_shells_max_free_chicken_configs(uint32_t value);
  public:

  // optional uint32 shells_intro_alert_threshold = 9;
  bool has_shells_intro_alert_threshold() const;
  private:
  bool _internal_has_shells_intro_alert_threshold() const;
  public:
  void clear_shells_intro_alert_threshold();
  uint32_t shells_intro_alert_threshold() const;
  void set_shells_intro_alert_threshold(uint32_t value);
  private:
  uint32_t _internal_shells_intro_alert_threshold() const;
  void _internal_set_shells_intro_alert_threshold(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.LiveConfig.MiscConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ask_to_track_message_;
  double ask_to_track_min_soul_eggs_;
  bool ask_to_track_;
  bool ask_to_track_show_pre_dialog_;
  bool ask_to_track_after_privacy_;
  uint32_t shells_intro_tickets_;
  double chicken_run_boost_percentage_;
  uint32_t shells_max_free_chicken_configs_;
  uint32_t shells_intro_alert_threshold_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class LiveConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.LiveConfig) */ {
 public:
  inline LiveConfig() : LiveConfig(nullptr) {}
  ~LiveConfig() override;
  explicit constexpr LiveConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LiveConfig(const LiveConfig& from);
  LiveConfig(LiveConfig&& from) noexcept
    : LiveConfig() {
    *this = ::std::move(from);
  }

  inline LiveConfig& operator=(const LiveConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline LiveConfig& operator=(LiveConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LiveConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const LiveConfig* internal_default_instance() {
    return reinterpret_cast<const LiveConfig*>(
               &_LiveConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(LiveConfig& a, LiveConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(LiveConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LiveConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LiveConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LiveConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LiveConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LiveConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LiveConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.LiveConfig";
  }
  protected:
  explicit LiveConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LiveConfig_BoostsConfig BoostsConfig;
  typedef LiveConfig_GiftConfig GiftConfig;
  typedef LiveConfig_MiscConfig MiscConfig;

  // accessors -------------------------------------------------------

  enum : int {
    kConfigIdFieldNumber = 1,
    kBoostsConfigFieldNumber = 2,
    kGiftConfigFieldNumber = 3,
    kMiscConfigFieldNumber = 4,
  };
  // optional string config_id = 1;
  bool has_config_id() const;
  private:
  bool _internal_has_config_id() const;
  public:
  void clear_config_id();
  const std::string& config_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_config_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_config_id();
  PROTOBUF_NODISCARD std::string* release_config_id();
  void set_allocated_config_id(std::string* config_id);
  private:
  const std::string& _internal_config_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_config_id(const std::string& value);
  std::string* _internal_mutable_config_id();
  public:

  // optional .ei.LiveConfig.BoostsConfig boosts_config = 2;
  bool has_boosts_config() const;
  private:
  bool _internal_has_boosts_config() const;
  public:
  void clear_boosts_config();
  const ::ei::LiveConfig_BoostsConfig& boosts_config() const;
  PROTOBUF_NODISCARD ::ei::LiveConfig_BoostsConfig* release_boosts_config();
  ::ei::LiveConfig_BoostsConfig* mutable_boosts_config();
  void set_allocated_boosts_config(::ei::LiveConfig_BoostsConfig* boosts_config);
  private:
  const ::ei::LiveConfig_BoostsConfig& _internal_boosts_config() const;
  ::ei::LiveConfig_BoostsConfig* _internal_mutable_boosts_config();
  public:
  void unsafe_arena_set_allocated_boosts_config(
      ::ei::LiveConfig_BoostsConfig* boosts_config);
  ::ei::LiveConfig_BoostsConfig* unsafe_arena_release_boosts_config();

  // optional .ei.LiveConfig.GiftConfig gift_config = 3;
  bool has_gift_config() const;
  private:
  bool _internal_has_gift_config() const;
  public:
  void clear_gift_config();
  const ::ei::LiveConfig_GiftConfig& gift_config() const;
  PROTOBUF_NODISCARD ::ei::LiveConfig_GiftConfig* release_gift_config();
  ::ei::LiveConfig_GiftConfig* mutable_gift_config();
  void set_allocated_gift_config(::ei::LiveConfig_GiftConfig* gift_config);
  private:
  const ::ei::LiveConfig_GiftConfig& _internal_gift_config() const;
  ::ei::LiveConfig_GiftConfig* _internal_mutable_gift_config();
  public:
  void unsafe_arena_set_allocated_gift_config(
      ::ei::LiveConfig_GiftConfig* gift_config);
  ::ei::LiveConfig_GiftConfig* unsafe_arena_release_gift_config();

  // optional .ei.LiveConfig.MiscConfig misc_config = 4;
  bool has_misc_config() const;
  private:
  bool _internal_has_misc_config() const;
  public:
  void clear_misc_config();
  const ::ei::LiveConfig_MiscConfig& misc_config() const;
  PROTOBUF_NODISCARD ::ei::LiveConfig_MiscConfig* release_misc_config();
  ::ei::LiveConfig_MiscConfig* mutable_misc_config();
  void set_allocated_misc_config(::ei::LiveConfig_MiscConfig* misc_config);
  private:
  const ::ei::LiveConfig_MiscConfig& _internal_misc_config() const;
  ::ei::LiveConfig_MiscConfig* _internal_mutable_misc_config();
  public:
  void unsafe_arena_set_allocated_misc_config(
      ::ei::LiveConfig_MiscConfig* misc_config);
  ::ei::LiveConfig_MiscConfig* unsafe_arena_release_misc_config();

  // @@protoc_insertion_point(class_scope:ei.LiveConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr config_id_;
  ::ei::LiveConfig_BoostsConfig* boosts_config_;
  ::ei::LiveConfig_GiftConfig* gift_config_;
  ::ei::LiveConfig_MiscConfig* misc_config_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class InGameMail final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.InGameMail) */ {
 public:
  inline InGameMail() : InGameMail(nullptr) {}
  ~InGameMail() override;
  explicit constexpr InGameMail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InGameMail(const InGameMail& from);
  InGameMail(InGameMail&& from) noexcept
    : InGameMail() {
    *this = ::std::move(from);
  }

  inline InGameMail& operator=(const InGameMail& from) {
    CopyFrom(from);
    return *this;
  }
  inline InGameMail& operator=(InGameMail&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InGameMail& default_instance() {
    return *internal_default_instance();
  }
  static inline const InGameMail* internal_default_instance() {
    return reinterpret_cast<const InGameMail*>(
               &_InGameMail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(InGameMail& a, InGameMail& b) {
    a.Swap(&b);
  }
  inline void Swap(InGameMail* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InGameMail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InGameMail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InGameMail>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InGameMail& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InGameMail& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InGameMail* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.InGameMail";
  }
  protected:
  explicit InGameMail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBuildsFieldNumber = 9,
    kIdFieldNumber = 1,
    kTitleFieldNumber = 2,
    kMessageFieldNumber = 3,
    kActionFieldNumber = 4,
    kUrlFieldNumber = 5,
    kDateFieldNumber = 8,
    kGoldTipFieldNumber = 6,
    kPlatformFieldNumber = 7,
    kMinClientVersionFieldNumber = 10,
    kMinSoulEggsFieldNumber = 11,
    kMinMysticalBonusFieldNumber = 13,
    kMaxClientVersionFieldNumber = 12,
  };
  // repeated string builds = 9;
  int builds_size() const;
  private:
  int _internal_builds_size() const;
  public:
  void clear_builds();
  const std::string& builds(int index) const;
  std::string* mutable_builds(int index);
  void set_builds(int index, const std::string& value);
  void set_builds(int index, std::string&& value);
  void set_builds(int index, const char* value);
  void set_builds(int index, const char* value, size_t size);
  std::string* add_builds();
  void add_builds(const std::string& value);
  void add_builds(std::string&& value);
  void add_builds(const char* value);
  void add_builds(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& builds() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_builds();
  private:
  const std::string& _internal_builds(int index) const;
  std::string* _internal_add_builds();
  public:

  // optional string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional string title = 2;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional string message = 3;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // optional string action = 4;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  const std::string& action() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_action(ArgT0&& arg0, ArgT... args);
  std::string* mutable_action();
  PROTOBUF_NODISCARD std::string* release_action();
  void set_allocated_action(std::string* action);
  private:
  const std::string& _internal_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action(const std::string& value);
  std::string* _internal_mutable_action();
  public:

  // optional string url = 5;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional string date = 8;
  bool has_date() const;
  private:
  bool _internal_has_date() const;
  public:
  void clear_date();
  const std::string& date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_date();
  PROTOBUF_NODISCARD std::string* release_date();
  void set_allocated_date(std::string* date);
  private:
  const std::string& _internal_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_date(const std::string& value);
  std::string* _internal_mutable_date();
  public:

  // optional double gold_tip = 6;
  bool has_gold_tip() const;
  private:
  bool _internal_has_gold_tip() const;
  public:
  void clear_gold_tip();
  double gold_tip() const;
  void set_gold_tip(double value);
  private:
  double _internal_gold_tip() const;
  void _internal_set_gold_tip(double value);
  public:

  // optional uint32 platform = 7;
  bool has_platform() const;
  private:
  bool _internal_has_platform() const;
  public:
  void clear_platform();
  uint32_t platform() const;
  void set_platform(uint32_t value);
  private:
  uint32_t _internal_platform() const;
  void _internal_set_platform(uint32_t value);
  public:

  // optional uint32 min_client_version = 10;
  bool has_min_client_version() const;
  private:
  bool _internal_has_min_client_version() const;
  public:
  void clear_min_client_version();
  uint32_t min_client_version() const;
  void set_min_client_version(uint32_t value);
  private:
  uint32_t _internal_min_client_version() const;
  void _internal_set_min_client_version(uint32_t value);
  public:

  // optional double min_soul_eggs = 11;
  bool has_min_soul_eggs() const;
  private:
  bool _internal_has_min_soul_eggs() const;
  public:
  void clear_min_soul_eggs();
  double min_soul_eggs() const;
  void set_min_soul_eggs(double value);
  private:
  double _internal_min_soul_eggs() const;
  void _internal_set_min_soul_eggs(double value);
  public:

  // optional double min_mystical_bonus = 13;
  bool has_min_mystical_bonus() const;
  private:
  bool _internal_has_min_mystical_bonus() const;
  public:
  void clear_min_mystical_bonus();
  double min_mystical_bonus() const;
  void set_min_mystical_bonus(double value);
  private:
  double _internal_min_mystical_bonus() const;
  void _internal_set_min_mystical_bonus(double value);
  public:

  // optional uint32 max_client_version = 12;
  bool has_max_client_version() const;
  private:
  bool _internal_has_max_client_version() const;
  public:
  void clear_max_client_version();
  uint32_t max_client_version() const;
  void set_max_client_version(uint32_t value);
  private:
  uint32_t _internal_max_client_version() const;
  void _internal_set_max_client_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.InGameMail)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> builds_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr action_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr date_;
  double gold_tip_;
  uint32_t platform_;
  uint32_t min_client_version_;
  double min_soul_eggs_;
  double min_mystical_bonus_;
  uint32_t max_client_version_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class MailDB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.MailDB) */ {
 public:
  inline MailDB() : MailDB(nullptr) {}
  ~MailDB() override;
  explicit constexpr MailDB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MailDB(const MailDB& from);
  MailDB(MailDB&& from) noexcept
    : MailDB() {
    *this = ::std::move(from);
  }

  inline MailDB& operator=(const MailDB& from) {
    CopyFrom(from);
    return *this;
  }
  inline MailDB& operator=(MailDB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MailDB& default_instance() {
    return *internal_default_instance();
  }
  static inline const MailDB* internal_default_instance() {
    return reinterpret_cast<const MailDB*>(
               &_MailDB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(MailDB& a, MailDB& b) {
    a.Swap(&b);
  }
  inline void Swap(MailDB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MailDB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MailDB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MailDB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MailDB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MailDB& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MailDB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.MailDB";
  }
  protected:
  explicit MailDB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMailFieldNumber = 1,
  };
  // repeated .ei.InGameMail mail = 1;
  int mail_size() const;
  private:
  int _internal_mail_size() const;
  public:
  void clear_mail();
  ::ei::InGameMail* mutable_mail(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::InGameMail >*
      mutable_mail();
  private:
  const ::ei::InGameMail& _internal_mail(int index) const;
  ::ei::InGameMail* _internal_add_mail();
  public:
  const ::ei::InGameMail& mail(int index) const;
  ::ei::InGameMail* add_mail();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::InGameMail >&
      mail() const;

  // @@protoc_insertion_point(class_scope:ei.MailDB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::InGameMail > mail_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class PeriodicalsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.PeriodicalsResponse) */ {
 public:
  inline PeriodicalsResponse() : PeriodicalsResponse(nullptr) {}
  ~PeriodicalsResponse() override;
  explicit constexpr PeriodicalsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PeriodicalsResponse(const PeriodicalsResponse& from);
  PeriodicalsResponse(PeriodicalsResponse&& from) noexcept
    : PeriodicalsResponse() {
    *this = ::std::move(from);
  }

  inline PeriodicalsResponse& operator=(const PeriodicalsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeriodicalsResponse& operator=(PeriodicalsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PeriodicalsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeriodicalsResponse* internal_default_instance() {
    return reinterpret_cast<const PeriodicalsResponse*>(
               &_PeriodicalsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(PeriodicalsResponse& a, PeriodicalsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PeriodicalsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeriodicalsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PeriodicalsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PeriodicalsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PeriodicalsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PeriodicalsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeriodicalsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.PeriodicalsResponse";
  }
  protected:
  explicit PeriodicalsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGiftsFieldNumber = 4,
    kSalesFieldNumber = 1,
    kEventsFieldNumber = 2,
    kContractsFieldNumber = 3,
    kLiveConfigFieldNumber = 5,
    kMailBagFieldNumber = 6,
  };
  // repeated .ei.ServerGift gifts = 4;
  int gifts_size() const;
  private:
  int _internal_gifts_size() const;
  public:
  void clear_gifts();
  ::ei::ServerGift* mutable_gifts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ServerGift >*
      mutable_gifts();
  private:
  const ::ei::ServerGift& _internal_gifts(int index) const;
  ::ei::ServerGift* _internal_add_gifts();
  public:
  const ::ei::ServerGift& gifts(int index) const;
  ::ei::ServerGift* add_gifts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ServerGift >&
      gifts() const;

  // optional .ei.SalesInfo sales = 1;
  bool has_sales() const;
  private:
  bool _internal_has_sales() const;
  public:
  void clear_sales();
  const ::ei::SalesInfo& sales() const;
  PROTOBUF_NODISCARD ::ei::SalesInfo* release_sales();
  ::ei::SalesInfo* mutable_sales();
  void set_allocated_sales(::ei::SalesInfo* sales);
  private:
  const ::ei::SalesInfo& _internal_sales() const;
  ::ei::SalesInfo* _internal_mutable_sales();
  public:
  void unsafe_arena_set_allocated_sales(
      ::ei::SalesInfo* sales);
  ::ei::SalesInfo* unsafe_arena_release_sales();

  // optional .ei.EggIncCurrentEvents events = 2;
  bool has_events() const;
  private:
  bool _internal_has_events() const;
  public:
  void clear_events();
  const ::ei::EggIncCurrentEvents& events() const;
  PROTOBUF_NODISCARD ::ei::EggIncCurrentEvents* release_events();
  ::ei::EggIncCurrentEvents* mutable_events();
  void set_allocated_events(::ei::EggIncCurrentEvents* events);
  private:
  const ::ei::EggIncCurrentEvents& _internal_events() const;
  ::ei::EggIncCurrentEvents* _internal_mutable_events();
  public:
  void unsafe_arena_set_allocated_events(
      ::ei::EggIncCurrentEvents* events);
  ::ei::EggIncCurrentEvents* unsafe_arena_release_events();

  // optional .ei.ContractsResponse contracts = 3;
  bool has_contracts() const;
  private:
  bool _internal_has_contracts() const;
  public:
  void clear_contracts();
  const ::ei::ContractsResponse& contracts() const;
  PROTOBUF_NODISCARD ::ei::ContractsResponse* release_contracts();
  ::ei::ContractsResponse* mutable_contracts();
  void set_allocated_contracts(::ei::ContractsResponse* contracts);
  private:
  const ::ei::ContractsResponse& _internal_contracts() const;
  ::ei::ContractsResponse* _internal_mutable_contracts();
  public:
  void unsafe_arena_set_allocated_contracts(
      ::ei::ContractsResponse* contracts);
  ::ei::ContractsResponse* unsafe_arena_release_contracts();

  // optional .ei.LiveConfig live_config = 5;
  bool has_live_config() const;
  private:
  bool _internal_has_live_config() const;
  public:
  void clear_live_config();
  const ::ei::LiveConfig& live_config() const;
  PROTOBUF_NODISCARD ::ei::LiveConfig* release_live_config();
  ::ei::LiveConfig* mutable_live_config();
  void set_allocated_live_config(::ei::LiveConfig* live_config);
  private:
  const ::ei::LiveConfig& _internal_live_config() const;
  ::ei::LiveConfig* _internal_mutable_live_config();
  public:
  void unsafe_arena_set_allocated_live_config(
      ::ei::LiveConfig* live_config);
  ::ei::LiveConfig* unsafe_arena_release_live_config();

  // optional .ei.MailDB mail_bag = 6;
  bool has_mail_bag() const;
  private:
  bool _internal_has_mail_bag() const;
  public:
  void clear_mail_bag();
  const ::ei::MailDB& mail_bag() const;
  PROTOBUF_NODISCARD ::ei::MailDB* release_mail_bag();
  ::ei::MailDB* mutable_mail_bag();
  void set_allocated_mail_bag(::ei::MailDB* mail_bag);
  private:
  const ::ei::MailDB& _internal_mail_bag() const;
  ::ei::MailDB* _internal_mutable_mail_bag();
  public:
  void unsafe_arena_set_allocated_mail_bag(
      ::ei::MailDB* mail_bag);
  ::ei::MailDB* unsafe_arena_release_mail_bag();

  // @@protoc_insertion_point(class_scope:ei.PeriodicalsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ServerGift > gifts_;
  ::ei::SalesInfo* sales_;
  ::ei::EggIncCurrentEvents* events_;
  ::ei::ContractsResponse* contracts_;
  ::ei::LiveConfig* live_config_;
  ::ei::MailDB* mail_bag_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class GetPeriodicalsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.GetPeriodicalsRequest) */ {
 public:
  inline GetPeriodicalsRequest() : GetPeriodicalsRequest(nullptr) {}
  ~GetPeriodicalsRequest() override;
  explicit constexpr GetPeriodicalsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPeriodicalsRequest(const GetPeriodicalsRequest& from);
  GetPeriodicalsRequest(GetPeriodicalsRequest&& from) noexcept
    : GetPeriodicalsRequest() {
    *this = ::std::move(from);
  }

  inline GetPeriodicalsRequest& operator=(const GetPeriodicalsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPeriodicalsRequest& operator=(GetPeriodicalsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPeriodicalsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPeriodicalsRequest* internal_default_instance() {
    return reinterpret_cast<const GetPeriodicalsRequest*>(
               &_GetPeriodicalsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(GetPeriodicalsRequest& a, GetPeriodicalsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPeriodicalsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPeriodicalsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPeriodicalsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPeriodicalsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPeriodicalsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetPeriodicalsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPeriodicalsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.GetPeriodicalsRequest";
  }
  protected:
  explicit GetPeriodicalsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kRinfoFieldNumber = 12,
    kSecondsFullRealtimeFieldNumber = 4,
    kSecondsFullGametimeFieldNumber = 5,
    kSoulEggsFieldNumber = 8,
    kLostIncrementsFieldNumber = 7,
    kPiggyFullFieldNumber = 2,
    kPiggyFoundFullFieldNumber = 3,
    kContractsUnlockedFieldNumber = 15,
    kArtifactsUnlockedFieldNumber = 16,
    kCurrentClientVersionFieldNumber = 10,
    kDebugFieldNumber = 11,
    kMysticalEarningsMultFieldNumber = 13,
    kEopFieldNumber = 14,
  };
  // optional string user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // optional .ei.BasicRequestInfo rinfo = 12;
  bool has_rinfo() const;
  private:
  bool _internal_has_rinfo() const;
  public:
  void clear_rinfo();
  const ::ei::BasicRequestInfo& rinfo() const;
  PROTOBUF_NODISCARD ::ei::BasicRequestInfo* release_rinfo();
  ::ei::BasicRequestInfo* mutable_rinfo();
  void set_allocated_rinfo(::ei::BasicRequestInfo* rinfo);
  private:
  const ::ei::BasicRequestInfo& _internal_rinfo() const;
  ::ei::BasicRequestInfo* _internal_mutable_rinfo();
  public:
  void unsafe_arena_set_allocated_rinfo(
      ::ei::BasicRequestInfo* rinfo);
  ::ei::BasicRequestInfo* unsafe_arena_release_rinfo();

  // optional double seconds_full_realtime = 4;
  bool has_seconds_full_realtime() const;
  private:
  bool _internal_has_seconds_full_realtime() const;
  public:
  void clear_seconds_full_realtime();
  double seconds_full_realtime() const;
  void set_seconds_full_realtime(double value);
  private:
  double _internal_seconds_full_realtime() const;
  void _internal_set_seconds_full_realtime(double value);
  public:

  // optional double seconds_full_gametime = 5;
  bool has_seconds_full_gametime() const;
  private:
  bool _internal_has_seconds_full_gametime() const;
  public:
  void clear_seconds_full_gametime();
  double seconds_full_gametime() const;
  void set_seconds_full_gametime(double value);
  private:
  double _internal_seconds_full_gametime() const;
  void _internal_set_seconds_full_gametime(double value);
  public:

  // optional double soul_eggs = 8;
  bool has_soul_eggs() const;
  private:
  bool _internal_has_soul_eggs() const;
  public:
  void clear_soul_eggs();
  double soul_eggs() const;
  void set_soul_eggs(double value);
  private:
  double _internal_soul_eggs() const;
  void _internal_set_soul_eggs(double value);
  public:

  // optional uint32 lost_increments = 7;
  bool has_lost_increments() const;
  private:
  bool _internal_has_lost_increments() const;
  public:
  void clear_lost_increments();
  uint32_t lost_increments() const;
  void set_lost_increments(uint32_t value);
  private:
  uint32_t _internal_lost_increments() const;
  void _internal_set_lost_increments(uint32_t value);
  public:

  // optional bool piggy_full = 2;
  bool has_piggy_full() const;
  private:
  bool _internal_has_piggy_full() const;
  public:
  void clear_piggy_full();
  bool piggy_full() const;
  void set_piggy_full(bool value);
  private:
  bool _internal_piggy_full() const;
  void _internal_set_piggy_full(bool value);
  public:

  // optional bool piggy_found_full = 3;
  bool has_piggy_found_full() const;
  private:
  bool _internal_has_piggy_found_full() const;
  public:
  void clear_piggy_found_full();
  bool piggy_found_full() const;
  void set_piggy_found_full(bool value);
  private:
  bool _internal_piggy_found_full() const;
  void _internal_set_piggy_found_full(bool value);
  public:

  // optional bool contracts_unlocked = 15;
  bool has_contracts_unlocked() const;
  private:
  bool _internal_has_contracts_unlocked() const;
  public:
  void clear_contracts_unlocked();
  bool contracts_unlocked() const;
  void set_contracts_unlocked(bool value);
  private:
  bool _internal_contracts_unlocked() const;
  void _internal_set_contracts_unlocked(bool value);
  public:

  // optional bool artifacts_unlocked = 16;
  bool has_artifacts_unlocked() const;
  private:
  bool _internal_has_artifacts_unlocked() const;
  public:
  void clear_artifacts_unlocked();
  bool artifacts_unlocked() const;
  void set_artifacts_unlocked(bool value);
  private:
  bool _internal_artifacts_unlocked() const;
  void _internal_set_artifacts_unlocked(bool value);
  public:

  // optional uint32 current_client_version = 10;
  bool has_current_client_version() const;
  private:
  bool _internal_has_current_client_version() const;
  public:
  void clear_current_client_version();
  uint32_t current_client_version() const;
  void set_current_client_version(uint32_t value);
  private:
  uint32_t _internal_current_client_version() const;
  void _internal_set_current_client_version(uint32_t value);
  public:

  // optional bool debug = 11;
  bool has_debug() const;
  private:
  bool _internal_has_debug() const;
  public:
  void clear_debug();
  bool debug() const;
  void set_debug(bool value);
  private:
  bool _internal_debug() const;
  void _internal_set_debug(bool value);
  public:

  // optional double mystical_earnings_mult = 13;
  bool has_mystical_earnings_mult() const;
  private:
  bool _internal_has_mystical_earnings_mult() const;
  public:
  void clear_mystical_earnings_mult();
  double mystical_earnings_mult() const;
  void set_mystical_earnings_mult(double value);
  private:
  double _internal_mystical_earnings_mult() const;
  void _internal_set_mystical_earnings_mult(double value);
  public:

  // optional uint32 eop = 14;
  bool has_eop() const;
  private:
  bool _internal_has_eop() const;
  public:
  void clear_eop();
  uint32_t eop() const;
  void set_eop(uint32_t value);
  private:
  uint32_t _internal_eop() const;
  void _internal_set_eop(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.GetPeriodicalsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::ei::BasicRequestInfo* rinfo_;
  double seconds_full_realtime_;
  double seconds_full_gametime_;
  double soul_eggs_;
  uint32_t lost_increments_;
  bool piggy_full_;
  bool piggy_found_full_;
  bool contracts_unlocked_;
  bool artifacts_unlocked_;
  uint32_t current_client_version_;
  bool debug_;
  double mystical_earnings_mult_;
  uint32_t eop_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ConfigRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ConfigRequest) */ {
 public:
  inline ConfigRequest() : ConfigRequest(nullptr) {}
  ~ConfigRequest() override;
  explicit constexpr ConfigRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigRequest(const ConfigRequest& from);
  ConfigRequest(ConfigRequest&& from) noexcept
    : ConfigRequest() {
    *this = ::std::move(from);
  }

  inline ConfigRequest& operator=(const ConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigRequest& operator=(ConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigRequest* internal_default_instance() {
    return reinterpret_cast<const ConfigRequest*>(
               &_ConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  friend void swap(ConfigRequest& a, ConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ConfigRequest";
  }
  protected:
  explicit ConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRinfoFieldNumber = 1,
    kSoulEggsFieldNumber = 2,
    kArtifactsEnabledFieldNumber = 3,
    kFuelTankUnlockedFieldNumber = 4,
  };
  // optional .ei.BasicRequestInfo rinfo = 1;
  bool has_rinfo() const;
  private:
  bool _internal_has_rinfo() const;
  public:
  void clear_rinfo();
  const ::ei::BasicRequestInfo& rinfo() const;
  PROTOBUF_NODISCARD ::ei::BasicRequestInfo* release_rinfo();
  ::ei::BasicRequestInfo* mutable_rinfo();
  void set_allocated_rinfo(::ei::BasicRequestInfo* rinfo);
  private:
  const ::ei::BasicRequestInfo& _internal_rinfo() const;
  ::ei::BasicRequestInfo* _internal_mutable_rinfo();
  public:
  void unsafe_arena_set_allocated_rinfo(
      ::ei::BasicRequestInfo* rinfo);
  ::ei::BasicRequestInfo* unsafe_arena_release_rinfo();

  // optional double soul_eggs = 2;
  bool has_soul_eggs() const;
  private:
  bool _internal_has_soul_eggs() const;
  public:
  void clear_soul_eggs();
  double soul_eggs() const;
  void set_soul_eggs(double value);
  private:
  double _internal_soul_eggs() const;
  void _internal_set_soul_eggs(double value);
  public:

  // optional bool artifacts_enabled = 3;
  bool has_artifacts_enabled() const;
  private:
  bool _internal_has_artifacts_enabled() const;
  public:
  void clear_artifacts_enabled();
  bool artifacts_enabled() const;
  void set_artifacts_enabled(bool value);
  private:
  bool _internal_artifacts_enabled() const;
  void _internal_set_artifacts_enabled(bool value);
  public:

  // optional bool fuel_tank_unlocked = 4;
  bool has_fuel_tank_unlocked() const;
  private:
  bool _internal_has_fuel_tank_unlocked() const;
  public:
  void clear_fuel_tank_unlocked();
  bool fuel_tank_unlocked() const;
  void set_fuel_tank_unlocked(bool value);
  private:
  bool _internal_fuel_tank_unlocked() const;
  void _internal_set_fuel_tank_unlocked(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ConfigRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ei::BasicRequestInfo* rinfo_;
  double soul_eggs_;
  bool artifacts_enabled_;
  bool fuel_tank_unlocked_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ConfigResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ConfigResponse) */ {
 public:
  inline ConfigResponse() : ConfigResponse(nullptr) {}
  ~ConfigResponse() override;
  explicit constexpr ConfigResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigResponse(const ConfigResponse& from);
  ConfigResponse(ConfigResponse&& from) noexcept
    : ConfigResponse() {
    *this = ::std::move(from);
  }

  inline ConfigResponse& operator=(const ConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigResponse& operator=(ConfigResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigResponse* internal_default_instance() {
    return reinterpret_cast<const ConfigResponse*>(
               &_ConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(ConfigResponse& a, ConfigResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ConfigResponse";
  }
  protected:
  explicit ConfigResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLiveConfigFieldNumber = 1,
    kMailBagFieldNumber = 2,
    kDlcCatalogFieldNumber = 3,
  };
  // optional .ei.LiveConfig live_config = 1;
  bool has_live_config() const;
  private:
  bool _internal_has_live_config() const;
  public:
  void clear_live_config();
  const ::ei::LiveConfig& live_config() const;
  PROTOBUF_NODISCARD ::ei::LiveConfig* release_live_config();
  ::ei::LiveConfig* mutable_live_config();
  void set_allocated_live_config(::ei::LiveConfig* live_config);
  private:
  const ::ei::LiveConfig& _internal_live_config() const;
  ::ei::LiveConfig* _internal_mutable_live_config();
  public:
  void unsafe_arena_set_allocated_live_config(
      ::ei::LiveConfig* live_config);
  ::ei::LiveConfig* unsafe_arena_release_live_config();

  // optional .ei.MailDB mail_bag = 2;
  bool has_mail_bag() const;
  private:
  bool _internal_has_mail_bag() const;
  public:
  void clear_mail_bag();
  const ::ei::MailDB& mail_bag() const;
  PROTOBUF_NODISCARD ::ei::MailDB* release_mail_bag();
  ::ei::MailDB* mutable_mail_bag();
  void set_allocated_mail_bag(::ei::MailDB* mail_bag);
  private:
  const ::ei::MailDB& _internal_mail_bag() const;
  ::ei::MailDB* _internal_mutable_mail_bag();
  public:
  void unsafe_arena_set_allocated_mail_bag(
      ::ei::MailDB* mail_bag);
  ::ei::MailDB* unsafe_arena_release_mail_bag();

  // optional .ei.DLCCatalog dlc_catalog = 3;
  bool has_dlc_catalog() const;
  private:
  bool _internal_has_dlc_catalog() const;
  public:
  void clear_dlc_catalog();
  const ::ei::DLCCatalog& dlc_catalog() const;
  PROTOBUF_NODISCARD ::ei::DLCCatalog* release_dlc_catalog();
  ::ei::DLCCatalog* mutable_dlc_catalog();
  void set_allocated_dlc_catalog(::ei::DLCCatalog* dlc_catalog);
  private:
  const ::ei::DLCCatalog& _internal_dlc_catalog() const;
  ::ei::DLCCatalog* _internal_mutable_dlc_catalog();
  public:
  void unsafe_arena_set_allocated_dlc_catalog(
      ::ei::DLCCatalog* dlc_catalog);
  ::ei::DLCCatalog* unsafe_arena_release_dlc_catalog();

  // @@protoc_insertion_point(class_scope:ei.ConfigResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ei::LiveConfig* live_config_;
  ::ei::MailDB* mail_bag_;
  ::ei::DLCCatalog* dlc_catalog_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class AdAttributionRawData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.AdAttributionRawData) */ {
 public:
  inline AdAttributionRawData() : AdAttributionRawData(nullptr) {}
  ~AdAttributionRawData() override;
  explicit constexpr AdAttributionRawData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdAttributionRawData(const AdAttributionRawData& from);
  AdAttributionRawData(AdAttributionRawData&& from) noexcept
    : AdAttributionRawData() {
    *this = ::std::move(from);
  }

  inline AdAttributionRawData& operator=(const AdAttributionRawData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdAttributionRawData& operator=(AdAttributionRawData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdAttributionRawData& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdAttributionRawData* internal_default_instance() {
    return reinterpret_cast<const AdAttributionRawData*>(
               &_AdAttributionRawData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(AdAttributionRawData& a, AdAttributionRawData& b) {
    a.Swap(&b);
  }
  inline void Swap(AdAttributionRawData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdAttributionRawData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdAttributionRawData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdAttributionRawData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AdAttributionRawData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AdAttributionRawData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdAttributionRawData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.AdAttributionRawData";
  }
  protected:
  explicit AdAttributionRawData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceAdIdFieldNumber = 1,
    kAdNetworkFieldNumber = 2,
    kJsonDataFieldNumber = 3,
    kUserIdFieldNumber = 4,
  };
  // optional string device_ad_id = 1;
  bool has_device_ad_id() const;
  private:
  bool _internal_has_device_ad_id() const;
  public:
  void clear_device_ad_id();
  const std::string& device_ad_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_ad_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_ad_id();
  PROTOBUF_NODISCARD std::string* release_device_ad_id();
  void set_allocated_device_ad_id(std::string* device_ad_id);
  private:
  const std::string& _internal_device_ad_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_ad_id(const std::string& value);
  std::string* _internal_mutable_device_ad_id();
  public:

  // optional string ad_network = 2;
  bool has_ad_network() const;
  private:
  bool _internal_has_ad_network() const;
  public:
  void clear_ad_network();
  const std::string& ad_network() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ad_network(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ad_network();
  PROTOBUF_NODISCARD std::string* release_ad_network();
  void set_allocated_ad_network(std::string* ad_network);
  private:
  const std::string& _internal_ad_network() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ad_network(const std::string& value);
  std::string* _internal_mutable_ad_network();
  public:

  // optional string json_data = 3;
  bool has_json_data() const;
  private:
  bool _internal_has_json_data() const;
  public:
  void clear_json_data();
  const std::string& json_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_json_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_json_data();
  PROTOBUF_NODISCARD std::string* release_json_data();
  void set_allocated_json_data(std::string* json_data);
  private:
  const std::string& _internal_json_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_json_data(const std::string& value);
  std::string* _internal_mutable_json_data();
  public:

  // optional string user_id = 4;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // @@protoc_insertion_point(class_scope:ei.AdAttributionRawData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_ad_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ad_network_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr json_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class AdAttributionRow final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.AdAttributionRow) */ {
 public:
  inline AdAttributionRow() : AdAttributionRow(nullptr) {}
  ~AdAttributionRow() override;
  explicit constexpr AdAttributionRow(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdAttributionRow(const AdAttributionRow& from);
  AdAttributionRow(AdAttributionRow&& from) noexcept
    : AdAttributionRow() {
    *this = ::std::move(from);
  }

  inline AdAttributionRow& operator=(const AdAttributionRow& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdAttributionRow& operator=(AdAttributionRow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdAttributionRow& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdAttributionRow* internal_default_instance() {
    return reinterpret_cast<const AdAttributionRow*>(
               &_AdAttributionRow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(AdAttributionRow& a, AdAttributionRow& b) {
    a.Swap(&b);
  }
  inline void Swap(AdAttributionRow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdAttributionRow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdAttributionRow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdAttributionRow>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AdAttributionRow& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AdAttributionRow& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdAttributionRow* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.AdAttributionRow";
  }
  protected:
  explicit AdAttributionRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kAdIdFieldNumber = 2,
    kAdNetworkFieldNumber = 3,
    kCampaignFieldNumber = 4,
    kKeywordFieldNumber = 5,
    kExtraFieldNumber = 6,
    kClickDateFieldNumber = 7,
    kDownloadDateFieldNumber = 8,
    kApproxTimeFieldNumber = 9,
  };
  // optional string user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // optional string ad_id = 2;
  bool has_ad_id() const;
  private:
  bool _internal_has_ad_id() const;
  public:
  void clear_ad_id();
  const std::string& ad_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ad_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ad_id();
  PROTOBUF_NODISCARD std::string* release_ad_id();
  void set_allocated_ad_id(std::string* ad_id);
  private:
  const std::string& _internal_ad_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ad_id(const std::string& value);
  std::string* _internal_mutable_ad_id();
  public:

  // optional string ad_network = 3;
  bool has_ad_network() const;
  private:
  bool _internal_has_ad_network() const;
  public:
  void clear_ad_network();
  const std::string& ad_network() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ad_network(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ad_network();
  PROTOBUF_NODISCARD std::string* release_ad_network();
  void set_allocated_ad_network(std::string* ad_network);
  private:
  const std::string& _internal_ad_network() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ad_network(const std::string& value);
  std::string* _internal_mutable_ad_network();
  public:

  // optional string campaign = 4;
  bool has_campaign() const;
  private:
  bool _internal_has_campaign() const;
  public:
  void clear_campaign();
  const std::string& campaign() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_campaign(ArgT0&& arg0, ArgT... args);
  std::string* mutable_campaign();
  PROTOBUF_NODISCARD std::string* release_campaign();
  void set_allocated_campaign(std::string* campaign);
  private:
  const std::string& _internal_campaign() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_campaign(const std::string& value);
  std::string* _internal_mutable_campaign();
  public:

  // optional string keyword = 5;
  bool has_keyword() const;
  private:
  bool _internal_has_keyword() const;
  public:
  void clear_keyword();
  const std::string& keyword() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_keyword(ArgT0&& arg0, ArgT... args);
  std::string* mutable_keyword();
  PROTOBUF_NODISCARD std::string* release_keyword();
  void set_allocated_keyword(std::string* keyword);
  private:
  const std::string& _internal_keyword() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_keyword(const std::string& value);
  std::string* _internal_mutable_keyword();
  public:

  // optional string extra = 6;
  bool has_extra() const;
  private:
  bool _internal_has_extra() const;
  public:
  void clear_extra();
  const std::string& extra() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extra(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extra();
  PROTOBUF_NODISCARD std::string* release_extra();
  void set_allocated_extra(std::string* extra);
  private:
  const std::string& _internal_extra() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extra(const std::string& value);
  std::string* _internal_mutable_extra();
  public:

  // optional float click_date = 7;
  bool has_click_date() const;
  private:
  bool _internal_has_click_date() const;
  public:
  void clear_click_date();
  float click_date() const;
  void set_click_date(float value);
  private:
  float _internal_click_date() const;
  void _internal_set_click_date(float value);
  public:

  // optional float download_date = 8;
  bool has_download_date() const;
  private:
  bool _internal_has_download_date() const;
  public:
  void clear_download_date();
  float download_date() const;
  void set_download_date(float value);
  private:
  float _internal_download_date() const;
  void _internal_set_download_date(float value);
  public:

  // optional float approx_time = 9;
  bool has_approx_time() const;
  private:
  bool _internal_has_approx_time() const;
  public:
  void clear_approx_time();
  float approx_time() const;
  void set_approx_time(float value);
  private:
  float _internal_approx_time() const;
  void _internal_set_approx_time(float value);
  public:

  // @@protoc_insertion_point(class_scope:ei.AdAttributionRow)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ad_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ad_network_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr campaign_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr keyword_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extra_;
  float click_date_;
  float download_date_;
  float approx_time_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class AdAttributionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.AdAttributionInfo) */ {
 public:
  inline AdAttributionInfo() : AdAttributionInfo(nullptr) {}
  ~AdAttributionInfo() override;
  explicit constexpr AdAttributionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdAttributionInfo(const AdAttributionInfo& from);
  AdAttributionInfo(AdAttributionInfo&& from) noexcept
    : AdAttributionInfo() {
    *this = ::std::move(from);
  }

  inline AdAttributionInfo& operator=(const AdAttributionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdAttributionInfo& operator=(AdAttributionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdAttributionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdAttributionInfo* internal_default_instance() {
    return reinterpret_cast<const AdAttributionInfo*>(
               &_AdAttributionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(AdAttributionInfo& a, AdAttributionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AdAttributionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdAttributionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdAttributionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdAttributionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AdAttributionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AdAttributionInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdAttributionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.AdAttributionInfo";
  }
  protected:
  explicit AdAttributionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceAdIdFieldNumber = 1,
    kNetworkNameFieldNumber = 2,
    kOrgNameFieldNumber = 4,
    kOrgIdFieldNumber = 5,
    kCampaignNameFieldNumber = 6,
    kCampaignIdFieldNumber = 7,
    kClickDateFieldNumber = 8,
    kConversionDateFieldNumber = 9,
    kConversionTypeFieldNumber = 10,
    kGeoFieldNumber = 11,
    kAdgroupNameFieldNumber = 12,
    kAdgroupIdFieldNumber = 13,
    kKeywordFieldNumber = 14,
    kKeywordIdFieldNumber = 15,
    kKeywordExtraFieldNumber = 16,
    kCreativesetNameFieldNumber = 17,
    kCreativesetIdFieldNumber = 18,
    kAttributionFieldNumber = 3,
  };
  // optional string device_ad_id = 1;
  bool has_device_ad_id() const;
  private:
  bool _internal_has_device_ad_id() const;
  public:
  void clear_device_ad_id();
  const std::string& device_ad_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_ad_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_ad_id();
  PROTOBUF_NODISCARD std::string* release_device_ad_id();
  void set_allocated_device_ad_id(std::string* device_ad_id);
  private:
  const std::string& _internal_device_ad_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_ad_id(const std::string& value);
  std::string* _internal_mutable_device_ad_id();
  public:

  // optional string network_name = 2;
  bool has_network_name() const;
  private:
  bool _internal_has_network_name() const;
  public:
  void clear_network_name();
  const std::string& network_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_network_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_network_name();
  PROTOBUF_NODISCARD std::string* release_network_name();
  void set_allocated_network_name(std::string* network_name);
  private:
  const std::string& _internal_network_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_network_name(const std::string& value);
  std::string* _internal_mutable_network_name();
  public:

  // optional string org_name = 4;
  bool has_org_name() const;
  private:
  bool _internal_has_org_name() const;
  public:
  void clear_org_name();
  const std::string& org_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_name();
  PROTOBUF_NODISCARD std::string* release_org_name();
  void set_allocated_org_name(std::string* org_name);
  private:
  const std::string& _internal_org_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_name(const std::string& value);
  std::string* _internal_mutable_org_name();
  public:

  // optional string org_id = 5;
  bool has_org_id() const;
  private:
  bool _internal_has_org_id() const;
  public:
  void clear_org_id();
  const std::string& org_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* org_id);
  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(const std::string& value);
  std::string* _internal_mutable_org_id();
  public:

  // optional string campaign_name = 6;
  bool has_campaign_name() const;
  private:
  bool _internal_has_campaign_name() const;
  public:
  void clear_campaign_name();
  const std::string& campaign_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_campaign_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_campaign_name();
  PROTOBUF_NODISCARD std::string* release_campaign_name();
  void set_allocated_campaign_name(std::string* campaign_name);
  private:
  const std::string& _internal_campaign_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_campaign_name(const std::string& value);
  std::string* _internal_mutable_campaign_name();
  public:

  // optional string campaign_id = 7;
  bool has_campaign_id() const;
  private:
  bool _internal_has_campaign_id() const;
  public:
  void clear_campaign_id();
  const std::string& campaign_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_campaign_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_campaign_id();
  PROTOBUF_NODISCARD std::string* release_campaign_id();
  void set_allocated_campaign_id(std::string* campaign_id);
  private:
  const std::string& _internal_campaign_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_campaign_id(const std::string& value);
  std::string* _internal_mutable_campaign_id();
  public:

  // optional string click_date = 8;
  bool has_click_date() const;
  private:
  bool _internal_has_click_date() const;
  public:
  void clear_click_date();
  const std::string& click_date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_click_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_click_date();
  PROTOBUF_NODISCARD std::string* release_click_date();
  void set_allocated_click_date(std::string* click_date);
  private:
  const std::string& _internal_click_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_click_date(const std::string& value);
  std::string* _internal_mutable_click_date();
  public:

  // optional string conversion_date = 9;
  bool has_conversion_date() const;
  private:
  bool _internal_has_conversion_date() const;
  public:
  void clear_conversion_date();
  const std::string& conversion_date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversion_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversion_date();
  PROTOBUF_NODISCARD std::string* release_conversion_date();
  void set_allocated_conversion_date(std::string* conversion_date);
  private:
  const std::string& _internal_conversion_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversion_date(const std::string& value);
  std::string* _internal_mutable_conversion_date();
  public:

  // optional string conversion_type = 10;
  bool has_conversion_type() const;
  private:
  bool _internal_has_conversion_type() const;
  public:
  void clear_conversion_type();
  const std::string& conversion_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversion_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversion_type();
  PROTOBUF_NODISCARD std::string* release_conversion_type();
  void set_allocated_conversion_type(std::string* conversion_type);
  private:
  const std::string& _internal_conversion_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversion_type(const std::string& value);
  std::string* _internal_mutable_conversion_type();
  public:

  // optional string geo = 11;
  bool has_geo() const;
  private:
  bool _internal_has_geo() const;
  public:
  void clear_geo();
  const std::string& geo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_geo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_geo();
  PROTOBUF_NODISCARD std::string* release_geo();
  void set_allocated_geo(std::string* geo);
  private:
  const std::string& _internal_geo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_geo(const std::string& value);
  std::string* _internal_mutable_geo();
  public:

  // optional string adgroup_name = 12;
  bool has_adgroup_name() const;
  private:
  bool _internal_has_adgroup_name() const;
  public:
  void clear_adgroup_name();
  const std::string& adgroup_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_adgroup_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_adgroup_name();
  PROTOBUF_NODISCARD std::string* release_adgroup_name();
  void set_allocated_adgroup_name(std::string* adgroup_name);
  private:
  const std::string& _internal_adgroup_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_adgroup_name(const std::string& value);
  std::string* _internal_mutable_adgroup_name();
  public:

  // optional string adgroup_id = 13;
  bool has_adgroup_id() const;
  private:
  bool _internal_has_adgroup_id() const;
  public:
  void clear_adgroup_id();
  const std::string& adgroup_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_adgroup_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_adgroup_id();
  PROTOBUF_NODISCARD std::string* release_adgroup_id();
  void set_allocated_adgroup_id(std::string* adgroup_id);
  private:
  const std::string& _internal_adgroup_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_adgroup_id(const std::string& value);
  std::string* _internal_mutable_adgroup_id();
  public:

  // optional string keyword = 14;
  bool has_keyword() const;
  private:
  bool _internal_has_keyword() const;
  public:
  void clear_keyword();
  const std::string& keyword() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_keyword(ArgT0&& arg0, ArgT... args);
  std::string* mutable_keyword();
  PROTOBUF_NODISCARD std::string* release_keyword();
  void set_allocated_keyword(std::string* keyword);
  private:
  const std::string& _internal_keyword() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_keyword(const std::string& value);
  std::string* _internal_mutable_keyword();
  public:

  // optional string keyword_id = 15;
  bool has_keyword_id() const;
  private:
  bool _internal_has_keyword_id() const;
  public:
  void clear_keyword_id();
  const std::string& keyword_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_keyword_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_keyword_id();
  PROTOBUF_NODISCARD std::string* release_keyword_id();
  void set_allocated_keyword_id(std::string* keyword_id);
  private:
  const std::string& _internal_keyword_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_keyword_id(const std::string& value);
  std::string* _internal_mutable_keyword_id();
  public:

  // optional string keyword_extra = 16;
  bool has_keyword_extra() const;
  private:
  bool _internal_has_keyword_extra() const;
  public:
  void clear_keyword_extra();
  const std::string& keyword_extra() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_keyword_extra(ArgT0&& arg0, ArgT... args);
  std::string* mutable_keyword_extra();
  PROTOBUF_NODISCARD std::string* release_keyword_extra();
  void set_allocated_keyword_extra(std::string* keyword_extra);
  private:
  const std::string& _internal_keyword_extra() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_keyword_extra(const std::string& value);
  std::string* _internal_mutable_keyword_extra();
  public:

  // optional string creativeset_name = 17;
  bool has_creativeset_name() const;
  private:
  bool _internal_has_creativeset_name() const;
  public:
  void clear_creativeset_name();
  const std::string& creativeset_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creativeset_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creativeset_name();
  PROTOBUF_NODISCARD std::string* release_creativeset_name();
  void set_allocated_creativeset_name(std::string* creativeset_name);
  private:
  const std::string& _internal_creativeset_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creativeset_name(const std::string& value);
  std::string* _internal_mutable_creativeset_name();
  public:

  // optional string creativeset_id = 18;
  bool has_creativeset_id() const;
  private:
  bool _internal_has_creativeset_id() const;
  public:
  void clear_creativeset_id();
  const std::string& creativeset_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creativeset_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creativeset_id();
  PROTOBUF_NODISCARD std::string* release_creativeset_id();
  void set_allocated_creativeset_id(std::string* creativeset_id);
  private:
  const std::string& _internal_creativeset_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creativeset_id(const std::string& value);
  std::string* _internal_mutable_creativeset_id();
  public:

  // optional bool attribution = 3;
  bool has_attribution() const;
  private:
  bool _internal_has_attribution() const;
  public:
  void clear_attribution();
  bool attribution() const;
  void set_attribution(bool value);
  private:
  bool _internal_attribution() const;
  void _internal_set_attribution(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ei.AdAttributionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_ad_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr network_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr campaign_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr campaign_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr click_date_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversion_date_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversion_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr geo_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr adgroup_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr adgroup_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr keyword_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr keyword_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr keyword_extra_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creativeset_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creativeset_id_;
  bool attribution_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ArtifactsClientInfo_LaunchCount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ArtifactsClientInfo.LaunchCount) */ {
 public:
  inline ArtifactsClientInfo_LaunchCount() : ArtifactsClientInfo_LaunchCount(nullptr) {}
  ~ArtifactsClientInfo_LaunchCount() override;
  explicit constexpr ArtifactsClientInfo_LaunchCount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArtifactsClientInfo_LaunchCount(const ArtifactsClientInfo_LaunchCount& from);
  ArtifactsClientInfo_LaunchCount(ArtifactsClientInfo_LaunchCount&& from) noexcept
    : ArtifactsClientInfo_LaunchCount() {
    *this = ::std::move(from);
  }

  inline ArtifactsClientInfo_LaunchCount& operator=(const ArtifactsClientInfo_LaunchCount& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArtifactsClientInfo_LaunchCount& operator=(ArtifactsClientInfo_LaunchCount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArtifactsClientInfo_LaunchCount& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArtifactsClientInfo_LaunchCount* internal_default_instance() {
    return reinterpret_cast<const ArtifactsClientInfo_LaunchCount*>(
               &_ArtifactsClientInfo_LaunchCount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  friend void swap(ArtifactsClientInfo_LaunchCount& a, ArtifactsClientInfo_LaunchCount& b) {
    a.Swap(&b);
  }
  inline void Swap(ArtifactsClientInfo_LaunchCount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArtifactsClientInfo_LaunchCount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArtifactsClientInfo_LaunchCount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArtifactsClientInfo_LaunchCount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArtifactsClientInfo_LaunchCount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ArtifactsClientInfo_LaunchCount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactsClientInfo_LaunchCount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ArtifactsClientInfo.LaunchCount";
  }
  protected:
  explicit ArtifactsClientInfo_LaunchCount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShipFieldNumber = 1,
    kNumLaunchesFieldNumber = 2,
    kLaunchPointsFieldNumber = 3,
  };
  // optional .ei.MissionInfo.Spaceship ship = 1;
  bool has_ship() const;
  private:
  bool _internal_has_ship() const;
  public:
  void clear_ship();
  ::ei::MissionInfo_Spaceship ship() const;
  void set_ship(::ei::MissionInfo_Spaceship value);
  private:
  ::ei::MissionInfo_Spaceship _internal_ship() const;
  void _internal_set_ship(::ei::MissionInfo_Spaceship value);
  public:

  // optional uint32 num_launches = 2;
  bool has_num_launches() const;
  private:
  bool _internal_has_num_launches() const;
  public:
  void clear_num_launches();
  uint32_t num_launches() const;
  void set_num_launches(uint32_t value);
  private:
  uint32_t _internal_num_launches() const;
  void _internal_set_num_launches(uint32_t value);
  public:

  // optional double launch_points = 3;
  bool has_launch_points() const;
  private:
  bool _internal_has_launch_points() const;
  public:
  void clear_launch_points();
  double launch_points() const;
  void set_launch_points(double value);
  private:
  double _internal_launch_points() const;
  void _internal_set_launch_points(double value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ArtifactsClientInfo.LaunchCount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int ship_;
  uint32_t num_launches_;
  double launch_points_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ArtifactsClientInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ArtifactsClientInfo) */ {
 public:
  inline ArtifactsClientInfo() : ArtifactsClientInfo(nullptr) {}
  ~ArtifactsClientInfo() override;
  explicit constexpr ArtifactsClientInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArtifactsClientInfo(const ArtifactsClientInfo& from);
  ArtifactsClientInfo(ArtifactsClientInfo&& from) noexcept
    : ArtifactsClientInfo() {
    *this = ::std::move(from);
  }

  inline ArtifactsClientInfo& operator=(const ArtifactsClientInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArtifactsClientInfo& operator=(ArtifactsClientInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArtifactsClientInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArtifactsClientInfo* internal_default_instance() {
    return reinterpret_cast<const ArtifactsClientInfo*>(
               &_ArtifactsClientInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  friend void swap(ArtifactsClientInfo& a, ArtifactsClientInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ArtifactsClientInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArtifactsClientInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArtifactsClientInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArtifactsClientInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArtifactsClientInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ArtifactsClientInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactsClientInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ArtifactsClientInfo";
  }
  protected:
  explicit ArtifactsClientInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ArtifactsClientInfo_LaunchCount LaunchCount;

  // accessors -------------------------------------------------------

  enum : int {
    kLaunchCountsFieldNumber = 3,
    kMissionCapacityMultFieldNumber = 1,
    kMissionDurationMultFieldNumber = 2,
    kMissionFtlDurationMultFieldNumber = 4,
  };
  // repeated .ei.ArtifactsClientInfo.LaunchCount launch_counts = 3;
  int launch_counts_size() const;
  private:
  int _internal_launch_counts_size() const;
  public:
  void clear_launch_counts();
  ::ei::ArtifactsClientInfo_LaunchCount* mutable_launch_counts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsClientInfo_LaunchCount >*
      mutable_launch_counts();
  private:
  const ::ei::ArtifactsClientInfo_LaunchCount& _internal_launch_counts(int index) const;
  ::ei::ArtifactsClientInfo_LaunchCount* _internal_add_launch_counts();
  public:
  const ::ei::ArtifactsClientInfo_LaunchCount& launch_counts(int index) const;
  ::ei::ArtifactsClientInfo_LaunchCount* add_launch_counts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsClientInfo_LaunchCount >&
      launch_counts() const;

  // optional double mission_capacity_mult = 1;
  bool has_mission_capacity_mult() const;
  private:
  bool _internal_has_mission_capacity_mult() const;
  public:
  void clear_mission_capacity_mult();
  double mission_capacity_mult() const;
  void set_mission_capacity_mult(double value);
  private:
  double _internal_mission_capacity_mult() const;
  void _internal_set_mission_capacity_mult(double value);
  public:

  // optional double mission_duration_mult = 2;
  bool has_mission_duration_mult() const;
  private:
  bool _internal_has_mission_duration_mult() const;
  public:
  void clear_mission_duration_mult();
  double mission_duration_mult() const;
  void set_mission_duration_mult(double value);
  private:
  double _internal_mission_duration_mult() const;
  void _internal_set_mission_duration_mult(double value);
  public:

  // optional double mission_ftl_duration_mult = 4;
  bool has_mission_ftl_duration_mult() const;
  private:
  bool _internal_has_mission_ftl_duration_mult() const;
  public:
  void clear_mission_ftl_duration_mult();
  double mission_ftl_duration_mult() const;
  void set_mission_ftl_duration_mult(double value);
  private:
  double _internal_mission_ftl_duration_mult() const;
  void _internal_set_mission_ftl_duration_mult(double value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ArtifactsClientInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsClientInfo_LaunchCount > launch_counts_;
  double mission_capacity_mult_;
  double mission_duration_mult_;
  double mission_ftl_duration_mult_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class MissionInfo_Fuel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.MissionInfo.Fuel) */ {
 public:
  inline MissionInfo_Fuel() : MissionInfo_Fuel(nullptr) {}
  ~MissionInfo_Fuel() override;
  explicit constexpr MissionInfo_Fuel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MissionInfo_Fuel(const MissionInfo_Fuel& from);
  MissionInfo_Fuel(MissionInfo_Fuel&& from) noexcept
    : MissionInfo_Fuel() {
    *this = ::std::move(from);
  }

  inline MissionInfo_Fuel& operator=(const MissionInfo_Fuel& from) {
    CopyFrom(from);
    return *this;
  }
  inline MissionInfo_Fuel& operator=(MissionInfo_Fuel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MissionInfo_Fuel& default_instance() {
    return *internal_default_instance();
  }
  static inline const MissionInfo_Fuel* internal_default_instance() {
    return reinterpret_cast<const MissionInfo_Fuel*>(
               &_MissionInfo_Fuel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  friend void swap(MissionInfo_Fuel& a, MissionInfo_Fuel& b) {
    a.Swap(&b);
  }
  inline void Swap(MissionInfo_Fuel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MissionInfo_Fuel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MissionInfo_Fuel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MissionInfo_Fuel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MissionInfo_Fuel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MissionInfo_Fuel& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MissionInfo_Fuel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.MissionInfo.Fuel";
  }
  protected:
  explicit MissionInfo_Fuel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAmountFieldNumber = 2,
    kEggFieldNumber = 1,
  };
  // optional double amount = 2;
  bool has_amount() const;
  private:
  bool _internal_has_amount() const;
  public:
  void clear_amount();
  double amount() const;
  void set_amount(double value);
  private:
  double _internal_amount() const;
  void _internal_set_amount(double value);
  public:

  // optional .ei.Egg egg = 1;
  bool has_egg() const;
  private:
  bool _internal_has_egg() const;
  public:
  void clear_egg();
  ::ei::Egg egg() const;
  void set_egg(::ei::Egg value);
  private:
  ::ei::Egg _internal_egg() const;
  void _internal_set_egg(::ei::Egg value);
  public:

  // @@protoc_insertion_point(class_scope:ei.MissionInfo.Fuel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double amount_;
  int egg_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class MissionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.MissionInfo) */ {
 public:
  inline MissionInfo() : MissionInfo(nullptr) {}
  ~MissionInfo() override;
  explicit constexpr MissionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MissionInfo(const MissionInfo& from);
  MissionInfo(MissionInfo&& from) noexcept
    : MissionInfo() {
    *this = ::std::move(from);
  }

  inline MissionInfo& operator=(const MissionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MissionInfo& operator=(MissionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MissionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MissionInfo* internal_default_instance() {
    return reinterpret_cast<const MissionInfo*>(
               &_MissionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    92;

  friend void swap(MissionInfo& a, MissionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MissionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MissionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MissionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MissionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MissionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MissionInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MissionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.MissionInfo";
  }
  protected:
  explicit MissionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MissionInfo_Fuel Fuel;

  typedef MissionInfo_Spaceship Spaceship;
  static constexpr Spaceship CHICKEN_ONE =
    MissionInfo_Spaceship_CHICKEN_ONE;
  static constexpr Spaceship CHICKEN_NINE =
    MissionInfo_Spaceship_CHICKEN_NINE;
  static constexpr Spaceship CHICKEN_HEAVY =
    MissionInfo_Spaceship_CHICKEN_HEAVY;
  static constexpr Spaceship BCR =
    MissionInfo_Spaceship_BCR;
  static constexpr Spaceship MILLENIUM_CHICKEN =
    MissionInfo_Spaceship_MILLENIUM_CHICKEN;
  static constexpr Spaceship CORELLIHEN_CORVETTE =
    MissionInfo_Spaceship_CORELLIHEN_CORVETTE;
  static constexpr Spaceship GALEGGTICA =
    MissionInfo_Spaceship_GALEGGTICA;
  static constexpr Spaceship CHICKFIANT =
    MissionInfo_Spaceship_CHICKFIANT;
  static constexpr Spaceship VOYEGGER =
    MissionInfo_Spaceship_VOYEGGER;
  static constexpr Spaceship HENERPRISE =
    MissionInfo_Spaceship_HENERPRISE;
  static inline bool Spaceship_IsValid(int value) {
    return MissionInfo_Spaceship_IsValid(value);
  }
  static constexpr Spaceship Spaceship_MIN =
    MissionInfo_Spaceship_Spaceship_MIN;
  static constexpr Spaceship Spaceship_MAX =
    MissionInfo_Spaceship_Spaceship_MAX;
  static constexpr int Spaceship_ARRAYSIZE =
    MissionInfo_Spaceship_Spaceship_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Spaceship_descriptor() {
    return MissionInfo_Spaceship_descriptor();
  }
  template<typename T>
  static inline const std::string& Spaceship_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Spaceship>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Spaceship_Name.");
    return MissionInfo_Spaceship_Name(enum_t_value);
  }
  static inline bool Spaceship_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Spaceship* value) {
    return MissionInfo_Spaceship_Parse(name, value);
  }

  typedef MissionInfo_Status Status;
  static constexpr Status FUELING =
    MissionInfo_Status_FUELING;
  static constexpr Status PREPARE_TO_LAUNCH =
    MissionInfo_Status_PREPARE_TO_LAUNCH;
  static constexpr Status EXPLORING =
    MissionInfo_Status_EXPLORING;
  static constexpr Status RETURNED =
    MissionInfo_Status_RETURNED;
  static constexpr Status ANALYZING =
    MissionInfo_Status_ANALYZING;
  static constexpr Status COMPLETE =
    MissionInfo_Status_COMPLETE;
  static constexpr Status ARCHIVED =
    MissionInfo_Status_ARCHIVED;
  static inline bool Status_IsValid(int value) {
    return MissionInfo_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    MissionInfo_Status_Status_MIN;
  static constexpr Status Status_MAX =
    MissionInfo_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    MissionInfo_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return MissionInfo_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return MissionInfo_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return MissionInfo_Status_Parse(name, value);
  }

  typedef MissionInfo_DurationType DurationType;
  static constexpr DurationType SHORT =
    MissionInfo_DurationType_SHORT;
  static constexpr DurationType LONG =
    MissionInfo_DurationType_LONG;
  static constexpr DurationType EPIC =
    MissionInfo_DurationType_EPIC;
  static constexpr DurationType TUTORIAL =
    MissionInfo_DurationType_TUTORIAL;
  static inline bool DurationType_IsValid(int value) {
    return MissionInfo_DurationType_IsValid(value);
  }
  static constexpr DurationType DurationType_MIN =
    MissionInfo_DurationType_DurationType_MIN;
  static constexpr DurationType DurationType_MAX =
    MissionInfo_DurationType_DurationType_MAX;
  static constexpr int DurationType_ARRAYSIZE =
    MissionInfo_DurationType_DurationType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DurationType_descriptor() {
    return MissionInfo_DurationType_descriptor();
  }
  template<typename T>
  static inline const std::string& DurationType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DurationType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DurationType_Name.");
    return MissionInfo_DurationType_Name(enum_t_value);
  }
  static inline bool DurationType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DurationType* value) {
    return MissionInfo_DurationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFuelFieldNumber = 4,
    kIdentifierFieldNumber = 7,
    kMissionLogFieldNumber = 10,
    kShipFieldNumber = 1,
    kStatusFieldNumber = 2,
    kDurationSecondsFieldNumber = 5,
    kSecondsRemainingFieldNumber = 6,
    kDurationTypeFieldNumber = 3,
    kCapacityFieldNumber = 9,
    kStartTimeDerivedFieldNumber = 8,
    kQualityBumpFieldNumber = 11,
    kLevelFieldNumber = 12,
  };
  // repeated .ei.MissionInfo.Fuel fuel = 4;
  int fuel_size() const;
  private:
  int _internal_fuel_size() const;
  public:
  void clear_fuel();
  ::ei::MissionInfo_Fuel* mutable_fuel(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::MissionInfo_Fuel >*
      mutable_fuel();
  private:
  const ::ei::MissionInfo_Fuel& _internal_fuel(int index) const;
  ::ei::MissionInfo_Fuel* _internal_add_fuel();
  public:
  const ::ei::MissionInfo_Fuel& fuel(int index) const;
  ::ei::MissionInfo_Fuel* add_fuel();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::MissionInfo_Fuel >&
      fuel() const;

  // optional string identifier = 7;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  PROTOBUF_NODISCARD std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // optional string mission_log = 10;
  bool has_mission_log() const;
  private:
  bool _internal_has_mission_log() const;
  public:
  void clear_mission_log();
  const std::string& mission_log() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mission_log(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mission_log();
  PROTOBUF_NODISCARD std::string* release_mission_log();
  void set_allocated_mission_log(std::string* mission_log);
  private:
  const std::string& _internal_mission_log() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mission_log(const std::string& value);
  std::string* _internal_mutable_mission_log();
  public:

  // optional .ei.MissionInfo.Spaceship ship = 1;
  bool has_ship() const;
  private:
  bool _internal_has_ship() const;
  public:
  void clear_ship();
  ::ei::MissionInfo_Spaceship ship() const;
  void set_ship(::ei::MissionInfo_Spaceship value);
  private:
  ::ei::MissionInfo_Spaceship _internal_ship() const;
  void _internal_set_ship(::ei::MissionInfo_Spaceship value);
  public:

  // optional .ei.MissionInfo.Status status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::ei::MissionInfo_Status status() const;
  void set_status(::ei::MissionInfo_Status value);
  private:
  ::ei::MissionInfo_Status _internal_status() const;
  void _internal_set_status(::ei::MissionInfo_Status value);
  public:

  // optional double duration_seconds = 5;
  bool has_duration_seconds() const;
  private:
  bool _internal_has_duration_seconds() const;
  public:
  void clear_duration_seconds();
  double duration_seconds() const;
  void set_duration_seconds(double value);
  private:
  double _internal_duration_seconds() const;
  void _internal_set_duration_seconds(double value);
  public:

  // optional double seconds_remaining = 6;
  bool has_seconds_remaining() const;
  private:
  bool _internal_has_seconds_remaining() const;
  public:
  void clear_seconds_remaining();
  double seconds_remaining() const;
  void set_seconds_remaining(double value);
  private:
  double _internal_seconds_remaining() const;
  void _internal_set_seconds_remaining(double value);
  public:

  // optional .ei.MissionInfo.DurationType duration_type = 3;
  bool has_duration_type() const;
  private:
  bool _internal_has_duration_type() const;
  public:
  void clear_duration_type();
  ::ei::MissionInfo_DurationType duration_type() const;
  void set_duration_type(::ei::MissionInfo_DurationType value);
  private:
  ::ei::MissionInfo_DurationType _internal_duration_type() const;
  void _internal_set_duration_type(::ei::MissionInfo_DurationType value);
  public:

  // optional uint32 capacity = 9;
  bool has_capacity() const;
  private:
  bool _internal_has_capacity() const;
  public:
  void clear_capacity();
  uint32_t capacity() const;
  void set_capacity(uint32_t value);
  private:
  uint32_t _internal_capacity() const;
  void _internal_set_capacity(uint32_t value);
  public:

  // optional double start_time_derived = 8;
  bool has_start_time_derived() const;
  private:
  bool _internal_has_start_time_derived() const;
  public:
  void clear_start_time_derived();
  double start_time_derived() const;
  void set_start_time_derived(double value);
  private:
  double _internal_start_time_derived() const;
  void _internal_set_start_time_derived(double value);
  public:

  // optional double quality_bump = 11;
  bool has_quality_bump() const;
  private:
  bool _internal_has_quality_bump() const;
  public:
  void clear_quality_bump();
  double quality_bump() const;
  void set_quality_bump(double value);
  private:
  double _internal_quality_bump() const;
  void _internal_set_quality_bump(double value);
  public:

  // optional uint32 level = 12;
  bool has_level() const;
  private:
  bool _internal_has_level() const;
  public:
  void clear_level();
  uint32_t level() const;
  void set_level(uint32_t value);
  private:
  uint32_t _internal_level() const;
  void _internal_set_level(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.MissionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::MissionInfo_Fuel > fuel_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mission_log_;
  int ship_;
  int status_;
  double duration_seconds_;
  double seconds_remaining_;
  int duration_type_;
  uint32_t capacity_;
  double start_time_derived_;
  double quality_bump_;
  uint32_t level_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ArtifactSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ArtifactSpec) */ {
 public:
  inline ArtifactSpec() : ArtifactSpec(nullptr) {}
  ~ArtifactSpec() override;
  explicit constexpr ArtifactSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArtifactSpec(const ArtifactSpec& from);
  ArtifactSpec(ArtifactSpec&& from) noexcept
    : ArtifactSpec() {
    *this = ::std::move(from);
  }

  inline ArtifactSpec& operator=(const ArtifactSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArtifactSpec& operator=(ArtifactSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArtifactSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArtifactSpec* internal_default_instance() {
    return reinterpret_cast<const ArtifactSpec*>(
               &_ArtifactSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    93;

  friend void swap(ArtifactSpec& a, ArtifactSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(ArtifactSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArtifactSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArtifactSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArtifactSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArtifactSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ArtifactSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ArtifactSpec";
  }
  protected:
  explicit ArtifactSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ArtifactSpec_Name Name;
  static constexpr Name LUNAR_TOTEM =
    ArtifactSpec_Name_LUNAR_TOTEM;
  static constexpr Name NEODYMIUM_MEDALLION =
    ArtifactSpec_Name_NEODYMIUM_MEDALLION;
  static constexpr Name BEAK_OF_MIDAS =
    ArtifactSpec_Name_BEAK_OF_MIDAS;
  static constexpr Name LIGHT_OF_EGGENDIL =
    ArtifactSpec_Name_LIGHT_OF_EGGENDIL;
  static constexpr Name DEMETERS_NECKLACE =
    ArtifactSpec_Name_DEMETERS_NECKLACE;
  static constexpr Name VIAL_MARTIAN_DUST =
    ArtifactSpec_Name_VIAL_MARTIAN_DUST;
  static constexpr Name ORNATE_GUSSET =
    ArtifactSpec_Name_ORNATE_GUSSET;
  static constexpr Name THE_CHALICE =
    ArtifactSpec_Name_THE_CHALICE;
  static constexpr Name BOOK_OF_BASAN =
    ArtifactSpec_Name_BOOK_OF_BASAN;
  static constexpr Name PHOENIX_FEATHER =
    ArtifactSpec_Name_PHOENIX_FEATHER;
  static constexpr Name TUNGSTEN_ANKH =
    ArtifactSpec_Name_TUNGSTEN_ANKH;
  static constexpr Name AURELIAN_BROOCH =
    ArtifactSpec_Name_AURELIAN_BROOCH;
  static constexpr Name CARVED_RAINSTICK =
    ArtifactSpec_Name_CARVED_RAINSTICK;
  static constexpr Name PUZZLE_CUBE =
    ArtifactSpec_Name_PUZZLE_CUBE;
  static constexpr Name QUANTUM_METRONOME =
    ArtifactSpec_Name_QUANTUM_METRONOME;
  static constexpr Name SHIP_IN_A_BOTTLE =
    ArtifactSpec_Name_SHIP_IN_A_BOTTLE;
  static constexpr Name TACHYON_DEFLECTOR =
    ArtifactSpec_Name_TACHYON_DEFLECTOR;
  static constexpr Name INTERSTELLAR_COMPASS =
    ArtifactSpec_Name_INTERSTELLAR_COMPASS;
  static constexpr Name DILITHIUM_MONOCLE =
    ArtifactSpec_Name_DILITHIUM_MONOCLE;
  static constexpr Name TITANIUM_ACTUATOR =
    ArtifactSpec_Name_TITANIUM_ACTUATOR;
  static constexpr Name MERCURYS_LENS =
    ArtifactSpec_Name_MERCURYS_LENS;
  static constexpr Name TACHYON_STONE =
    ArtifactSpec_Name_TACHYON_STONE;
  static constexpr Name DILITHIUM_STONE =
    ArtifactSpec_Name_DILITHIUM_STONE;
  static constexpr Name SHELL_STONE =
    ArtifactSpec_Name_SHELL_STONE;
  static constexpr Name LUNAR_STONE =
    ArtifactSpec_Name_LUNAR_STONE;
  static constexpr Name SOUL_STONE =
    ArtifactSpec_Name_SOUL_STONE;
  static constexpr Name PROPHECY_STONE =
    ArtifactSpec_Name_PROPHECY_STONE;
  static constexpr Name QUANTUM_STONE =
    ArtifactSpec_Name_QUANTUM_STONE;
  static constexpr Name TERRA_STONE =
    ArtifactSpec_Name_TERRA_STONE;
  static constexpr Name LIFE_STONE =
    ArtifactSpec_Name_LIFE_STONE;
  static constexpr Name CLARITY_STONE =
    ArtifactSpec_Name_CLARITY_STONE;
  static constexpr Name EXTRATERRESTRIAL_ALUMINUM =
    ArtifactSpec_Name_EXTRATERRESTRIAL_ALUMINUM;
  static constexpr Name ANCIENT_TUNGSTEN =
    ArtifactSpec_Name_ANCIENT_TUNGSTEN;
  static constexpr Name SPACE_ROCKS =
    ArtifactSpec_Name_SPACE_ROCKS;
  static constexpr Name ALIEN_WOOD =
    ArtifactSpec_Name_ALIEN_WOOD;
  static constexpr Name GOLD_METEORITE =
    ArtifactSpec_Name_GOLD_METEORITE;
  static constexpr Name TAU_CETI_GEODE =
    ArtifactSpec_Name_TAU_CETI_GEODE;
  static constexpr Name CENTAURIAN_STEEL =
    ArtifactSpec_Name_CENTAURIAN_STEEL;
  static constexpr Name ERIDANI_FEATHER =
    ArtifactSpec_Name_ERIDANI_FEATHER;
  static constexpr Name DRONE_PARTS =
    ArtifactSpec_Name_DRONE_PARTS;
  static constexpr Name CELESTIAL_BRONZE =
    ArtifactSpec_Name_CELESTIAL_BRONZE;
  static constexpr Name LALANDE_HIDE =
    ArtifactSpec_Name_LALANDE_HIDE;
  static constexpr Name SOLAR_TITANIUM =
    ArtifactSpec_Name_SOLAR_TITANIUM;
  static constexpr Name TACHYON_STONE_FRAGMENT =
    ArtifactSpec_Name_TACHYON_STONE_FRAGMENT;
  static constexpr Name DILITHIUM_STONE_FRAGMENT =
    ArtifactSpec_Name_DILITHIUM_STONE_FRAGMENT;
  static constexpr Name SHELL_STONE_FRAGMENT =
    ArtifactSpec_Name_SHELL_STONE_FRAGMENT;
  static constexpr Name LUNAR_STONE_FRAGMENT =
    ArtifactSpec_Name_LUNAR_STONE_FRAGMENT;
  static constexpr Name SOUL_STONE_FRAGMENT =
    ArtifactSpec_Name_SOUL_STONE_FRAGMENT;
  static constexpr Name PROPHECY_STONE_FRAGMENT =
    ArtifactSpec_Name_PROPHECY_STONE_FRAGMENT;
  static constexpr Name QUANTUM_STONE_FRAGMENT =
    ArtifactSpec_Name_QUANTUM_STONE_FRAGMENT;
  static constexpr Name TERRA_STONE_FRAGMENT =
    ArtifactSpec_Name_TERRA_STONE_FRAGMENT;
  static constexpr Name LIFE_STONE_FRAGMENT =
    ArtifactSpec_Name_LIFE_STONE_FRAGMENT;
  static constexpr Name CLARITY_STONE_FRAGMENT =
    ArtifactSpec_Name_CLARITY_STONE_FRAGMENT;
  static constexpr Name UNKNOWN =
    ArtifactSpec_Name_UNKNOWN;
  static inline bool Name_IsValid(int value) {
    return ArtifactSpec_Name_IsValid(value);
  }
  static constexpr Name Name_MIN =
    ArtifactSpec_Name_Name_MIN;
  static constexpr Name Name_MAX =
    ArtifactSpec_Name_Name_MAX;
  static constexpr int Name_ARRAYSIZE =
    ArtifactSpec_Name_Name_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Name_descriptor() {
    return ArtifactSpec_Name_descriptor();
  }
  template<typename T>
  static inline const std::string& Name_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Name>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Name_Name.");
    return ArtifactSpec_Name_Name(enum_t_value);
  }
  static inline bool Name_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Name* value) {
    return ArtifactSpec_Name_Parse(name, value);
  }

  typedef ArtifactSpec_Level Level;
  static constexpr Level INFERIOR =
    ArtifactSpec_Level_INFERIOR;
  static constexpr Level LESSER =
    ArtifactSpec_Level_LESSER;
  static constexpr Level NORMAL =
    ArtifactSpec_Level_NORMAL;
  static constexpr Level GREATER =
    ArtifactSpec_Level_GREATER;
  static constexpr Level SUPERIOR =
    ArtifactSpec_Level_SUPERIOR;
  static inline bool Level_IsValid(int value) {
    return ArtifactSpec_Level_IsValid(value);
  }
  static constexpr Level Level_MIN =
    ArtifactSpec_Level_Level_MIN;
  static constexpr Level Level_MAX =
    ArtifactSpec_Level_Level_MAX;
  static constexpr int Level_ARRAYSIZE =
    ArtifactSpec_Level_Level_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Level_descriptor() {
    return ArtifactSpec_Level_descriptor();
  }
  template<typename T>
  static inline const std::string& Level_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Level>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Level_Name.");
    return ArtifactSpec_Level_Name(enum_t_value);
  }
  static inline bool Level_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Level* value) {
    return ArtifactSpec_Level_Parse(name, value);
  }

  typedef ArtifactSpec_Rarity Rarity;
  static constexpr Rarity COMMON =
    ArtifactSpec_Rarity_COMMON;
  static constexpr Rarity RARE =
    ArtifactSpec_Rarity_RARE;
  static constexpr Rarity EPIC =
    ArtifactSpec_Rarity_EPIC;
  static constexpr Rarity LEGENDARY =
    ArtifactSpec_Rarity_LEGENDARY;
  static inline bool Rarity_IsValid(int value) {
    return ArtifactSpec_Rarity_IsValid(value);
  }
  static constexpr Rarity Rarity_MIN =
    ArtifactSpec_Rarity_Rarity_MIN;
  static constexpr Rarity Rarity_MAX =
    ArtifactSpec_Rarity_Rarity_MAX;
  static constexpr int Rarity_ARRAYSIZE =
    ArtifactSpec_Rarity_Rarity_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Rarity_descriptor() {
    return ArtifactSpec_Rarity_descriptor();
  }
  template<typename T>
  static inline const std::string& Rarity_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Rarity>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Rarity_Name.");
    return ArtifactSpec_Rarity_Name(enum_t_value);
  }
  static inline bool Rarity_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Rarity* value) {
    return ArtifactSpec_Rarity_Parse(name, value);
  }

  typedef ArtifactSpec_Type Type;
  static constexpr Type ARTIFACT =
    ArtifactSpec_Type_ARTIFACT;
  static constexpr Type STONE =
    ArtifactSpec_Type_STONE;
  static constexpr Type INGREDIENT =
    ArtifactSpec_Type_INGREDIENT;
  static constexpr Type STONE_INGREDIENT =
    ArtifactSpec_Type_STONE_INGREDIENT;
  static inline bool Type_IsValid(int value) {
    return ArtifactSpec_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    ArtifactSpec_Type_Type_MIN;
  static constexpr Type Type_MAX =
    ArtifactSpec_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    ArtifactSpec_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return ArtifactSpec_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return ArtifactSpec_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return ArtifactSpec_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kLevelFieldNumber = 2,
    kRarityFieldNumber = 3,
    kEggFieldNumber = 4,
  };
  // optional .ei.ArtifactSpec.Name name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  ::ei::ArtifactSpec_Name name() const;
  void set_name(::ei::ArtifactSpec_Name value);
  private:
  ::ei::ArtifactSpec_Name _internal_name() const;
  void _internal_set_name(::ei::ArtifactSpec_Name value);
  public:

  // optional .ei.ArtifactSpec.Level level = 2;
  bool has_level() const;
  private:
  bool _internal_has_level() const;
  public:
  void clear_level();
  ::ei::ArtifactSpec_Level level() const;
  void set_level(::ei::ArtifactSpec_Level value);
  private:
  ::ei::ArtifactSpec_Level _internal_level() const;
  void _internal_set_level(::ei::ArtifactSpec_Level value);
  public:

  // optional .ei.ArtifactSpec.Rarity rarity = 3;
  bool has_rarity() const;
  private:
  bool _internal_has_rarity() const;
  public:
  void clear_rarity();
  ::ei::ArtifactSpec_Rarity rarity() const;
  void set_rarity(::ei::ArtifactSpec_Rarity value);
  private:
  ::ei::ArtifactSpec_Rarity _internal_rarity() const;
  void _internal_set_rarity(::ei::ArtifactSpec_Rarity value);
  public:

  // optional .ei.Egg egg = 4;
  bool has_egg() const;
  private:
  bool _internal_has_egg() const;
  public:
  void clear_egg();
  ::ei::Egg egg() const;
  void set_egg(::ei::Egg value);
  private:
  ::ei::Egg _internal_egg() const;
  void _internal_set_egg(::ei::Egg value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ArtifactSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int name_;
  int level_;
  int rarity_;
  int egg_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class CompleteArtifact final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.CompleteArtifact) */ {
 public:
  inline CompleteArtifact() : CompleteArtifact(nullptr) {}
  ~CompleteArtifact() override;
  explicit constexpr CompleteArtifact(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompleteArtifact(const CompleteArtifact& from);
  CompleteArtifact(CompleteArtifact&& from) noexcept
    : CompleteArtifact() {
    *this = ::std::move(from);
  }

  inline CompleteArtifact& operator=(const CompleteArtifact& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompleteArtifact& operator=(CompleteArtifact&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompleteArtifact& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompleteArtifact* internal_default_instance() {
    return reinterpret_cast<const CompleteArtifact*>(
               &_CompleteArtifact_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    94;

  friend void swap(CompleteArtifact& a, CompleteArtifact& b) {
    a.Swap(&b);
  }
  inline void Swap(CompleteArtifact* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompleteArtifact* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompleteArtifact* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompleteArtifact>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompleteArtifact& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CompleteArtifact& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompleteArtifact* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.CompleteArtifact";
  }
  protected:
  explicit CompleteArtifact(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStonesFieldNumber = 2,
    kSpecFieldNumber = 1,
  };
  // repeated .ei.ArtifactSpec stones = 2;
  int stones_size() const;
  private:
  int _internal_stones_size() const;
  public:
  void clear_stones();
  ::ei::ArtifactSpec* mutable_stones(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactSpec >*
      mutable_stones();
  private:
  const ::ei::ArtifactSpec& _internal_stones(int index) const;
  ::ei::ArtifactSpec* _internal_add_stones();
  public:
  const ::ei::ArtifactSpec& stones(int index) const;
  ::ei::ArtifactSpec* add_stones();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactSpec >&
      stones() const;

  // optional .ei.ArtifactSpec spec = 1;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::ei::ArtifactSpec& spec() const;
  PROTOBUF_NODISCARD ::ei::ArtifactSpec* release_spec();
  ::ei::ArtifactSpec* mutable_spec();
  void set_allocated_spec(::ei::ArtifactSpec* spec);
  private:
  const ::ei::ArtifactSpec& _internal_spec() const;
  ::ei::ArtifactSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::ei::ArtifactSpec* spec);
  ::ei::ArtifactSpec* unsafe_arena_release_spec();

  // @@protoc_insertion_point(class_scope:ei.CompleteArtifact)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactSpec > stones_;
  ::ei::ArtifactSpec* spec_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ArtifactInventoryItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ArtifactInventoryItem) */ {
 public:
  inline ArtifactInventoryItem() : ArtifactInventoryItem(nullptr) {}
  ~ArtifactInventoryItem() override;
  explicit constexpr ArtifactInventoryItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArtifactInventoryItem(const ArtifactInventoryItem& from);
  ArtifactInventoryItem(ArtifactInventoryItem&& from) noexcept
    : ArtifactInventoryItem() {
    *this = ::std::move(from);
  }

  inline ArtifactInventoryItem& operator=(const ArtifactInventoryItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArtifactInventoryItem& operator=(ArtifactInventoryItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArtifactInventoryItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArtifactInventoryItem* internal_default_instance() {
    return reinterpret_cast<const ArtifactInventoryItem*>(
               &_ArtifactInventoryItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    95;

  friend void swap(ArtifactInventoryItem& a, ArtifactInventoryItem& b) {
    a.Swap(&b);
  }
  inline void Swap(ArtifactInventoryItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArtifactInventoryItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArtifactInventoryItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArtifactInventoryItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArtifactInventoryItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ArtifactInventoryItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactInventoryItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ArtifactInventoryItem";
  }
  protected:
  explicit ArtifactInventoryItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerIdFieldNumber = 4,
    kArtifactFieldNumber = 2,
    kItemIdFieldNumber = 1,
    kQuantityFieldNumber = 3,
  };
  // optional string server_id = 4;
  bool has_server_id() const;
  private:
  bool _internal_has_server_id() const;
  public:
  void clear_server_id();
  const std::string& server_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_id();
  PROTOBUF_NODISCARD std::string* release_server_id();
  void set_allocated_server_id(std::string* server_id);
  private:
  const std::string& _internal_server_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_id(const std::string& value);
  std::string* _internal_mutable_server_id();
  public:

  // optional .ei.CompleteArtifact artifact = 2;
  bool has_artifact() const;
  private:
  bool _internal_has_artifact() const;
  public:
  void clear_artifact();
  const ::ei::CompleteArtifact& artifact() const;
  PROTOBUF_NODISCARD ::ei::CompleteArtifact* release_artifact();
  ::ei::CompleteArtifact* mutable_artifact();
  void set_allocated_artifact(::ei::CompleteArtifact* artifact);
  private:
  const ::ei::CompleteArtifact& _internal_artifact() const;
  ::ei::CompleteArtifact* _internal_mutable_artifact();
  public:
  void unsafe_arena_set_allocated_artifact(
      ::ei::CompleteArtifact* artifact);
  ::ei::CompleteArtifact* unsafe_arena_release_artifact();

  // optional uint64 item_id = 1;
  bool has_item_id() const;
  private:
  bool _internal_has_item_id() const;
  public:
  void clear_item_id();
  uint64_t item_id() const;
  void set_item_id(uint64_t value);
  private:
  uint64_t _internal_item_id() const;
  void _internal_set_item_id(uint64_t value);
  public:

  // optional double quantity = 3;
  bool has_quantity() const;
  private:
  bool _internal_has_quantity() const;
  public:
  void clear_quantity();
  double quantity() const;
  void set_quantity(double value);
  private:
  double _internal_quantity() const;
  void _internal_set_quantity(double value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ArtifactInventoryItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_id_;
  ::ei::CompleteArtifact* artifact_;
  uint64_t item_id_;
  double quantity_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class InventorySlot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.InventorySlot) */ {
 public:
  inline InventorySlot() : InventorySlot(nullptr) {}
  ~InventorySlot() override;
  explicit constexpr InventorySlot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InventorySlot(const InventorySlot& from);
  InventorySlot(InventorySlot&& from) noexcept
    : InventorySlot() {
    *this = ::std::move(from);
  }

  inline InventorySlot& operator=(const InventorySlot& from) {
    CopyFrom(from);
    return *this;
  }
  inline InventorySlot& operator=(InventorySlot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InventorySlot& default_instance() {
    return *internal_default_instance();
  }
  static inline const InventorySlot* internal_default_instance() {
    return reinterpret_cast<const InventorySlot*>(
               &_InventorySlot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    96;

  friend void swap(InventorySlot& a, InventorySlot& b) {
    a.Swap(&b);
  }
  inline void Swap(InventorySlot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InventorySlot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InventorySlot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InventorySlot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InventorySlot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InventorySlot& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InventorySlot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.InventorySlot";
  }
  protected:
  explicit InventorySlot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOccupiedFieldNumber = 1,
    kItemIdFieldNumber = 2,
  };
  // optional bool occupied = 1;
  bool has_occupied() const;
  private:
  bool _internal_has_occupied() const;
  public:
  void clear_occupied();
  bool occupied() const;
  void set_occupied(bool value);
  private:
  bool _internal_occupied() const;
  void _internal_set_occupied(bool value);
  public:

  // optional uint32 item_id = 2;
  bool has_item_id() const;
  private:
  bool _internal_has_item_id() const;
  public:
  void clear_item_id();
  uint32_t item_id() const;
  void set_item_id(uint32_t value);
  private:
  uint32_t _internal_item_id() const;
  void _internal_set_item_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.InventorySlot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool occupied_;
  uint32_t item_id_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ArtifactsConfigurationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ArtifactsConfigurationRequest) */ {
 public:
  inline ArtifactsConfigurationRequest() : ArtifactsConfigurationRequest(nullptr) {}
  ~ArtifactsConfigurationRequest() override;
  explicit constexpr ArtifactsConfigurationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArtifactsConfigurationRequest(const ArtifactsConfigurationRequest& from);
  ArtifactsConfigurationRequest(ArtifactsConfigurationRequest&& from) noexcept
    : ArtifactsConfigurationRequest() {
    *this = ::std::move(from);
  }

  inline ArtifactsConfigurationRequest& operator=(const ArtifactsConfigurationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArtifactsConfigurationRequest& operator=(ArtifactsConfigurationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArtifactsConfigurationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArtifactsConfigurationRequest* internal_default_instance() {
    return reinterpret_cast<const ArtifactsConfigurationRequest*>(
               &_ArtifactsConfigurationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    97;

  friend void swap(ArtifactsConfigurationRequest& a, ArtifactsConfigurationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ArtifactsConfigurationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArtifactsConfigurationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArtifactsConfigurationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArtifactsConfigurationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArtifactsConfigurationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ArtifactsConfigurationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactsConfigurationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ArtifactsConfigurationRequest";
  }
  protected:
  explicit ArtifactsConfigurationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRinfoFieldNumber = 2,
    kClientVersionFieldNumber = 1,
  };
  // optional .ei.BasicRequestInfo rinfo = 2;
  bool has_rinfo() const;
  private:
  bool _internal_has_rinfo() const;
  public:
  void clear_rinfo();
  const ::ei::BasicRequestInfo& rinfo() const;
  PROTOBUF_NODISCARD ::ei::BasicRequestInfo* release_rinfo();
  ::ei::BasicRequestInfo* mutable_rinfo();
  void set_allocated_rinfo(::ei::BasicRequestInfo* rinfo);
  private:
  const ::ei::BasicRequestInfo& _internal_rinfo() const;
  ::ei::BasicRequestInfo* _internal_mutable_rinfo();
  public:
  void unsafe_arena_set_allocated_rinfo(
      ::ei::BasicRequestInfo* rinfo);
  ::ei::BasicRequestInfo* unsafe_arena_release_rinfo();

  // optional uint32 client_version = 1;
  bool has_client_version() const;
  private:
  bool _internal_has_client_version() const;
  public:
  void clear_client_version();
  uint32_t client_version() const;
  void set_client_version(uint32_t value);
  private:
  uint32_t _internal_client_version() const;
  void _internal_set_client_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ArtifactsConfigurationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ei::BasicRequestInfo* rinfo_;
  uint32_t client_version_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ArtifactsConfigurationResponse_MissionParameters_Duration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ArtifactsConfigurationResponse.MissionParameters.Duration) */ {
 public:
  inline ArtifactsConfigurationResponse_MissionParameters_Duration() : ArtifactsConfigurationResponse_MissionParameters_Duration(nullptr) {}
  ~ArtifactsConfigurationResponse_MissionParameters_Duration() override;
  explicit constexpr ArtifactsConfigurationResponse_MissionParameters_Duration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArtifactsConfigurationResponse_MissionParameters_Duration(const ArtifactsConfigurationResponse_MissionParameters_Duration& from);
  ArtifactsConfigurationResponse_MissionParameters_Duration(ArtifactsConfigurationResponse_MissionParameters_Duration&& from) noexcept
    : ArtifactsConfigurationResponse_MissionParameters_Duration() {
    *this = ::std::move(from);
  }

  inline ArtifactsConfigurationResponse_MissionParameters_Duration& operator=(const ArtifactsConfigurationResponse_MissionParameters_Duration& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArtifactsConfigurationResponse_MissionParameters_Duration& operator=(ArtifactsConfigurationResponse_MissionParameters_Duration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArtifactsConfigurationResponse_MissionParameters_Duration& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArtifactsConfigurationResponse_MissionParameters_Duration* internal_default_instance() {
    return reinterpret_cast<const ArtifactsConfigurationResponse_MissionParameters_Duration*>(
               &_ArtifactsConfigurationResponse_MissionParameters_Duration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    98;

  friend void swap(ArtifactsConfigurationResponse_MissionParameters_Duration& a, ArtifactsConfigurationResponse_MissionParameters_Duration& b) {
    a.Swap(&b);
  }
  inline void Swap(ArtifactsConfigurationResponse_MissionParameters_Duration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArtifactsConfigurationResponse_MissionParameters_Duration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArtifactsConfigurationResponse_MissionParameters_Duration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArtifactsConfigurationResponse_MissionParameters_Duration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArtifactsConfigurationResponse_MissionParameters_Duration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ArtifactsConfigurationResponse_MissionParameters_Duration& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactsConfigurationResponse_MissionParameters_Duration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ArtifactsConfigurationResponse.MissionParameters.Duration";
  }
  protected:
  explicit ArtifactsConfigurationResponse_MissionParameters_Duration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecondsFieldNumber = 2,
    kDurationTypeFieldNumber = 1,
    kQualityFieldNumber = 3,
    kMinQualityFieldNumber = 4,
    kMaxQualityFieldNumber = 5,
    kCapacityFieldNumber = 6,
    kLevelCapacityBumpFieldNumber = 7,
    kLevelQualityBumpFieldNumber = 8,
  };
  // optional double seconds = 2;
  bool has_seconds() const;
  private:
  bool _internal_has_seconds() const;
  public:
  void clear_seconds();
  double seconds() const;
  void set_seconds(double value);
  private:
  double _internal_seconds() const;
  void _internal_set_seconds(double value);
  public:

  // optional .ei.MissionInfo.DurationType duration_type = 1;
  bool has_duration_type() const;
  private:
  bool _internal_has_duration_type() const;
  public:
  void clear_duration_type();
  ::ei::MissionInfo_DurationType duration_type() const;
  void set_duration_type(::ei::MissionInfo_DurationType value);
  private:
  ::ei::MissionInfo_DurationType _internal_duration_type() const;
  void _internal_set_duration_type(::ei::MissionInfo_DurationType value);
  public:

  // optional float quality = 3;
  bool has_quality() const;
  private:
  bool _internal_has_quality() const;
  public:
  void clear_quality();
  float quality() const;
  void set_quality(float value);
  private:
  float _internal_quality() const;
  void _internal_set_quality(float value);
  public:

  // optional float min_quality = 4;
  bool has_min_quality() const;
  private:
  bool _internal_has_min_quality() const;
  public:
  void clear_min_quality();
  float min_quality() const;
  void set_min_quality(float value);
  private:
  float _internal_min_quality() const;
  void _internal_set_min_quality(float value);
  public:

  // optional float max_quality = 5;
  bool has_max_quality() const;
  private:
  bool _internal_has_max_quality() const;
  public:
  void clear_max_quality();
  float max_quality() const;
  void set_max_quality(float value);
  private:
  float _internal_max_quality() const;
  void _internal_set_max_quality(float value);
  public:

  // optional uint32 capacity = 6;
  bool has_capacity() const;
  private:
  bool _internal_has_capacity() const;
  public:
  void clear_capacity();
  uint32_t capacity() const;
  void set_capacity(uint32_t value);
  private:
  uint32_t _internal_capacity() const;
  void _internal_set_capacity(uint32_t value);
  public:

  // optional uint32 level_capacity_bump = 7;
  bool has_level_capacity_bump() const;
  private:
  bool _internal_has_level_capacity_bump() const;
  public:
  void clear_level_capacity_bump();
  uint32_t level_capacity_bump() const;
  void set_level_capacity_bump(uint32_t value);
  private:
  uint32_t _internal_level_capacity_bump() const;
  void _internal_set_level_capacity_bump(uint32_t value);
  public:

  // optional float level_quality_bump = 8;
  bool has_level_quality_bump() const;
  private:
  bool _internal_has_level_quality_bump() const;
  public:
  void clear_level_quality_bump();
  float level_quality_bump() const;
  void set_level_quality_bump(float value);
  private:
  float _internal_level_quality_bump() const;
  void _internal_set_level_quality_bump(float value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ArtifactsConfigurationResponse.MissionParameters.Duration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double seconds_;
  int duration_type_;
  float quality_;
  float min_quality_;
  float max_quality_;
  uint32_t capacity_;
  uint32_t level_capacity_bump_;
  float level_quality_bump_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ArtifactsConfigurationResponse_MissionParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ArtifactsConfigurationResponse.MissionParameters) */ {
 public:
  inline ArtifactsConfigurationResponse_MissionParameters() : ArtifactsConfigurationResponse_MissionParameters(nullptr) {}
  ~ArtifactsConfigurationResponse_MissionParameters() override;
  explicit constexpr ArtifactsConfigurationResponse_MissionParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArtifactsConfigurationResponse_MissionParameters(const ArtifactsConfigurationResponse_MissionParameters& from);
  ArtifactsConfigurationResponse_MissionParameters(ArtifactsConfigurationResponse_MissionParameters&& from) noexcept
    : ArtifactsConfigurationResponse_MissionParameters() {
    *this = ::std::move(from);
  }

  inline ArtifactsConfigurationResponse_MissionParameters& operator=(const ArtifactsConfigurationResponse_MissionParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArtifactsConfigurationResponse_MissionParameters& operator=(ArtifactsConfigurationResponse_MissionParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArtifactsConfigurationResponse_MissionParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArtifactsConfigurationResponse_MissionParameters* internal_default_instance() {
    return reinterpret_cast<const ArtifactsConfigurationResponse_MissionParameters*>(
               &_ArtifactsConfigurationResponse_MissionParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    99;

  friend void swap(ArtifactsConfigurationResponse_MissionParameters& a, ArtifactsConfigurationResponse_MissionParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(ArtifactsConfigurationResponse_MissionParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArtifactsConfigurationResponse_MissionParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArtifactsConfigurationResponse_MissionParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArtifactsConfigurationResponse_MissionParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArtifactsConfigurationResponse_MissionParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ArtifactsConfigurationResponse_MissionParameters& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactsConfigurationResponse_MissionParameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ArtifactsConfigurationResponse.MissionParameters";
  }
  protected:
  explicit ArtifactsConfigurationResponse_MissionParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ArtifactsConfigurationResponse_MissionParameters_Duration Duration;

  // accessors -------------------------------------------------------

  enum : int {
    kDurationsFieldNumber = 3,
    kLevelMissionRequirementsFieldNumber = 4,
    kShipFieldNumber = 1,
    kCapacityDEPRECATEDFieldNumber = 2,
  };
  // repeated .ei.ArtifactsConfigurationResponse.MissionParameters.Duration durations = 3;
  int durations_size() const;
  private:
  int _internal_durations_size() const;
  public:
  void clear_durations();
  ::ei::ArtifactsConfigurationResponse_MissionParameters_Duration* mutable_durations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsConfigurationResponse_MissionParameters_Duration >*
      mutable_durations();
  private:
  const ::ei::ArtifactsConfigurationResponse_MissionParameters_Duration& _internal_durations(int index) const;
  ::ei::ArtifactsConfigurationResponse_MissionParameters_Duration* _internal_add_durations();
  public:
  const ::ei::ArtifactsConfigurationResponse_MissionParameters_Duration& durations(int index) const;
  ::ei::ArtifactsConfigurationResponse_MissionParameters_Duration* add_durations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsConfigurationResponse_MissionParameters_Duration >&
      durations() const;

  // repeated uint32 level_mission_requirements = 4;
  int level_mission_requirements_size() const;
  private:
  int _internal_level_mission_requirements_size() const;
  public:
  void clear_level_mission_requirements();
  private:
  uint32_t _internal_level_mission_requirements(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_level_mission_requirements() const;
  void _internal_add_level_mission_requirements(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_level_mission_requirements();
  public:
  uint32_t level_mission_requirements(int index) const;
  void set_level_mission_requirements(int index, uint32_t value);
  void add_level_mission_requirements(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      level_mission_requirements() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_level_mission_requirements();

  // optional .ei.MissionInfo.Spaceship ship = 1;
  bool has_ship() const;
  private:
  bool _internal_has_ship() const;
  public:
  void clear_ship();
  ::ei::MissionInfo_Spaceship ship() const;
  void set_ship(::ei::MissionInfo_Spaceship value);
  private:
  ::ei::MissionInfo_Spaceship _internal_ship() const;
  void _internal_set_ship(::ei::MissionInfo_Spaceship value);
  public:

  // optional uint32 capacity_DEPRECATED = 2;
  bool has_capacity_deprecated() const;
  private:
  bool _internal_has_capacity_deprecated() const;
  public:
  void clear_capacity_deprecated();
  uint32_t capacity_deprecated() const;
  void set_capacity_deprecated(uint32_t value);
  private:
  uint32_t _internal_capacity_deprecated() const;
  void _internal_set_capacity_deprecated(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ArtifactsConfigurationResponse.MissionParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsConfigurationResponse_MissionParameters_Duration > durations_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > level_mission_requirements_;
  int ship_;
  uint32_t capacity_deprecated_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ArtifactsConfigurationResponse_ArtifactParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ArtifactsConfigurationResponse.ArtifactParameters) */ {
 public:
  inline ArtifactsConfigurationResponse_ArtifactParameters() : ArtifactsConfigurationResponse_ArtifactParameters(nullptr) {}
  ~ArtifactsConfigurationResponse_ArtifactParameters() override;
  explicit constexpr ArtifactsConfigurationResponse_ArtifactParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArtifactsConfigurationResponse_ArtifactParameters(const ArtifactsConfigurationResponse_ArtifactParameters& from);
  ArtifactsConfigurationResponse_ArtifactParameters(ArtifactsConfigurationResponse_ArtifactParameters&& from) noexcept
    : ArtifactsConfigurationResponse_ArtifactParameters() {
    *this = ::std::move(from);
  }

  inline ArtifactsConfigurationResponse_ArtifactParameters& operator=(const ArtifactsConfigurationResponse_ArtifactParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArtifactsConfigurationResponse_ArtifactParameters& operator=(ArtifactsConfigurationResponse_ArtifactParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArtifactsConfigurationResponse_ArtifactParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArtifactsConfigurationResponse_ArtifactParameters* internal_default_instance() {
    return reinterpret_cast<const ArtifactsConfigurationResponse_ArtifactParameters*>(
               &_ArtifactsConfigurationResponse_ArtifactParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    100;

  friend void swap(ArtifactsConfigurationResponse_ArtifactParameters& a, ArtifactsConfigurationResponse_ArtifactParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(ArtifactsConfigurationResponse_ArtifactParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArtifactsConfigurationResponse_ArtifactParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArtifactsConfigurationResponse_ArtifactParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArtifactsConfigurationResponse_ArtifactParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArtifactsConfigurationResponse_ArtifactParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ArtifactsConfigurationResponse_ArtifactParameters& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactsConfigurationResponse_ArtifactParameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ArtifactsConfigurationResponse.ArtifactParameters";
  }
  protected:
  explicit ArtifactsConfigurationResponse_ArtifactParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecFieldNumber = 1,
    kBaseQualityFieldNumber = 2,
    kValueFieldNumber = 3,
    kOddsMultiplierFieldNumber = 4,
    kCraftingPriceFieldNumber = 5,
    kCraftingPriceLowFieldNumber = 6,
    kCraftingPriceCurveFieldNumber = 8,
    kCraftingPriceDomainFieldNumber = 7,
  };
  // optional .ei.ArtifactSpec spec = 1;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::ei::ArtifactSpec& spec() const;
  PROTOBUF_NODISCARD ::ei::ArtifactSpec* release_spec();
  ::ei::ArtifactSpec* mutable_spec();
  void set_allocated_spec(::ei::ArtifactSpec* spec);
  private:
  const ::ei::ArtifactSpec& _internal_spec() const;
  ::ei::ArtifactSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::ei::ArtifactSpec* spec);
  ::ei::ArtifactSpec* unsafe_arena_release_spec();

  // optional double base_quality = 2;
  bool has_base_quality() const;
  private:
  bool _internal_has_base_quality() const;
  public:
  void clear_base_quality();
  double base_quality() const;
  void set_base_quality(double value);
  private:
  double _internal_base_quality() const;
  void _internal_set_base_quality(double value);
  public:

  // optional double value = 3;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  double value() const;
  void set_value(double value);
  private:
  double _internal_value() const;
  void _internal_set_value(double value);
  public:

  // optional double odds_multiplier = 4;
  bool has_odds_multiplier() const;
  private:
  bool _internal_has_odds_multiplier() const;
  public:
  void clear_odds_multiplier();
  double odds_multiplier() const;
  void set_odds_multiplier(double value);
  private:
  double _internal_odds_multiplier() const;
  void _internal_set_odds_multiplier(double value);
  public:

  // optional double crafting_price = 5;
  bool has_crafting_price() const;
  private:
  bool _internal_has_crafting_price() const;
  public:
  void clear_crafting_price();
  double crafting_price() const;
  void set_crafting_price(double value);
  private:
  double _internal_crafting_price() const;
  void _internal_set_crafting_price(double value);
  public:

  // optional double crafting_price_low = 6;
  bool has_crafting_price_low() const;
  private:
  bool _internal_has_crafting_price_low() const;
  public:
  void clear_crafting_price_low();
  double crafting_price_low() const;
  void set_crafting_price_low(double value);
  private:
  double _internal_crafting_price_low() const;
  void _internal_set_crafting_price_low(double value);
  public:

  // optional double crafting_price_curve = 8;
  bool has_crafting_price_curve() const;
  private:
  bool _internal_has_crafting_price_curve() const;
  public:
  void clear_crafting_price_curve();
  double crafting_price_curve() const;
  void set_crafting_price_curve(double value);
  private:
  double _internal_crafting_price_curve() const;
  void _internal_set_crafting_price_curve(double value);
  public:

  // optional uint32 crafting_price_domain = 7;
  bool has_crafting_price_domain() const;
  private:
  bool _internal_has_crafting_price_domain() const;
  public:
  void clear_crafting_price_domain();
  uint32_t crafting_price_domain() const;
  void set_crafting_price_domain(uint32_t value);
  private:
  uint32_t _internal_crafting_price_domain() const;
  void _internal_set_crafting_price_domain(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ArtifactsConfigurationResponse.ArtifactParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ei::ArtifactSpec* spec_;
  double base_quality_;
  double value_;
  double odds_multiplier_;
  double crafting_price_;
  double crafting_price_low_;
  double crafting_price_curve_;
  uint32_t crafting_price_domain_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ArtifactsConfigurationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ArtifactsConfigurationResponse) */ {
 public:
  inline ArtifactsConfigurationResponse() : ArtifactsConfigurationResponse(nullptr) {}
  ~ArtifactsConfigurationResponse() override;
  explicit constexpr ArtifactsConfigurationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArtifactsConfigurationResponse(const ArtifactsConfigurationResponse& from);
  ArtifactsConfigurationResponse(ArtifactsConfigurationResponse&& from) noexcept
    : ArtifactsConfigurationResponse() {
    *this = ::std::move(from);
  }

  inline ArtifactsConfigurationResponse& operator=(const ArtifactsConfigurationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArtifactsConfigurationResponse& operator=(ArtifactsConfigurationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArtifactsConfigurationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArtifactsConfigurationResponse* internal_default_instance() {
    return reinterpret_cast<const ArtifactsConfigurationResponse*>(
               &_ArtifactsConfigurationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    101;

  friend void swap(ArtifactsConfigurationResponse& a, ArtifactsConfigurationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ArtifactsConfigurationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArtifactsConfigurationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArtifactsConfigurationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArtifactsConfigurationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArtifactsConfigurationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ArtifactsConfigurationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactsConfigurationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ArtifactsConfigurationResponse";
  }
  protected:
  explicit ArtifactsConfigurationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ArtifactsConfigurationResponse_MissionParameters MissionParameters;
  typedef ArtifactsConfigurationResponse_ArtifactParameters ArtifactParameters;

  // accessors -------------------------------------------------------

  enum : int {
    kMissionParametersFieldNumber = 1,
    kArtifactParametersFieldNumber = 2,
  };
  // repeated .ei.ArtifactsConfigurationResponse.MissionParameters mission_parameters = 1;
  int mission_parameters_size() const;
  private:
  int _internal_mission_parameters_size() const;
  public:
  void clear_mission_parameters();
  ::ei::ArtifactsConfigurationResponse_MissionParameters* mutable_mission_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsConfigurationResponse_MissionParameters >*
      mutable_mission_parameters();
  private:
  const ::ei::ArtifactsConfigurationResponse_MissionParameters& _internal_mission_parameters(int index) const;
  ::ei::ArtifactsConfigurationResponse_MissionParameters* _internal_add_mission_parameters();
  public:
  const ::ei::ArtifactsConfigurationResponse_MissionParameters& mission_parameters(int index) const;
  ::ei::ArtifactsConfigurationResponse_MissionParameters* add_mission_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsConfigurationResponse_MissionParameters >&
      mission_parameters() const;

  // repeated .ei.ArtifactsConfigurationResponse.ArtifactParameters artifact_parameters = 2;
  int artifact_parameters_size() const;
  private:
  int _internal_artifact_parameters_size() const;
  public:
  void clear_artifact_parameters();
  ::ei::ArtifactsConfigurationResponse_ArtifactParameters* mutable_artifact_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsConfigurationResponse_ArtifactParameters >*
      mutable_artifact_parameters();
  private:
  const ::ei::ArtifactsConfigurationResponse_ArtifactParameters& _internal_artifact_parameters(int index) const;
  ::ei::ArtifactsConfigurationResponse_ArtifactParameters* _internal_add_artifact_parameters();
  public:
  const ::ei::ArtifactsConfigurationResponse_ArtifactParameters& artifact_parameters(int index) const;
  ::ei::ArtifactsConfigurationResponse_ArtifactParameters* add_artifact_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsConfigurationResponse_ArtifactParameters >&
      artifact_parameters() const;

  // @@protoc_insertion_point(class_scope:ei.ArtifactsConfigurationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsConfigurationResponse_MissionParameters > mission_parameters_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsConfigurationResponse_ArtifactParameters > artifact_parameters_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class MissionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.MissionRequest) */ {
 public:
  inline MissionRequest() : MissionRequest(nullptr) {}
  ~MissionRequest() override;
  explicit constexpr MissionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MissionRequest(const MissionRequest& from);
  MissionRequest(MissionRequest&& from) noexcept
    : MissionRequest() {
    *this = ::std::move(from);
  }

  inline MissionRequest& operator=(const MissionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MissionRequest& operator=(MissionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MissionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MissionRequest* internal_default_instance() {
    return reinterpret_cast<const MissionRequest*>(
               &_MissionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    102;

  friend void swap(MissionRequest& a, MissionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MissionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MissionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MissionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MissionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MissionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MissionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MissionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.MissionRequest";
  }
  protected:
  explicit MissionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEiUserIdFieldNumber = 3,
    kInfoFieldNumber = 2,
    kRinfoFieldNumber = 4,
    kClientInfoFieldNumber = 5,
    kClientVersionFieldNumber = 1,
  };
  // optional string ei_user_id = 3;
  bool has_ei_user_id() const;
  private:
  bool _internal_has_ei_user_id() const;
  public:
  void clear_ei_user_id();
  const std::string& ei_user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ei_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ei_user_id();
  PROTOBUF_NODISCARD std::string* release_ei_user_id();
  void set_allocated_ei_user_id(std::string* ei_user_id);
  private:
  const std::string& _internal_ei_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ei_user_id(const std::string& value);
  std::string* _internal_mutable_ei_user_id();
  public:

  // optional .ei.MissionInfo info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::ei::MissionInfo& info() const;
  PROTOBUF_NODISCARD ::ei::MissionInfo* release_info();
  ::ei::MissionInfo* mutable_info();
  void set_allocated_info(::ei::MissionInfo* info);
  private:
  const ::ei::MissionInfo& _internal_info() const;
  ::ei::MissionInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::ei::MissionInfo* info);
  ::ei::MissionInfo* unsafe_arena_release_info();

  // optional .ei.BasicRequestInfo rinfo = 4;
  bool has_rinfo() const;
  private:
  bool _internal_has_rinfo() const;
  public:
  void clear_rinfo();
  const ::ei::BasicRequestInfo& rinfo() const;
  PROTOBUF_NODISCARD ::ei::BasicRequestInfo* release_rinfo();
  ::ei::BasicRequestInfo* mutable_rinfo();
  void set_allocated_rinfo(::ei::BasicRequestInfo* rinfo);
  private:
  const ::ei::BasicRequestInfo& _internal_rinfo() const;
  ::ei::BasicRequestInfo* _internal_mutable_rinfo();
  public:
  void unsafe_arena_set_allocated_rinfo(
      ::ei::BasicRequestInfo* rinfo);
  ::ei::BasicRequestInfo* unsafe_arena_release_rinfo();

  // optional .ei.ArtifactsClientInfo client_info = 5;
  bool has_client_info() const;
  private:
  bool _internal_has_client_info() const;
  public:
  void clear_client_info();
  const ::ei::ArtifactsClientInfo& client_info() const;
  PROTOBUF_NODISCARD ::ei::ArtifactsClientInfo* release_client_info();
  ::ei::ArtifactsClientInfo* mutable_client_info();
  void set_allocated_client_info(::ei::ArtifactsClientInfo* client_info);
  private:
  const ::ei::ArtifactsClientInfo& _internal_client_info() const;
  ::ei::ArtifactsClientInfo* _internal_mutable_client_info();
  public:
  void unsafe_arena_set_allocated_client_info(
      ::ei::ArtifactsClientInfo* client_info);
  ::ei::ArtifactsClientInfo* unsafe_arena_release_client_info();

  // optional uint32 client_version = 1;
  bool has_client_version() const;
  private:
  bool _internal_has_client_version() const;
  public:
  void clear_client_version();
  uint32_t client_version() const;
  void set_client_version(uint32_t value);
  private:
  uint32_t _internal_client_version() const;
  void _internal_set_client_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.MissionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ei_user_id_;
  ::ei::MissionInfo* info_;
  ::ei::BasicRequestInfo* rinfo_;
  ::ei::ArtifactsClientInfo* client_info_;
  uint32_t client_version_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class MissionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.MissionResponse) */ {
 public:
  inline MissionResponse() : MissionResponse(nullptr) {}
  ~MissionResponse() override;
  explicit constexpr MissionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MissionResponse(const MissionResponse& from);
  MissionResponse(MissionResponse&& from) noexcept
    : MissionResponse() {
    *this = ::std::move(from);
  }

  inline MissionResponse& operator=(const MissionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MissionResponse& operator=(MissionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MissionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MissionResponse* internal_default_instance() {
    return reinterpret_cast<const MissionResponse*>(
               &_MissionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    103;

  friend void swap(MissionResponse& a, MissionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MissionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MissionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MissionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MissionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MissionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MissionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MissionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.MissionResponse";
  }
  protected:
  explicit MissionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // optional .ei.MissionInfo info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::ei::MissionInfo& info() const;
  PROTOBUF_NODISCARD ::ei::MissionInfo* release_info();
  ::ei::MissionInfo* mutable_info();
  void set_allocated_info(::ei::MissionInfo* info);
  private:
  const ::ei::MissionInfo& _internal_info() const;
  ::ei::MissionInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::ei::MissionInfo* info);
  ::ei::MissionInfo* unsafe_arena_release_info();

  // optional bool success = 1;
  bool has_success() const;
  private:
  bool _internal_has_success() const;
  public:
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ei.MissionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ei::MissionInfo* info_;
  bool success_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class CompleteMissionResponse_SecureArtifactSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.CompleteMissionResponse.SecureArtifactSpec) */ {
 public:
  inline CompleteMissionResponse_SecureArtifactSpec() : CompleteMissionResponse_SecureArtifactSpec(nullptr) {}
  ~CompleteMissionResponse_SecureArtifactSpec() override;
  explicit constexpr CompleteMissionResponse_SecureArtifactSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompleteMissionResponse_SecureArtifactSpec(const CompleteMissionResponse_SecureArtifactSpec& from);
  CompleteMissionResponse_SecureArtifactSpec(CompleteMissionResponse_SecureArtifactSpec&& from) noexcept
    : CompleteMissionResponse_SecureArtifactSpec() {
    *this = ::std::move(from);
  }

  inline CompleteMissionResponse_SecureArtifactSpec& operator=(const CompleteMissionResponse_SecureArtifactSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompleteMissionResponse_SecureArtifactSpec& operator=(CompleteMissionResponse_SecureArtifactSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompleteMissionResponse_SecureArtifactSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompleteMissionResponse_SecureArtifactSpec* internal_default_instance() {
    return reinterpret_cast<const CompleteMissionResponse_SecureArtifactSpec*>(
               &_CompleteMissionResponse_SecureArtifactSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    104;

  friend void swap(CompleteMissionResponse_SecureArtifactSpec& a, CompleteMissionResponse_SecureArtifactSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(CompleteMissionResponse_SecureArtifactSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompleteMissionResponse_SecureArtifactSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompleteMissionResponse_SecureArtifactSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompleteMissionResponse_SecureArtifactSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompleteMissionResponse_SecureArtifactSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CompleteMissionResponse_SecureArtifactSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompleteMissionResponse_SecureArtifactSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.CompleteMissionResponse.SecureArtifactSpec";
  }
  protected:
  explicit CompleteMissionResponse_SecureArtifactSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerIdFieldNumber = 2,
    kSpecFieldNumber = 1,
  };
  // optional string server_id = 2;
  bool has_server_id() const;
  private:
  bool _internal_has_server_id() const;
  public:
  void clear_server_id();
  const std::string& server_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_id();
  PROTOBUF_NODISCARD std::string* release_server_id();
  void set_allocated_server_id(std::string* server_id);
  private:
  const std::string& _internal_server_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_id(const std::string& value);
  std::string* _internal_mutable_server_id();
  public:

  // optional .ei.ArtifactSpec spec = 1;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::ei::ArtifactSpec& spec() const;
  PROTOBUF_NODISCARD ::ei::ArtifactSpec* release_spec();
  ::ei::ArtifactSpec* mutable_spec();
  void set_allocated_spec(::ei::ArtifactSpec* spec);
  private:
  const ::ei::ArtifactSpec& _internal_spec() const;
  ::ei::ArtifactSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::ei::ArtifactSpec* spec);
  ::ei::ArtifactSpec* unsafe_arena_release_spec();

  // @@protoc_insertion_point(class_scope:ei.CompleteMissionResponse.SecureArtifactSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_id_;
  ::ei::ArtifactSpec* spec_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class CompleteMissionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.CompleteMissionResponse) */ {
 public:
  inline CompleteMissionResponse() : CompleteMissionResponse(nullptr) {}
  ~CompleteMissionResponse() override;
  explicit constexpr CompleteMissionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompleteMissionResponse(const CompleteMissionResponse& from);
  CompleteMissionResponse(CompleteMissionResponse&& from) noexcept
    : CompleteMissionResponse() {
    *this = ::std::move(from);
  }

  inline CompleteMissionResponse& operator=(const CompleteMissionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompleteMissionResponse& operator=(CompleteMissionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompleteMissionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompleteMissionResponse* internal_default_instance() {
    return reinterpret_cast<const CompleteMissionResponse*>(
               &_CompleteMissionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    105;

  friend void swap(CompleteMissionResponse& a, CompleteMissionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CompleteMissionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompleteMissionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompleteMissionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompleteMissionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompleteMissionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CompleteMissionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompleteMissionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.CompleteMissionResponse";
  }
  protected:
  explicit CompleteMissionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CompleteMissionResponse_SecureArtifactSpec SecureArtifactSpec;

  // accessors -------------------------------------------------------

  enum : int {
    kArtifactsFieldNumber = 3,
    kOtherRewardsFieldNumber = 4,
    kEiUserIdFieldNumber = 5,
    kInfoFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // repeated .ei.CompleteMissionResponse.SecureArtifactSpec artifacts = 3;
  int artifacts_size() const;
  private:
  int _internal_artifacts_size() const;
  public:
  void clear_artifacts();
  ::ei::CompleteMissionResponse_SecureArtifactSpec* mutable_artifacts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::CompleteMissionResponse_SecureArtifactSpec >*
      mutable_artifacts();
  private:
  const ::ei::CompleteMissionResponse_SecureArtifactSpec& _internal_artifacts(int index) const;
  ::ei::CompleteMissionResponse_SecureArtifactSpec* _internal_add_artifacts();
  public:
  const ::ei::CompleteMissionResponse_SecureArtifactSpec& artifacts(int index) const;
  ::ei::CompleteMissionResponse_SecureArtifactSpec* add_artifacts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::CompleteMissionResponse_SecureArtifactSpec >&
      artifacts() const;

  // repeated .ei.Reward other_rewards = 4;
  int other_rewards_size() const;
  private:
  int _internal_other_rewards_size() const;
  public:
  void clear_other_rewards();
  ::ei::Reward* mutable_other_rewards(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Reward >*
      mutable_other_rewards();
  private:
  const ::ei::Reward& _internal_other_rewards(int index) const;
  ::ei::Reward* _internal_add_other_rewards();
  public:
  const ::ei::Reward& other_rewards(int index) const;
  ::ei::Reward* add_other_rewards();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Reward >&
      other_rewards() const;

  // optional string ei_user_id = 5;
  bool has_ei_user_id() const;
  private:
  bool _internal_has_ei_user_id() const;
  public:
  void clear_ei_user_id();
  const std::string& ei_user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ei_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ei_user_id();
  PROTOBUF_NODISCARD std::string* release_ei_user_id();
  void set_allocated_ei_user_id(std::string* ei_user_id);
  private:
  const std::string& _internal_ei_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ei_user_id(const std::string& value);
  std::string* _internal_mutable_ei_user_id();
  public:

  // optional .ei.MissionInfo info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::ei::MissionInfo& info() const;
  PROTOBUF_NODISCARD ::ei::MissionInfo* release_info();
  ::ei::MissionInfo* mutable_info();
  void set_allocated_info(::ei::MissionInfo* info);
  private:
  const ::ei::MissionInfo& _internal_info() const;
  ::ei::MissionInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::ei::MissionInfo* info);
  ::ei::MissionInfo* unsafe_arena_release_info();

  // optional bool success = 1;
  bool has_success() const;
  private:
  bool _internal_has_success() const;
  public:
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ei.CompleteMissionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::CompleteMissionResponse_SecureArtifactSpec > artifacts_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Reward > other_rewards_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ei_user_id_;
  ::ei::MissionInfo* info_;
  bool success_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class CollectContractArtifactRewardsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.CollectContractArtifactRewardsRequest) */ {
 public:
  inline CollectContractArtifactRewardsRequest() : CollectContractArtifactRewardsRequest(nullptr) {}
  ~CollectContractArtifactRewardsRequest() override;
  explicit constexpr CollectContractArtifactRewardsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CollectContractArtifactRewardsRequest(const CollectContractArtifactRewardsRequest& from);
  CollectContractArtifactRewardsRequest(CollectContractArtifactRewardsRequest&& from) noexcept
    : CollectContractArtifactRewardsRequest() {
    *this = ::std::move(from);
  }

  inline CollectContractArtifactRewardsRequest& operator=(const CollectContractArtifactRewardsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollectContractArtifactRewardsRequest& operator=(CollectContractArtifactRewardsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollectContractArtifactRewardsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollectContractArtifactRewardsRequest* internal_default_instance() {
    return reinterpret_cast<const CollectContractArtifactRewardsRequest*>(
               &_CollectContractArtifactRewardsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    106;

  friend void swap(CollectContractArtifactRewardsRequest& a, CollectContractArtifactRewardsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CollectContractArtifactRewardsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollectContractArtifactRewardsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollectContractArtifactRewardsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CollectContractArtifactRewardsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CollectContractArtifactRewardsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CollectContractArtifactRewardsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CollectContractArtifactRewardsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.CollectContractArtifactRewardsRequest";
  }
  protected:
  explicit CollectContractArtifactRewardsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractIdentifierFieldNumber = 2,
    kRinfoFieldNumber = 1,
    kGoalIndexFieldNumber = 3,
    kBestShipFieldNumber = 4,
    kLeagueFieldNumber = 5,
  };
  // optional string contract_identifier = 2;
  bool has_contract_identifier() const;
  private:
  bool _internal_has_contract_identifier() const;
  public:
  void clear_contract_identifier();
  const std::string& contract_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_identifier();
  PROTOBUF_NODISCARD std::string* release_contract_identifier();
  void set_allocated_contract_identifier(std::string* contract_identifier);
  private:
  const std::string& _internal_contract_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_identifier(const std::string& value);
  std::string* _internal_mutable_contract_identifier();
  public:

  // optional .ei.BasicRequestInfo rinfo = 1;
  bool has_rinfo() const;
  private:
  bool _internal_has_rinfo() const;
  public:
  void clear_rinfo();
  const ::ei::BasicRequestInfo& rinfo() const;
  PROTOBUF_NODISCARD ::ei::BasicRequestInfo* release_rinfo();
  ::ei::BasicRequestInfo* mutable_rinfo();
  void set_allocated_rinfo(::ei::BasicRequestInfo* rinfo);
  private:
  const ::ei::BasicRequestInfo& _internal_rinfo() const;
  ::ei::BasicRequestInfo* _internal_mutable_rinfo();
  public:
  void unsafe_arena_set_allocated_rinfo(
      ::ei::BasicRequestInfo* rinfo);
  ::ei::BasicRequestInfo* unsafe_arena_release_rinfo();

  // optional uint32 goal_index = 3;
  bool has_goal_index() const;
  private:
  bool _internal_has_goal_index() const;
  public:
  void clear_goal_index();
  uint32_t goal_index() const;
  void set_goal_index(uint32_t value);
  private:
  uint32_t _internal_goal_index() const;
  void _internal_set_goal_index(uint32_t value);
  public:

  // optional .ei.MissionInfo.Spaceship best_ship = 4;
  bool has_best_ship() const;
  private:
  bool _internal_has_best_ship() const;
  public:
  void clear_best_ship();
  ::ei::MissionInfo_Spaceship best_ship() const;
  void set_best_ship(::ei::MissionInfo_Spaceship value);
  private:
  ::ei::MissionInfo_Spaceship _internal_best_ship() const;
  void _internal_set_best_ship(::ei::MissionInfo_Spaceship value);
  public:

  // optional uint32 league = 5;
  bool has_league() const;
  private:
  bool _internal_has_league() const;
  public:
  void clear_league();
  uint32_t league() const;
  void set_league(uint32_t value);
  private:
  uint32_t _internal_league() const;
  void _internal_set_league(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.CollectContractArtifactRewardsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_identifier_;
  ::ei::BasicRequestInfo* rinfo_;
  uint32_t goal_index_;
  int best_ship_;
  uint32_t league_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class CraftArtifactRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.CraftArtifactRequest) */ {
 public:
  inline CraftArtifactRequest() : CraftArtifactRequest(nullptr) {}
  ~CraftArtifactRequest() override;
  explicit constexpr CraftArtifactRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CraftArtifactRequest(const CraftArtifactRequest& from);
  CraftArtifactRequest(CraftArtifactRequest&& from) noexcept
    : CraftArtifactRequest() {
    *this = ::std::move(from);
  }

  inline CraftArtifactRequest& operator=(const CraftArtifactRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CraftArtifactRequest& operator=(CraftArtifactRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CraftArtifactRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CraftArtifactRequest* internal_default_instance() {
    return reinterpret_cast<const CraftArtifactRequest*>(
               &_CraftArtifactRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    107;

  friend void swap(CraftArtifactRequest& a, CraftArtifactRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CraftArtifactRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CraftArtifactRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CraftArtifactRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CraftArtifactRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CraftArtifactRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CraftArtifactRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CraftArtifactRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.CraftArtifactRequest";
  }
  protected:
  explicit CraftArtifactRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIngredientsFieldNumber = 4,
    kEiUserIdFieldNumber = 1,
    kSpecFieldNumber = 2,
    kRinfoFieldNumber = 5,
    kItemIdFieldNumber = 3,
    kGoldPricePaidFieldNumber = 6,
    kCraftingCountFieldNumber = 7,
  };
  // repeated .ei.ArtifactInventoryItem ingredients = 4;
  int ingredients_size() const;
  private:
  int _internal_ingredients_size() const;
  public:
  void clear_ingredients();
  ::ei::ArtifactInventoryItem* mutable_ingredients(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactInventoryItem >*
      mutable_ingredients();
  private:
  const ::ei::ArtifactInventoryItem& _internal_ingredients(int index) const;
  ::ei::ArtifactInventoryItem* _internal_add_ingredients();
  public:
  const ::ei::ArtifactInventoryItem& ingredients(int index) const;
  ::ei::ArtifactInventoryItem* add_ingredients();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactInventoryItem >&
      ingredients() const;

  // optional string ei_user_id = 1;
  bool has_ei_user_id() const;
  private:
  bool _internal_has_ei_user_id() const;
  public:
  void clear_ei_user_id();
  const std::string& ei_user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ei_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ei_user_id();
  PROTOBUF_NODISCARD std::string* release_ei_user_id();
  void set_allocated_ei_user_id(std::string* ei_user_id);
  private:
  const std::string& _internal_ei_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ei_user_id(const std::string& value);
  std::string* _internal_mutable_ei_user_id();
  public:

  // optional .ei.ArtifactSpec spec = 2;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::ei::ArtifactSpec& spec() const;
  PROTOBUF_NODISCARD ::ei::ArtifactSpec* release_spec();
  ::ei::ArtifactSpec* mutable_spec();
  void set_allocated_spec(::ei::ArtifactSpec* spec);
  private:
  const ::ei::ArtifactSpec& _internal_spec() const;
  ::ei::ArtifactSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::ei::ArtifactSpec* spec);
  ::ei::ArtifactSpec* unsafe_arena_release_spec();

  // optional .ei.BasicRequestInfo rinfo = 5;
  bool has_rinfo() const;
  private:
  bool _internal_has_rinfo() const;
  public:
  void clear_rinfo();
  const ::ei::BasicRequestInfo& rinfo() const;
  PROTOBUF_NODISCARD ::ei::BasicRequestInfo* release_rinfo();
  ::ei::BasicRequestInfo* mutable_rinfo();
  void set_allocated_rinfo(::ei::BasicRequestInfo* rinfo);
  private:
  const ::ei::BasicRequestInfo& _internal_rinfo() const;
  ::ei::BasicRequestInfo* _internal_mutable_rinfo();
  public:
  void unsafe_arena_set_allocated_rinfo(
      ::ei::BasicRequestInfo* rinfo);
  ::ei::BasicRequestInfo* unsafe_arena_release_rinfo();

  // optional uint64 item_id = 3;
  bool has_item_id() const;
  private:
  bool _internal_has_item_id() const;
  public:
  void clear_item_id();
  uint64_t item_id() const;
  void set_item_id(uint64_t value);
  private:
  uint64_t _internal_item_id() const;
  void _internal_set_item_id(uint64_t value);
  public:

  // optional double gold_price_paid = 6;
  bool has_gold_price_paid() const;
  private:
  bool _internal_has_gold_price_paid() const;
  public:
  void clear_gold_price_paid();
  double gold_price_paid() const;
  void set_gold_price_paid(double value);
  private:
  double _internal_gold_price_paid() const;
  void _internal_set_gold_price_paid(double value);
  public:

  // optional uint32 crafting_count = 7;
  bool has_crafting_count() const;
  private:
  bool _internal_has_crafting_count() const;
  public:
  void clear_crafting_count();
  uint32_t crafting_count() const;
  void set_crafting_count(uint32_t value);
  private:
  uint32_t _internal_crafting_count() const;
  void _internal_set_crafting_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.CraftArtifactRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactInventoryItem > ingredients_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ei_user_id_;
  ::ei::ArtifactSpec* spec_;
  ::ei::BasicRequestInfo* rinfo_;
  uint64_t item_id_;
  double gold_price_paid_;
  uint32_t crafting_count_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class CraftArtifactResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.CraftArtifactResponse) */ {
 public:
  inline CraftArtifactResponse() : CraftArtifactResponse(nullptr) {}
  ~CraftArtifactResponse() override;
  explicit constexpr CraftArtifactResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CraftArtifactResponse(const CraftArtifactResponse& from);
  CraftArtifactResponse(CraftArtifactResponse&& from) noexcept
    : CraftArtifactResponse() {
    *this = ::std::move(from);
  }

  inline CraftArtifactResponse& operator=(const CraftArtifactResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CraftArtifactResponse& operator=(CraftArtifactResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CraftArtifactResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CraftArtifactResponse* internal_default_instance() {
    return reinterpret_cast<const CraftArtifactResponse*>(
               &_CraftArtifactResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    108;

  friend void swap(CraftArtifactResponse& a, CraftArtifactResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CraftArtifactResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CraftArtifactResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CraftArtifactResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CraftArtifactResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CraftArtifactResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CraftArtifactResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CraftArtifactResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.CraftArtifactResponse";
  }
  protected:
  explicit CraftArtifactResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerIdFieldNumber = 3,
    kEiUserIdFieldNumber = 5,
    kItemIdFieldNumber = 1,
    kRarityAchievedFieldNumber = 2,
  };
  // optional string server_id = 3;
  bool has_server_id() const;
  private:
  bool _internal_has_server_id() const;
  public:
  void clear_server_id();
  const std::string& server_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_id();
  PROTOBUF_NODISCARD std::string* release_server_id();
  void set_allocated_server_id(std::string* server_id);
  private:
  const std::string& _internal_server_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_id(const std::string& value);
  std::string* _internal_mutable_server_id();
  public:

  // optional string ei_user_id = 5;
  bool has_ei_user_id() const;
  private:
  bool _internal_has_ei_user_id() const;
  public:
  void clear_ei_user_id();
  const std::string& ei_user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ei_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ei_user_id();
  PROTOBUF_NODISCARD std::string* release_ei_user_id();
  void set_allocated_ei_user_id(std::string* ei_user_id);
  private:
  const std::string& _internal_ei_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ei_user_id(const std::string& value);
  std::string* _internal_mutable_ei_user_id();
  public:

  // optional uint64 item_id = 1;
  bool has_item_id() const;
  private:
  bool _internal_has_item_id() const;
  public:
  void clear_item_id();
  uint64_t item_id() const;
  void set_item_id(uint64_t value);
  private:
  uint64_t _internal_item_id() const;
  void _internal_set_item_id(uint64_t value);
  public:

  // optional .ei.ArtifactSpec.Rarity rarity_achieved = 2 [default = COMMON];
  bool has_rarity_achieved() const;
  private:
  bool _internal_has_rarity_achieved() const;
  public:
  void clear_rarity_achieved();
  ::ei::ArtifactSpec_Rarity rarity_achieved() const;
  void set_rarity_achieved(::ei::ArtifactSpec_Rarity value);
  private:
  ::ei::ArtifactSpec_Rarity _internal_rarity_achieved() const;
  void _internal_set_rarity_achieved(::ei::ArtifactSpec_Rarity value);
  public:

  // @@protoc_insertion_point(class_scope:ei.CraftArtifactResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ei_user_id_;
  uint64_t item_id_;
  int rarity_achieved_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ConsumeArtifactRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ConsumeArtifactRequest) */ {
 public:
  inline ConsumeArtifactRequest() : ConsumeArtifactRequest(nullptr) {}
  ~ConsumeArtifactRequest() override;
  explicit constexpr ConsumeArtifactRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConsumeArtifactRequest(const ConsumeArtifactRequest& from);
  ConsumeArtifactRequest(ConsumeArtifactRequest&& from) noexcept
    : ConsumeArtifactRequest() {
    *this = ::std::move(from);
  }

  inline ConsumeArtifactRequest& operator=(const ConsumeArtifactRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConsumeArtifactRequest& operator=(ConsumeArtifactRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConsumeArtifactRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConsumeArtifactRequest* internal_default_instance() {
    return reinterpret_cast<const ConsumeArtifactRequest*>(
               &_ConsumeArtifactRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    109;

  friend void swap(ConsumeArtifactRequest& a, ConsumeArtifactRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConsumeArtifactRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConsumeArtifactRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConsumeArtifactRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConsumeArtifactRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConsumeArtifactRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConsumeArtifactRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConsumeArtifactRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ConsumeArtifactRequest";
  }
  protected:
  explicit ConsumeArtifactRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEiUserIdFieldNumber = 3,
    kArtifactServerIdFieldNumber = 5,
    kSpecFieldNumber = 1,
    kRinfoFieldNumber = 4,
    kOriginalItemIdFieldNumber = 2,
    kQuantityFieldNumber = 6,
  };
  // optional string ei_user_id = 3;
  bool has_ei_user_id() const;
  private:
  bool _internal_has_ei_user_id() const;
  public:
  void clear_ei_user_id();
  const std::string& ei_user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ei_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ei_user_id();
  PROTOBUF_NODISCARD std::string* release_ei_user_id();
  void set_allocated_ei_user_id(std::string* ei_user_id);
  private:
  const std::string& _internal_ei_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ei_user_id(const std::string& value);
  std::string* _internal_mutable_ei_user_id();
  public:

  // optional string artifact_server_id = 5;
  bool has_artifact_server_id() const;
  private:
  bool _internal_has_artifact_server_id() const;
  public:
  void clear_artifact_server_id();
  const std::string& artifact_server_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_artifact_server_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_artifact_server_id();
  PROTOBUF_NODISCARD std::string* release_artifact_server_id();
  void set_allocated_artifact_server_id(std::string* artifact_server_id);
  private:
  const std::string& _internal_artifact_server_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_artifact_server_id(const std::string& value);
  std::string* _internal_mutable_artifact_server_id();
  public:

  // optional .ei.ArtifactSpec spec = 1;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::ei::ArtifactSpec& spec() const;
  PROTOBUF_NODISCARD ::ei::ArtifactSpec* release_spec();
  ::ei::ArtifactSpec* mutable_spec();
  void set_allocated_spec(::ei::ArtifactSpec* spec);
  private:
  const ::ei::ArtifactSpec& _internal_spec() const;
  ::ei::ArtifactSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::ei::ArtifactSpec* spec);
  ::ei::ArtifactSpec* unsafe_arena_release_spec();

  // optional .ei.BasicRequestInfo rinfo = 4;
  bool has_rinfo() const;
  private:
  bool _internal_has_rinfo() const;
  public:
  void clear_rinfo();
  const ::ei::BasicRequestInfo& rinfo() const;
  PROTOBUF_NODISCARD ::ei::BasicRequestInfo* release_rinfo();
  ::ei::BasicRequestInfo* mutable_rinfo();
  void set_allocated_rinfo(::ei::BasicRequestInfo* rinfo);
  private:
  const ::ei::BasicRequestInfo& _internal_rinfo() const;
  ::ei::BasicRequestInfo* _internal_mutable_rinfo();
  public:
  void unsafe_arena_set_allocated_rinfo(
      ::ei::BasicRequestInfo* rinfo);
  ::ei::BasicRequestInfo* unsafe_arena_release_rinfo();

  // optional uint64 original_item_id = 2;
  bool has_original_item_id() const;
  private:
  bool _internal_has_original_item_id() const;
  public:
  void clear_original_item_id();
  uint64_t original_item_id() const;
  void set_original_item_id(uint64_t value);
  private:
  uint64_t _internal_original_item_id() const;
  void _internal_set_original_item_id(uint64_t value);
  public:

  // optional uint32 quantity = 6;
  bool has_quantity() const;
  private:
  bool _internal_has_quantity() const;
  public:
  void clear_quantity();
  uint32_t quantity() const;
  void set_quantity(uint32_t value);
  private:
  uint32_t _internal_quantity() const;
  void _internal_set_quantity(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ConsumeArtifactRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ei_user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr artifact_server_id_;
  ::ei::ArtifactSpec* spec_;
  ::ei::BasicRequestInfo* rinfo_;
  uint64_t original_item_id_;
  uint32_t quantity_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ConsumeArtifactResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ConsumeArtifactResponse) */ {
 public:
  inline ConsumeArtifactResponse() : ConsumeArtifactResponse(nullptr) {}
  ~ConsumeArtifactResponse() override;
  explicit constexpr ConsumeArtifactResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConsumeArtifactResponse(const ConsumeArtifactResponse& from);
  ConsumeArtifactResponse(ConsumeArtifactResponse&& from) noexcept
    : ConsumeArtifactResponse() {
    *this = ::std::move(from);
  }

  inline ConsumeArtifactResponse& operator=(const ConsumeArtifactResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConsumeArtifactResponse& operator=(ConsumeArtifactResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConsumeArtifactResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConsumeArtifactResponse* internal_default_instance() {
    return reinterpret_cast<const ConsumeArtifactResponse*>(
               &_ConsumeArtifactResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    110;

  friend void swap(ConsumeArtifactResponse& a, ConsumeArtifactResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ConsumeArtifactResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConsumeArtifactResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConsumeArtifactResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConsumeArtifactResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConsumeArtifactResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConsumeArtifactResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConsumeArtifactResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ConsumeArtifactResponse";
  }
  protected:
  explicit ConsumeArtifactResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kByproductsFieldNumber = 3,
    kOtherRewardsFieldNumber = 4,
    kEiUserIdFieldNumber = 5,
    kOriginalItemIdFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // repeated .ei.ArtifactSpec byproducts = 3;
  int byproducts_size() const;
  private:
  int _internal_byproducts_size() const;
  public:
  void clear_byproducts();
  ::ei::ArtifactSpec* mutable_byproducts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactSpec >*
      mutable_byproducts();
  private:
  const ::ei::ArtifactSpec& _internal_byproducts(int index) const;
  ::ei::ArtifactSpec* _internal_add_byproducts();
  public:
  const ::ei::ArtifactSpec& byproducts(int index) const;
  ::ei::ArtifactSpec* add_byproducts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactSpec >&
      byproducts() const;

  // repeated .ei.Reward other_rewards = 4;
  int other_rewards_size() const;
  private:
  int _internal_other_rewards_size() const;
  public:
  void clear_other_rewards();
  ::ei::Reward* mutable_other_rewards(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Reward >*
      mutable_other_rewards();
  private:
  const ::ei::Reward& _internal_other_rewards(int index) const;
  ::ei::Reward* _internal_add_other_rewards();
  public:
  const ::ei::Reward& other_rewards(int index) const;
  ::ei::Reward* add_other_rewards();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Reward >&
      other_rewards() const;

  // optional string ei_user_id = 5;
  bool has_ei_user_id() const;
  private:
  bool _internal_has_ei_user_id() const;
  public:
  void clear_ei_user_id();
  const std::string& ei_user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ei_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ei_user_id();
  PROTOBUF_NODISCARD std::string* release_ei_user_id();
  void set_allocated_ei_user_id(std::string* ei_user_id);
  private:
  const std::string& _internal_ei_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ei_user_id(const std::string& value);
  std::string* _internal_mutable_ei_user_id();
  public:

  // optional uint64 original_item_id = 2;
  bool has_original_item_id() const;
  private:
  bool _internal_has_original_item_id() const;
  public:
  void clear_original_item_id();
  uint64_t original_item_id() const;
  void set_original_item_id(uint64_t value);
  private:
  uint64_t _internal_original_item_id() const;
  void _internal_set_original_item_id(uint64_t value);
  public:

  // optional bool success = 1;
  bool has_success() const;
  private:
  bool _internal_has_success() const;
  public:
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ConsumeArtifactResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactSpec > byproducts_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Reward > other_rewards_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ei_user_id_;
  uint64_t original_item_id_;
  bool success_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class AuthenticateArtifactResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.AuthenticateArtifactResponse) */ {
 public:
  inline AuthenticateArtifactResponse() : AuthenticateArtifactResponse(nullptr) {}
  ~AuthenticateArtifactResponse() override;
  explicit constexpr AuthenticateArtifactResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticateArtifactResponse(const AuthenticateArtifactResponse& from);
  AuthenticateArtifactResponse(AuthenticateArtifactResponse&& from) noexcept
    : AuthenticateArtifactResponse() {
    *this = ::std::move(from);
  }

  inline AuthenticateArtifactResponse& operator=(const AuthenticateArtifactResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticateArtifactResponse& operator=(AuthenticateArtifactResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticateArtifactResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthenticateArtifactResponse* internal_default_instance() {
    return reinterpret_cast<const AuthenticateArtifactResponse*>(
               &_AuthenticateArtifactResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    111;

  friend void swap(AuthenticateArtifactResponse& a, AuthenticateArtifactResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticateArtifactResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticateArtifactResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthenticateArtifactResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthenticateArtifactResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticateArtifactResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AuthenticateArtifactResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateArtifactResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.AuthenticateArtifactResponse";
  }
  protected:
  explicit AuthenticateArtifactResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEiUserIdFieldNumber = 5,
    kOriginalItemIdFieldNumber = 2,
    kSuccessFieldNumber = 1,
    kDemoteFieldNumber = 3,
    kDeleteFieldNumber = 4,
  };
  // optional string ei_user_id = 5;
  bool has_ei_user_id() const;
  private:
  bool _internal_has_ei_user_id() const;
  public:
  void clear_ei_user_id();
  const std::string& ei_user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ei_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ei_user_id();
  PROTOBUF_NODISCARD std::string* release_ei_user_id();
  void set_allocated_ei_user_id(std::string* ei_user_id);
  private:
  const std::string& _internal_ei_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ei_user_id(const std::string& value);
  std::string* _internal_mutable_ei_user_id();
  public:

  // optional uint64 original_item_id = 2;
  bool has_original_item_id() const;
  private:
  bool _internal_has_original_item_id() const;
  public:
  void clear_original_item_id();
  uint64_t original_item_id() const;
  void set_original_item_id(uint64_t value);
  private:
  uint64_t _internal_original_item_id() const;
  void _internal_set_original_item_id(uint64_t value);
  public:

  // optional bool success = 1;
  bool has_success() const;
  private:
  bool _internal_has_success() const;
  public:
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // optional bool demote = 3;
  bool has_demote() const;
  private:
  bool _internal_has_demote() const;
  public:
  void clear_demote();
  bool demote() const;
  void set_demote(bool value);
  private:
  bool _internal_demote() const;
  void _internal_set_demote(bool value);
  public:

  // optional bool delete = 4;
  bool has_delete_() const;
  private:
  bool _internal_has_delete_() const;
  public:
  void clear_delete_();
  bool delete_() const;
  void set_delete_(bool value);
  private:
  bool _internal_delete_() const;
  void _internal_set_delete_(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ei.AuthenticateArtifactResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ei_user_id_;
  uint64_t original_item_id_;
  bool success_;
  bool demote_;
  bool delete__;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class SetArtifactRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.SetArtifactRequest) */ {
 public:
  inline SetArtifactRequest() : SetArtifactRequest(nullptr) {}
  ~SetArtifactRequest() override;
  explicit constexpr SetArtifactRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetArtifactRequest(const SetArtifactRequest& from);
  SetArtifactRequest(SetArtifactRequest&& from) noexcept
    : SetArtifactRequest() {
    *this = ::std::move(from);
  }

  inline SetArtifactRequest& operator=(const SetArtifactRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetArtifactRequest& operator=(SetArtifactRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetArtifactRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetArtifactRequest* internal_default_instance() {
    return reinterpret_cast<const SetArtifactRequest*>(
               &_SetArtifactRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    112;

  friend void swap(SetArtifactRequest& a, SetArtifactRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetArtifactRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetArtifactRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetArtifactRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetArtifactRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetArtifactRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetArtifactRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetArtifactRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.SetArtifactRequest";
  }
  protected:
  explicit SetArtifactRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStonesFieldNumber = 3,
    kRinfoFieldNumber = 1,
    kArtifactFieldNumber = 2,
    kGoldPricePaidFieldNumber = 4,
  };
  // repeated .ei.ArtifactSpec stones = 3;
  int stones_size() const;
  private:
  int _internal_stones_size() const;
  public:
  void clear_stones();
  ::ei::ArtifactSpec* mutable_stones(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactSpec >*
      mutable_stones();
  private:
  const ::ei::ArtifactSpec& _internal_stones(int index) const;
  ::ei::ArtifactSpec* _internal_add_stones();
  public:
  const ::ei::ArtifactSpec& stones(int index) const;
  ::ei::ArtifactSpec* add_stones();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactSpec >&
      stones() const;

  // optional .ei.BasicRequestInfo rinfo = 1;
  bool has_rinfo() const;
  private:
  bool _internal_has_rinfo() const;
  public:
  void clear_rinfo();
  const ::ei::BasicRequestInfo& rinfo() const;
  PROTOBUF_NODISCARD ::ei::BasicRequestInfo* release_rinfo();
  ::ei::BasicRequestInfo* mutable_rinfo();
  void set_allocated_rinfo(::ei::BasicRequestInfo* rinfo);
  private:
  const ::ei::BasicRequestInfo& _internal_rinfo() const;
  ::ei::BasicRequestInfo* _internal_mutable_rinfo();
  public:
  void unsafe_arena_set_allocated_rinfo(
      ::ei::BasicRequestInfo* rinfo);
  ::ei::BasicRequestInfo* unsafe_arena_release_rinfo();

  // optional .ei.ArtifactInventoryItem artifact = 2;
  bool has_artifact() const;
  private:
  bool _internal_has_artifact() const;
  public:
  void clear_artifact();
  const ::ei::ArtifactInventoryItem& artifact() const;
  PROTOBUF_NODISCARD ::ei::ArtifactInventoryItem* release_artifact();
  ::ei::ArtifactInventoryItem* mutable_artifact();
  void set_allocated_artifact(::ei::ArtifactInventoryItem* artifact);
  private:
  const ::ei::ArtifactInventoryItem& _internal_artifact() const;
  ::ei::ArtifactInventoryItem* _internal_mutable_artifact();
  public:
  void unsafe_arena_set_allocated_artifact(
      ::ei::ArtifactInventoryItem* artifact);
  ::ei::ArtifactInventoryItem* unsafe_arena_release_artifact();

  // optional double gold_price_paid = 4;
  bool has_gold_price_paid() const;
  private:
  bool _internal_has_gold_price_paid() const;
  public:
  void clear_gold_price_paid();
  double gold_price_paid() const;
  void set_gold_price_paid(double value);
  private:
  double _internal_gold_price_paid() const;
  void _internal_set_gold_price_paid(double value);
  public:

  // @@protoc_insertion_point(class_scope:ei.SetArtifactRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactSpec > stones_;
  ::ei::BasicRequestInfo* rinfo_;
  ::ei::ArtifactInventoryItem* artifact_;
  double gold_price_paid_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class SetArtifactResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.SetArtifactResponse) */ {
 public:
  inline SetArtifactResponse() : SetArtifactResponse(nullptr) {}
  ~SetArtifactResponse() override;
  explicit constexpr SetArtifactResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetArtifactResponse(const SetArtifactResponse& from);
  SetArtifactResponse(SetArtifactResponse&& from) noexcept
    : SetArtifactResponse() {
    *this = ::std::move(from);
  }

  inline SetArtifactResponse& operator=(const SetArtifactResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetArtifactResponse& operator=(SetArtifactResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetArtifactResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetArtifactResponse* internal_default_instance() {
    return reinterpret_cast<const SetArtifactResponse*>(
               &_SetArtifactResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    113;

  friend void swap(SetArtifactResponse& a, SetArtifactResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetArtifactResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetArtifactResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetArtifactResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetArtifactResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetArtifactResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetArtifactResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetArtifactResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.SetArtifactResponse";
  }
  protected:
  explicit SetArtifactResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEiUserIdFieldNumber = 5,
    kOriginalItemIdFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // optional string ei_user_id = 5;
  bool has_ei_user_id() const;
  private:
  bool _internal_has_ei_user_id() const;
  public:
  void clear_ei_user_id();
  const std::string& ei_user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ei_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ei_user_id();
  PROTOBUF_NODISCARD std::string* release_ei_user_id();
  void set_allocated_ei_user_id(std::string* ei_user_id);
  private:
  const std::string& _internal_ei_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ei_user_id(const std::string& value);
  std::string* _internal_mutable_ei_user_id();
  public:

  // optional uint64 original_item_id = 2;
  bool has_original_item_id() const;
  private:
  bool _internal_has_original_item_id() const;
  public:
  void clear_original_item_id();
  uint64_t original_item_id() const;
  void set_original_item_id(uint64_t value);
  private:
  uint64_t _internal_original_item_id() const;
  void _internal_set_original_item_id(uint64_t value);
  public:

  // optional bool success = 1;
  bool has_success() const;
  private:
  bool _internal_has_success() const;
  public:
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ei.SetArtifactResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ei_user_id_;
  uint64_t original_item_id_;
  bool success_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ArtifactsDB_ActiveArtifactSlot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ArtifactsDB.ActiveArtifactSlot) */ {
 public:
  inline ArtifactsDB_ActiveArtifactSlot() : ArtifactsDB_ActiveArtifactSlot(nullptr) {}
  ~ArtifactsDB_ActiveArtifactSlot() override;
  explicit constexpr ArtifactsDB_ActiveArtifactSlot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArtifactsDB_ActiveArtifactSlot(const ArtifactsDB_ActiveArtifactSlot& from);
  ArtifactsDB_ActiveArtifactSlot(ArtifactsDB_ActiveArtifactSlot&& from) noexcept
    : ArtifactsDB_ActiveArtifactSlot() {
    *this = ::std::move(from);
  }

  inline ArtifactsDB_ActiveArtifactSlot& operator=(const ArtifactsDB_ActiveArtifactSlot& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArtifactsDB_ActiveArtifactSlot& operator=(ArtifactsDB_ActiveArtifactSlot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArtifactsDB_ActiveArtifactSlot& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArtifactsDB_ActiveArtifactSlot* internal_default_instance() {
    return reinterpret_cast<const ArtifactsDB_ActiveArtifactSlot*>(
               &_ArtifactsDB_ActiveArtifactSlot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    114;

  friend void swap(ArtifactsDB_ActiveArtifactSlot& a, ArtifactsDB_ActiveArtifactSlot& b) {
    a.Swap(&b);
  }
  inline void Swap(ArtifactsDB_ActiveArtifactSlot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArtifactsDB_ActiveArtifactSlot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArtifactsDB_ActiveArtifactSlot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArtifactsDB_ActiveArtifactSlot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArtifactsDB_ActiveArtifactSlot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ArtifactsDB_ActiveArtifactSlot& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactsDB_ActiveArtifactSlot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ArtifactsDB.ActiveArtifactSlot";
  }
  protected:
  explicit ArtifactsDB_ActiveArtifactSlot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 2,
    kOccupiedFieldNumber = 1,
  };
  // optional uint64 item_id = 2;
  bool has_item_id() const;
  private:
  bool _internal_has_item_id() const;
  public:
  void clear_item_id();
  uint64_t item_id() const;
  void set_item_id(uint64_t value);
  private:
  uint64_t _internal_item_id() const;
  void _internal_set_item_id(uint64_t value);
  public:

  // optional bool occupied = 1;
  bool has_occupied() const;
  private:
  bool _internal_has_occupied() const;
  public:
  void clear_occupied();
  bool occupied() const;
  void set_occupied(bool value);
  private:
  bool _internal_occupied() const;
  void _internal_set_occupied(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ArtifactsDB.ActiveArtifactSlot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t item_id_;
  bool occupied_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ArtifactsDB_ActiveArtifactSet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ArtifactsDB.ActiveArtifactSet) */ {
 public:
  inline ArtifactsDB_ActiveArtifactSet() : ArtifactsDB_ActiveArtifactSet(nullptr) {}
  ~ArtifactsDB_ActiveArtifactSet() override;
  explicit constexpr ArtifactsDB_ActiveArtifactSet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArtifactsDB_ActiveArtifactSet(const ArtifactsDB_ActiveArtifactSet& from);
  ArtifactsDB_ActiveArtifactSet(ArtifactsDB_ActiveArtifactSet&& from) noexcept
    : ArtifactsDB_ActiveArtifactSet() {
    *this = ::std::move(from);
  }

  inline ArtifactsDB_ActiveArtifactSet& operator=(const ArtifactsDB_ActiveArtifactSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArtifactsDB_ActiveArtifactSet& operator=(ArtifactsDB_ActiveArtifactSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArtifactsDB_ActiveArtifactSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArtifactsDB_ActiveArtifactSet* internal_default_instance() {
    return reinterpret_cast<const ArtifactsDB_ActiveArtifactSet*>(
               &_ArtifactsDB_ActiveArtifactSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    115;

  friend void swap(ArtifactsDB_ActiveArtifactSet& a, ArtifactsDB_ActiveArtifactSet& b) {
    a.Swap(&b);
  }
  inline void Swap(ArtifactsDB_ActiveArtifactSet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArtifactsDB_ActiveArtifactSet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArtifactsDB_ActiveArtifactSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArtifactsDB_ActiveArtifactSet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArtifactsDB_ActiveArtifactSet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ArtifactsDB_ActiveArtifactSet& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactsDB_ActiveArtifactSet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ArtifactsDB.ActiveArtifactSet";
  }
  protected:
  explicit ArtifactsDB_ActiveArtifactSet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlotsFieldNumber = 1,
  };
  // repeated .ei.ArtifactsDB.ActiveArtifactSlot slots = 1;
  int slots_size() const;
  private:
  int _internal_slots_size() const;
  public:
  void clear_slots();
  ::ei::ArtifactsDB_ActiveArtifactSlot* mutable_slots(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsDB_ActiveArtifactSlot >*
      mutable_slots();
  private:
  const ::ei::ArtifactsDB_ActiveArtifactSlot& _internal_slots(int index) const;
  ::ei::ArtifactsDB_ActiveArtifactSlot* _internal_add_slots();
  public:
  const ::ei::ArtifactsDB_ActiveArtifactSlot& slots(int index) const;
  ::ei::ArtifactsDB_ActiveArtifactSlot* add_slots();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsDB_ActiveArtifactSlot >&
      slots() const;

  // @@protoc_insertion_point(class_scope:ei.ArtifactsDB.ActiveArtifactSet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsDB_ActiveArtifactSlot > slots_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ArtifactsDB_CraftableArtifact final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ArtifactsDB.CraftableArtifact) */ {
 public:
  inline ArtifactsDB_CraftableArtifact() : ArtifactsDB_CraftableArtifact(nullptr) {}
  ~ArtifactsDB_CraftableArtifact() override;
  explicit constexpr ArtifactsDB_CraftableArtifact(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArtifactsDB_CraftableArtifact(const ArtifactsDB_CraftableArtifact& from);
  ArtifactsDB_CraftableArtifact(ArtifactsDB_CraftableArtifact&& from) noexcept
    : ArtifactsDB_CraftableArtifact() {
    *this = ::std::move(from);
  }

  inline ArtifactsDB_CraftableArtifact& operator=(const ArtifactsDB_CraftableArtifact& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArtifactsDB_CraftableArtifact& operator=(ArtifactsDB_CraftableArtifact&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArtifactsDB_CraftableArtifact& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArtifactsDB_CraftableArtifact* internal_default_instance() {
    return reinterpret_cast<const ArtifactsDB_CraftableArtifact*>(
               &_ArtifactsDB_CraftableArtifact_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    116;

  friend void swap(ArtifactsDB_CraftableArtifact& a, ArtifactsDB_CraftableArtifact& b) {
    a.Swap(&b);
  }
  inline void Swap(ArtifactsDB_CraftableArtifact* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArtifactsDB_CraftableArtifact* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArtifactsDB_CraftableArtifact* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArtifactsDB_CraftableArtifact>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArtifactsDB_CraftableArtifact& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ArtifactsDB_CraftableArtifact& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactsDB_CraftableArtifact* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ArtifactsDB.CraftableArtifact";
  }
  protected:
  explicit ArtifactsDB_CraftableArtifact(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecFieldNumber = 1,
    kSeenFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // optional .ei.ArtifactSpec spec = 1;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::ei::ArtifactSpec& spec() const;
  PROTOBUF_NODISCARD ::ei::ArtifactSpec* release_spec();
  ::ei::ArtifactSpec* mutable_spec();
  void set_allocated_spec(::ei::ArtifactSpec* spec);
  private:
  const ::ei::ArtifactSpec& _internal_spec() const;
  ::ei::ArtifactSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::ei::ArtifactSpec* spec);
  ::ei::ArtifactSpec* unsafe_arena_release_spec();

  // optional bool seen = 2;
  bool has_seen() const;
  private:
  bool _internal_has_seen() const;
  public:
  void clear_seen();
  bool seen() const;
  void set_seen(bool value);
  private:
  bool _internal_seen() const;
  void _internal_set_seen(bool value);
  public:

  // optional uint32 count = 3;
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ArtifactsDB.CraftableArtifact)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ei::ArtifactSpec* spec_;
  bool seen_;
  uint32_t count_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ArtifactsDB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ArtifactsDB) */ {
 public:
  inline ArtifactsDB() : ArtifactsDB(nullptr) {}
  ~ArtifactsDB() override;
  explicit constexpr ArtifactsDB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArtifactsDB(const ArtifactsDB& from);
  ArtifactsDB(ArtifactsDB&& from) noexcept
    : ArtifactsDB() {
    *this = ::std::move(from);
  }

  inline ArtifactsDB& operator=(const ArtifactsDB& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArtifactsDB& operator=(ArtifactsDB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArtifactsDB& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArtifactsDB* internal_default_instance() {
    return reinterpret_cast<const ArtifactsDB*>(
               &_ArtifactsDB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    117;

  friend void swap(ArtifactsDB& a, ArtifactsDB& b) {
    a.Swap(&b);
  }
  inline void Swap(ArtifactsDB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArtifactsDB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArtifactsDB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArtifactsDB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArtifactsDB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ArtifactsDB& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactsDB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ArtifactsDB";
  }
  protected:
  explicit ArtifactsDB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ArtifactsDB_ActiveArtifactSlot ActiveArtifactSlot;
  typedef ArtifactsDB_ActiveArtifactSet ActiveArtifactSet;
  typedef ArtifactsDB_CraftableArtifact CraftableArtifact;

  // accessors -------------------------------------------------------

  enum : int {
    kInventoryItemsFieldNumber = 1,
    kInventorySlotsFieldNumber = 3,
    kMissionInfosFieldNumber = 4,
    kMissionArchiveFieldNumber = 5,
    kActiveArtifactsFieldNumber = 7,
    kDiscoveredArtifactsFieldNumber = 8,
    kCraftableArtifactsFieldNumber = 9,
    kCraftingCountsFieldNumber = 10,
    kActiveArtifactSetsFieldNumber = 11,
    kItemSequenceFieldNumber = 2,
  };
  // repeated .ei.ArtifactInventoryItem inventory_items = 1;
  int inventory_items_size() const;
  private:
  int _internal_inventory_items_size() const;
  public:
  void clear_inventory_items();
  ::ei::ArtifactInventoryItem* mutable_inventory_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactInventoryItem >*
      mutable_inventory_items();
  private:
  const ::ei::ArtifactInventoryItem& _internal_inventory_items(int index) const;
  ::ei::ArtifactInventoryItem* _internal_add_inventory_items();
  public:
  const ::ei::ArtifactInventoryItem& inventory_items(int index) const;
  ::ei::ArtifactInventoryItem* add_inventory_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactInventoryItem >&
      inventory_items() const;

  // repeated .ei.InventorySlot inventory_slots = 3;
  int inventory_slots_size() const;
  private:
  int _internal_inventory_slots_size() const;
  public:
  void clear_inventory_slots();
  ::ei::InventorySlot* mutable_inventory_slots(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::InventorySlot >*
      mutable_inventory_slots();
  private:
  const ::ei::InventorySlot& _internal_inventory_slots(int index) const;
  ::ei::InventorySlot* _internal_add_inventory_slots();
  public:
  const ::ei::InventorySlot& inventory_slots(int index) const;
  ::ei::InventorySlot* add_inventory_slots();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::InventorySlot >&
      inventory_slots() const;

  // repeated .ei.MissionInfo mission_infos = 4;
  int mission_infos_size() const;
  private:
  int _internal_mission_infos_size() const;
  public:
  void clear_mission_infos();
  ::ei::MissionInfo* mutable_mission_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::MissionInfo >*
      mutable_mission_infos();
  private:
  const ::ei::MissionInfo& _internal_mission_infos(int index) const;
  ::ei::MissionInfo* _internal_add_mission_infos();
  public:
  const ::ei::MissionInfo& mission_infos(int index) const;
  ::ei::MissionInfo* add_mission_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::MissionInfo >&
      mission_infos() const;

  // repeated .ei.MissionInfo mission_archive = 5;
  int mission_archive_size() const;
  private:
  int _internal_mission_archive_size() const;
  public:
  void clear_mission_archive();
  ::ei::MissionInfo* mutable_mission_archive(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::MissionInfo >*
      mutable_mission_archive();
  private:
  const ::ei::MissionInfo& _internal_mission_archive(int index) const;
  ::ei::MissionInfo* _internal_add_mission_archive();
  public:
  const ::ei::MissionInfo& mission_archive(int index) const;
  ::ei::MissionInfo* add_mission_archive();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::MissionInfo >&
      mission_archive() const;

  // repeated .ei.ArtifactsDB.ActiveArtifactSlot active_artifacts = 7;
  int active_artifacts_size() const;
  private:
  int _internal_active_artifacts_size() const;
  public:
  void clear_active_artifacts();
  ::ei::ArtifactsDB_ActiveArtifactSlot* mutable_active_artifacts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsDB_ActiveArtifactSlot >*
      mutable_active_artifacts();
  private:
  const ::ei::ArtifactsDB_ActiveArtifactSlot& _internal_active_artifacts(int index) const;
  ::ei::ArtifactsDB_ActiveArtifactSlot* _internal_add_active_artifacts();
  public:
  const ::ei::ArtifactsDB_ActiveArtifactSlot& active_artifacts(int index) const;
  ::ei::ArtifactsDB_ActiveArtifactSlot* add_active_artifacts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsDB_ActiveArtifactSlot >&
      active_artifacts() const;

  // repeated .ei.ArtifactSpec discovered_artifacts = 8;
  int discovered_artifacts_size() const;
  private:
  int _internal_discovered_artifacts_size() const;
  public:
  void clear_discovered_artifacts();
  ::ei::ArtifactSpec* mutable_discovered_artifacts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactSpec >*
      mutable_discovered_artifacts();
  private:
  const ::ei::ArtifactSpec& _internal_discovered_artifacts(int index) const;
  ::ei::ArtifactSpec* _internal_add_discovered_artifacts();
  public:
  const ::ei::ArtifactSpec& discovered_artifacts(int index) const;
  ::ei::ArtifactSpec* add_discovered_artifacts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactSpec >&
      discovered_artifacts() const;

  // repeated .ei.ArtifactsDB.CraftableArtifact craftable_artifacts = 9;
  int craftable_artifacts_size() const;
  private:
  int _internal_craftable_artifacts_size() const;
  public:
  void clear_craftable_artifacts();
  ::ei::ArtifactsDB_CraftableArtifact* mutable_craftable_artifacts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsDB_CraftableArtifact >*
      mutable_craftable_artifacts();
  private:
  const ::ei::ArtifactsDB_CraftableArtifact& _internal_craftable_artifacts(int index) const;
  ::ei::ArtifactsDB_CraftableArtifact* _internal_add_craftable_artifacts();
  public:
  const ::ei::ArtifactsDB_CraftableArtifact& craftable_artifacts(int index) const;
  ::ei::ArtifactsDB_CraftableArtifact* add_craftable_artifacts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsDB_CraftableArtifact >&
      craftable_artifacts() const;

  // repeated .ei.ArtifactsDB.CraftableArtifact crafting_counts = 10;
  int crafting_counts_size() const;
  private:
  int _internal_crafting_counts_size() const;
  public:
  void clear_crafting_counts();
  ::ei::ArtifactsDB_CraftableArtifact* mutable_crafting_counts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsDB_CraftableArtifact >*
      mutable_crafting_counts();
  private:
  const ::ei::ArtifactsDB_CraftableArtifact& _internal_crafting_counts(int index) const;
  ::ei::ArtifactsDB_CraftableArtifact* _internal_add_crafting_counts();
  public:
  const ::ei::ArtifactsDB_CraftableArtifact& crafting_counts(int index) const;
  ::ei::ArtifactsDB_CraftableArtifact* add_crafting_counts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsDB_CraftableArtifact >&
      crafting_counts() const;

  // repeated .ei.ArtifactsDB.ActiveArtifactSet active_artifact_sets = 11;
  int active_artifact_sets_size() const;
  private:
  int _internal_active_artifact_sets_size() const;
  public:
  void clear_active_artifact_sets();
  ::ei::ArtifactsDB_ActiveArtifactSet* mutable_active_artifact_sets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsDB_ActiveArtifactSet >*
      mutable_active_artifact_sets();
  private:
  const ::ei::ArtifactsDB_ActiveArtifactSet& _internal_active_artifact_sets(int index) const;
  ::ei::ArtifactsDB_ActiveArtifactSet* _internal_add_active_artifact_sets();
  public:
  const ::ei::ArtifactsDB_ActiveArtifactSet& active_artifact_sets(int index) const;
  ::ei::ArtifactsDB_ActiveArtifactSet* add_active_artifact_sets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsDB_ActiveArtifactSet >&
      active_artifact_sets() const;

  // optional uint64 item_sequence = 2;
  bool has_item_sequence() const;
  private:
  bool _internal_has_item_sequence() const;
  public:
  void clear_item_sequence();
  uint64_t item_sequence() const;
  void set_item_sequence(uint64_t value);
  private:
  uint64_t _internal_item_sequence() const;
  void _internal_set_item_sequence(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ArtifactsDB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactInventoryItem > inventory_items_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::InventorySlot > inventory_slots_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::MissionInfo > mission_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::MissionInfo > mission_archive_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsDB_ActiveArtifactSlot > active_artifacts_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactSpec > discovered_artifacts_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsDB_CraftableArtifact > craftable_artifacts_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsDB_CraftableArtifact > crafting_counts_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsDB_ActiveArtifactSet > active_artifact_sets_;
  uint64_t item_sequence_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class AuthenticatedMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.AuthenticatedMessage) */ {
 public:
  inline AuthenticatedMessage() : AuthenticatedMessage(nullptr) {}
  ~AuthenticatedMessage() override;
  explicit constexpr AuthenticatedMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticatedMessage(const AuthenticatedMessage& from);
  AuthenticatedMessage(AuthenticatedMessage&& from) noexcept
    : AuthenticatedMessage() {
    *this = ::std::move(from);
  }

  inline AuthenticatedMessage& operator=(const AuthenticatedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticatedMessage& operator=(AuthenticatedMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticatedMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthenticatedMessage* internal_default_instance() {
    return reinterpret_cast<const AuthenticatedMessage*>(
               &_AuthenticatedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    118;

  friend void swap(AuthenticatedMessage& a, AuthenticatedMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticatedMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticatedMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthenticatedMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthenticatedMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticatedMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AuthenticatedMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticatedMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.AuthenticatedMessage";
  }
  protected:
  explicit AuthenticatedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
    kCodeFieldNumber = 2,
    kVersionFieldNumber = 3,
  };
  // optional bytes message = 1;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // optional string code = 2;
  bool has_code() const;
  private:
  bool _internal_has_code() const;
  public:
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // optional uint32 version = 3;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.AuthenticatedMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
  uint32_t version_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class LogCompleteMissionPayload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.LogCompleteMissionPayload) */ {
 public:
  inline LogCompleteMissionPayload() : LogCompleteMissionPayload(nullptr) {}
  ~LogCompleteMissionPayload() override;
  explicit constexpr LogCompleteMissionPayload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogCompleteMissionPayload(const LogCompleteMissionPayload& from);
  LogCompleteMissionPayload(LogCompleteMissionPayload&& from) noexcept
    : LogCompleteMissionPayload() {
    *this = ::std::move(from);
  }

  inline LogCompleteMissionPayload& operator=(const LogCompleteMissionPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogCompleteMissionPayload& operator=(LogCompleteMissionPayload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogCompleteMissionPayload& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogCompleteMissionPayload* internal_default_instance() {
    return reinterpret_cast<const LogCompleteMissionPayload*>(
               &_LogCompleteMissionPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    119;

  friend void swap(LogCompleteMissionPayload& a, LogCompleteMissionPayload& b) {
    a.Swap(&b);
  }
  inline void Swap(LogCompleteMissionPayload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogCompleteMissionPayload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogCompleteMissionPayload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogCompleteMissionPayload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogCompleteMissionPayload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LogCompleteMissionPayload& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogCompleteMissionPayload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.LogCompleteMissionPayload";
  }
  protected:
  explicit LogCompleteMissionPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqFieldNumber = 1,
    kResFieldNumber = 2,
  };
  // optional .ei.MissionRequest req = 1;
  bool has_req() const;
  private:
  bool _internal_has_req() const;
  public:
  void clear_req();
  const ::ei::MissionRequest& req() const;
  PROTOBUF_NODISCARD ::ei::MissionRequest* release_req();
  ::ei::MissionRequest* mutable_req();
  void set_allocated_req(::ei::MissionRequest* req);
  private:
  const ::ei::MissionRequest& _internal_req() const;
  ::ei::MissionRequest* _internal_mutable_req();
  public:
  void unsafe_arena_set_allocated_req(
      ::ei::MissionRequest* req);
  ::ei::MissionRequest* unsafe_arena_release_req();

  // optional .ei.CompleteMissionResponse res = 2;
  bool has_res() const;
  private:
  bool _internal_has_res() const;
  public:
  void clear_res();
  const ::ei::CompleteMissionResponse& res() const;
  PROTOBUF_NODISCARD ::ei::CompleteMissionResponse* release_res();
  ::ei::CompleteMissionResponse* mutable_res();
  void set_allocated_res(::ei::CompleteMissionResponse* res);
  private:
  const ::ei::CompleteMissionResponse& _internal_res() const;
  ::ei::CompleteMissionResponse* _internal_mutable_res();
  public:
  void unsafe_arena_set_allocated_res(
      ::ei::CompleteMissionResponse* res);
  ::ei::CompleteMissionResponse* unsafe_arena_release_res();

  // @@protoc_insertion_point(class_scope:ei.LogCompleteMissionPayload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ei::MissionRequest* req_;
  ::ei::CompleteMissionResponse* res_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class LogCraftArtifactPayload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.LogCraftArtifactPayload) */ {
 public:
  inline LogCraftArtifactPayload() : LogCraftArtifactPayload(nullptr) {}
  ~LogCraftArtifactPayload() override;
  explicit constexpr LogCraftArtifactPayload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogCraftArtifactPayload(const LogCraftArtifactPayload& from);
  LogCraftArtifactPayload(LogCraftArtifactPayload&& from) noexcept
    : LogCraftArtifactPayload() {
    *this = ::std::move(from);
  }

  inline LogCraftArtifactPayload& operator=(const LogCraftArtifactPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogCraftArtifactPayload& operator=(LogCraftArtifactPayload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogCraftArtifactPayload& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogCraftArtifactPayload* internal_default_instance() {
    return reinterpret_cast<const LogCraftArtifactPayload*>(
               &_LogCraftArtifactPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    120;

  friend void swap(LogCraftArtifactPayload& a, LogCraftArtifactPayload& b) {
    a.Swap(&b);
  }
  inline void Swap(LogCraftArtifactPayload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogCraftArtifactPayload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogCraftArtifactPayload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogCraftArtifactPayload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogCraftArtifactPayload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LogCraftArtifactPayload& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogCraftArtifactPayload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.LogCraftArtifactPayload";
  }
  protected:
  explicit LogCraftArtifactPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqFieldNumber = 1,
    kResFieldNumber = 2,
  };
  // optional .ei.CraftArtifactRequest req = 1;
  bool has_req() const;
  private:
  bool _internal_has_req() const;
  public:
  void clear_req();
  const ::ei::CraftArtifactRequest& req() const;
  PROTOBUF_NODISCARD ::ei::CraftArtifactRequest* release_req();
  ::ei::CraftArtifactRequest* mutable_req();
  void set_allocated_req(::ei::CraftArtifactRequest* req);
  private:
  const ::ei::CraftArtifactRequest& _internal_req() const;
  ::ei::CraftArtifactRequest* _internal_mutable_req();
  public:
  void unsafe_arena_set_allocated_req(
      ::ei::CraftArtifactRequest* req);
  ::ei::CraftArtifactRequest* unsafe_arena_release_req();

  // optional .ei.CraftArtifactResponse res = 2;
  bool has_res() const;
  private:
  bool _internal_has_res() const;
  public:
  void clear_res();
  const ::ei::CraftArtifactResponse& res() const;
  PROTOBUF_NODISCARD ::ei::CraftArtifactResponse* release_res();
  ::ei::CraftArtifactResponse* mutable_res();
  void set_allocated_res(::ei::CraftArtifactResponse* res);
  private:
  const ::ei::CraftArtifactResponse& _internal_res() const;
  ::ei::CraftArtifactResponse* _internal_mutable_res();
  public:
  void unsafe_arena_set_allocated_res(
      ::ei::CraftArtifactResponse* res);
  ::ei::CraftArtifactResponse* unsafe_arena_release_res();

  // @@protoc_insertion_point(class_scope:ei.LogCraftArtifactPayload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ei::CraftArtifactRequest* req_;
  ::ei::CraftArtifactResponse* res_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class LogConsumeArtifactPayload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.LogConsumeArtifactPayload) */ {
 public:
  inline LogConsumeArtifactPayload() : LogConsumeArtifactPayload(nullptr) {}
  ~LogConsumeArtifactPayload() override;
  explicit constexpr LogConsumeArtifactPayload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogConsumeArtifactPayload(const LogConsumeArtifactPayload& from);
  LogConsumeArtifactPayload(LogConsumeArtifactPayload&& from) noexcept
    : LogConsumeArtifactPayload() {
    *this = ::std::move(from);
  }

  inline LogConsumeArtifactPayload& operator=(const LogConsumeArtifactPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogConsumeArtifactPayload& operator=(LogConsumeArtifactPayload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogConsumeArtifactPayload& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogConsumeArtifactPayload* internal_default_instance() {
    return reinterpret_cast<const LogConsumeArtifactPayload*>(
               &_LogConsumeArtifactPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    121;

  friend void swap(LogConsumeArtifactPayload& a, LogConsumeArtifactPayload& b) {
    a.Swap(&b);
  }
  inline void Swap(LogConsumeArtifactPayload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogConsumeArtifactPayload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogConsumeArtifactPayload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogConsumeArtifactPayload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogConsumeArtifactPayload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LogConsumeArtifactPayload& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogConsumeArtifactPayload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.LogConsumeArtifactPayload";
  }
  protected:
  explicit LogConsumeArtifactPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqFieldNumber = 1,
    kResFieldNumber = 2,
  };
  // optional .ei.ConsumeArtifactRequest req = 1;
  bool has_req() const;
  private:
  bool _internal_has_req() const;
  public:
  void clear_req();
  const ::ei::ConsumeArtifactRequest& req() const;
  PROTOBUF_NODISCARD ::ei::ConsumeArtifactRequest* release_req();
  ::ei::ConsumeArtifactRequest* mutable_req();
  void set_allocated_req(::ei::ConsumeArtifactRequest* req);
  private:
  const ::ei::ConsumeArtifactRequest& _internal_req() const;
  ::ei::ConsumeArtifactRequest* _internal_mutable_req();
  public:
  void unsafe_arena_set_allocated_req(
      ::ei::ConsumeArtifactRequest* req);
  ::ei::ConsumeArtifactRequest* unsafe_arena_release_req();

  // optional .ei.ConsumeArtifactResponse res = 2;
  bool has_res() const;
  private:
  bool _internal_has_res() const;
  public:
  void clear_res();
  const ::ei::ConsumeArtifactResponse& res() const;
  PROTOBUF_NODISCARD ::ei::ConsumeArtifactResponse* release_res();
  ::ei::ConsumeArtifactResponse* mutable_res();
  void set_allocated_res(::ei::ConsumeArtifactResponse* res);
  private:
  const ::ei::ConsumeArtifactResponse& _internal_res() const;
  ::ei::ConsumeArtifactResponse* _internal_mutable_res();
  public:
  void unsafe_arena_set_allocated_res(
      ::ei::ConsumeArtifactResponse* res);
  ::ei::ConsumeArtifactResponse* unsafe_arena_release_res();

  // @@protoc_insertion_point(class_scope:ei.LogConsumeArtifactPayload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ei::ConsumeArtifactRequest* req_;
  ::ei::ConsumeArtifactResponse* res_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class LogSetArtifactPayload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.LogSetArtifactPayload) */ {
 public:
  inline LogSetArtifactPayload() : LogSetArtifactPayload(nullptr) {}
  ~LogSetArtifactPayload() override;
  explicit constexpr LogSetArtifactPayload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogSetArtifactPayload(const LogSetArtifactPayload& from);
  LogSetArtifactPayload(LogSetArtifactPayload&& from) noexcept
    : LogSetArtifactPayload() {
    *this = ::std::move(from);
  }

  inline LogSetArtifactPayload& operator=(const LogSetArtifactPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogSetArtifactPayload& operator=(LogSetArtifactPayload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogSetArtifactPayload& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogSetArtifactPayload* internal_default_instance() {
    return reinterpret_cast<const LogSetArtifactPayload*>(
               &_LogSetArtifactPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    122;

  friend void swap(LogSetArtifactPayload& a, LogSetArtifactPayload& b) {
    a.Swap(&b);
  }
  inline void Swap(LogSetArtifactPayload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogSetArtifactPayload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogSetArtifactPayload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogSetArtifactPayload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogSetArtifactPayload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LogSetArtifactPayload& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogSetArtifactPayload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.LogSetArtifactPayload";
  }
  protected:
  explicit LogSetArtifactPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqFieldNumber = 1,
    kResFieldNumber = 2,
  };
  // optional .ei.SetArtifactRequest req = 1;
  bool has_req() const;
  private:
  bool _internal_has_req() const;
  public:
  void clear_req();
  const ::ei::SetArtifactRequest& req() const;
  PROTOBUF_NODISCARD ::ei::SetArtifactRequest* release_req();
  ::ei::SetArtifactRequest* mutable_req();
  void set_allocated_req(::ei::SetArtifactRequest* req);
  private:
  const ::ei::SetArtifactRequest& _internal_req() const;
  ::ei::SetArtifactRequest* _internal_mutable_req();
  public:
  void unsafe_arena_set_allocated_req(
      ::ei::SetArtifactRequest* req);
  ::ei::SetArtifactRequest* unsafe_arena_release_req();

  // optional .ei.SetArtifactResponse res = 2;
  bool has_res() const;
  private:
  bool _internal_has_res() const;
  public:
  void clear_res();
  const ::ei::SetArtifactResponse& res() const;
  PROTOBUF_NODISCARD ::ei::SetArtifactResponse* release_res();
  ::ei::SetArtifactResponse* mutable_res();
  void set_allocated_res(::ei::SetArtifactResponse* res);
  private:
  const ::ei::SetArtifactResponse& _internal_res() const;
  ::ei::SetArtifactResponse* _internal_mutable_res();
  public:
  void unsafe_arena_set_allocated_res(
      ::ei::SetArtifactResponse* res);
  ::ei::SetArtifactResponse* unsafe_arena_release_res();

  // @@protoc_insertion_point(class_scope:ei.LogSetArtifactPayload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ei::SetArtifactRequest* req_;
  ::ei::SetArtifactResponse* res_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class AccountTransferPayload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.AccountTransferPayload) */ {
 public:
  inline AccountTransferPayload() : AccountTransferPayload(nullptr) {}
  ~AccountTransferPayload() override;
  explicit constexpr AccountTransferPayload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountTransferPayload(const AccountTransferPayload& from);
  AccountTransferPayload(AccountTransferPayload&& from) noexcept
    : AccountTransferPayload() {
    *this = ::std::move(from);
  }

  inline AccountTransferPayload& operator=(const AccountTransferPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountTransferPayload& operator=(AccountTransferPayload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountTransferPayload& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountTransferPayload* internal_default_instance() {
    return reinterpret_cast<const AccountTransferPayload*>(
               &_AccountTransferPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    123;

  friend void swap(AccountTransferPayload& a, AccountTransferPayload& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountTransferPayload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountTransferPayload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountTransferPayload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccountTransferPayload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountTransferPayload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AccountTransferPayload& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountTransferPayload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.AccountTransferPayload";
  }
  protected:
  explicit AccountTransferPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromIdFieldNumber = 1,
    kToEiUserIdFieldNumber = 2,
  };
  // optional string from_id = 1;
  bool has_from_id() const;
  private:
  bool _internal_has_from_id() const;
  public:
  void clear_from_id();
  const std::string& from_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from_id();
  PROTOBUF_NODISCARD std::string* release_from_id();
  void set_allocated_from_id(std::string* from_id);
  private:
  const std::string& _internal_from_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from_id(const std::string& value);
  std::string* _internal_mutable_from_id();
  public:

  // optional string to_ei_user_id = 2;
  bool has_to_ei_user_id() const;
  private:
  bool _internal_has_to_ei_user_id() const;
  public:
  void clear_to_ei_user_id();
  const std::string& to_ei_user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_ei_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_ei_user_id();
  PROTOBUF_NODISCARD std::string* release_to_ei_user_id();
  void set_allocated_to_ei_user_id(std::string* to_ei_user_id);
  private:
  const std::string& _internal_to_ei_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_ei_user_id(const std::string& value);
  std::string* _internal_mutable_to_ei_user_id();
  public:

  // @@protoc_insertion_point(class_scope:ei.AccountTransferPayload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_ei_user_id_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class SaveBackupResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.SaveBackupResponse) */ {
 public:
  inline SaveBackupResponse() : SaveBackupResponse(nullptr) {}
  ~SaveBackupResponse() override;
  explicit constexpr SaveBackupResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SaveBackupResponse(const SaveBackupResponse& from);
  SaveBackupResponse(SaveBackupResponse&& from) noexcept
    : SaveBackupResponse() {
    *this = ::std::move(from);
  }

  inline SaveBackupResponse& operator=(const SaveBackupResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveBackupResponse& operator=(SaveBackupResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaveBackupResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveBackupResponse* internal_default_instance() {
    return reinterpret_cast<const SaveBackupResponse*>(
               &_SaveBackupResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    124;

  friend void swap(SaveBackupResponse& a, SaveBackupResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SaveBackupResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveBackupResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveBackupResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaveBackupResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SaveBackupResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SaveBackupResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SaveBackupResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.SaveBackupResponse";
  }
  protected:
  explicit SaveBackupResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SaveBackupResponse_ErrorCodes ErrorCodes;
  static constexpr ErrorCodes NO_ERROR =
    SaveBackupResponse_ErrorCodes_NO_ERROR;
  static constexpr ErrorCodes USER_NOT_FOUND =
    SaveBackupResponse_ErrorCodes_USER_NOT_FOUND;
  static constexpr ErrorCodes COULD_NOT_OVERWRITE =
    SaveBackupResponse_ErrorCodes_COULD_NOT_OVERWRITE;
  static constexpr ErrorCodes BACKUP_OFFERED =
    SaveBackupResponse_ErrorCodes_BACKUP_OFFERED;
  static constexpr ErrorCodes BAD_USER_ID =
    SaveBackupResponse_ErrorCodes_BAD_USER_ID;
  static inline bool ErrorCodes_IsValid(int value) {
    return SaveBackupResponse_ErrorCodes_IsValid(value);
  }
  static constexpr ErrorCodes ErrorCodes_MIN =
    SaveBackupResponse_ErrorCodes_ErrorCodes_MIN;
  static constexpr ErrorCodes ErrorCodes_MAX =
    SaveBackupResponse_ErrorCodes_ErrorCodes_MAX;
  static constexpr int ErrorCodes_ARRAYSIZE =
    SaveBackupResponse_ErrorCodes_ErrorCodes_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ErrorCodes_descriptor() {
    return SaveBackupResponse_ErrorCodes_descriptor();
  }
  template<typename T>
  static inline const std::string& ErrorCodes_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ErrorCodes>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ErrorCodes_Name.");
    return SaveBackupResponse_ErrorCodes_Name(enum_t_value);
  }
  static inline bool ErrorCodes_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ErrorCodes* value) {
    return SaveBackupResponse_ErrorCodes_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kExistingBackupFieldNumber = 4,
    kSuccessFieldNumber = 1,
    kErrorCodeFieldNumber = 2,
  };
  // optional string message = 3;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // optional .ei.Backup existing_backup = 4;
  bool has_existing_backup() const;
  private:
  bool _internal_has_existing_backup() const;
  public:
  void clear_existing_backup();
  const ::ei::Backup& existing_backup() const;
  PROTOBUF_NODISCARD ::ei::Backup* release_existing_backup();
  ::ei::Backup* mutable_existing_backup();
  void set_allocated_existing_backup(::ei::Backup* existing_backup);
  private:
  const ::ei::Backup& _internal_existing_backup() const;
  ::ei::Backup* _internal_mutable_existing_backup();
  public:
  void unsafe_arena_set_allocated_existing_backup(
      ::ei::Backup* existing_backup);
  ::ei::Backup* unsafe_arena_release_existing_backup();

  // optional bool success = 1;
  bool has_success() const;
  private:
  bool _internal_has_success() const;
  public:
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // optional uint32 error_code = 2;
  bool has_error_code() const;
  private:
  bool _internal_has_error_code() const;
  public:
  void clear_error_code();
  uint32_t error_code() const;
  void set_error_code(uint32_t value);
  private:
  uint32_t _internal_error_code() const;
  void _internal_set_error_code(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.SaveBackupResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::ei::Backup* existing_backup_;
  bool success_;
  uint32_t error_code_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class CleanAccountRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.CleanAccountRequest) */ {
 public:
  inline CleanAccountRequest() : CleanAccountRequest(nullptr) {}
  ~CleanAccountRequest() override;
  explicit constexpr CleanAccountRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CleanAccountRequest(const CleanAccountRequest& from);
  CleanAccountRequest(CleanAccountRequest&& from) noexcept
    : CleanAccountRequest() {
    *this = ::std::move(from);
  }

  inline CleanAccountRequest& operator=(const CleanAccountRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CleanAccountRequest& operator=(CleanAccountRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CleanAccountRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CleanAccountRequest* internal_default_instance() {
    return reinterpret_cast<const CleanAccountRequest*>(
               &_CleanAccountRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    125;

  friend void swap(CleanAccountRequest& a, CleanAccountRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CleanAccountRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CleanAccountRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CleanAccountRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CleanAccountRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CleanAccountRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CleanAccountRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CleanAccountRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.CleanAccountRequest";
  }
  protected:
  explicit CleanAccountRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEiUserIdToKeepFieldNumber = 1,
    kGameServicesIdFieldNumber = 2,
  };
  // optional string ei_user_id_to_keep = 1;
  bool has_ei_user_id_to_keep() const;
  private:
  bool _internal_has_ei_user_id_to_keep() const;
  public:
  void clear_ei_user_id_to_keep();
  const std::string& ei_user_id_to_keep() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ei_user_id_to_keep(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ei_user_id_to_keep();
  PROTOBUF_NODISCARD std::string* release_ei_user_id_to_keep();
  void set_allocated_ei_user_id_to_keep(std::string* ei_user_id_to_keep);
  private:
  const std::string& _internal_ei_user_id_to_keep() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ei_user_id_to_keep(const std::string& value);
  std::string* _internal_mutable_ei_user_id_to_keep();
  public:

  // optional string game_services_id = 2;
  bool has_game_services_id() const;
  private:
  bool _internal_has_game_services_id() const;
  public:
  void clear_game_services_id();
  const std::string& game_services_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_services_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_services_id();
  PROTOBUF_NODISCARD std::string* release_game_services_id();
  void set_allocated_game_services_id(std::string* game_services_id);
  private:
  const std::string& _internal_game_services_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_services_id(const std::string& value);
  std::string* _internal_mutable_game_services_id();
  public:

  // @@protoc_insertion_point(class_scope:ei.CleanAccountRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ei_user_id_to_keep_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_services_id_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ReturnEDTPayload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ReturnEDTPayload) */ {
 public:
  inline ReturnEDTPayload() : ReturnEDTPayload(nullptr) {}
  ~ReturnEDTPayload() override;
  explicit constexpr ReturnEDTPayload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReturnEDTPayload(const ReturnEDTPayload& from);
  ReturnEDTPayload(ReturnEDTPayload&& from) noexcept
    : ReturnEDTPayload() {
    *this = ::std::move(from);
  }

  inline ReturnEDTPayload& operator=(const ReturnEDTPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReturnEDTPayload& operator=(ReturnEDTPayload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReturnEDTPayload& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReturnEDTPayload* internal_default_instance() {
    return reinterpret_cast<const ReturnEDTPayload*>(
               &_ReturnEDTPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    126;

  friend void swap(ReturnEDTPayload& a, ReturnEDTPayload& b) {
    a.Swap(&b);
  }
  inline void Swap(ReturnEDTPayload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReturnEDTPayload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReturnEDTPayload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReturnEDTPayload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReturnEDTPayload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReturnEDTPayload& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReturnEDTPayload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ReturnEDTPayload";
  }
  protected:
  explicit ReturnEDTPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEiUserIdFieldNumber = 1,
  };
  // optional string ei_user_id = 1;
  bool has_ei_user_id() const;
  private:
  bool _internal_has_ei_user_id() const;
  public:
  void clear_ei_user_id();
  const std::string& ei_user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ei_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ei_user_id();
  PROTOBUF_NODISCARD std::string* release_ei_user_id();
  void set_allocated_ei_user_id(std::string* ei_user_id);
  private:
  const std::string& _internal_ei_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ei_user_id(const std::string& value);
  std::string* _internal_mutable_ei_user_id();
  public:

  // @@protoc_insertion_point(class_scope:ei.ReturnEDTPayload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ei_user_id_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class DLCItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.DLCItem) */ {
 public:
  inline DLCItem() : DLCItem(nullptr) {}
  ~DLCItem() override;
  explicit constexpr DLCItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DLCItem(const DLCItem& from);
  DLCItem(DLCItem&& from) noexcept
    : DLCItem() {
    *this = ::std::move(from);
  }

  inline DLCItem& operator=(const DLCItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline DLCItem& operator=(DLCItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DLCItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const DLCItem* internal_default_instance() {
    return reinterpret_cast<const DLCItem*>(
               &_DLCItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    127;

  friend void swap(DLCItem& a, DLCItem& b) {
    a.Swap(&b);
  }
  inline void Swap(DLCItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DLCItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DLCItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DLCItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DLCItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DLCItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DLCItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.DLCItem";
  }
  protected:
  explicit DLCItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDirectoryFieldNumber = 2,
    kExtFieldNumber = 3,
    kUrlFieldNumber = 4,
    kChecksumFieldNumber = 5,
    kOriginalSizeFieldNumber = 7,
    kCompressedFieldNumber = 6,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string directory = 2;
  bool has_directory() const;
  private:
  bool _internal_has_directory() const;
  public:
  void clear_directory();
  const std::string& directory() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_directory(ArgT0&& arg0, ArgT... args);
  std::string* mutable_directory();
  PROTOBUF_NODISCARD std::string* release_directory();
  void set_allocated_directory(std::string* directory);
  private:
  const std::string& _internal_directory() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_directory(const std::string& value);
  std::string* _internal_mutable_directory();
  public:

  // optional string ext = 3;
  bool has_ext() const;
  private:
  bool _internal_has_ext() const;
  public:
  void clear_ext();
  const std::string& ext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ext();
  PROTOBUF_NODISCARD std::string* release_ext();
  void set_allocated_ext(std::string* ext);
  private:
  const std::string& _internal_ext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ext(const std::string& value);
  std::string* _internal_mutable_ext();
  public:

  // optional string url = 4;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional string checksum = 5;
  bool has_checksum() const;
  private:
  bool _internal_has_checksum() const;
  public:
  void clear_checksum();
  const std::string& checksum() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_checksum(ArgT0&& arg0, ArgT... args);
  std::string* mutable_checksum();
  PROTOBUF_NODISCARD std::string* release_checksum();
  void set_allocated_checksum(std::string* checksum);
  private:
  const std::string& _internal_checksum() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_checksum(const std::string& value);
  std::string* _internal_mutable_checksum();
  public:

  // optional uint64 original_size = 7;
  bool has_original_size() const;
  private:
  bool _internal_has_original_size() const;
  public:
  void clear_original_size();
  uint64_t original_size() const;
  void set_original_size(uint64_t value);
  private:
  uint64_t _internal_original_size() const;
  void _internal_set_original_size(uint64_t value);
  public:

  // optional bool compressed = 6;
  bool has_compressed() const;
  private:
  bool _internal_has_compressed() const;
  public:
  void clear_compressed();
  bool compressed() const;
  void set_compressed(bool value);
  private:
  bool _internal_compressed() const;
  void _internal_set_compressed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ei.DLCItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr directory_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ext_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr checksum_;
  uint64_t original_size_;
  bool compressed_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ShellSpec_ShellPiece final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ShellSpec.ShellPiece) */ {
 public:
  inline ShellSpec_ShellPiece() : ShellSpec_ShellPiece(nullptr) {}
  ~ShellSpec_ShellPiece() override;
  explicit constexpr ShellSpec_ShellPiece(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShellSpec_ShellPiece(const ShellSpec_ShellPiece& from);
  ShellSpec_ShellPiece(ShellSpec_ShellPiece&& from) noexcept
    : ShellSpec_ShellPiece() {
    *this = ::std::move(from);
  }

  inline ShellSpec_ShellPiece& operator=(const ShellSpec_ShellPiece& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShellSpec_ShellPiece& operator=(ShellSpec_ShellPiece&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShellSpec_ShellPiece& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShellSpec_ShellPiece* internal_default_instance() {
    return reinterpret_cast<const ShellSpec_ShellPiece*>(
               &_ShellSpec_ShellPiece_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    128;

  friend void swap(ShellSpec_ShellPiece& a, ShellSpec_ShellPiece& b) {
    a.Swap(&b);
  }
  inline void Swap(ShellSpec_ShellPiece* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShellSpec_ShellPiece* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShellSpec_ShellPiece* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShellSpec_ShellPiece>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShellSpec_ShellPiece& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShellSpec_ShellPiece& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShellSpec_ShellPiece* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ShellSpec.ShellPiece";
  }
  protected:
  explicit ShellSpec_ShellPiece(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDlcFieldNumber = 2,
    kAssetTypeFieldNumber = 1,
  };
  // optional .ei.DLCItem dlc = 2;
  bool has_dlc() const;
  private:
  bool _internal_has_dlc() const;
  public:
  void clear_dlc();
  const ::ei::DLCItem& dlc() const;
  PROTOBUF_NODISCARD ::ei::DLCItem* release_dlc();
  ::ei::DLCItem* mutable_dlc();
  void set_allocated_dlc(::ei::DLCItem* dlc);
  private:
  const ::ei::DLCItem& _internal_dlc() const;
  ::ei::DLCItem* _internal_mutable_dlc();
  public:
  void unsafe_arena_set_allocated_dlc(
      ::ei::DLCItem* dlc);
  ::ei::DLCItem* unsafe_arena_release_dlc();

  // optional .ei.ShellSpec.AssetType asset_type = 1;
  bool has_asset_type() const;
  private:
  bool _internal_has_asset_type() const;
  public:
  void clear_asset_type();
  ::ei::ShellSpec_AssetType asset_type() const;
  void set_asset_type(::ei::ShellSpec_AssetType value);
  private:
  ::ei::ShellSpec_AssetType _internal_asset_type() const;
  void _internal_set_asset_type(::ei::ShellSpec_AssetType value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ShellSpec.ShellPiece)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ei::DLCItem* dlc_;
  int asset_type_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ShellSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ShellSpec) */ {
 public:
  inline ShellSpec() : ShellSpec(nullptr) {}
  ~ShellSpec() override;
  explicit constexpr ShellSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShellSpec(const ShellSpec& from);
  ShellSpec(ShellSpec&& from) noexcept
    : ShellSpec() {
    *this = ::std::move(from);
  }

  inline ShellSpec& operator=(const ShellSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShellSpec& operator=(ShellSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShellSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShellSpec* internal_default_instance() {
    return reinterpret_cast<const ShellSpec*>(
               &_ShellSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    129;

  friend void swap(ShellSpec& a, ShellSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(ShellSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShellSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShellSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShellSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShellSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShellSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShellSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ShellSpec";
  }
  protected:
  explicit ShellSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ShellSpec_ShellPiece ShellPiece;

  typedef ShellSpec_AssetType AssetType;
  static constexpr AssetType COOP =
    ShellSpec_AssetType_COOP;
  static constexpr AssetType SHACK =
    ShellSpec_AssetType_SHACK;
  static constexpr AssetType SUPER_SHACK =
    ShellSpec_AssetType_SUPER_SHACK;
  static constexpr AssetType SHORT_HOUSE =
    ShellSpec_AssetType_SHORT_HOUSE;
  static constexpr AssetType THE_STANDARD =
    ShellSpec_AssetType_THE_STANDARD;
  static constexpr AssetType LONG_HOUSE =
    ShellSpec_AssetType_LONG_HOUSE;
  static constexpr AssetType DOUBLE_DECKER =
    ShellSpec_AssetType_DOUBLE_DECKER;
  static constexpr AssetType WAREHOUSE =
    ShellSpec_AssetType_WAREHOUSE;
  static constexpr AssetType CENTER =
    ShellSpec_AssetType_CENTER;
  static constexpr AssetType BUNKER =
    ShellSpec_AssetType_BUNKER;
  static constexpr AssetType EGGKEA =
    ShellSpec_AssetType_EGGKEA;
  static constexpr AssetType HAB_1K =
    ShellSpec_AssetType_HAB_1K;
  static constexpr AssetType HANGAR =
    ShellSpec_AssetType_HANGAR;
  static constexpr AssetType TOWER =
    ShellSpec_AssetType_TOWER;
  static constexpr AssetType HAB_10K =
    ShellSpec_AssetType_HAB_10K;
  static constexpr AssetType EGGTOPIA =
    ShellSpec_AssetType_EGGTOPIA;
  static constexpr AssetType MONOLITH =
    ShellSpec_AssetType_MONOLITH;
  static constexpr AssetType PLANET_PORTAL =
    ShellSpec_AssetType_PLANET_PORTAL;
  static constexpr AssetType CHICKEN_UNIVERSE =
    ShellSpec_AssetType_CHICKEN_UNIVERSE;
  static constexpr AssetType SILO_0_SMALL =
    ShellSpec_AssetType_SILO_0_SMALL;
  static constexpr AssetType SILO_0_MED =
    ShellSpec_AssetType_SILO_0_MED;
  static constexpr AssetType SILO_0_LARGE =
    ShellSpec_AssetType_SILO_0_LARGE;
  static constexpr AssetType SILO_1_SMALL =
    ShellSpec_AssetType_SILO_1_SMALL;
  static constexpr AssetType SILO_1_MED =
    ShellSpec_AssetType_SILO_1_MED;
  static constexpr AssetType SILO_1_LARGE =
    ShellSpec_AssetType_SILO_1_LARGE;
  static constexpr AssetType SILO_ALL =
    ShellSpec_AssetType_SILO_ALL;
  static constexpr AssetType MAILBOX =
    ShellSpec_AssetType_MAILBOX;
  static constexpr AssetType TROPHY_CASE =
    ShellSpec_AssetType_TROPHY_CASE;
  static constexpr AssetType GROUND =
    ShellSpec_AssetType_GROUND;
  static constexpr AssetType HARDSCAPE =
    ShellSpec_AssetType_HARDSCAPE;
  static constexpr AssetType HYPERLOOP =
    ShellSpec_AssetType_HYPERLOOP;
  static constexpr AssetType DEPOT_1 =
    ShellSpec_AssetType_DEPOT_1;
  static constexpr AssetType DEPOT_2 =
    ShellSpec_AssetType_DEPOT_2;
  static constexpr AssetType DEPOT_3 =
    ShellSpec_AssetType_DEPOT_3;
  static constexpr AssetType DEPOT_4 =
    ShellSpec_AssetType_DEPOT_4;
  static constexpr AssetType DEPOT_5 =
    ShellSpec_AssetType_DEPOT_5;
  static constexpr AssetType DEPOT_6 =
    ShellSpec_AssetType_DEPOT_6;
  static constexpr AssetType DEPOT_7 =
    ShellSpec_AssetType_DEPOT_7;
  static constexpr AssetType LAB_1 =
    ShellSpec_AssetType_LAB_1;
  static constexpr AssetType LAB_2 =
    ShellSpec_AssetType_LAB_2;
  static constexpr AssetType LAB_3 =
    ShellSpec_AssetType_LAB_3;
  static constexpr AssetType LAB_4 =
    ShellSpec_AssetType_LAB_4;
  static constexpr AssetType LAB_5 =
    ShellSpec_AssetType_LAB_5;
  static constexpr AssetType LAB_6 =
    ShellSpec_AssetType_LAB_6;
  static constexpr AssetType HATCHERY_EDIBLE =
    ShellSpec_AssetType_HATCHERY_EDIBLE;
  static constexpr AssetType HATCHERY_SUPERFOOD =
    ShellSpec_AssetType_HATCHERY_SUPERFOOD;
  static constexpr AssetType HATCHERY_MEDICAL =
    ShellSpec_AssetType_HATCHERY_MEDICAL;
  static constexpr AssetType HATCHERY_ROCKET_FUEL =
    ShellSpec_AssetType_HATCHERY_ROCKET_FUEL;
  static constexpr AssetType HATCHERY_SUPERMATERIAL =
    ShellSpec_AssetType_HATCHERY_SUPERMATERIAL;
  static constexpr AssetType HATCHERY_FUSION =
    ShellSpec_AssetType_HATCHERY_FUSION;
  static constexpr AssetType HATCHERY_QUANTUM =
    ShellSpec_AssetType_HATCHERY_QUANTUM;
  static constexpr AssetType HATCHERY_IMMORTALITY =
    ShellSpec_AssetType_HATCHERY_IMMORTALITY;
  static constexpr AssetType HATCHERY_TACHYON =
    ShellSpec_AssetType_HATCHERY_TACHYON;
  static constexpr AssetType HATCHERY_GRAVITON =
    ShellSpec_AssetType_HATCHERY_GRAVITON;
  static constexpr AssetType HATCHERY_DILITHIUM =
    ShellSpec_AssetType_HATCHERY_DILITHIUM;
  static constexpr AssetType HATCHERY_PRODIGY =
    ShellSpec_AssetType_HATCHERY_PRODIGY;
  static constexpr AssetType HATCHERY_TERRAFORM =
    ShellSpec_AssetType_HATCHERY_TERRAFORM;
  static constexpr AssetType HATCHERY_ANTIMATTER =
    ShellSpec_AssetType_HATCHERY_ANTIMATTER;
  static constexpr AssetType HATCHERY_DARK_MATTER =
    ShellSpec_AssetType_HATCHERY_DARK_MATTER;
  static constexpr AssetType HATCHERY_AI =
    ShellSpec_AssetType_HATCHERY_AI;
  static constexpr AssetType HATCHERY_NEBULA =
    ShellSpec_AssetType_HATCHERY_NEBULA;
  static constexpr AssetType HATCHERY_UNIVERSE =
    ShellSpec_AssetType_HATCHERY_UNIVERSE;
  static constexpr AssetType HATCHERY_ENLIGHTENMENT =
    ShellSpec_AssetType_HATCHERY_ENLIGHTENMENT;
  static constexpr AssetType HATCHERY_CHOCOLATE =
    ShellSpec_AssetType_HATCHERY_CHOCOLATE;
  static constexpr AssetType HATCHERY_EASTER =
    ShellSpec_AssetType_HATCHERY_EASTER;
  static constexpr AssetType HATCHERY_WATERBALLOON =
    ShellSpec_AssetType_HATCHERY_WATERBALLOON;
  static constexpr AssetType HATCHERY_FIREWORK =
    ShellSpec_AssetType_HATCHERY_FIREWORK;
  static constexpr AssetType HATCHERY_PUMPKIN =
    ShellSpec_AssetType_HATCHERY_PUMPKIN;
  static constexpr AssetType HOA_1 =
    ShellSpec_AssetType_HOA_1;
  static constexpr AssetType HOA_2 =
    ShellSpec_AssetType_HOA_2;
  static constexpr AssetType HOA_3 =
    ShellSpec_AssetType_HOA_3;
  static constexpr AssetType MISSION_CONTROL_1 =
    ShellSpec_AssetType_MISSION_CONTROL_1;
  static constexpr AssetType MISSION_CONTROL_2 =
    ShellSpec_AssetType_MISSION_CONTROL_2;
  static constexpr AssetType MISSION_CONTROL_3 =
    ShellSpec_AssetType_MISSION_CONTROL_3;
  static constexpr AssetType FUEL_TANK_1 =
    ShellSpec_AssetType_FUEL_TANK_1;
  static constexpr AssetType FUEL_TANK_2 =
    ShellSpec_AssetType_FUEL_TANK_2;
  static constexpr AssetType FUEL_TANK_3 =
    ShellSpec_AssetType_FUEL_TANK_3;
  static constexpr AssetType FUEL_TANK_4 =
    ShellSpec_AssetType_FUEL_TANK_4;
  static constexpr AssetType HATCHERY_GRAVITON_TOP =
    ShellSpec_AssetType_HATCHERY_GRAVITON_TOP;
  static constexpr AssetType HATCHERY_NEBULA_MIDDLE =
    ShellSpec_AssetType_HATCHERY_NEBULA_MIDDLE;
  static constexpr AssetType HATCHERY_NEBULA_TOP =
    ShellSpec_AssetType_HATCHERY_NEBULA_TOP;
  static constexpr AssetType HATCHERY_DARK_MATTER_RING_1 =
    ShellSpec_AssetType_HATCHERY_DARK_MATTER_RING_1;
  static constexpr AssetType HATCHERY_DARK_MATTER_RING_2 =
    ShellSpec_AssetType_HATCHERY_DARK_MATTER_RING_2;
  static constexpr AssetType HATCHERY_DARK_MATTER_RING_3 =
    ShellSpec_AssetType_HATCHERY_DARK_MATTER_RING_3;
  static constexpr AssetType HATCHERY_AI_TOP_1 =
    ShellSpec_AssetType_HATCHERY_AI_TOP_1;
  static constexpr AssetType HATCHERY_AI_TOP_2 =
    ShellSpec_AssetType_HATCHERY_AI_TOP_2;
  static constexpr AssetType HATCHERY_AI_TOP_3 =
    ShellSpec_AssetType_HATCHERY_AI_TOP_3;
  static constexpr AssetType HATCHERY_AI_TOP_4 =
    ShellSpec_AssetType_HATCHERY_AI_TOP_4;
  static constexpr AssetType HATCHERY_UNIVERSE_PROBE =
    ShellSpec_AssetType_HATCHERY_UNIVERSE_PROBE;
  static constexpr AssetType HATCHERY_UNIVERSE_BOLT =
    ShellSpec_AssetType_HATCHERY_UNIVERSE_BOLT;
  static constexpr AssetType HATCHERY_ENLIGHTENMENT_ORB =
    ShellSpec_AssetType_HATCHERY_ENLIGHTENMENT_ORB;
  static constexpr AssetType HYPERLOOP_TRACK =
    ShellSpec_AssetType_HYPERLOOP_TRACK;
  static constexpr AssetType MAILBOX_FULL =
    ShellSpec_AssetType_MAILBOX_FULL;
  static constexpr AssetType CHICKEN =
    ShellSpec_AssetType_CHICKEN;
  static constexpr AssetType HAT =
    ShellSpec_AssetType_HAT;
  static constexpr AssetType UNKNOWN =
    ShellSpec_AssetType_UNKNOWN;
  static inline bool AssetType_IsValid(int value) {
    return ShellSpec_AssetType_IsValid(value);
  }
  static constexpr AssetType AssetType_MIN =
    ShellSpec_AssetType_AssetType_MIN;
  static constexpr AssetType AssetType_MAX =
    ShellSpec_AssetType_AssetType_MAX;
  static constexpr int AssetType_ARRAYSIZE =
    ShellSpec_AssetType_AssetType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AssetType_descriptor() {
    return ShellSpec_AssetType_descriptor();
  }
  template<typename T>
  static inline const std::string& AssetType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AssetType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AssetType_Name.");
    return ShellSpec_AssetType_Name(enum_t_value);
  }
  static inline bool AssetType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AssetType* value) {
    return ShellSpec_AssetType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPiecesFieldNumber = 11,
    kIdentifierFieldNumber = 1,
    kNameFieldNumber = 3,
    kSetIdentifierFieldNumber = 13,
    kPrimaryPieceFieldNumber = 12,
    kPriceFieldNumber = 4,
    kRequiredEopFieldNumber = 5,
    kRequiredSoulEggsFieldNumber = 6,
    kIsNewFieldNumber = 14,
    kExpiresFieldNumber = 15,
    kDefaultAppearanceFieldNumber = 8,
    kSecondsRemainingFieldNumber = 16,
  };
  // repeated .ei.ShellSpec.ShellPiece pieces = 11;
  int pieces_size() const;
  private:
  int _internal_pieces_size() const;
  public:
  void clear_pieces();
  ::ei::ShellSpec_ShellPiece* mutable_pieces(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellSpec_ShellPiece >*
      mutable_pieces();
  private:
  const ::ei::ShellSpec_ShellPiece& _internal_pieces(int index) const;
  ::ei::ShellSpec_ShellPiece* _internal_add_pieces();
  public:
  const ::ei::ShellSpec_ShellPiece& pieces(int index) const;
  ::ei::ShellSpec_ShellPiece* add_pieces();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellSpec_ShellPiece >&
      pieces() const;

  // optional string identifier = 1;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  PROTOBUF_NODISCARD std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // optional string name = 3;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string set_identifier = 13;
  bool has_set_identifier() const;
  private:
  bool _internal_has_set_identifier() const;
  public:
  void clear_set_identifier();
  const std::string& set_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_set_identifier();
  PROTOBUF_NODISCARD std::string* release_set_identifier();
  void set_allocated_set_identifier(std::string* set_identifier);
  private:
  const std::string& _internal_set_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_set_identifier(const std::string& value);
  std::string* _internal_mutable_set_identifier();
  public:

  // optional .ei.ShellSpec.ShellPiece primary_piece = 12;
  bool has_primary_piece() const;
  private:
  bool _internal_has_primary_piece() const;
  public:
  void clear_primary_piece();
  const ::ei::ShellSpec_ShellPiece& primary_piece() const;
  PROTOBUF_NODISCARD ::ei::ShellSpec_ShellPiece* release_primary_piece();
  ::ei::ShellSpec_ShellPiece* mutable_primary_piece();
  void set_allocated_primary_piece(::ei::ShellSpec_ShellPiece* primary_piece);
  private:
  const ::ei::ShellSpec_ShellPiece& _internal_primary_piece() const;
  ::ei::ShellSpec_ShellPiece* _internal_mutable_primary_piece();
  public:
  void unsafe_arena_set_allocated_primary_piece(
      ::ei::ShellSpec_ShellPiece* primary_piece);
  ::ei::ShellSpec_ShellPiece* unsafe_arena_release_primary_piece();

  // optional uint32 price = 4;
  bool has_price() const;
  private:
  bool _internal_has_price() const;
  public:
  void clear_price();
  uint32_t price() const;
  void set_price(uint32_t value);
  private:
  uint32_t _internal_price() const;
  void _internal_set_price(uint32_t value);
  public:

  // optional uint32 required_eop = 5;
  bool has_required_eop() const;
  private:
  bool _internal_has_required_eop() const;
  public:
  void clear_required_eop();
  uint32_t required_eop() const;
  void set_required_eop(uint32_t value);
  private:
  uint32_t _internal_required_eop() const;
  void _internal_set_required_eop(uint32_t value);
  public:

  // optional double required_soul_eggs = 6;
  bool has_required_soul_eggs() const;
  private:
  bool _internal_has_required_soul_eggs() const;
  public:
  void clear_required_soul_eggs();
  double required_soul_eggs() const;
  void set_required_soul_eggs(double value);
  private:
  double _internal_required_soul_eggs() const;
  void _internal_set_required_soul_eggs(double value);
  public:

  // optional bool is_new = 14;
  bool has_is_new() const;
  private:
  bool _internal_has_is_new() const;
  public:
  void clear_is_new();
  bool is_new() const;
  void set_is_new(bool value);
  private:
  bool _internal_is_new() const;
  void _internal_set_is_new(bool value);
  public:

  // optional bool expires = 15;
  bool has_expires() const;
  private:
  bool _internal_has_expires() const;
  public:
  void clear_expires();
  bool expires() const;
  void set_expires(bool value);
  private:
  bool _internal_expires() const;
  void _internal_set_expires(bool value);
  public:

  // optional bool default_appearance = 8;
  bool has_default_appearance() const;
  private:
  bool _internal_has_default_appearance() const;
  public:
  void clear_default_appearance();
  bool default_appearance() const;
  void set_default_appearance(bool value);
  private:
  bool _internal_default_appearance() const;
  void _internal_set_default_appearance(bool value);
  public:

  // optional double seconds_remaining = 16;
  bool has_seconds_remaining() const;
  private:
  bool _internal_has_seconds_remaining() const;
  public:
  void clear_seconds_remaining();
  double seconds_remaining() const;
  void set_seconds_remaining(double value);
  private:
  double _internal_seconds_remaining() const;
  void _internal_set_seconds_remaining(double value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ShellSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellSpec_ShellPiece > pieces_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr set_identifier_;
  ::ei::ShellSpec_ShellPiece* primary_piece_;
  uint32_t price_;
  uint32_t required_eop_;
  double required_soul_eggs_;
  bool is_new_;
  bool expires_;
  bool default_appearance_;
  double seconds_remaining_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ShellSetSpec_VariationInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ShellSetSpec.VariationInfo) */ {
 public:
  inline ShellSetSpec_VariationInfo() : ShellSetSpec_VariationInfo(nullptr) {}
  ~ShellSetSpec_VariationInfo() override;
  explicit constexpr ShellSetSpec_VariationInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShellSetSpec_VariationInfo(const ShellSetSpec_VariationInfo& from);
  ShellSetSpec_VariationInfo(ShellSetSpec_VariationInfo&& from) noexcept
    : ShellSetSpec_VariationInfo() {
    *this = ::std::move(from);
  }

  inline ShellSetSpec_VariationInfo& operator=(const ShellSetSpec_VariationInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShellSetSpec_VariationInfo& operator=(ShellSetSpec_VariationInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShellSetSpec_VariationInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShellSetSpec_VariationInfo* internal_default_instance() {
    return reinterpret_cast<const ShellSetSpec_VariationInfo*>(
               &_ShellSetSpec_VariationInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    130;

  friend void swap(ShellSetSpec_VariationInfo& a, ShellSetSpec_VariationInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ShellSetSpec_VariationInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShellSetSpec_VariationInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShellSetSpec_VariationInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShellSetSpec_VariationInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShellSetSpec_VariationInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShellSetSpec_VariationInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShellSetSpec_VariationInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ShellSetSpec.VariationInfo";
  }
  protected:
  explicit ShellSetSpec_VariationInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifierFieldNumber = 1,
    kHexColorFieldNumber = 2,
    kPriceFieldNumber = 3,
  };
  // optional string identifier = 1;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  PROTOBUF_NODISCARD std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // optional string hex_color = 2;
  bool has_hex_color() const;
  private:
  bool _internal_has_hex_color() const;
  public:
  void clear_hex_color();
  const std::string& hex_color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hex_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hex_color();
  PROTOBUF_NODISCARD std::string* release_hex_color();
  void set_allocated_hex_color(std::string* hex_color);
  private:
  const std::string& _internal_hex_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hex_color(const std::string& value);
  std::string* _internal_mutable_hex_color();
  public:

  // optional uint32 price = 3;
  bool has_price() const;
  private:
  bool _internal_has_price() const;
  public:
  void clear_price();
  uint32_t price() const;
  void set_price(uint32_t value);
  private:
  uint32_t _internal_price() const;
  void _internal_set_price(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ShellSetSpec.VariationInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hex_color_;
  uint32_t price_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ShellSetSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ShellSetSpec) */ {
 public:
  inline ShellSetSpec() : ShellSetSpec(nullptr) {}
  ~ShellSetSpec() override;
  explicit constexpr ShellSetSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShellSetSpec(const ShellSetSpec& from);
  ShellSetSpec(ShellSetSpec&& from) noexcept
    : ShellSetSpec() {
    *this = ::std::move(from);
  }

  inline ShellSetSpec& operator=(const ShellSetSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShellSetSpec& operator=(ShellSetSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShellSetSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShellSetSpec* internal_default_instance() {
    return reinterpret_cast<const ShellSetSpec*>(
               &_ShellSetSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    131;

  friend void swap(ShellSetSpec& a, ShellSetSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(ShellSetSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShellSetSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShellSetSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShellSetSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShellSetSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShellSetSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShellSetSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ShellSetSpec";
  }
  protected:
  explicit ShellSetSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ShellSetSpec_VariationInfo VariationInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kVariationsFieldNumber = 15,
    kIdentifierFieldNumber = 1,
    kNameFieldNumber = 2,
    kHexBaseColorFieldNumber = 16,
    kPriceFieldNumber = 3,
    kRequiredEopFieldNumber = 4,
    kRequiredSoulEggsFieldNumber = 5,
    kElementSetFieldNumber = 7,
    kDefaultAppearanceFieldNumber = 6,
    kCustomAppearanceFieldNumber = 12,
    kIsNewFieldNumber = 9,
    kExpiresFieldNumber = 10,
    kDecoratorFieldNumber = 14,
    kModifiedGeometryFieldNumber = 13,
    kSecondsRemainingFieldNumber = 11,
    kDiscountFieldNumber = 17,
    kPriceMultDEPRECATEDFieldNumber = 8,
  };
  // repeated .ei.ShellSetSpec.VariationInfo variations = 15;
  int variations_size() const;
  private:
  int _internal_variations_size() const;
  public:
  void clear_variations();
  ::ei::ShellSetSpec_VariationInfo* mutable_variations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellSetSpec_VariationInfo >*
      mutable_variations();
  private:
  const ::ei::ShellSetSpec_VariationInfo& _internal_variations(int index) const;
  ::ei::ShellSetSpec_VariationInfo* _internal_add_variations();
  public:
  const ::ei::ShellSetSpec_VariationInfo& variations(int index) const;
  ::ei::ShellSetSpec_VariationInfo* add_variations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellSetSpec_VariationInfo >&
      variations() const;

  // optional string identifier = 1;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  PROTOBUF_NODISCARD std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string hex_base_color = 16;
  bool has_hex_base_color() const;
  private:
  bool _internal_has_hex_base_color() const;
  public:
  void clear_hex_base_color();
  const std::string& hex_base_color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hex_base_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hex_base_color();
  PROTOBUF_NODISCARD std::string* release_hex_base_color();
  void set_allocated_hex_base_color(std::string* hex_base_color);
  private:
  const std::string& _internal_hex_base_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hex_base_color(const std::string& value);
  std::string* _internal_mutable_hex_base_color();
  public:

  // optional uint32 price = 3;
  bool has_price() const;
  private:
  bool _internal_has_price() const;
  public:
  void clear_price();
  uint32_t price() const;
  void set_price(uint32_t value);
  private:
  uint32_t _internal_price() const;
  void _internal_set_price(uint32_t value);
  public:

  // optional uint32 required_eop = 4;
  bool has_required_eop() const;
  private:
  bool _internal_has_required_eop() const;
  public:
  void clear_required_eop();
  uint32_t required_eop() const;
  void set_required_eop(uint32_t value);
  private:
  uint32_t _internal_required_eop() const;
  void _internal_set_required_eop(uint32_t value);
  public:

  // optional double required_soul_eggs = 5;
  bool has_required_soul_eggs() const;
  private:
  bool _internal_has_required_soul_eggs() const;
  public:
  void clear_required_soul_eggs();
  double required_soul_eggs() const;
  void set_required_soul_eggs(double value);
  private:
  double _internal_required_soul_eggs() const;
  void _internal_set_required_soul_eggs(double value);
  public:

  // optional bool element_set = 7;
  bool has_element_set() const;
  private:
  bool _internal_has_element_set() const;
  public:
  void clear_element_set();
  bool element_set() const;
  void set_element_set(bool value);
  private:
  bool _internal_element_set() const;
  void _internal_set_element_set(bool value);
  public:

  // optional bool default_appearance = 6;
  bool has_default_appearance() const;
  private:
  bool _internal_has_default_appearance() const;
  public:
  void clear_default_appearance();
  bool default_appearance() const;
  void set_default_appearance(bool value);
  private:
  bool _internal_default_appearance() const;
  void _internal_set_default_appearance(bool value);
  public:

  // optional bool custom_appearance = 12;
  bool has_custom_appearance() const;
  private:
  bool _internal_has_custom_appearance() const;
  public:
  void clear_custom_appearance();
  bool custom_appearance() const;
  void set_custom_appearance(bool value);
  private:
  bool _internal_custom_appearance() const;
  void _internal_set_custom_appearance(bool value);
  public:

  // optional bool is_new = 9;
  bool has_is_new() const;
  private:
  bool _internal_has_is_new() const;
  public:
  void clear_is_new();
  bool is_new() const;
  void set_is_new(bool value);
  private:
  bool _internal_is_new() const;
  void _internal_set_is_new(bool value);
  public:

  // optional bool expires = 10;
  bool has_expires() const;
  private:
  bool _internal_has_expires() const;
  public:
  void clear_expires();
  bool expires() const;
  void set_expires(bool value);
  private:
  bool _internal_expires() const;
  void _internal_set_expires(bool value);
  public:

  // optional bool decorator = 14;
  bool has_decorator() const;
  private:
  bool _internal_has_decorator() const;
  public:
  void clear_decorator();
  bool decorator() const;
  void set_decorator(bool value);
  private:
  bool _internal_decorator() const;
  void _internal_set_decorator(bool value);
  public:

  // optional bool modified_geometry = 13;
  bool has_modified_geometry() const;
  private:
  bool _internal_has_modified_geometry() const;
  public:
  void clear_modified_geometry();
  bool modified_geometry() const;
  void set_modified_geometry(bool value);
  private:
  bool _internal_modified_geometry() const;
  void _internal_set_modified_geometry(bool value);
  public:

  // optional double seconds_remaining = 11;
  bool has_seconds_remaining() const;
  private:
  bool _internal_has_seconds_remaining() const;
  public:
  void clear_seconds_remaining();
  double seconds_remaining() const;
  void set_seconds_remaining(double value);
  private:
  double _internal_seconds_remaining() const;
  void _internal_set_seconds_remaining(double value);
  public:

  // optional double discount = 17;
  bool has_discount() const;
  private:
  bool _internal_has_discount() const;
  public:
  void clear_discount();
  double discount() const;
  void set_discount(double value);
  private:
  double _internal_discount() const;
  void _internal_set_discount(double value);
  public:

  // optional double price_mult_DEPRECATED = 8 [default = 1];
  bool has_price_mult_deprecated() const;
  private:
  bool _internal_has_price_mult_deprecated() const;
  public:
  void clear_price_mult_deprecated();
  double price_mult_deprecated() const;
  void set_price_mult_deprecated(double value);
  private:
  double _internal_price_mult_deprecated() const;
  void _internal_set_price_mult_deprecated(double value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ShellSetSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellSetSpec_VariationInfo > variations_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hex_base_color_;
  uint32_t price_;
  uint32_t required_eop_;
  double required_soul_eggs_;
  bool element_set_;
  bool default_appearance_;
  bool custom_appearance_;
  bool is_new_;
  bool expires_;
  bool decorator_;
  bool modified_geometry_;
  double seconds_remaining_;
  double discount_;
  double price_mult_deprecated_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ShellObjectSpec_LODPiece final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ShellObjectSpec.LODPiece) */ {
 public:
  inline ShellObjectSpec_LODPiece() : ShellObjectSpec_LODPiece(nullptr) {}
  ~ShellObjectSpec_LODPiece() override;
  explicit constexpr ShellObjectSpec_LODPiece(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShellObjectSpec_LODPiece(const ShellObjectSpec_LODPiece& from);
  ShellObjectSpec_LODPiece(ShellObjectSpec_LODPiece&& from) noexcept
    : ShellObjectSpec_LODPiece() {
    *this = ::std::move(from);
  }

  inline ShellObjectSpec_LODPiece& operator=(const ShellObjectSpec_LODPiece& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShellObjectSpec_LODPiece& operator=(ShellObjectSpec_LODPiece&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShellObjectSpec_LODPiece& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShellObjectSpec_LODPiece* internal_default_instance() {
    return reinterpret_cast<const ShellObjectSpec_LODPiece*>(
               &_ShellObjectSpec_LODPiece_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    132;

  friend void swap(ShellObjectSpec_LODPiece& a, ShellObjectSpec_LODPiece& b) {
    a.Swap(&b);
  }
  inline void Swap(ShellObjectSpec_LODPiece* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShellObjectSpec_LODPiece* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShellObjectSpec_LODPiece* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShellObjectSpec_LODPiece>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShellObjectSpec_LODPiece& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShellObjectSpec_LODPiece& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShellObjectSpec_LODPiece* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ShellObjectSpec.LODPiece";
  }
  protected:
  explicit ShellObjectSpec_LODPiece(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDlcFieldNumber = 1,
    kLodFieldNumber = 2,
  };
  // optional .ei.DLCItem dlc = 1;
  bool has_dlc() const;
  private:
  bool _internal_has_dlc() const;
  public:
  void clear_dlc();
  const ::ei::DLCItem& dlc() const;
  PROTOBUF_NODISCARD ::ei::DLCItem* release_dlc();
  ::ei::DLCItem* mutable_dlc();
  void set_allocated_dlc(::ei::DLCItem* dlc);
  private:
  const ::ei::DLCItem& _internal_dlc() const;
  ::ei::DLCItem* _internal_mutable_dlc();
  public:
  void unsafe_arena_set_allocated_dlc(
      ::ei::DLCItem* dlc);
  ::ei::DLCItem* unsafe_arena_release_dlc();

  // optional uint32 lod = 2;
  bool has_lod() const;
  private:
  bool _internal_has_lod() const;
  public:
  void clear_lod();
  uint32_t lod() const;
  void set_lod(uint32_t value);
  private:
  uint32_t _internal_lod() const;
  void _internal_set_lod(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ShellObjectSpec.LODPiece)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ei::DLCItem* dlc_;
  uint32_t lod_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ShellObjectSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ShellObjectSpec) */ {
 public:
  inline ShellObjectSpec() : ShellObjectSpec(nullptr) {}
  ~ShellObjectSpec() override;
  explicit constexpr ShellObjectSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShellObjectSpec(const ShellObjectSpec& from);
  ShellObjectSpec(ShellObjectSpec&& from) noexcept
    : ShellObjectSpec() {
    *this = ::std::move(from);
  }

  inline ShellObjectSpec& operator=(const ShellObjectSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShellObjectSpec& operator=(ShellObjectSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShellObjectSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShellObjectSpec* internal_default_instance() {
    return reinterpret_cast<const ShellObjectSpec*>(
               &_ShellObjectSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    133;

  friend void swap(ShellObjectSpec& a, ShellObjectSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(ShellObjectSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShellObjectSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShellObjectSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShellObjectSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShellObjectSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShellObjectSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShellObjectSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ShellObjectSpec";
  }
  protected:
  explicit ShellObjectSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ShellObjectSpec_LODPiece LODPiece;

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 7,
    kPiecesFieldNumber = 8,
    kIdentifierFieldNumber = 1,
    kNameFieldNumber = 2,
    kObjectClassFieldNumber = 14,
    kPriceFieldNumber = 4,
    kRequiredEopFieldNumber = 5,
    kRequiredSoulEggsFieldNumber = 6,
    kSecondsRemainingFieldNumber = 12,
    kIsNewFieldNumber = 10,
    kExpiresFieldNumber = 11,
    kNoHatsFieldNumber = 13,
    kDefaultAppearanceFieldNumber = 9,
    kAssetTypeFieldNumber = 3,
  };
  // repeated double metadata = 7;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  double _internal_metadata(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_metadata() const;
  void _internal_add_metadata(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_metadata();
  public:
  double metadata(int index) const;
  void set_metadata(int index, double value);
  void add_metadata(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_metadata();

  // repeated .ei.ShellObjectSpec.LODPiece pieces = 8;
  int pieces_size() const;
  private:
  int _internal_pieces_size() const;
  public:
  void clear_pieces();
  ::ei::ShellObjectSpec_LODPiece* mutable_pieces(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellObjectSpec_LODPiece >*
      mutable_pieces();
  private:
  const ::ei::ShellObjectSpec_LODPiece& _internal_pieces(int index) const;
  ::ei::ShellObjectSpec_LODPiece* _internal_add_pieces();
  public:
  const ::ei::ShellObjectSpec_LODPiece& pieces(int index) const;
  ::ei::ShellObjectSpec_LODPiece* add_pieces();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellObjectSpec_LODPiece >&
      pieces() const;

  // optional string identifier = 1;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  PROTOBUF_NODISCARD std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string object_class = 14;
  bool has_object_class() const;
  private:
  bool _internal_has_object_class() const;
  public:
  void clear_object_class();
  const std::string& object_class() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_object_class(ArgT0&& arg0, ArgT... args);
  std::string* mutable_object_class();
  PROTOBUF_NODISCARD std::string* release_object_class();
  void set_allocated_object_class(std::string* object_class);
  private:
  const std::string& _internal_object_class() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_object_class(const std::string& value);
  std::string* _internal_mutable_object_class();
  public:

  // optional uint32 price = 4;
  bool has_price() const;
  private:
  bool _internal_has_price() const;
  public:
  void clear_price();
  uint32_t price() const;
  void set_price(uint32_t value);
  private:
  uint32_t _internal_price() const;
  void _internal_set_price(uint32_t value);
  public:

  // optional uint32 required_eop = 5;
  bool has_required_eop() const;
  private:
  bool _internal_has_required_eop() const;
  public:
  void clear_required_eop();
  uint32_t required_eop() const;
  void set_required_eop(uint32_t value);
  private:
  uint32_t _internal_required_eop() const;
  void _internal_set_required_eop(uint32_t value);
  public:

  // optional double required_soul_eggs = 6;
  bool has_required_soul_eggs() const;
  private:
  bool _internal_has_required_soul_eggs() const;
  public:
  void clear_required_soul_eggs();
  double required_soul_eggs() const;
  void set_required_soul_eggs(double value);
  private:
  double _internal_required_soul_eggs() const;
  void _internal_set_required_soul_eggs(double value);
  public:

  // optional double seconds_remaining = 12;
  bool has_seconds_remaining() const;
  private:
  bool _internal_has_seconds_remaining() const;
  public:
  void clear_seconds_remaining();
  double seconds_remaining() const;
  void set_seconds_remaining(double value);
  private:
  double _internal_seconds_remaining() const;
  void _internal_set_seconds_remaining(double value);
  public:

  // optional bool is_new = 10;
  bool has_is_new() const;
  private:
  bool _internal_has_is_new() const;
  public:
  void clear_is_new();
  bool is_new() const;
  void set_is_new(bool value);
  private:
  bool _internal_is_new() const;
  void _internal_set_is_new(bool value);
  public:

  // optional bool expires = 11;
  bool has_expires() const;
  private:
  bool _internal_has_expires() const;
  public:
  void clear_expires();
  bool expires() const;
  void set_expires(bool value);
  private:
  bool _internal_expires() const;
  void _internal_set_expires(bool value);
  public:

  // optional bool no_hats = 13;
  bool has_no_hats() const;
  private:
  bool _internal_has_no_hats() const;
  public:
  void clear_no_hats();
  bool no_hats() const;
  void set_no_hats(bool value);
  private:
  bool _internal_no_hats() const;
  void _internal_set_no_hats(bool value);
  public:

  // optional bool default_appearance = 9;
  bool has_default_appearance() const;
  private:
  bool _internal_has_default_appearance() const;
  public:
  void clear_default_appearance();
  bool default_appearance() const;
  void set_default_appearance(bool value);
  private:
  bool _internal_default_appearance() const;
  void _internal_set_default_appearance(bool value);
  public:

  // optional .ei.ShellSpec.AssetType asset_type = 3;
  bool has_asset_type() const;
  private:
  bool _internal_has_asset_type() const;
  public:
  void clear_asset_type();
  ::ei::ShellSpec_AssetType asset_type() const;
  void set_asset_type(::ei::ShellSpec_AssetType value);
  private:
  ::ei::ShellSpec_AssetType _internal_asset_type() const;
  void _internal_set_asset_type(::ei::ShellSpec_AssetType value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ShellObjectSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellObjectSpec_LODPiece > pieces_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr object_class_;
  uint32_t price_;
  uint32_t required_eop_;
  double required_soul_eggs_;
  double seconds_remaining_;
  bool is_new_;
  bool expires_;
  bool no_hats_;
  bool default_appearance_;
  int asset_type_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ShellGroupSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ShellGroupSpec) */ {
 public:
  inline ShellGroupSpec() : ShellGroupSpec(nullptr) {}
  ~ShellGroupSpec() override;
  explicit constexpr ShellGroupSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShellGroupSpec(const ShellGroupSpec& from);
  ShellGroupSpec(ShellGroupSpec&& from) noexcept
    : ShellGroupSpec() {
    *this = ::std::move(from);
  }

  inline ShellGroupSpec& operator=(const ShellGroupSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShellGroupSpec& operator=(ShellGroupSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShellGroupSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShellGroupSpec* internal_default_instance() {
    return reinterpret_cast<const ShellGroupSpec*>(
               &_ShellGroupSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    134;

  friend void swap(ShellGroupSpec& a, ShellGroupSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(ShellGroupSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShellGroupSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShellGroupSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShellGroupSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShellGroupSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShellGroupSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShellGroupSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ShellGroupSpec";
  }
  protected:
  explicit ShellGroupSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMemberIdsFieldNumber = 3,
    kIdentifierFieldNumber = 1,
    kNameFieldNumber = 2,
    kPriceMultDEPRECATEDFieldNumber = 4,
    kAssetTypeFieldNumber = 5,
  };
  // repeated string member_ids = 3;
  int member_ids_size() const;
  private:
  int _internal_member_ids_size() const;
  public:
  void clear_member_ids();
  const std::string& member_ids(int index) const;
  std::string* mutable_member_ids(int index);
  void set_member_ids(int index, const std::string& value);
  void set_member_ids(int index, std::string&& value);
  void set_member_ids(int index, const char* value);
  void set_member_ids(int index, const char* value, size_t size);
  std::string* add_member_ids();
  void add_member_ids(const std::string& value);
  void add_member_ids(std::string&& value);
  void add_member_ids(const char* value);
  void add_member_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& member_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_member_ids();
  private:
  const std::string& _internal_member_ids(int index) const;
  std::string* _internal_add_member_ids();
  public:

  // optional string identifier = 1;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  PROTOBUF_NODISCARD std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional double price_mult_DEPRECATED = 4;
  bool has_price_mult_deprecated() const;
  private:
  bool _internal_has_price_mult_deprecated() const;
  public:
  void clear_price_mult_deprecated();
  double price_mult_deprecated() const;
  void set_price_mult_deprecated(double value);
  private:
  double _internal_price_mult_deprecated() const;
  void _internal_set_price_mult_deprecated(double value);
  public:

  // optional .ei.ShellSpec.AssetType asset_type = 5;
  bool has_asset_type() const;
  private:
  bool _internal_has_asset_type() const;
  public:
  void clear_asset_type();
  ::ei::ShellSpec_AssetType asset_type() const;
  void set_asset_type(::ei::ShellSpec_AssetType value);
  private:
  ::ei::ShellSpec_AssetType _internal_asset_type() const;
  void _internal_set_asset_type(::ei::ShellSpec_AssetType value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ShellGroupSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> member_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  double price_mult_deprecated_;
  int asset_type_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class DLCCatalog final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.DLCCatalog) */ {
 public:
  inline DLCCatalog() : DLCCatalog(nullptr) {}
  ~DLCCatalog() override;
  explicit constexpr DLCCatalog(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DLCCatalog(const DLCCatalog& from);
  DLCCatalog(DLCCatalog&& from) noexcept
    : DLCCatalog() {
    *this = ::std::move(from);
  }

  inline DLCCatalog& operator=(const DLCCatalog& from) {
    CopyFrom(from);
    return *this;
  }
  inline DLCCatalog& operator=(DLCCatalog&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DLCCatalog& default_instance() {
    return *internal_default_instance();
  }
  static inline const DLCCatalog* internal_default_instance() {
    return reinterpret_cast<const DLCCatalog*>(
               &_DLCCatalog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    135;

  friend void swap(DLCCatalog& a, DLCCatalog& b) {
    a.Swap(&b);
  }
  inline void Swap(DLCCatalog* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DLCCatalog* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DLCCatalog* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DLCCatalog>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DLCCatalog& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DLCCatalog& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DLCCatalog* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.DLCCatalog";
  }
  protected:
  explicit DLCCatalog(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
    kShellsFieldNumber = 2,
    kShellSetsFieldNumber = 3,
    kShellObjectsFieldNumber = 4,
    kShellGroupsFieldNumber = 5,
  };
  // repeated .ei.DLCItem items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::ei::DLCItem* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::DLCItem >*
      mutable_items();
  private:
  const ::ei::DLCItem& _internal_items(int index) const;
  ::ei::DLCItem* _internal_add_items();
  public:
  const ::ei::DLCItem& items(int index) const;
  ::ei::DLCItem* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::DLCItem >&
      items() const;

  // repeated .ei.ShellSpec shells = 2;
  int shells_size() const;
  private:
  int _internal_shells_size() const;
  public:
  void clear_shells();
  ::ei::ShellSpec* mutable_shells(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellSpec >*
      mutable_shells();
  private:
  const ::ei::ShellSpec& _internal_shells(int index) const;
  ::ei::ShellSpec* _internal_add_shells();
  public:
  const ::ei::ShellSpec& shells(int index) const;
  ::ei::ShellSpec* add_shells();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellSpec >&
      shells() const;

  // repeated .ei.ShellSetSpec shell_sets = 3;
  int shell_sets_size() const;
  private:
  int _internal_shell_sets_size() const;
  public:
  void clear_shell_sets();
  ::ei::ShellSetSpec* mutable_shell_sets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellSetSpec >*
      mutable_shell_sets();
  private:
  const ::ei::ShellSetSpec& _internal_shell_sets(int index) const;
  ::ei::ShellSetSpec* _internal_add_shell_sets();
  public:
  const ::ei::ShellSetSpec& shell_sets(int index) const;
  ::ei::ShellSetSpec* add_shell_sets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellSetSpec >&
      shell_sets() const;

  // repeated .ei.ShellObjectSpec shell_objects = 4;
  int shell_objects_size() const;
  private:
  int _internal_shell_objects_size() const;
  public:
  void clear_shell_objects();
  ::ei::ShellObjectSpec* mutable_shell_objects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellObjectSpec >*
      mutable_shell_objects();
  private:
  const ::ei::ShellObjectSpec& _internal_shell_objects(int index) const;
  ::ei::ShellObjectSpec* _internal_add_shell_objects();
  public:
  const ::ei::ShellObjectSpec& shell_objects(int index) const;
  ::ei::ShellObjectSpec* add_shell_objects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellObjectSpec >&
      shell_objects() const;

  // repeated .ei.ShellGroupSpec shell_groups = 5;
  int shell_groups_size() const;
  private:
  int _internal_shell_groups_size() const;
  public:
  void clear_shell_groups();
  ::ei::ShellGroupSpec* mutable_shell_groups(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellGroupSpec >*
      mutable_shell_groups();
  private:
  const ::ei::ShellGroupSpec& _internal_shell_groups(int index) const;
  ::ei::ShellGroupSpec* _internal_add_shell_groups();
  public:
  const ::ei::ShellGroupSpec& shell_groups(int index) const;
  ::ei::ShellGroupSpec* add_shell_groups();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellGroupSpec >&
      shell_groups() const;

  // @@protoc_insertion_point(class_scope:ei.DLCCatalog)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::DLCItem > items_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellSpec > shells_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellSetSpec > shell_sets_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellObjectSpec > shell_objects_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellGroupSpec > shell_groups_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ShellDB_ShellStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ShellDB.ShellStatus) */ {
 public:
  inline ShellDB_ShellStatus() : ShellDB_ShellStatus(nullptr) {}
  ~ShellDB_ShellStatus() override;
  explicit constexpr ShellDB_ShellStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShellDB_ShellStatus(const ShellDB_ShellStatus& from);
  ShellDB_ShellStatus(ShellDB_ShellStatus&& from) noexcept
    : ShellDB_ShellStatus() {
    *this = ::std::move(from);
  }

  inline ShellDB_ShellStatus& operator=(const ShellDB_ShellStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShellDB_ShellStatus& operator=(ShellDB_ShellStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShellDB_ShellStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShellDB_ShellStatus* internal_default_instance() {
    return reinterpret_cast<const ShellDB_ShellStatus*>(
               &_ShellDB_ShellStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    136;

  friend void swap(ShellDB_ShellStatus& a, ShellDB_ShellStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ShellDB_ShellStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShellDB_ShellStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShellDB_ShellStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShellDB_ShellStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShellDB_ShellStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShellDB_ShellStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShellDB_ShellStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ShellDB.ShellStatus";
  }
  protected:
  explicit ShellDB_ShellStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifierFieldNumber = 1,
    kOwnedFieldNumber = 2,
  };
  // optional string identifier = 1;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  PROTOBUF_NODISCARD std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // optional bool owned = 2;
  bool has_owned() const;
  private:
  bool _internal_has_owned() const;
  public:
  void clear_owned();
  bool owned() const;
  void set_owned(bool value);
  private:
  bool _internal_owned() const;
  void _internal_set_owned(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ShellDB.ShellStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  bool owned_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ShellDB_ShellElementStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ShellDB.ShellElementStatus) */ {
 public:
  inline ShellDB_ShellElementStatus() : ShellDB_ShellElementStatus(nullptr) {}
  ~ShellDB_ShellElementStatus() override;
  explicit constexpr ShellDB_ShellElementStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShellDB_ShellElementStatus(const ShellDB_ShellElementStatus& from);
  ShellDB_ShellElementStatus(ShellDB_ShellElementStatus&& from) noexcept
    : ShellDB_ShellElementStatus() {
    *this = ::std::move(from);
  }

  inline ShellDB_ShellElementStatus& operator=(const ShellDB_ShellElementStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShellDB_ShellElementStatus& operator=(ShellDB_ShellElementStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShellDB_ShellElementStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShellDB_ShellElementStatus* internal_default_instance() {
    return reinterpret_cast<const ShellDB_ShellElementStatus*>(
               &_ShellDB_ShellElementStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    137;

  friend void swap(ShellDB_ShellElementStatus& a, ShellDB_ShellElementStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ShellDB_ShellElementStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShellDB_ShellElementStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShellDB_ShellElementStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShellDB_ShellElementStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShellDB_ShellElementStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShellDB_ShellElementStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShellDB_ShellElementStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ShellDB.ShellElementStatus";
  }
  protected:
  explicit ShellDB_ShellElementStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSetIdentifierFieldNumber = 2,
    kElementFieldNumber = 1,
  };
  // optional string set_identifier = 2;
  bool has_set_identifier() const;
  private:
  bool _internal_has_set_identifier() const;
  public:
  void clear_set_identifier();
  const std::string& set_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_set_identifier();
  PROTOBUF_NODISCARD std::string* release_set_identifier();
  void set_allocated_set_identifier(std::string* set_identifier);
  private:
  const std::string& _internal_set_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_set_identifier(const std::string& value);
  std::string* _internal_mutable_set_identifier();
  public:

  // optional .ei.ShellDB.FarmElement element = 1;
  bool has_element() const;
  private:
  bool _internal_has_element() const;
  public:
  void clear_element();
  ::ei::ShellDB_FarmElement element() const;
  void set_element(::ei::ShellDB_FarmElement value);
  private:
  ::ei::ShellDB_FarmElement _internal_element() const;
  void _internal_set_element(::ei::ShellDB_FarmElement value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ShellDB.ShellElementStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr set_identifier_;
  int element_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ShellDB_ShellSetVariationStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ShellDB.ShellSetVariationStatus) */ {
 public:
  inline ShellDB_ShellSetVariationStatus() : ShellDB_ShellSetVariationStatus(nullptr) {}
  ~ShellDB_ShellSetVariationStatus() override;
  explicit constexpr ShellDB_ShellSetVariationStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShellDB_ShellSetVariationStatus(const ShellDB_ShellSetVariationStatus& from);
  ShellDB_ShellSetVariationStatus(ShellDB_ShellSetVariationStatus&& from) noexcept
    : ShellDB_ShellSetVariationStatus() {
    *this = ::std::move(from);
  }

  inline ShellDB_ShellSetVariationStatus& operator=(const ShellDB_ShellSetVariationStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShellDB_ShellSetVariationStatus& operator=(ShellDB_ShellSetVariationStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShellDB_ShellSetVariationStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShellDB_ShellSetVariationStatus* internal_default_instance() {
    return reinterpret_cast<const ShellDB_ShellSetVariationStatus*>(
               &_ShellDB_ShellSetVariationStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    138;

  friend void swap(ShellDB_ShellSetVariationStatus& a, ShellDB_ShellSetVariationStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ShellDB_ShellSetVariationStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShellDB_ShellSetVariationStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShellDB_ShellSetVariationStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShellDB_ShellSetVariationStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShellDB_ShellSetVariationStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShellDB_ShellSetVariationStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShellDB_ShellSetVariationStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ShellDB.ShellSetVariationStatus";
  }
  protected:
  explicit ShellDB_ShellSetVariationStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnedVariationsFieldNumber = 2,
    kSetIdentifierFieldNumber = 1,
  };
  // repeated string owned_variations = 2;
  int owned_variations_size() const;
  private:
  int _internal_owned_variations_size() const;
  public:
  void clear_owned_variations();
  const std::string& owned_variations(int index) const;
  std::string* mutable_owned_variations(int index);
  void set_owned_variations(int index, const std::string& value);
  void set_owned_variations(int index, std::string&& value);
  void set_owned_variations(int index, const char* value);
  void set_owned_variations(int index, const char* value, size_t size);
  std::string* add_owned_variations();
  void add_owned_variations(const std::string& value);
  void add_owned_variations(std::string&& value);
  void add_owned_variations(const char* value);
  void add_owned_variations(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& owned_variations() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_owned_variations();
  private:
  const std::string& _internal_owned_variations(int index) const;
  std::string* _internal_add_owned_variations();
  public:

  // optional string set_identifier = 1;
  bool has_set_identifier() const;
  private:
  bool _internal_has_set_identifier() const;
  public:
  void clear_set_identifier();
  const std::string& set_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_set_identifier();
  PROTOBUF_NODISCARD std::string* release_set_identifier();
  void set_allocated_set_identifier(std::string* set_identifier);
  private:
  const std::string& _internal_set_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_set_identifier(const std::string& value);
  std::string* _internal_mutable_set_identifier();
  public:

  // @@protoc_insertion_point(class_scope:ei.ShellDB.ShellSetVariationStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> owned_variations_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr set_identifier_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ShellDB_FarmConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ShellDB.FarmConfiguration) */ {
 public:
  inline ShellDB_FarmConfiguration() : ShellDB_FarmConfiguration(nullptr) {}
  ~ShellDB_FarmConfiguration() override;
  explicit constexpr ShellDB_FarmConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShellDB_FarmConfiguration(const ShellDB_FarmConfiguration& from);
  ShellDB_FarmConfiguration(ShellDB_FarmConfiguration&& from) noexcept
    : ShellDB_FarmConfiguration() {
    *this = ::std::move(from);
  }

  inline ShellDB_FarmConfiguration& operator=(const ShellDB_FarmConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShellDB_FarmConfiguration& operator=(ShellDB_FarmConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShellDB_FarmConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShellDB_FarmConfiguration* internal_default_instance() {
    return reinterpret_cast<const ShellDB_FarmConfiguration*>(
               &_ShellDB_FarmConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    139;

  friend void swap(ShellDB_FarmConfiguration& a, ShellDB_FarmConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(ShellDB_FarmConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShellDB_FarmConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShellDB_FarmConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShellDB_FarmConfiguration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShellDB_FarmConfiguration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShellDB_FarmConfiguration& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShellDB_FarmConfiguration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ShellDB.FarmConfiguration";
  }
  protected:
  explicit ShellDB_FarmConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShellConfigsFieldNumber = 1,
    kShellSetConfigsFieldNumber = 2,
    kGroupConfigsFieldNumber = 8,
    kChickenConfigsFieldNumber = 9,
    kConfigureChickensByGroupFieldNumber = 7,
  };
  // repeated .ei.ShellDB.ShellConfiguration shell_configs = 1;
  int shell_configs_size() const;
  private:
  int _internal_shell_configs_size() const;
  public:
  void clear_shell_configs();
  ::ei::ShellDB_ShellConfiguration* mutable_shell_configs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellConfiguration >*
      mutable_shell_configs();
  private:
  const ::ei::ShellDB_ShellConfiguration& _internal_shell_configs(int index) const;
  ::ei::ShellDB_ShellConfiguration* _internal_add_shell_configs();
  public:
  const ::ei::ShellDB_ShellConfiguration& shell_configs(int index) const;
  ::ei::ShellDB_ShellConfiguration* add_shell_configs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellConfiguration >&
      shell_configs() const;

  // repeated .ei.ShellDB.ShellSetConfiguration shell_set_configs = 2;
  int shell_set_configs_size() const;
  private:
  int _internal_shell_set_configs_size() const;
  public:
  void clear_shell_set_configs();
  ::ei::ShellDB_ShellSetConfiguration* mutable_shell_set_configs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellSetConfiguration >*
      mutable_shell_set_configs();
  private:
  const ::ei::ShellDB_ShellSetConfiguration& _internal_shell_set_configs(int index) const;
  ::ei::ShellDB_ShellSetConfiguration* _internal_add_shell_set_configs();
  public:
  const ::ei::ShellDB_ShellSetConfiguration& shell_set_configs(int index) const;
  ::ei::ShellDB_ShellSetConfiguration* add_shell_set_configs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellSetConfiguration >&
      shell_set_configs() const;

  // repeated .ei.ShellDB.ShellGroupConfiguration group_configs = 8;
  int group_configs_size() const;
  private:
  int _internal_group_configs_size() const;
  public:
  void clear_group_configs();
  ::ei::ShellDB_ShellGroupConfiguration* mutable_group_configs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellGroupConfiguration >*
      mutable_group_configs();
  private:
  const ::ei::ShellDB_ShellGroupConfiguration& _internal_group_configs(int index) const;
  ::ei::ShellDB_ShellGroupConfiguration* _internal_add_group_configs();
  public:
  const ::ei::ShellDB_ShellGroupConfiguration& group_configs(int index) const;
  ::ei::ShellDB_ShellGroupConfiguration* add_group_configs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellGroupConfiguration >&
      group_configs() const;

  // repeated .ei.ShellDB.ChickenConfig chicken_configs = 9;
  int chicken_configs_size() const;
  private:
  int _internal_chicken_configs_size() const;
  public:
  void clear_chicken_configs();
  ::ei::ShellDB_ChickenConfig* mutable_chicken_configs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ChickenConfig >*
      mutable_chicken_configs();
  private:
  const ::ei::ShellDB_ChickenConfig& _internal_chicken_configs(int index) const;
  ::ei::ShellDB_ChickenConfig* _internal_add_chicken_configs();
  public:
  const ::ei::ShellDB_ChickenConfig& chicken_configs(int index) const;
  ::ei::ShellDB_ChickenConfig* add_chicken_configs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ChickenConfig >&
      chicken_configs() const;

  // optional bool configure_chickens_by_group = 7;
  bool has_configure_chickens_by_group() const;
  private:
  bool _internal_has_configure_chickens_by_group() const;
  public:
  void clear_configure_chickens_by_group();
  bool configure_chickens_by_group() const;
  void set_configure_chickens_by_group(bool value);
  private:
  bool _internal_configure_chickens_by_group() const;
  void _internal_set_configure_chickens_by_group(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ShellDB.FarmConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellConfiguration > shell_configs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellSetConfiguration > shell_set_configs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellGroupConfiguration > group_configs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ChickenConfig > chicken_configs_;
  bool configure_chickens_by_group_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ShellDB_ShellConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ShellDB.ShellConfiguration) */ {
 public:
  inline ShellDB_ShellConfiguration() : ShellDB_ShellConfiguration(nullptr) {}
  ~ShellDB_ShellConfiguration() override;
  explicit constexpr ShellDB_ShellConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShellDB_ShellConfiguration(const ShellDB_ShellConfiguration& from);
  ShellDB_ShellConfiguration(ShellDB_ShellConfiguration&& from) noexcept
    : ShellDB_ShellConfiguration() {
    *this = ::std::move(from);
  }

  inline ShellDB_ShellConfiguration& operator=(const ShellDB_ShellConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShellDB_ShellConfiguration& operator=(ShellDB_ShellConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShellDB_ShellConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShellDB_ShellConfiguration* internal_default_instance() {
    return reinterpret_cast<const ShellDB_ShellConfiguration*>(
               &_ShellDB_ShellConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    140;

  friend void swap(ShellDB_ShellConfiguration& a, ShellDB_ShellConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(ShellDB_ShellConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShellDB_ShellConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShellDB_ShellConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShellDB_ShellConfiguration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShellDB_ShellConfiguration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShellDB_ShellConfiguration& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShellDB_ShellConfiguration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ShellDB.ShellConfiguration";
  }
  protected:
  explicit ShellDB_ShellConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShellIdentifierFieldNumber = 3,
    kIndexFieldNumber = 2,
    kAssetTypeFieldNumber = 1,
  };
  // optional string shell_identifier = 3;
  bool has_shell_identifier() const;
  private:
  bool _internal_has_shell_identifier() const;
  public:
  void clear_shell_identifier();
  const std::string& shell_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shell_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shell_identifier();
  PROTOBUF_NODISCARD std::string* release_shell_identifier();
  void set_allocated_shell_identifier(std::string* shell_identifier);
  private:
  const std::string& _internal_shell_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shell_identifier(const std::string& value);
  std::string* _internal_mutable_shell_identifier();
  public:

  // optional uint32 index = 2;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // optional .ei.ShellSpec.AssetType asset_type = 1;
  bool has_asset_type() const;
  private:
  bool _internal_has_asset_type() const;
  public:
  void clear_asset_type();
  ::ei::ShellSpec_AssetType asset_type() const;
  void set_asset_type(::ei::ShellSpec_AssetType value);
  private:
  ::ei::ShellSpec_AssetType _internal_asset_type() const;
  void _internal_set_asset_type(::ei::ShellSpec_AssetType value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ShellDB.ShellConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shell_identifier_;
  uint32_t index_;
  int asset_type_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ShellDB_ShellSetConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ShellDB.ShellSetConfiguration) */ {
 public:
  inline ShellDB_ShellSetConfiguration() : ShellDB_ShellSetConfiguration(nullptr) {}
  ~ShellDB_ShellSetConfiguration() override;
  explicit constexpr ShellDB_ShellSetConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShellDB_ShellSetConfiguration(const ShellDB_ShellSetConfiguration& from);
  ShellDB_ShellSetConfiguration(ShellDB_ShellSetConfiguration&& from) noexcept
    : ShellDB_ShellSetConfiguration() {
    *this = ::std::move(from);
  }

  inline ShellDB_ShellSetConfiguration& operator=(const ShellDB_ShellSetConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShellDB_ShellSetConfiguration& operator=(ShellDB_ShellSetConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShellDB_ShellSetConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShellDB_ShellSetConfiguration* internal_default_instance() {
    return reinterpret_cast<const ShellDB_ShellSetConfiguration*>(
               &_ShellDB_ShellSetConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    141;

  friend void swap(ShellDB_ShellSetConfiguration& a, ShellDB_ShellSetConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(ShellDB_ShellSetConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShellDB_ShellSetConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShellDB_ShellSetConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShellDB_ShellSetConfiguration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShellDB_ShellSetConfiguration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShellDB_ShellSetConfiguration& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShellDB_ShellSetConfiguration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ShellDB.ShellSetConfiguration";
  }
  protected:
  explicit ShellDB_ShellSetConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShellSetIdentifierFieldNumber = 3,
    kVariationIdentifierFieldNumber = 4,
    kDecoratorIdentifierFieldNumber = 5,
    kIndexFieldNumber = 2,
    kElementFieldNumber = 1,
  };
  // optional string shell_set_identifier = 3;
  bool has_shell_set_identifier() const;
  private:
  bool _internal_has_shell_set_identifier() const;
  public:
  void clear_shell_set_identifier();
  const std::string& shell_set_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shell_set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shell_set_identifier();
  PROTOBUF_NODISCARD std::string* release_shell_set_identifier();
  void set_allocated_shell_set_identifier(std::string* shell_set_identifier);
  private:
  const std::string& _internal_shell_set_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shell_set_identifier(const std::string& value);
  std::string* _internal_mutable_shell_set_identifier();
  public:

  // optional string variation_identifier = 4;
  bool has_variation_identifier() const;
  private:
  bool _internal_has_variation_identifier() const;
  public:
  void clear_variation_identifier();
  const std::string& variation_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_variation_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_variation_identifier();
  PROTOBUF_NODISCARD std::string* release_variation_identifier();
  void set_allocated_variation_identifier(std::string* variation_identifier);
  private:
  const std::string& _internal_variation_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_variation_identifier(const std::string& value);
  std::string* _internal_mutable_variation_identifier();
  public:

  // optional string decorator_identifier = 5;
  bool has_decorator_identifier() const;
  private:
  bool _internal_has_decorator_identifier() const;
  public:
  void clear_decorator_identifier();
  const std::string& decorator_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_decorator_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_decorator_identifier();
  PROTOBUF_NODISCARD std::string* release_decorator_identifier();
  void set_allocated_decorator_identifier(std::string* decorator_identifier);
  private:
  const std::string& _internal_decorator_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_decorator_identifier(const std::string& value);
  std::string* _internal_mutable_decorator_identifier();
  public:

  // optional uint32 index = 2;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // optional .ei.ShellDB.FarmElement element = 1;
  bool has_element() const;
  private:
  bool _internal_has_element() const;
  public:
  void clear_element();
  ::ei::ShellDB_FarmElement element() const;
  void set_element(::ei::ShellDB_FarmElement value);
  private:
  ::ei::ShellDB_FarmElement _internal_element() const;
  void _internal_set_element(::ei::ShellDB_FarmElement value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ShellDB.ShellSetConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shell_set_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr variation_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr decorator_identifier_;
  uint32_t index_;
  int element_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ShellDB_ShellGroupConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ShellDB.ShellGroupConfiguration) */ {
 public:
  inline ShellDB_ShellGroupConfiguration() : ShellDB_ShellGroupConfiguration(nullptr) {}
  ~ShellDB_ShellGroupConfiguration() override;
  explicit constexpr ShellDB_ShellGroupConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShellDB_ShellGroupConfiguration(const ShellDB_ShellGroupConfiguration& from);
  ShellDB_ShellGroupConfiguration(ShellDB_ShellGroupConfiguration&& from) noexcept
    : ShellDB_ShellGroupConfiguration() {
    *this = ::std::move(from);
  }

  inline ShellDB_ShellGroupConfiguration& operator=(const ShellDB_ShellGroupConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShellDB_ShellGroupConfiguration& operator=(ShellDB_ShellGroupConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShellDB_ShellGroupConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShellDB_ShellGroupConfiguration* internal_default_instance() {
    return reinterpret_cast<const ShellDB_ShellGroupConfiguration*>(
               &_ShellDB_ShellGroupConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    142;

  friend void swap(ShellDB_ShellGroupConfiguration& a, ShellDB_ShellGroupConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(ShellDB_ShellGroupConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShellDB_ShellGroupConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShellDB_ShellGroupConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShellDB_ShellGroupConfiguration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShellDB_ShellGroupConfiguration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShellDB_ShellGroupConfiguration& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShellDB_ShellGroupConfiguration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ShellDB.ShellGroupConfiguration";
  }
  protected:
  explicit ShellDB_ShellGroupConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupIdentifierFieldNumber = 2,
    kAssetTypeFieldNumber = 1,
  };
  // optional string group_identifier = 2;
  bool has_group_identifier() const;
  private:
  bool _internal_has_group_identifier() const;
  public:
  void clear_group_identifier();
  const std::string& group_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group_identifier();
  PROTOBUF_NODISCARD std::string* release_group_identifier();
  void set_allocated_group_identifier(std::string* group_identifier);
  private:
  const std::string& _internal_group_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_identifier(const std::string& value);
  std::string* _internal_mutable_group_identifier();
  public:

  // optional .ei.ShellSpec.AssetType asset_type = 1;
  bool has_asset_type() const;
  private:
  bool _internal_has_asset_type() const;
  public:
  void clear_asset_type();
  ::ei::ShellSpec_AssetType asset_type() const;
  void set_asset_type(::ei::ShellSpec_AssetType value);
  private:
  ::ei::ShellSpec_AssetType _internal_asset_type() const;
  void _internal_set_asset_type(::ei::ShellSpec_AssetType value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ShellDB.ShellGroupConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_identifier_;
  int asset_type_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ShellDB_ChickenConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ShellDB.ChickenConfig) */ {
 public:
  inline ShellDB_ChickenConfig() : ShellDB_ChickenConfig(nullptr) {}
  ~ShellDB_ChickenConfig() override;
  explicit constexpr ShellDB_ChickenConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShellDB_ChickenConfig(const ShellDB_ChickenConfig& from);
  ShellDB_ChickenConfig(ShellDB_ChickenConfig&& from) noexcept
    : ShellDB_ChickenConfig() {
    *this = ::std::move(from);
  }

  inline ShellDB_ChickenConfig& operator=(const ShellDB_ChickenConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShellDB_ChickenConfig& operator=(ShellDB_ChickenConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShellDB_ChickenConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShellDB_ChickenConfig* internal_default_instance() {
    return reinterpret_cast<const ShellDB_ChickenConfig*>(
               &_ShellDB_ChickenConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    143;

  friend void swap(ShellDB_ChickenConfig& a, ShellDB_ChickenConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ShellDB_ChickenConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShellDB_ChickenConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShellDB_ChickenConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShellDB_ChickenConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShellDB_ChickenConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShellDB_ChickenConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShellDB_ChickenConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ShellDB.ChickenConfig";
  }
  protected:
  explicit ShellDB_ChickenConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChickenIdentifierFieldNumber = 1,
    kHatIdentifierFieldNumber = 2,
  };
  // optional string chicken_identifier = 1;
  bool has_chicken_identifier() const;
  private:
  bool _internal_has_chicken_identifier() const;
  public:
  void clear_chicken_identifier();
  const std::string& chicken_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chicken_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chicken_identifier();
  PROTOBUF_NODISCARD std::string* release_chicken_identifier();
  void set_allocated_chicken_identifier(std::string* chicken_identifier);
  private:
  const std::string& _internal_chicken_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chicken_identifier(const std::string& value);
  std::string* _internal_mutable_chicken_identifier();
  public:

  // optional string hat_identifier = 2;
  bool has_hat_identifier() const;
  private:
  bool _internal_has_hat_identifier() const;
  public:
  void clear_hat_identifier();
  const std::string& hat_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hat_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hat_identifier();
  PROTOBUF_NODISCARD std::string* release_hat_identifier();
  void set_allocated_hat_identifier(std::string* hat_identifier);
  private:
  const std::string& _internal_hat_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hat_identifier(const std::string& value);
  std::string* _internal_mutable_hat_identifier();
  public:

  // @@protoc_insertion_point(class_scope:ei.ShellDB.ChickenConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chicken_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hat_identifier_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ShellDB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ShellDB) */ {
 public:
  inline ShellDB() : ShellDB(nullptr) {}
  ~ShellDB() override;
  explicit constexpr ShellDB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShellDB(const ShellDB& from);
  ShellDB(ShellDB&& from) noexcept
    : ShellDB() {
    *this = ::std::move(from);
  }

  inline ShellDB& operator=(const ShellDB& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShellDB& operator=(ShellDB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShellDB& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShellDB* internal_default_instance() {
    return reinterpret_cast<const ShellDB*>(
               &_ShellDB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    144;

  friend void swap(ShellDB& a, ShellDB& b) {
    a.Swap(&b);
  }
  inline void Swap(ShellDB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShellDB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShellDB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShellDB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShellDB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShellDB& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShellDB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ShellDB";
  }
  protected:
  explicit ShellDB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ShellDB_ShellStatus ShellStatus;
  typedef ShellDB_ShellElementStatus ShellElementStatus;
  typedef ShellDB_ShellSetVariationStatus ShellSetVariationStatus;
  typedef ShellDB_FarmConfiguration FarmConfiguration;
  typedef ShellDB_ShellConfiguration ShellConfiguration;
  typedef ShellDB_ShellSetConfiguration ShellSetConfiguration;
  typedef ShellDB_ShellGroupConfiguration ShellGroupConfiguration;
  typedef ShellDB_ChickenConfig ChickenConfig;

  typedef ShellDB_FarmElement FarmElement;
  static constexpr FarmElement HEN_HOUSE =
    ShellDB_FarmElement_HEN_HOUSE;
  static constexpr FarmElement SILO =
    ShellDB_FarmElement_SILO;
  static constexpr FarmElement MAILBOX =
    ShellDB_FarmElement_MAILBOX;
  static constexpr FarmElement TROPHY_CASE =
    ShellDB_FarmElement_TROPHY_CASE;
  static constexpr FarmElement GROUND =
    ShellDB_FarmElement_GROUND;
  static constexpr FarmElement HARDSCAPE =
    ShellDB_FarmElement_HARDSCAPE;
  static constexpr FarmElement HYPERLOOP =
    ShellDB_FarmElement_HYPERLOOP;
  static constexpr FarmElement DEPOT =
    ShellDB_FarmElement_DEPOT;
  static constexpr FarmElement LAB =
    ShellDB_FarmElement_LAB;
  static constexpr FarmElement HATCHERY =
    ShellDB_FarmElement_HATCHERY;
  static constexpr FarmElement HOA =
    ShellDB_FarmElement_HOA;
  static constexpr FarmElement MISSION_CONTROL =
    ShellDB_FarmElement_MISSION_CONTROL;
  static constexpr FarmElement FUEL_TANK =
    ShellDB_FarmElement_FUEL_TANK;
  static constexpr FarmElement CHICKEN =
    ShellDB_FarmElement_CHICKEN;
  static constexpr FarmElement HAT =
    ShellDB_FarmElement_HAT;
  static constexpr FarmElement UNKNOWN =
    ShellDB_FarmElement_UNKNOWN;
  static inline bool FarmElement_IsValid(int value) {
    return ShellDB_FarmElement_IsValid(value);
  }
  static constexpr FarmElement FarmElement_MIN =
    ShellDB_FarmElement_FarmElement_MIN;
  static constexpr FarmElement FarmElement_MAX =
    ShellDB_FarmElement_FarmElement_MAX;
  static constexpr int FarmElement_ARRAYSIZE =
    ShellDB_FarmElement_FarmElement_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FarmElement_descriptor() {
    return ShellDB_FarmElement_descriptor();
  }
  template<typename T>
  static inline const std::string& FarmElement_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FarmElement>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FarmElement_Name.");
    return ShellDB_FarmElement_Name(enum_t_value);
  }
  static inline bool FarmElement_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FarmElement* value) {
    return ShellDB_FarmElement_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kShellInventoryFieldNumber = 1,
    kShellSetInventoryFieldNumber = 2,
    kFarmConfigsFieldNumber = 3,
    kShellObjectInventoryFieldNumber = 4,
    kShellElementInventoryFieldNumber = 5,
    kNewShellsDownloadedFieldNumber = 6,
    kNewShellsSeenFieldNumber = 7,
    kShellVariationInventoryFieldNumber = 8,
  };
  // repeated .ei.ShellDB.ShellStatus shell_inventory = 1;
  int shell_inventory_size() const;
  private:
  int _internal_shell_inventory_size() const;
  public:
  void clear_shell_inventory();
  ::ei::ShellDB_ShellStatus* mutable_shell_inventory(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellStatus >*
      mutable_shell_inventory();
  private:
  const ::ei::ShellDB_ShellStatus& _internal_shell_inventory(int index) const;
  ::ei::ShellDB_ShellStatus* _internal_add_shell_inventory();
  public:
  const ::ei::ShellDB_ShellStatus& shell_inventory(int index) const;
  ::ei::ShellDB_ShellStatus* add_shell_inventory();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellStatus >&
      shell_inventory() const;

  // repeated .ei.ShellDB.ShellStatus shell_set_inventory = 2;
  int shell_set_inventory_size() const;
  private:
  int _internal_shell_set_inventory_size() const;
  public:
  void clear_shell_set_inventory();
  ::ei::ShellDB_ShellStatus* mutable_shell_set_inventory(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellStatus >*
      mutable_shell_set_inventory();
  private:
  const ::ei::ShellDB_ShellStatus& _internal_shell_set_inventory(int index) const;
  ::ei::ShellDB_ShellStatus* _internal_add_shell_set_inventory();
  public:
  const ::ei::ShellDB_ShellStatus& shell_set_inventory(int index) const;
  ::ei::ShellDB_ShellStatus* add_shell_set_inventory();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellStatus >&
      shell_set_inventory() const;

  // repeated .ei.ShellDB.FarmConfiguration farm_configs = 3;
  int farm_configs_size() const;
  private:
  int _internal_farm_configs_size() const;
  public:
  void clear_farm_configs();
  ::ei::ShellDB_FarmConfiguration* mutable_farm_configs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_FarmConfiguration >*
      mutable_farm_configs();
  private:
  const ::ei::ShellDB_FarmConfiguration& _internal_farm_configs(int index) const;
  ::ei::ShellDB_FarmConfiguration* _internal_add_farm_configs();
  public:
  const ::ei::ShellDB_FarmConfiguration& farm_configs(int index) const;
  ::ei::ShellDB_FarmConfiguration* add_farm_configs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_FarmConfiguration >&
      farm_configs() const;

  // repeated .ei.ShellDB.ShellStatus shell_object_inventory = 4;
  int shell_object_inventory_size() const;
  private:
  int _internal_shell_object_inventory_size() const;
  public:
  void clear_shell_object_inventory();
  ::ei::ShellDB_ShellStatus* mutable_shell_object_inventory(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellStatus >*
      mutable_shell_object_inventory();
  private:
  const ::ei::ShellDB_ShellStatus& _internal_shell_object_inventory(int index) const;
  ::ei::ShellDB_ShellStatus* _internal_add_shell_object_inventory();
  public:
  const ::ei::ShellDB_ShellStatus& shell_object_inventory(int index) const;
  ::ei::ShellDB_ShellStatus* add_shell_object_inventory();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellStatus >&
      shell_object_inventory() const;

  // repeated .ei.ShellDB.ShellElementStatus shell_element_inventory = 5;
  int shell_element_inventory_size() const;
  private:
  int _internal_shell_element_inventory_size() const;
  public:
  void clear_shell_element_inventory();
  ::ei::ShellDB_ShellElementStatus* mutable_shell_element_inventory(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellElementStatus >*
      mutable_shell_element_inventory();
  private:
  const ::ei::ShellDB_ShellElementStatus& _internal_shell_element_inventory(int index) const;
  ::ei::ShellDB_ShellElementStatus* _internal_add_shell_element_inventory();
  public:
  const ::ei::ShellDB_ShellElementStatus& shell_element_inventory(int index) const;
  ::ei::ShellDB_ShellElementStatus* add_shell_element_inventory();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellElementStatus >&
      shell_element_inventory() const;

  // repeated string new_shells_downloaded = 6;
  int new_shells_downloaded_size() const;
  private:
  int _internal_new_shells_downloaded_size() const;
  public:
  void clear_new_shells_downloaded();
  const std::string& new_shells_downloaded(int index) const;
  std::string* mutable_new_shells_downloaded(int index);
  void set_new_shells_downloaded(int index, const std::string& value);
  void set_new_shells_downloaded(int index, std::string&& value);
  void set_new_shells_downloaded(int index, const char* value);
  void set_new_shells_downloaded(int index, const char* value, size_t size);
  std::string* add_new_shells_downloaded();
  void add_new_shells_downloaded(const std::string& value);
  void add_new_shells_downloaded(std::string&& value);
  void add_new_shells_downloaded(const char* value);
  void add_new_shells_downloaded(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& new_shells_downloaded() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_new_shells_downloaded();
  private:
  const std::string& _internal_new_shells_downloaded(int index) const;
  std::string* _internal_add_new_shells_downloaded();
  public:

  // repeated string new_shells_seen = 7;
  int new_shells_seen_size() const;
  private:
  int _internal_new_shells_seen_size() const;
  public:
  void clear_new_shells_seen();
  const std::string& new_shells_seen(int index) const;
  std::string* mutable_new_shells_seen(int index);
  void set_new_shells_seen(int index, const std::string& value);
  void set_new_shells_seen(int index, std::string&& value);
  void set_new_shells_seen(int index, const char* value);
  void set_new_shells_seen(int index, const char* value, size_t size);
  std::string* add_new_shells_seen();
  void add_new_shells_seen(const std::string& value);
  void add_new_shells_seen(std::string&& value);
  void add_new_shells_seen(const char* value);
  void add_new_shells_seen(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& new_shells_seen() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_new_shells_seen();
  private:
  const std::string& _internal_new_shells_seen(int index) const;
  std::string* _internal_add_new_shells_seen();
  public:

  // repeated .ei.ShellDB.ShellSetVariationStatus shell_variation_inventory = 8;
  int shell_variation_inventory_size() const;
  private:
  int _internal_shell_variation_inventory_size() const;
  public:
  void clear_shell_variation_inventory();
  ::ei::ShellDB_ShellSetVariationStatus* mutable_shell_variation_inventory(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellSetVariationStatus >*
      mutable_shell_variation_inventory();
  private:
  const ::ei::ShellDB_ShellSetVariationStatus& _internal_shell_variation_inventory(int index) const;
  ::ei::ShellDB_ShellSetVariationStatus* _internal_add_shell_variation_inventory();
  public:
  const ::ei::ShellDB_ShellSetVariationStatus& shell_variation_inventory(int index) const;
  ::ei::ShellDB_ShellSetVariationStatus* add_shell_variation_inventory();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellSetVariationStatus >&
      shell_variation_inventory() const;

  // @@protoc_insertion_point(class_scope:ei.ShellDB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellStatus > shell_inventory_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellStatus > shell_set_inventory_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_FarmConfiguration > farm_configs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellStatus > shell_object_inventory_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellElementStatus > shell_element_inventory_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> new_shells_downloaded_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> new_shells_seen_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellSetVariationStatus > shell_variation_inventory_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ei_2eproto;
};
// -------------------------------------------------------------------

class ShellsActionLog final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ei.ShellsActionLog) */ {
 public:
  inline ShellsActionLog() : ShellsActionLog(nullptr) {}
  ~ShellsActionLog() override;
  explicit constexpr ShellsActionLog(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShellsActionLog(const ShellsActionLog& from);
  ShellsActionLog(ShellsActionLog&& from) noexcept
    : ShellsActionLog() {
    *this = ::std::move(from);
  }

  inline ShellsActionLog& operator=(const ShellsActionLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShellsActionLog& operator=(ShellsActionLog&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShellsActionLog& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShellsActionLog* internal_default_instance() {
    return reinterpret_cast<const ShellsActionLog*>(
               &_ShellsActionLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    145;

  friend void swap(ShellsActionLog& a, ShellsActionLog& b) {
    a.Swap(&b);
  }
  inline void Swap(ShellsActionLog* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShellsActionLog* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShellsActionLog* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShellsActionLog>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShellsActionLog& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShellsActionLog& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShellsActionLog* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ei.ShellsActionLog";
  }
  protected:
  explicit ShellsActionLog(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kActionFieldNumber = 2,
    kSubIdFieldNumber = 3,
    kVersionFieldNumber = 6,
    kRinfoFieldNumber = 8,
    kApproxTimeFieldNumber = 5,
    kCostFieldNumber = 4,
    kFarmIndexFieldNumber = 7,
    kFarmElementFieldNumber = 9,
  };
  // optional string user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // optional string action = 2;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  const std::string& action() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_action(ArgT0&& arg0, ArgT... args);
  std::string* mutable_action();
  PROTOBUF_NODISCARD std::string* release_action();
  void set_allocated_action(std::string* action);
  private:
  const std::string& _internal_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action(const std::string& value);
  std::string* _internal_mutable_action();
  public:

  // optional string sub_id = 3;
  bool has_sub_id() const;
  private:
  bool _internal_has_sub_id() const;
  public:
  void clear_sub_id();
  const std::string& sub_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sub_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sub_id();
  PROTOBUF_NODISCARD std::string* release_sub_id();
  void set_allocated_sub_id(std::string* sub_id);
  private:
  const std::string& _internal_sub_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sub_id(const std::string& value);
  std::string* _internal_mutable_sub_id();
  public:

  // optional string version = 6;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // optional .ei.BasicRequestInfo rinfo = 8;
  bool has_rinfo() const;
  private:
  bool _internal_has_rinfo() const;
  public:
  void clear_rinfo();
  const ::ei::BasicRequestInfo& rinfo() const;
  PROTOBUF_NODISCARD ::ei::BasicRequestInfo* release_rinfo();
  ::ei::BasicRequestInfo* mutable_rinfo();
  void set_allocated_rinfo(::ei::BasicRequestInfo* rinfo);
  private:
  const ::ei::BasicRequestInfo& _internal_rinfo() const;
  ::ei::BasicRequestInfo* _internal_mutable_rinfo();
  public:
  void unsafe_arena_set_allocated_rinfo(
      ::ei::BasicRequestInfo* rinfo);
  ::ei::BasicRequestInfo* unsafe_arena_release_rinfo();

  // optional double approx_time = 5;
  bool has_approx_time() const;
  private:
  bool _internal_has_approx_time() const;
  public:
  void clear_approx_time();
  double approx_time() const;
  void set_approx_time(double value);
  private:
  double _internal_approx_time() const;
  void _internal_set_approx_time(double value);
  public:

  // optional uint32 cost = 4;
  bool has_cost() const;
  private:
  bool _internal_has_cost() const;
  public:
  void clear_cost();
  uint32_t cost() const;
  void set_cost(uint32_t value);
  private:
  uint32_t _internal_cost() const;
  void _internal_set_cost(uint32_t value);
  public:

  // optional int32 farm_index = 7;
  bool has_farm_index() const;
  private:
  bool _internal_has_farm_index() const;
  public:
  void clear_farm_index();
  int32_t farm_index() const;
  void set_farm_index(int32_t value);
  private:
  int32_t _internal_farm_index() const;
  void _internal_set_farm_index(int32_t value);
  public:

  // optional .ei.ShellDB.FarmElement farm_element = 9;
  bool has_farm_element() const;
  private:
  bool _internal_has_farm_element() const;
  public:
  void clear_farm_element();
  ::ei::ShellDB_FarmElement farm_element() const;
  void set_farm_element(::ei::ShellDB_FarmElement value);
  private:
  ::ei::ShellDB_FarmElement _internal_farm_element() const;
  void _internal_set_farm_element(::ei::ShellDB_FarmElement value);
  public:

  // @@protoc_insertion_point(class_scope:ei.ShellsActionLog)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr action_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sub_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::ei::BasicRequestInfo* rinfo_;
  double approx_time_;
  uint32_t cost_;
  int32_t farm_index_;
  int farm_element_;
  friend struct ::TableStruct_ei_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Backup_Settings

// optional bool sfx = 1;
inline bool Backup_Settings::_internal_has_sfx() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Backup_Settings::has_sfx() const {
  return _internal_has_sfx();
}
inline void Backup_Settings::clear_sfx() {
  sfx_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool Backup_Settings::_internal_sfx() const {
  return sfx_;
}
inline bool Backup_Settings::sfx() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Settings.sfx)
  return _internal_sfx();
}
inline void Backup_Settings::_internal_set_sfx(bool value) {
  _has_bits_[0] |= 0x00000001u;
  sfx_ = value;
}
inline void Backup_Settings::set_sfx(bool value) {
  _internal_set_sfx(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Settings.sfx)
}

// optional bool music = 2;
inline bool Backup_Settings::_internal_has_music() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Backup_Settings::has_music() const {
  return _internal_has_music();
}
inline void Backup_Settings::clear_music() {
  music_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool Backup_Settings::_internal_music() const {
  return music_;
}
inline bool Backup_Settings::music() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Settings.music)
  return _internal_music();
}
inline void Backup_Settings::_internal_set_music(bool value) {
  _has_bits_[0] |= 0x00000002u;
  music_ = value;
}
inline void Backup_Settings::set_music(bool value) {
  _internal_set_music(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Settings.music)
}

// optional bool low_battery_mode = 3;
inline bool Backup_Settings::_internal_has_low_battery_mode() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Backup_Settings::has_low_battery_mode() const {
  return _internal_has_low_battery_mode();
}
inline void Backup_Settings::clear_low_battery_mode() {
  low_battery_mode_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Backup_Settings::_internal_low_battery_mode() const {
  return low_battery_mode_;
}
inline bool Backup_Settings::low_battery_mode() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Settings.low_battery_mode)
  return _internal_low_battery_mode();
}
inline void Backup_Settings::_internal_set_low_battery_mode(bool value) {
  _has_bits_[0] |= 0x00000004u;
  low_battery_mode_ = value;
}
inline void Backup_Settings::set_low_battery_mode(bool value) {
  _internal_set_low_battery_mode(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Settings.low_battery_mode)
}

// optional bool low_performance_mode = 4;
inline bool Backup_Settings::_internal_has_low_performance_mode() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Backup_Settings::has_low_performance_mode() const {
  return _internal_has_low_performance_mode();
}
inline void Backup_Settings::clear_low_performance_mode() {
  low_performance_mode_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool Backup_Settings::_internal_low_performance_mode() const {
  return low_performance_mode_;
}
inline bool Backup_Settings::low_performance_mode() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Settings.low_performance_mode)
  return _internal_low_performance_mode();
}
inline void Backup_Settings::_internal_set_low_performance_mode(bool value) {
  _has_bits_[0] |= 0x00000008u;
  low_performance_mode_ = value;
}
inline void Backup_Settings::set_low_performance_mode(bool value) {
  _internal_set_low_performance_mode(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Settings.low_performance_mode)
}

// optional bool force_touch_chicken_btn = 9;
inline bool Backup_Settings::_internal_has_force_touch_chicken_btn() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Backup_Settings::has_force_touch_chicken_btn() const {
  return _internal_has_force_touch_chicken_btn();
}
inline void Backup_Settings::clear_force_touch_chicken_btn() {
  force_touch_chicken_btn_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool Backup_Settings::_internal_force_touch_chicken_btn() const {
  return force_touch_chicken_btn_;
}
inline bool Backup_Settings::force_touch_chicken_btn() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Settings.force_touch_chicken_btn)
  return _internal_force_touch_chicken_btn();
}
inline void Backup_Settings::_internal_set_force_touch_chicken_btn(bool value) {
  _has_bits_[0] |= 0x00000010u;
  force_touch_chicken_btn_ = value;
}
inline void Backup_Settings::set_force_touch_chicken_btn(bool value) {
  _internal_set_force_touch_chicken_btn(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Settings.force_touch_chicken_btn)
}

// optional bool notifications_queried = 5;
inline bool Backup_Settings::_internal_has_notifications_queried() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Backup_Settings::has_notifications_queried() const {
  return _internal_has_notifications_queried();
}
inline void Backup_Settings::clear_notifications_queried() {
  notifications_queried_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool Backup_Settings::_internal_notifications_queried() const {
  return notifications_queried_;
}
inline bool Backup_Settings::notifications_queried() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Settings.notifications_queried)
  return _internal_notifications_queried();
}
inline void Backup_Settings::_internal_set_notifications_queried(bool value) {
  _has_bits_[0] |= 0x00000020u;
  notifications_queried_ = value;
}
inline void Backup_Settings::set_notifications_queried(bool value) {
  _internal_set_notifications_queried(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Settings.notifications_queried)
}

// optional bool notifications_on = 6;
inline bool Backup_Settings::_internal_has_notifications_on() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Backup_Settings::has_notifications_on() const {
  return _internal_has_notifications_on();
}
inline void Backup_Settings::clear_notifications_on() {
  notifications_on_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool Backup_Settings::_internal_notifications_on() const {
  return notifications_on_;
}
inline bool Backup_Settings::notifications_on() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Settings.notifications_on)
  return _internal_notifications_on();
}
inline void Backup_Settings::_internal_set_notifications_on(bool value) {
  _has_bits_[0] |= 0x00000040u;
  notifications_on_ = value;
}
inline void Backup_Settings::set_notifications_on(bool value) {
  _internal_set_notifications_on(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Settings.notifications_on)
}

// optional bool notify_daily_gift = 11;
inline bool Backup_Settings::_internal_has_notify_daily_gift() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Backup_Settings::has_notify_daily_gift() const {
  return _internal_has_notify_daily_gift();
}
inline void Backup_Settings::clear_notify_daily_gift() {
  notify_daily_gift_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool Backup_Settings::_internal_notify_daily_gift() const {
  return notify_daily_gift_;
}
inline bool Backup_Settings::notify_daily_gift() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Settings.notify_daily_gift)
  return _internal_notify_daily_gift();
}
inline void Backup_Settings::_internal_set_notify_daily_gift(bool value) {
  _has_bits_[0] |= 0x00000080u;
  notify_daily_gift_ = value;
}
inline void Backup_Settings::set_notify_daily_gift(bool value) {
  _internal_set_notify_daily_gift(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Settings.notify_daily_gift)
}

// optional bool coppa_queried = 7;
inline bool Backup_Settings::_internal_has_coppa_queried() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Backup_Settings::has_coppa_queried() const {
  return _internal_has_coppa_queried();
}
inline void Backup_Settings::clear_coppa_queried() {
  coppa_queried_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool Backup_Settings::_internal_coppa_queried() const {
  return coppa_queried_;
}
inline bool Backup_Settings::coppa_queried() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Settings.coppa_queried)
  return _internal_coppa_queried();
}
inline void Backup_Settings::_internal_set_coppa_queried(bool value) {
  _has_bits_[0] |= 0x00000100u;
  coppa_queried_ = value;
}
inline void Backup_Settings::set_coppa_queried(bool value) {
  _internal_set_coppa_queried(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Settings.coppa_queried)
}

// optional bool coppa_restricted = 8;
inline bool Backup_Settings::_internal_has_coppa_restricted() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Backup_Settings::has_coppa_restricted() const {
  return _internal_has_coppa_restricted();
}
inline void Backup_Settings::clear_coppa_restricted() {
  coppa_restricted_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool Backup_Settings::_internal_coppa_restricted() const {
  return coppa_restricted_;
}
inline bool Backup_Settings::coppa_restricted() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Settings.coppa_restricted)
  return _internal_coppa_restricted();
}
inline void Backup_Settings::_internal_set_coppa_restricted(bool value) {
  _has_bits_[0] |= 0x00000200u;
  coppa_restricted_ = value;
}
inline void Backup_Settings::set_coppa_restricted(bool value) {
  _internal_set_coppa_restricted(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Settings.coppa_restricted)
}

// optional bool gdpr_consent_queried = 12;
inline bool Backup_Settings::_internal_has_gdpr_consent_queried() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Backup_Settings::has_gdpr_consent_queried() const {
  return _internal_has_gdpr_consent_queried();
}
inline void Backup_Settings::clear_gdpr_consent_queried() {
  gdpr_consent_queried_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool Backup_Settings::_internal_gdpr_consent_queried() const {
  return gdpr_consent_queried_;
}
inline bool Backup_Settings::gdpr_consent_queried() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Settings.gdpr_consent_queried)
  return _internal_gdpr_consent_queried();
}
inline void Backup_Settings::_internal_set_gdpr_consent_queried(bool value) {
  _has_bits_[0] |= 0x00000400u;
  gdpr_consent_queried_ = value;
}
inline void Backup_Settings::set_gdpr_consent_queried(bool value) {
  _internal_set_gdpr_consent_queried(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Settings.gdpr_consent_queried)
}

// optional bool gdpr_age_restricted = 16;
inline bool Backup_Settings::_internal_has_gdpr_age_restricted() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool Backup_Settings::has_gdpr_age_restricted() const {
  return _internal_has_gdpr_age_restricted();
}
inline void Backup_Settings::clear_gdpr_age_restricted() {
  gdpr_age_restricted_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool Backup_Settings::_internal_gdpr_age_restricted() const {
  return gdpr_age_restricted_;
}
inline bool Backup_Settings::gdpr_age_restricted() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Settings.gdpr_age_restricted)
  return _internal_gdpr_age_restricted();
}
inline void Backup_Settings::_internal_set_gdpr_age_restricted(bool value) {
  _has_bits_[0] |= 0x00000800u;
  gdpr_age_restricted_ = value;
}
inline void Backup_Settings::set_gdpr_age_restricted(bool value) {
  _internal_set_gdpr_age_restricted(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Settings.gdpr_age_restricted)
}

// optional bool gdpr_consent_given = 13;
inline bool Backup_Settings::_internal_has_gdpr_consent_given() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Backup_Settings::has_gdpr_consent_given() const {
  return _internal_has_gdpr_consent_given();
}
inline void Backup_Settings::clear_gdpr_consent_given() {
  gdpr_consent_given_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool Backup_Settings::_internal_gdpr_consent_given() const {
  return gdpr_consent_given_;
}
inline bool Backup_Settings::gdpr_consent_given() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Settings.gdpr_consent_given)
  return _internal_gdpr_consent_given();
}
inline void Backup_Settings::_internal_set_gdpr_consent_given(bool value) {
  _has_bits_[0] |= 0x00002000u;
  gdpr_consent_given_ = value;
}
inline void Backup_Settings::set_gdpr_consent_given(bool value) {
  _internal_set_gdpr_consent_given(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Settings.gdpr_consent_given)
}

// optional bool age_queried = 18;
inline bool Backup_Settings::_internal_has_age_queried() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Backup_Settings::has_age_queried() const {
  return _internal_has_age_queried();
}
inline void Backup_Settings::clear_age_queried() {
  age_queried_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool Backup_Settings::_internal_age_queried() const {
  return age_queried_;
}
inline bool Backup_Settings::age_queried() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Settings.age_queried)
  return _internal_age_queried();
}
inline void Backup_Settings::_internal_set_age_queried(bool value) {
  _has_bits_[0] |= 0x00004000u;
  age_queried_ = value;
}
inline void Backup_Settings::set_age_queried(bool value) {
  _internal_set_age_queried(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Settings.age_queried)
}

// optional bool age_restricted = 19 [default = false];
inline bool Backup_Settings::_internal_has_age_restricted() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool Backup_Settings::has_age_restricted() const {
  return _internal_has_age_restricted();
}
inline void Backup_Settings::clear_age_restricted() {
  age_restricted_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool Backup_Settings::_internal_age_restricted() const {
  return age_restricted_;
}
inline bool Backup_Settings::age_restricted() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Settings.age_restricted)
  return _internal_age_restricted();
}
inline void Backup_Settings::_internal_set_age_restricted(bool value) {
  _has_bits_[0] |= 0x00008000u;
  age_restricted_ = value;
}
inline void Backup_Settings::set_age_restricted(bool value) {
  _internal_set_age_restricted(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Settings.age_restricted)
}

// optional bool data_collection_consent_queried = 20;
inline bool Backup_Settings::_internal_has_data_collection_consent_queried() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool Backup_Settings::has_data_collection_consent_queried() const {
  return _internal_has_data_collection_consent_queried();
}
inline void Backup_Settings::clear_data_collection_consent_queried() {
  data_collection_consent_queried_ = false;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool Backup_Settings::_internal_data_collection_consent_queried() const {
  return data_collection_consent_queried_;
}
inline bool Backup_Settings::data_collection_consent_queried() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Settings.data_collection_consent_queried)
  return _internal_data_collection_consent_queried();
}
inline void Backup_Settings::_internal_set_data_collection_consent_queried(bool value) {
  _has_bits_[0] |= 0x00010000u;
  data_collection_consent_queried_ = value;
}
inline void Backup_Settings::set_data_collection_consent_queried(bool value) {
  _internal_set_data_collection_consent_queried(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Settings.data_collection_consent_queried)
}

// optional bool data_collection_consent_given = 21;
inline bool Backup_Settings::_internal_has_data_collection_consent_given() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool Backup_Settings::has_data_collection_consent_given() const {
  return _internal_has_data_collection_consent_given();
}
inline void Backup_Settings::clear_data_collection_consent_given() {
  data_collection_consent_given_ = false;
  _has_bits_[0] &= ~0x00020000u;
}
inline bool Backup_Settings::_internal_data_collection_consent_given() const {
  return data_collection_consent_given_;
}
inline bool Backup_Settings::data_collection_consent_given() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Settings.data_collection_consent_given)
  return _internal_data_collection_consent_given();
}
inline void Backup_Settings::_internal_set_data_collection_consent_given(bool value) {
  _has_bits_[0] |= 0x00020000u;
  data_collection_consent_given_ = value;
}
inline void Backup_Settings::set_data_collection_consent_given(bool value) {
  _internal_set_data_collection_consent_given(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Settings.data_collection_consent_given)
}

// optional uint32 last_day_age_queried = 17;
inline bool Backup_Settings::_internal_has_last_day_age_queried() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Backup_Settings::has_last_day_age_queried() const {
  return _internal_has_last_day_age_queried();
}
inline void Backup_Settings::clear_last_day_age_queried() {
  last_day_age_queried_ = 0u;
  _has_bits_[0] &= ~0x00001000u;
}
inline uint32_t Backup_Settings::_internal_last_day_age_queried() const {
  return last_day_age_queried_;
}
inline uint32_t Backup_Settings::last_day_age_queried() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Settings.last_day_age_queried)
  return _internal_last_day_age_queried();
}
inline void Backup_Settings::_internal_set_last_day_age_queried(uint32_t value) {
  _has_bits_[0] |= 0x00001000u;
  last_day_age_queried_ = value;
}
inline void Backup_Settings::set_last_day_age_queried(uint32_t value) {
  _internal_set_last_day_age_queried(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Settings.last_day_age_queried)
}

// optional bool user_ads_enabled = 14 [default = true];
inline bool Backup_Settings::_internal_has_user_ads_enabled() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool Backup_Settings::has_user_ads_enabled() const {
  return _internal_has_user_ads_enabled();
}
inline void Backup_Settings::clear_user_ads_enabled() {
  user_ads_enabled_ = true;
  _has_bits_[0] &= ~0x00200000u;
}
inline bool Backup_Settings::_internal_user_ads_enabled() const {
  return user_ads_enabled_;
}
inline bool Backup_Settings::user_ads_enabled() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Settings.user_ads_enabled)
  return _internal_user_ads_enabled();
}
inline void Backup_Settings::_internal_set_user_ads_enabled(bool value) {
  _has_bits_[0] |= 0x00200000u;
  user_ads_enabled_ = value;
}
inline void Backup_Settings::set_user_ads_enabled(bool value) {
  _internal_set_user_ads_enabled(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Settings.user_ads_enabled)
}

// optional bool user_cloud_enabled = 15 [default = true];
inline bool Backup_Settings::_internal_has_user_cloud_enabled() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool Backup_Settings::has_user_cloud_enabled() const {
  return _internal_has_user_cloud_enabled();
}
inline void Backup_Settings::clear_user_cloud_enabled() {
  user_cloud_enabled_ = true;
  _has_bits_[0] &= ~0x00400000u;
}
inline bool Backup_Settings::_internal_user_cloud_enabled() const {
  return user_cloud_enabled_;
}
inline bool Backup_Settings::user_cloud_enabled() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Settings.user_cloud_enabled)
  return _internal_user_cloud_enabled();
}
inline void Backup_Settings::_internal_set_user_cloud_enabled(bool value) {
  _has_bits_[0] |= 0x00400000u;
  user_cloud_enabled_ = value;
}
inline void Backup_Settings::set_user_cloud_enabled(bool value) {
  _internal_set_user_cloud_enabled(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Settings.user_cloud_enabled)
}

// optional bool user_analytics_enabled = 22 [default = true];
inline bool Backup_Settings::_internal_has_user_analytics_enabled() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool Backup_Settings::has_user_analytics_enabled() const {
  return _internal_has_user_analytics_enabled();
}
inline void Backup_Settings::clear_user_analytics_enabled() {
  user_analytics_enabled_ = true;
  _has_bits_[0] &= ~0x00800000u;
}
inline bool Backup_Settings::_internal_user_analytics_enabled() const {
  return user_analytics_enabled_;
}
inline bool Backup_Settings::user_analytics_enabled() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Settings.user_analytics_enabled)
  return _internal_user_analytics_enabled();
}
inline void Backup_Settings::_internal_set_user_analytics_enabled(bool value) {
  _has_bits_[0] |= 0x00800000u;
  user_analytics_enabled_ = value;
}
inline void Backup_Settings::set_user_analytics_enabled(bool value) {
  _internal_set_user_analytics_enabled(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Settings.user_analytics_enabled)
}

// optional bool user_personalized_ads_enabled = 23 [default = true];
inline bool Backup_Settings::_internal_has_user_personalized_ads_enabled() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool Backup_Settings::has_user_personalized_ads_enabled() const {
  return _internal_has_user_personalized_ads_enabled();
}
inline void Backup_Settings::clear_user_personalized_ads_enabled() {
  user_personalized_ads_enabled_ = true;
  _has_bits_[0] &= ~0x01000000u;
}
inline bool Backup_Settings::_internal_user_personalized_ads_enabled() const {
  return user_personalized_ads_enabled_;
}
inline bool Backup_Settings::user_personalized_ads_enabled() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Settings.user_personalized_ads_enabled)
  return _internal_user_personalized_ads_enabled();
}
inline void Backup_Settings::_internal_set_user_personalized_ads_enabled(bool value) {
  _has_bits_[0] |= 0x01000000u;
  user_personalized_ads_enabled_ = value;
}
inline void Backup_Settings::set_user_personalized_ads_enabled(bool value) {
  _internal_set_user_personalized_ads_enabled(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Settings.user_personalized_ads_enabled)
}

// optional bool low_performance = 10;
inline bool Backup_Settings::_internal_has_low_performance() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool Backup_Settings::has_low_performance() const {
  return _internal_has_low_performance();
}
inline void Backup_Settings::clear_low_performance() {
  low_performance_ = false;
  _has_bits_[0] &= ~0x00040000u;
}
inline bool Backup_Settings::_internal_low_performance() const {
  return low_performance_;
}
inline bool Backup_Settings::low_performance() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Settings.low_performance)
  return _internal_low_performance();
}
inline void Backup_Settings::_internal_set_low_performance(bool value) {
  _has_bits_[0] |= 0x00040000u;
  low_performance_ = value;
}
inline void Backup_Settings::set_low_performance(bool value) {
  _internal_set_low_performance(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Settings.low_performance)
}

// optional bool auto_stop_fueling = 25;
inline bool Backup_Settings::_internal_has_auto_stop_fueling() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool Backup_Settings::has_auto_stop_fueling() const {
  return _internal_has_auto_stop_fueling();
}
inline void Backup_Settings::clear_auto_stop_fueling() {
  auto_stop_fueling_ = false;
  _has_bits_[0] &= ~0x00080000u;
}
inline bool Backup_Settings::_internal_auto_stop_fueling() const {
  return auto_stop_fueling_;
}
inline bool Backup_Settings::auto_stop_fueling() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Settings.auto_stop_fueling)
  return _internal_auto_stop_fueling();
}
inline void Backup_Settings::_internal_set_auto_stop_fueling(bool value) {
  _has_bits_[0] |= 0x00080000u;
  auto_stop_fueling_ = value;
}
inline void Backup_Settings::set_auto_stop_fueling(bool value) {
  _internal_set_auto_stop_fueling(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Settings.auto_stop_fueling)
}

// optional double last_backup_time = 24;
inline bool Backup_Settings::_internal_has_last_backup_time() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool Backup_Settings::has_last_backup_time() const {
  return _internal_has_last_backup_time();
}
inline void Backup_Settings::clear_last_backup_time() {
  last_backup_time_ = 0;
  _has_bits_[0] &= ~0x00100000u;
}
inline double Backup_Settings::_internal_last_backup_time() const {
  return last_backup_time_;
}
inline double Backup_Settings::last_backup_time() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Settings.last_backup_time)
  return _internal_last_backup_time();
}
inline void Backup_Settings::_internal_set_last_backup_time(double value) {
  _has_bits_[0] |= 0x00100000u;
  last_backup_time_ = value;
}
inline void Backup_Settings::set_last_backup_time(double value) {
  _internal_set_last_backup_time(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Settings.last_backup_time)
}

// -------------------------------------------------------------------

// Backup_Tutorial

// optional bool intro_shown = 1;
inline bool Backup_Tutorial::_internal_has_intro_shown() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Backup_Tutorial::has_intro_shown() const {
  return _internal_has_intro_shown();
}
inline void Backup_Tutorial::clear_intro_shown() {
  intro_shown_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool Backup_Tutorial::_internal_intro_shown() const {
  return intro_shown_;
}
inline bool Backup_Tutorial::intro_shown() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Tutorial.intro_shown)
  return _internal_intro_shown();
}
inline void Backup_Tutorial::_internal_set_intro_shown(bool value) {
  _has_bits_[0] |= 0x00000001u;
  intro_shown_ = value;
}
inline void Backup_Tutorial::set_intro_shown(bool value) {
  _internal_set_intro_shown(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Tutorial.intro_shown)
}

// optional bool click_tutorial_shown = 2;
inline bool Backup_Tutorial::_internal_has_click_tutorial_shown() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Backup_Tutorial::has_click_tutorial_shown() const {
  return _internal_has_click_tutorial_shown();
}
inline void Backup_Tutorial::clear_click_tutorial_shown() {
  click_tutorial_shown_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool Backup_Tutorial::_internal_click_tutorial_shown() const {
  return click_tutorial_shown_;
}
inline bool Backup_Tutorial::click_tutorial_shown() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Tutorial.click_tutorial_shown)
  return _internal_click_tutorial_shown();
}
inline void Backup_Tutorial::_internal_set_click_tutorial_shown(bool value) {
  _has_bits_[0] |= 0x00000002u;
  click_tutorial_shown_ = value;
}
inline void Backup_Tutorial::set_click_tutorial_shown(bool value) {
  _internal_set_click_tutorial_shown(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Tutorial.click_tutorial_shown)
}

// optional bool buy_hab_shown = 3;
inline bool Backup_Tutorial::_internal_has_buy_hab_shown() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Backup_Tutorial::has_buy_hab_shown() const {
  return _internal_has_buy_hab_shown();
}
inline void Backup_Tutorial::clear_buy_hab_shown() {
  buy_hab_shown_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Backup_Tutorial::_internal_buy_hab_shown() const {
  return buy_hab_shown_;
}
inline bool Backup_Tutorial::buy_hab_shown() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Tutorial.buy_hab_shown)
  return _internal_buy_hab_shown();
}
inline void Backup_Tutorial::_internal_set_buy_hab_shown(bool value) {
  _has_bits_[0] |= 0x00000004u;
  buy_hab_shown_ = value;
}
inline void Backup_Tutorial::set_buy_hab_shown(bool value) {
  _internal_set_buy_hab_shown(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Tutorial.buy_hab_shown)
}

// optional bool hire_vehicle_shown = 4;
inline bool Backup_Tutorial::_internal_has_hire_vehicle_shown() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Backup_Tutorial::has_hire_vehicle_shown() const {
  return _internal_has_hire_vehicle_shown();
}
inline void Backup_Tutorial::clear_hire_vehicle_shown() {
  hire_vehicle_shown_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool Backup_Tutorial::_internal_hire_vehicle_shown() const {
  return hire_vehicle_shown_;
}
inline bool Backup_Tutorial::hire_vehicle_shown() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Tutorial.hire_vehicle_shown)
  return _internal_hire_vehicle_shown();
}
inline void Backup_Tutorial::_internal_set_hire_vehicle_shown(bool value) {
  _has_bits_[0] |= 0x00000008u;
  hire_vehicle_shown_ = value;
}
inline void Backup_Tutorial::set_hire_vehicle_shown(bool value) {
  _internal_set_hire_vehicle_shown(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Tutorial.hire_vehicle_shown)
}

// optional bool q_num_shown = 5;
inline bool Backup_Tutorial::_internal_has_q_num_shown() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Backup_Tutorial::has_q_num_shown() const {
  return _internal_has_q_num_shown();
}
inline void Backup_Tutorial::clear_q_num_shown() {
  q_num_shown_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool Backup_Tutorial::_internal_q_num_shown() const {
  return q_num_shown_;
}
inline bool Backup_Tutorial::q_num_shown() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Tutorial.q_num_shown)
  return _internal_q_num_shown();
}
inline void Backup_Tutorial::_internal_set_q_num_shown(bool value) {
  _has_bits_[0] |= 0x00000010u;
  q_num_shown_ = value;
}
inline void Backup_Tutorial::set_q_num_shown(bool value) {
  _internal_set_q_num_shown(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Tutorial.q_num_shown)
}

// optional bool s_num_shown = 6;
inline bool Backup_Tutorial::_internal_has_s_num_shown() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Backup_Tutorial::has_s_num_shown() const {
  return _internal_has_s_num_shown();
}
inline void Backup_Tutorial::clear_s_num_shown() {
  s_num_shown_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool Backup_Tutorial::_internal_s_num_shown() const {
  return s_num_shown_;
}
inline bool Backup_Tutorial::s_num_shown() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Tutorial.s_num_shown)
  return _internal_s_num_shown();
}
inline void Backup_Tutorial::_internal_set_s_num_shown(bool value) {
  _has_bits_[0] |= 0x00000020u;
  s_num_shown_ = value;
}
inline void Backup_Tutorial::set_s_num_shown(bool value) {
  _internal_set_s_num_shown(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Tutorial.s_num_shown)
}

// optional bool contracts_tab_shown = 7;
inline bool Backup_Tutorial::_internal_has_contracts_tab_shown() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Backup_Tutorial::has_contracts_tab_shown() const {
  return _internal_has_contracts_tab_shown();
}
inline void Backup_Tutorial::clear_contracts_tab_shown() {
  contracts_tab_shown_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool Backup_Tutorial::_internal_contracts_tab_shown() const {
  return contracts_tab_shown_;
}
inline bool Backup_Tutorial::contracts_tab_shown() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Tutorial.contracts_tab_shown)
  return _internal_contracts_tab_shown();
}
inline void Backup_Tutorial::_internal_set_contracts_tab_shown(bool value) {
  _has_bits_[0] |= 0x00000040u;
  contracts_tab_shown_ = value;
}
inline void Backup_Tutorial::set_contracts_tab_shown(bool value) {
  _internal_set_contracts_tab_shown(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Tutorial.contracts_tab_shown)
}

// optional bool contract_info_shown = 8;
inline bool Backup_Tutorial::_internal_has_contract_info_shown() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Backup_Tutorial::has_contract_info_shown() const {
  return _internal_has_contract_info_shown();
}
inline void Backup_Tutorial::clear_contract_info_shown() {
  contract_info_shown_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool Backup_Tutorial::_internal_contract_info_shown() const {
  return contract_info_shown_;
}
inline bool Backup_Tutorial::contract_info_shown() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Tutorial.contract_info_shown)
  return _internal_contract_info_shown();
}
inline void Backup_Tutorial::_internal_set_contract_info_shown(bool value) {
  _has_bits_[0] |= 0x00000080u;
  contract_info_shown_ = value;
}
inline void Backup_Tutorial::set_contract_info_shown(bool value) {
  _internal_set_contract_info_shown(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Tutorial.contract_info_shown)
}

// optional bool join_coop_shown = 9;
inline bool Backup_Tutorial::_internal_has_join_coop_shown() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Backup_Tutorial::has_join_coop_shown() const {
  return _internal_has_join_coop_shown();
}
inline void Backup_Tutorial::clear_join_coop_shown() {
  join_coop_shown_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool Backup_Tutorial::_internal_join_coop_shown() const {
  return join_coop_shown_;
}
inline bool Backup_Tutorial::join_coop_shown() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Tutorial.join_coop_shown)
  return _internal_join_coop_shown();
}
inline void Backup_Tutorial::_internal_set_join_coop_shown(bool value) {
  _has_bits_[0] |= 0x00000100u;
  join_coop_shown_ = value;
}
inline void Backup_Tutorial::set_join_coop_shown(bool value) {
  _internal_set_join_coop_shown(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Tutorial.join_coop_shown)
}

// optional bool switch_farm_shown = 10;
inline bool Backup_Tutorial::_internal_has_switch_farm_shown() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Backup_Tutorial::has_switch_farm_shown() const {
  return _internal_has_switch_farm_shown();
}
inline void Backup_Tutorial::clear_switch_farm_shown() {
  switch_farm_shown_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool Backup_Tutorial::_internal_switch_farm_shown() const {
  return switch_farm_shown_;
}
inline bool Backup_Tutorial::switch_farm_shown() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Tutorial.switch_farm_shown)
  return _internal_switch_farm_shown();
}
inline void Backup_Tutorial::_internal_set_switch_farm_shown(bool value) {
  _has_bits_[0] |= 0x00000200u;
  switch_farm_shown_ = value;
}
inline void Backup_Tutorial::set_switch_farm_shown(bool value) {
  _internal_set_switch_farm_shown(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Tutorial.switch_farm_shown)
}

// repeated bool tutorial_shown = 11;
inline int Backup_Tutorial::_internal_tutorial_shown_size() const {
  return tutorial_shown_.size();
}
inline int Backup_Tutorial::tutorial_shown_size() const {
  return _internal_tutorial_shown_size();
}
inline void Backup_Tutorial::clear_tutorial_shown() {
  tutorial_shown_.Clear();
}
inline bool Backup_Tutorial::_internal_tutorial_shown(int index) const {
  return tutorial_shown_.Get(index);
}
inline bool Backup_Tutorial::tutorial_shown(int index) const {
  // @@protoc_insertion_point(field_get:ei.Backup.Tutorial.tutorial_shown)
  return _internal_tutorial_shown(index);
}
inline void Backup_Tutorial::set_tutorial_shown(int index, bool value) {
  tutorial_shown_.Set(index, value);
  // @@protoc_insertion_point(field_set:ei.Backup.Tutorial.tutorial_shown)
}
inline void Backup_Tutorial::_internal_add_tutorial_shown(bool value) {
  tutorial_shown_.Add(value);
}
inline void Backup_Tutorial::add_tutorial_shown(bool value) {
  _internal_add_tutorial_shown(value);
  // @@protoc_insertion_point(field_add:ei.Backup.Tutorial.tutorial_shown)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
Backup_Tutorial::_internal_tutorial_shown() const {
  return tutorial_shown_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
Backup_Tutorial::tutorial_shown() const {
  // @@protoc_insertion_point(field_list:ei.Backup.Tutorial.tutorial_shown)
  return _internal_tutorial_shown();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
Backup_Tutorial::_internal_mutable_tutorial_shown() {
  return &tutorial_shown_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
Backup_Tutorial::mutable_tutorial_shown() {
  // @@protoc_insertion_point(field_mutable_list:ei.Backup.Tutorial.tutorial_shown)
  return _internal_mutable_tutorial_shown();
}

// -------------------------------------------------------------------

// Backup_Stats

// repeated uint64 egg_totals_OLD = 1;
inline int Backup_Stats::_internal_egg_totals_old_size() const {
  return egg_totals_old_.size();
}
inline int Backup_Stats::egg_totals_old_size() const {
  return _internal_egg_totals_old_size();
}
inline void Backup_Stats::clear_egg_totals_old() {
  egg_totals_old_.Clear();
}
inline uint64_t Backup_Stats::_internal_egg_totals_old(int index) const {
  return egg_totals_old_.Get(index);
}
inline uint64_t Backup_Stats::egg_totals_old(int index) const {
  // @@protoc_insertion_point(field_get:ei.Backup.Stats.egg_totals_OLD)
  return _internal_egg_totals_old(index);
}
inline void Backup_Stats::set_egg_totals_old(int index, uint64_t value) {
  egg_totals_old_.Set(index, value);
  // @@protoc_insertion_point(field_set:ei.Backup.Stats.egg_totals_OLD)
}
inline void Backup_Stats::_internal_add_egg_totals_old(uint64_t value) {
  egg_totals_old_.Add(value);
}
inline void Backup_Stats::add_egg_totals_old(uint64_t value) {
  _internal_add_egg_totals_old(value);
  // @@protoc_insertion_point(field_add:ei.Backup.Stats.egg_totals_OLD)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Backup_Stats::_internal_egg_totals_old() const {
  return egg_totals_old_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Backup_Stats::egg_totals_old() const {
  // @@protoc_insertion_point(field_list:ei.Backup.Stats.egg_totals_OLD)
  return _internal_egg_totals_old();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Backup_Stats::_internal_mutable_egg_totals_old() {
  return &egg_totals_old_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Backup_Stats::mutable_egg_totals_old() {
  // @@protoc_insertion_point(field_mutable_list:ei.Backup.Stats.egg_totals_OLD)
  return _internal_mutable_egg_totals_old();
}

// repeated double egg_totals = 8;
inline int Backup_Stats::_internal_egg_totals_size() const {
  return egg_totals_.size();
}
inline int Backup_Stats::egg_totals_size() const {
  return _internal_egg_totals_size();
}
inline void Backup_Stats::clear_egg_totals() {
  egg_totals_.Clear();
}
inline double Backup_Stats::_internal_egg_totals(int index) const {
  return egg_totals_.Get(index);
}
inline double Backup_Stats::egg_totals(int index) const {
  // @@protoc_insertion_point(field_get:ei.Backup.Stats.egg_totals)
  return _internal_egg_totals(index);
}
inline void Backup_Stats::set_egg_totals(int index, double value) {
  egg_totals_.Set(index, value);
  // @@protoc_insertion_point(field_set:ei.Backup.Stats.egg_totals)
}
inline void Backup_Stats::_internal_add_egg_totals(double value) {
  egg_totals_.Add(value);
}
inline void Backup_Stats::add_egg_totals(double value) {
  _internal_add_egg_totals(value);
  // @@protoc_insertion_point(field_add:ei.Backup.Stats.egg_totals)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Backup_Stats::_internal_egg_totals() const {
  return egg_totals_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Backup_Stats::egg_totals() const {
  // @@protoc_insertion_point(field_list:ei.Backup.Stats.egg_totals)
  return _internal_egg_totals();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Backup_Stats::_internal_mutable_egg_totals() {
  return &egg_totals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Backup_Stats::mutable_egg_totals() {
  // @@protoc_insertion_point(field_mutable_list:ei.Backup.Stats.egg_totals)
  return _internal_mutable_egg_totals();
}

// optional uint64 unlimited_chickens_uses = 7;
inline bool Backup_Stats::_internal_has_unlimited_chickens_uses() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Backup_Stats::has_unlimited_chickens_uses() const {
  return _internal_has_unlimited_chickens_uses();
}
inline void Backup_Stats::clear_unlimited_chickens_uses() {
  unlimited_chickens_uses_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000020u;
}
inline uint64_t Backup_Stats::_internal_unlimited_chickens_uses() const {
  return unlimited_chickens_uses_;
}
inline uint64_t Backup_Stats::unlimited_chickens_uses() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Stats.unlimited_chickens_uses)
  return _internal_unlimited_chickens_uses();
}
inline void Backup_Stats::_internal_set_unlimited_chickens_uses(uint64_t value) {
  _has_bits_[0] |= 0x00000020u;
  unlimited_chickens_uses_ = value;
}
inline void Backup_Stats::set_unlimited_chickens_uses(uint64_t value) {
  _internal_set_unlimited_chickens_uses(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Stats.unlimited_chickens_uses)
}

// optional uint64 refill_uses = 2;
inline bool Backup_Stats::_internal_has_refill_uses() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Backup_Stats::has_refill_uses() const {
  return _internal_has_refill_uses();
}
inline void Backup_Stats::clear_refill_uses() {
  refill_uses_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t Backup_Stats::_internal_refill_uses() const {
  return refill_uses_;
}
inline uint64_t Backup_Stats::refill_uses() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Stats.refill_uses)
  return _internal_refill_uses();
}
inline void Backup_Stats::_internal_set_refill_uses(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  refill_uses_ = value;
}
inline void Backup_Stats::set_refill_uses(uint64_t value) {
  _internal_set_refill_uses(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Stats.refill_uses)
}

// optional uint64 warp_1_uses = 4;
inline bool Backup_Stats::_internal_has_warp_1_uses() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Backup_Stats::has_warp_1_uses() const {
  return _internal_has_warp_1_uses();
}
inline void Backup_Stats::clear_warp_1_uses() {
  warp_1_uses_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t Backup_Stats::_internal_warp_1_uses() const {
  return warp_1_uses_;
}
inline uint64_t Backup_Stats::warp_1_uses() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Stats.warp_1_uses)
  return _internal_warp_1_uses();
}
inline void Backup_Stats::_internal_set_warp_1_uses(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  warp_1_uses_ = value;
}
inline void Backup_Stats::set_warp_1_uses(uint64_t value) {
  _internal_set_warp_1_uses(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Stats.warp_1_uses)
}

// optional uint64 warp_8_uses = 5;
inline bool Backup_Stats::_internal_has_warp_8_uses() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Backup_Stats::has_warp_8_uses() const {
  return _internal_has_warp_8_uses();
}
inline void Backup_Stats::clear_warp_8_uses() {
  warp_8_uses_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t Backup_Stats::_internal_warp_8_uses() const {
  return warp_8_uses_;
}
inline uint64_t Backup_Stats::warp_8_uses() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Stats.warp_8_uses)
  return _internal_warp_8_uses();
}
inline void Backup_Stats::_internal_set_warp_8_uses(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  warp_8_uses_ = value;
}
inline void Backup_Stats::set_warp_8_uses(uint64_t value) {
  _internal_set_warp_8_uses(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Stats.warp_8_uses)
}

// optional uint64 boosts_used = 13;
inline bool Backup_Stats::_internal_has_boosts_used() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Backup_Stats::has_boosts_used() const {
  return _internal_has_boosts_used();
}
inline void Backup_Stats::clear_boosts_used() {
  boosts_used_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000400u;
}
inline uint64_t Backup_Stats::_internal_boosts_used() const {
  return boosts_used_;
}
inline uint64_t Backup_Stats::boosts_used() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Stats.boosts_used)
  return _internal_boosts_used();
}
inline void Backup_Stats::_internal_set_boosts_used(uint64_t value) {
  _has_bits_[0] |= 0x00000400u;
  boosts_used_ = value;
}
inline void Backup_Stats::set_boosts_used(uint64_t value) {
  _internal_set_boosts_used(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Stats.boosts_used)
}

// optional uint64 video_doubler_uses = 3;
inline bool Backup_Stats::_internal_has_video_doubler_uses() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Backup_Stats::has_video_doubler_uses() const {
  return _internal_has_video_doubler_uses();
}
inline void Backup_Stats::clear_video_doubler_uses() {
  video_doubler_uses_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t Backup_Stats::_internal_video_doubler_uses() const {
  return video_doubler_uses_;
}
inline uint64_t Backup_Stats::video_doubler_uses() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Stats.video_doubler_uses)
  return _internal_video_doubler_uses();
}
inline void Backup_Stats::_internal_set_video_doubler_uses(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  video_doubler_uses_ = value;
}
inline void Backup_Stats::set_video_doubler_uses(uint64_t value) {
  _internal_set_video_doubler_uses(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Stats.video_doubler_uses)
}

// optional uint64 drone_takedowns = 6;
inline bool Backup_Stats::_internal_has_drone_takedowns() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Backup_Stats::has_drone_takedowns() const {
  return _internal_has_drone_takedowns();
}
inline void Backup_Stats::clear_drone_takedowns() {
  drone_takedowns_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000010u;
}
inline uint64_t Backup_Stats::_internal_drone_takedowns() const {
  return drone_takedowns_;
}
inline uint64_t Backup_Stats::drone_takedowns() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Stats.drone_takedowns)
  return _internal_drone_takedowns();
}
inline void Backup_Stats::_internal_set_drone_takedowns(uint64_t value) {
  _has_bits_[0] |= 0x00000010u;
  drone_takedowns_ = value;
}
inline void Backup_Stats::set_drone_takedowns(uint64_t value) {
  _internal_set_drone_takedowns(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Stats.drone_takedowns)
}

// optional uint64 drone_takedowns_elite = 10;
inline bool Backup_Stats::_internal_has_drone_takedowns_elite() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Backup_Stats::has_drone_takedowns_elite() const {
  return _internal_has_drone_takedowns_elite();
}
inline void Backup_Stats::clear_drone_takedowns_elite() {
  drone_takedowns_elite_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000080u;
}
inline uint64_t Backup_Stats::_internal_drone_takedowns_elite() const {
  return drone_takedowns_elite_;
}
inline uint64_t Backup_Stats::drone_takedowns_elite() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Stats.drone_takedowns_elite)
  return _internal_drone_takedowns_elite();
}
inline void Backup_Stats::_internal_set_drone_takedowns_elite(uint64_t value) {
  _has_bits_[0] |= 0x00000080u;
  drone_takedowns_elite_ = value;
}
inline void Backup_Stats::set_drone_takedowns_elite(uint64_t value) {
  _internal_set_drone_takedowns_elite(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Stats.drone_takedowns_elite)
}

// optional uint64 num_prestiges = 9;
inline bool Backup_Stats::_internal_has_num_prestiges() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Backup_Stats::has_num_prestiges() const {
  return _internal_has_num_prestiges();
}
inline void Backup_Stats::clear_num_prestiges() {
  num_prestiges_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000040u;
}
inline uint64_t Backup_Stats::_internal_num_prestiges() const {
  return num_prestiges_;
}
inline uint64_t Backup_Stats::num_prestiges() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Stats.num_prestiges)
  return _internal_num_prestiges();
}
inline void Backup_Stats::_internal_set_num_prestiges(uint64_t value) {
  _has_bits_[0] |= 0x00000040u;
  num_prestiges_ = value;
}
inline void Backup_Stats::set_num_prestiges(uint64_t value) {
  _internal_set_num_prestiges(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Stats.num_prestiges)
}

// optional uint64 num_piggy_breaks = 11;
inline bool Backup_Stats::_internal_has_num_piggy_breaks() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Backup_Stats::has_num_piggy_breaks() const {
  return _internal_has_num_piggy_breaks();
}
inline void Backup_Stats::clear_num_piggy_breaks() {
  num_piggy_breaks_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000100u;
}
inline uint64_t Backup_Stats::_internal_num_piggy_breaks() const {
  return num_piggy_breaks_;
}
inline uint64_t Backup_Stats::num_piggy_breaks() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Stats.num_piggy_breaks)
  return _internal_num_piggy_breaks();
}
inline void Backup_Stats::_internal_set_num_piggy_breaks(uint64_t value) {
  _has_bits_[0] |= 0x00000100u;
  num_piggy_breaks_ = value;
}
inline void Backup_Stats::set_num_piggy_breaks(uint64_t value) {
  _internal_set_num_piggy_breaks(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Stats.num_piggy_breaks)
}

// optional uint64 iap_packs_purchased = 12;
inline bool Backup_Stats::_internal_has_iap_packs_purchased() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Backup_Stats::has_iap_packs_purchased() const {
  return _internal_has_iap_packs_purchased();
}
inline void Backup_Stats::clear_iap_packs_purchased() {
  iap_packs_purchased_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000200u;
}
inline uint64_t Backup_Stats::_internal_iap_packs_purchased() const {
  return iap_packs_purchased_;
}
inline uint64_t Backup_Stats::iap_packs_purchased() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Stats.iap_packs_purchased)
  return _internal_iap_packs_purchased();
}
inline void Backup_Stats::_internal_set_iap_packs_purchased(uint64_t value) {
  _has_bits_[0] |= 0x00000200u;
  iap_packs_purchased_ = value;
}
inline void Backup_Stats::set_iap_packs_purchased(uint64_t value) {
  _internal_set_iap_packs_purchased(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Stats.iap_packs_purchased)
}

// optional bool piggy_full = 14;
inline bool Backup_Stats::_internal_has_piggy_full() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Backup_Stats::has_piggy_full() const {
  return _internal_has_piggy_full();
}
inline void Backup_Stats::clear_piggy_full() {
  piggy_full_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool Backup_Stats::_internal_piggy_full() const {
  return piggy_full_;
}
inline bool Backup_Stats::piggy_full() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Stats.piggy_full)
  return _internal_piggy_full();
}
inline void Backup_Stats::_internal_set_piggy_full(bool value) {
  _has_bits_[0] |= 0x00004000u;
  piggy_full_ = value;
}
inline void Backup_Stats::set_piggy_full(bool value) {
  _internal_set_piggy_full(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Stats.piggy_full)
}

// optional bool piggy_found_full = 15;
inline bool Backup_Stats::_internal_has_piggy_found_full() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool Backup_Stats::has_piggy_found_full() const {
  return _internal_has_piggy_found_full();
}
inline void Backup_Stats::clear_piggy_found_full() {
  piggy_found_full_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool Backup_Stats::_internal_piggy_found_full() const {
  return piggy_found_full_;
}
inline bool Backup_Stats::piggy_found_full() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Stats.piggy_found_full)
  return _internal_piggy_found_full();
}
inline void Backup_Stats::_internal_set_piggy_found_full(bool value) {
  _has_bits_[0] |= 0x00008000u;
  piggy_found_full_ = value;
}
inline void Backup_Stats::set_piggy_found_full(bool value) {
  _internal_set_piggy_found_full(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Stats.piggy_found_full)
}

// optional double time_piggy_filled_realtime = 16;
inline bool Backup_Stats::_internal_has_time_piggy_filled_realtime() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool Backup_Stats::has_time_piggy_filled_realtime() const {
  return _internal_has_time_piggy_filled_realtime();
}
inline void Backup_Stats::clear_time_piggy_filled_realtime() {
  time_piggy_filled_realtime_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline double Backup_Stats::_internal_time_piggy_filled_realtime() const {
  return time_piggy_filled_realtime_;
}
inline double Backup_Stats::time_piggy_filled_realtime() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Stats.time_piggy_filled_realtime)
  return _internal_time_piggy_filled_realtime();
}
inline void Backup_Stats::_internal_set_time_piggy_filled_realtime(double value) {
  _has_bits_[0] |= 0x00000800u;
  time_piggy_filled_realtime_ = value;
}
inline void Backup_Stats::set_time_piggy_filled_realtime(double value) {
  _internal_set_time_piggy_filled_realtime(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Stats.time_piggy_filled_realtime)
}

// optional double time_piggy_full_gametime = 17;
inline bool Backup_Stats::_internal_has_time_piggy_full_gametime() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Backup_Stats::has_time_piggy_full_gametime() const {
  return _internal_has_time_piggy_full_gametime();
}
inline void Backup_Stats::clear_time_piggy_full_gametime() {
  time_piggy_full_gametime_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline double Backup_Stats::_internal_time_piggy_full_gametime() const {
  return time_piggy_full_gametime_;
}
inline double Backup_Stats::time_piggy_full_gametime() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Stats.time_piggy_full_gametime)
  return _internal_time_piggy_full_gametime();
}
inline void Backup_Stats::_internal_set_time_piggy_full_gametime(double value) {
  _has_bits_[0] |= 0x00001000u;
  time_piggy_full_gametime_ = value;
}
inline void Backup_Stats::set_time_piggy_full_gametime(double value) {
  _internal_set_time_piggy_full_gametime(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Stats.time_piggy_full_gametime)
}

// optional uint64 lost_piggy_increments = 18;
inline bool Backup_Stats::_internal_has_lost_piggy_increments() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Backup_Stats::has_lost_piggy_increments() const {
  return _internal_has_lost_piggy_increments();
}
inline void Backup_Stats::clear_lost_piggy_increments() {
  lost_piggy_increments_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00002000u;
}
inline uint64_t Backup_Stats::_internal_lost_piggy_increments() const {
  return lost_piggy_increments_;
}
inline uint64_t Backup_Stats::lost_piggy_increments() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Stats.lost_piggy_increments)
  return _internal_lost_piggy_increments();
}
inline void Backup_Stats::_internal_set_lost_piggy_increments(uint64_t value) {
  _has_bits_[0] |= 0x00002000u;
  lost_piggy_increments_ = value;
}
inline void Backup_Stats::set_lost_piggy_increments(uint64_t value) {
  _internal_set_lost_piggy_increments(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Stats.lost_piggy_increments)
}

// -------------------------------------------------------------------

// Backup_Game

// optional uint32 current_farm = 22 [default = 0];
inline bool Backup_Game::_internal_has_current_farm() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool Backup_Game::has_current_farm() const {
  return _internal_has_current_farm();
}
inline void Backup_Game::clear_current_farm() {
  current_farm_ = 0u;
  _has_bits_[0] &= ~0x00010000u;
}
inline uint32_t Backup_Game::_internal_current_farm() const {
  return current_farm_;
}
inline uint32_t Backup_Game::current_farm() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.current_farm)
  return _internal_current_farm();
}
inline void Backup_Game::_internal_set_current_farm(uint32_t value) {
  _has_bits_[0] |= 0x00010000u;
  current_farm_ = value;
}
inline void Backup_Game::set_current_farm(uint32_t value) {
  _internal_set_current_farm(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.current_farm)
}

// optional .ei.Egg max_egg_reached = 1;
inline bool Backup_Game::_internal_has_max_egg_reached() const {
  bool value = (_has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool Backup_Game::has_max_egg_reached() const {
  return _internal_has_max_egg_reached();
}
inline void Backup_Game::clear_max_egg_reached() {
  max_egg_reached_ = 1;
  _has_bits_[1] &= ~0x00000001u;
}
inline ::ei::Egg Backup_Game::_internal_max_egg_reached() const {
  return static_cast< ::ei::Egg >(max_egg_reached_);
}
inline ::ei::Egg Backup_Game::max_egg_reached() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.max_egg_reached)
  return _internal_max_egg_reached();
}
inline void Backup_Game::_internal_set_max_egg_reached(::ei::Egg value) {
  assert(::ei::Egg_IsValid(value));
  _has_bits_[1] |= 0x00000001u;
  max_egg_reached_ = value;
}
inline void Backup_Game::set_max_egg_reached(::ei::Egg value) {
  _internal_set_max_egg_reached(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.max_egg_reached)
}

// optional uint64 golden_eggs_earned = 2;
inline bool Backup_Game::_internal_has_golden_eggs_earned() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Backup_Game::has_golden_eggs_earned() const {
  return _internal_has_golden_eggs_earned();
}
inline void Backup_Game::clear_golden_eggs_earned() {
  golden_eggs_earned_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t Backup_Game::_internal_golden_eggs_earned() const {
  return golden_eggs_earned_;
}
inline uint64_t Backup_Game::golden_eggs_earned() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.golden_eggs_earned)
  return _internal_golden_eggs_earned();
}
inline void Backup_Game::_internal_set_golden_eggs_earned(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  golden_eggs_earned_ = value;
}
inline void Backup_Game::set_golden_eggs_earned(uint64_t value) {
  _internal_set_golden_eggs_earned(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.golden_eggs_earned)
}

// optional uint64 golden_eggs_spent = 3;
inline bool Backup_Game::_internal_has_golden_eggs_spent() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Backup_Game::has_golden_eggs_spent() const {
  return _internal_has_golden_eggs_spent();
}
inline void Backup_Game::clear_golden_eggs_spent() {
  golden_eggs_spent_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t Backup_Game::_internal_golden_eggs_spent() const {
  return golden_eggs_spent_;
}
inline uint64_t Backup_Game::golden_eggs_spent() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.golden_eggs_spent)
  return _internal_golden_eggs_spent();
}
inline void Backup_Game::_internal_set_golden_eggs_spent(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  golden_eggs_spent_ = value;
}
inline void Backup_Game::set_golden_eggs_spent(uint64_t value) {
  _internal_set_golden_eggs_spent(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.golden_eggs_spent)
}

// optional uint64 uncliamed_golden_eggs = 16;
inline bool Backup_Game::_internal_has_uncliamed_golden_eggs() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Backup_Game::has_uncliamed_golden_eggs() const {
  return _internal_has_uncliamed_golden_eggs();
}
inline void Backup_Game::clear_uncliamed_golden_eggs() {
  uncliamed_golden_eggs_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00001000u;
}
inline uint64_t Backup_Game::_internal_uncliamed_golden_eggs() const {
  return uncliamed_golden_eggs_;
}
inline uint64_t Backup_Game::uncliamed_golden_eggs() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.uncliamed_golden_eggs)
  return _internal_uncliamed_golden_eggs();
}
inline void Backup_Game::_internal_set_uncliamed_golden_eggs(uint64_t value) {
  _has_bits_[0] |= 0x00001000u;
  uncliamed_golden_eggs_ = value;
}
inline void Backup_Game::set_uncliamed_golden_eggs(uint64_t value) {
  _internal_set_uncliamed_golden_eggs(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.uncliamed_golden_eggs)
}

// optional uint64 soul_eggs = 4;
inline bool Backup_Game::_internal_has_soul_eggs() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Backup_Game::has_soul_eggs() const {
  return _internal_has_soul_eggs();
}
inline void Backup_Game::clear_soul_eggs() {
  soul_eggs_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t Backup_Game::_internal_soul_eggs() const {
  return soul_eggs_;
}
inline uint64_t Backup_Game::soul_eggs() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.soul_eggs)
  return _internal_soul_eggs();
}
inline void Backup_Game::_internal_set_soul_eggs(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  soul_eggs_ = value;
}
inline void Backup_Game::set_soul_eggs(uint64_t value) {
  _internal_set_soul_eggs(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.soul_eggs)
}

// optional uint64 unclaimed_soul_eggs = 17;
inline bool Backup_Game::_internal_has_unclaimed_soul_eggs() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Backup_Game::has_unclaimed_soul_eggs() const {
  return _internal_has_unclaimed_soul_eggs();
}
inline void Backup_Game::clear_unclaimed_soul_eggs() {
  unclaimed_soul_eggs_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00002000u;
}
inline uint64_t Backup_Game::_internal_unclaimed_soul_eggs() const {
  return unclaimed_soul_eggs_;
}
inline uint64_t Backup_Game::unclaimed_soul_eggs() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.unclaimed_soul_eggs)
  return _internal_unclaimed_soul_eggs();
}
inline void Backup_Game::_internal_set_unclaimed_soul_eggs(uint64_t value) {
  _has_bits_[0] |= 0x00002000u;
  unclaimed_soul_eggs_ = value;
}
inline void Backup_Game::set_unclaimed_soul_eggs(uint64_t value) {
  _internal_set_unclaimed_soul_eggs(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.unclaimed_soul_eggs)
}

// optional double soul_eggs_d = 34;
inline bool Backup_Game::_internal_has_soul_eggs_d() const {
  bool value = (_has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool Backup_Game::has_soul_eggs_d() const {
  return _internal_has_soul_eggs_d();
}
inline void Backup_Game::clear_soul_eggs_d() {
  soul_eggs_d_ = 0;
  _has_bits_[0] &= ~0x04000000u;
}
inline double Backup_Game::_internal_soul_eggs_d() const {
  return soul_eggs_d_;
}
inline double Backup_Game::soul_eggs_d() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.soul_eggs_d)
  return _internal_soul_eggs_d();
}
inline void Backup_Game::_internal_set_soul_eggs_d(double value) {
  _has_bits_[0] |= 0x04000000u;
  soul_eggs_d_ = value;
}
inline void Backup_Game::set_soul_eggs_d(double value) {
  _internal_set_soul_eggs_d(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.soul_eggs_d)
}

// optional double unclaimed_soul_eggs_d = 35;
inline bool Backup_Game::_internal_has_unclaimed_soul_eggs_d() const {
  bool value = (_has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool Backup_Game::has_unclaimed_soul_eggs_d() const {
  return _internal_has_unclaimed_soul_eggs_d();
}
inline void Backup_Game::clear_unclaimed_soul_eggs_d() {
  unclaimed_soul_eggs_d_ = 0;
  _has_bits_[0] &= ~0x08000000u;
}
inline double Backup_Game::_internal_unclaimed_soul_eggs_d() const {
  return unclaimed_soul_eggs_d_;
}
inline double Backup_Game::unclaimed_soul_eggs_d() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.unclaimed_soul_eggs_d)
  return _internal_unclaimed_soul_eggs_d();
}
inline void Backup_Game::_internal_set_unclaimed_soul_eggs_d(double value) {
  _has_bits_[0] |= 0x08000000u;
  unclaimed_soul_eggs_d_ = value;
}
inline void Backup_Game::set_unclaimed_soul_eggs_d(double value) {
  _internal_set_unclaimed_soul_eggs_d(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.unclaimed_soul_eggs_d)
}

// optional uint64 eggs_of_prophecy = 23;
inline bool Backup_Game::_internal_has_eggs_of_prophecy() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Backup_Game::has_eggs_of_prophecy() const {
  return _internal_has_eggs_of_prophecy();
}
inline void Backup_Game::clear_eggs_of_prophecy() {
  eggs_of_prophecy_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00004000u;
}
inline uint64_t Backup_Game::_internal_eggs_of_prophecy() const {
  return eggs_of_prophecy_;
}
inline uint64_t Backup_Game::eggs_of_prophecy() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.eggs_of_prophecy)
  return _internal_eggs_of_prophecy();
}
inline void Backup_Game::_internal_set_eggs_of_prophecy(uint64_t value) {
  _has_bits_[0] |= 0x00004000u;
  eggs_of_prophecy_ = value;
}
inline void Backup_Game::set_eggs_of_prophecy(uint64_t value) {
  _internal_set_eggs_of_prophecy(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.eggs_of_prophecy)
}

// optional uint64 unclaimed_eggs_of_prophecy = 24;
inline bool Backup_Game::_internal_has_unclaimed_eggs_of_prophecy() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool Backup_Game::has_unclaimed_eggs_of_prophecy() const {
  return _internal_has_unclaimed_eggs_of_prophecy();
}
inline void Backup_Game::clear_unclaimed_eggs_of_prophecy() {
  unclaimed_eggs_of_prophecy_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00008000u;
}
inline uint64_t Backup_Game::_internal_unclaimed_eggs_of_prophecy() const {
  return unclaimed_eggs_of_prophecy_;
}
inline uint64_t Backup_Game::unclaimed_eggs_of_prophecy() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.unclaimed_eggs_of_prophecy)
  return _internal_unclaimed_eggs_of_prophecy();
}
inline void Backup_Game::_internal_set_unclaimed_eggs_of_prophecy(uint64_t value) {
  _has_bits_[0] |= 0x00008000u;
  unclaimed_eggs_of_prophecy_ = value;
}
inline void Backup_Game::set_unclaimed_eggs_of_prophecy(uint64_t value) {
  _internal_set_unclaimed_eggs_of_prophecy(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.unclaimed_eggs_of_prophecy)
}

// optional uint64 shell_scripts_earned = 38;
inline bool Backup_Game::_internal_has_shell_scripts_earned() const {
  bool value = (_has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool Backup_Game::has_shell_scripts_earned() const {
  return _internal_has_shell_scripts_earned();
}
inline void Backup_Game::clear_shell_scripts_earned() {
  shell_scripts_earned_ = uint64_t{0u};
  _has_bits_[0] &= ~0x20000000u;
}
inline uint64_t Backup_Game::_internal_shell_scripts_earned() const {
  return shell_scripts_earned_;
}
inline uint64_t Backup_Game::shell_scripts_earned() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.shell_scripts_earned)
  return _internal_shell_scripts_earned();
}
inline void Backup_Game::_internal_set_shell_scripts_earned(uint64_t value) {
  _has_bits_[0] |= 0x20000000u;
  shell_scripts_earned_ = value;
}
inline void Backup_Game::set_shell_scripts_earned(uint64_t value) {
  _internal_set_shell_scripts_earned(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.shell_scripts_earned)
}

// optional uint64 shell_scripts_spent = 39;
inline bool Backup_Game::_internal_has_shell_scripts_spent() const {
  bool value = (_has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool Backup_Game::has_shell_scripts_spent() const {
  return _internal_has_shell_scripts_spent();
}
inline void Backup_Game::clear_shell_scripts_spent() {
  shell_scripts_spent_ = uint64_t{0u};
  _has_bits_[0] &= ~0x40000000u;
}
inline uint64_t Backup_Game::_internal_shell_scripts_spent() const {
  return shell_scripts_spent_;
}
inline uint64_t Backup_Game::shell_scripts_spent() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.shell_scripts_spent)
  return _internal_shell_scripts_spent();
}
inline void Backup_Game::_internal_set_shell_scripts_spent(uint64_t value) {
  _has_bits_[0] |= 0x40000000u;
  shell_scripts_spent_ = value;
}
inline void Backup_Game::set_shell_scripts_spent(uint64_t value) {
  _internal_set_shell_scripts_spent(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.shell_scripts_spent)
}

// optional uint64 unclaimed_shell_scripts = 40;
inline bool Backup_Game::_internal_has_unclaimed_shell_scripts() const {
  bool value = (_has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool Backup_Game::has_unclaimed_shell_scripts() const {
  return _internal_has_unclaimed_shell_scripts();
}
inline void Backup_Game::clear_unclaimed_shell_scripts() {
  unclaimed_shell_scripts_ = uint64_t{0u};
  _has_bits_[0] &= ~0x80000000u;
}
inline uint64_t Backup_Game::_internal_unclaimed_shell_scripts() const {
  return unclaimed_shell_scripts_;
}
inline uint64_t Backup_Game::unclaimed_shell_scripts() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.unclaimed_shell_scripts)
  return _internal_unclaimed_shell_scripts();
}
inline void Backup_Game::_internal_set_unclaimed_shell_scripts(uint64_t value) {
  _has_bits_[0] |= 0x80000000u;
  unclaimed_shell_scripts_ = value;
}
inline void Backup_Game::set_unclaimed_shell_scripts(uint64_t value) {
  _internal_set_unclaimed_shell_scripts(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.unclaimed_shell_scripts)
}

// optional double prestige_cash_earned = 5;
inline bool Backup_Game::_internal_has_prestige_cash_earned() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Backup_Game::has_prestige_cash_earned() const {
  return _internal_has_prestige_cash_earned();
}
inline void Backup_Game::clear_prestige_cash_earned() {
  prestige_cash_earned_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double Backup_Game::_internal_prestige_cash_earned() const {
  return prestige_cash_earned_;
}
inline double Backup_Game::prestige_cash_earned() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.prestige_cash_earned)
  return _internal_prestige_cash_earned();
}
inline void Backup_Game::_internal_set_prestige_cash_earned(double value) {
  _has_bits_[0] |= 0x00000008u;
  prestige_cash_earned_ = value;
}
inline void Backup_Game::set_prestige_cash_earned(double value) {
  _internal_set_prestige_cash_earned(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.prestige_cash_earned)
}

// optional double prestige_soul_boost_cash = 33;
inline bool Backup_Game::_internal_has_prestige_soul_boost_cash() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool Backup_Game::has_prestige_soul_boost_cash() const {
  return _internal_has_prestige_soul_boost_cash();
}
inline void Backup_Game::clear_prestige_soul_boost_cash() {
  prestige_soul_boost_cash_ = 0;
  _has_bits_[0] &= ~0x02000000u;
}
inline double Backup_Game::_internal_prestige_soul_boost_cash() const {
  return prestige_soul_boost_cash_;
}
inline double Backup_Game::prestige_soul_boost_cash() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.prestige_soul_boost_cash)
  return _internal_prestige_soul_boost_cash();
}
inline void Backup_Game::_internal_set_prestige_soul_boost_cash(double value) {
  _has_bits_[0] |= 0x02000000u;
  prestige_soul_boost_cash_ = value;
}
inline void Backup_Game::set_prestige_soul_boost_cash(double value) {
  _internal_set_prestige_soul_boost_cash(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.prestige_soul_boost_cash)
}

// optional double lifetime_cash_earned = 6;
inline bool Backup_Game::_internal_has_lifetime_cash_earned() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Backup_Game::has_lifetime_cash_earned() const {
  return _internal_has_lifetime_cash_earned();
}
inline void Backup_Game::clear_lifetime_cash_earned() {
  lifetime_cash_earned_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double Backup_Game::_internal_lifetime_cash_earned() const {
  return lifetime_cash_earned_;
}
inline double Backup_Game::lifetime_cash_earned() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.lifetime_cash_earned)
  return _internal_lifetime_cash_earned();
}
inline void Backup_Game::_internal_set_lifetime_cash_earned(double value) {
  _has_bits_[0] |= 0x00000010u;
  lifetime_cash_earned_ = value;
}
inline void Backup_Game::set_lifetime_cash_earned(double value) {
  _internal_set_lifetime_cash_earned(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.lifetime_cash_earned)
}

// optional uint64 piggy_bank = 7;
inline bool Backup_Game::_internal_has_piggy_bank() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Backup_Game::has_piggy_bank() const {
  return _internal_has_piggy_bank();
}
inline void Backup_Game::clear_piggy_bank() {
  piggy_bank_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000020u;
}
inline uint64_t Backup_Game::_internal_piggy_bank() const {
  return piggy_bank_;
}
inline uint64_t Backup_Game::piggy_bank() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.piggy_bank)
  return _internal_piggy_bank();
}
inline void Backup_Game::_internal_set_piggy_bank(uint64_t value) {
  _has_bits_[0] |= 0x00000020u;
  piggy_bank_ = value;
}
inline void Backup_Game::set_piggy_bank(uint64_t value) {
  _internal_set_piggy_bank(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.piggy_bank)
}

// optional bool piggy_full_alert_shown = 31;
inline bool Backup_Game::_internal_has_piggy_full_alert_shown() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool Backup_Game::has_piggy_full_alert_shown() const {
  return _internal_has_piggy_full_alert_shown();
}
inline void Backup_Game::clear_piggy_full_alert_shown() {
  piggy_full_alert_shown_ = false;
  _has_bits_[0] &= ~0x00100000u;
}
inline bool Backup_Game::_internal_piggy_full_alert_shown() const {
  return piggy_full_alert_shown_;
}
inline bool Backup_Game::piggy_full_alert_shown() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.piggy_full_alert_shown)
  return _internal_piggy_full_alert_shown();
}
inline void Backup_Game::_internal_set_piggy_full_alert_shown(bool value) {
  _has_bits_[0] |= 0x00100000u;
  piggy_full_alert_shown_ = value;
}
inline void Backup_Game::set_piggy_full_alert_shown(bool value) {
  _internal_set_piggy_full_alert_shown(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.piggy_full_alert_shown)
}

// optional uint32 permit_level = 8;
inline bool Backup_Game::_internal_has_permit_level() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Backup_Game::has_permit_level() const {
  return _internal_has_permit_level();
}
inline void Backup_Game::clear_permit_level() {
  permit_level_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline uint32_t Backup_Game::_internal_permit_level() const {
  return permit_level_;
}
inline uint32_t Backup_Game::permit_level() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.permit_level)
  return _internal_permit_level();
}
inline void Backup_Game::_internal_set_permit_level(uint32_t value) {
  _has_bits_[0] |= 0x00000400u;
  permit_level_ = value;
}
inline void Backup_Game::set_permit_level(uint32_t value) {
  _internal_set_permit_level(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.permit_level)
}

// repeated .ei.Backup.ResearchItem epic_research = 9;
inline int Backup_Game::_internal_epic_research_size() const {
  return epic_research_.size();
}
inline int Backup_Game::epic_research_size() const {
  return _internal_epic_research_size();
}
inline void Backup_Game::clear_epic_research() {
  epic_research_.Clear();
}
inline ::ei::Backup_ResearchItem* Backup_Game::mutable_epic_research(int index) {
  // @@protoc_insertion_point(field_mutable:ei.Backup.Game.epic_research)
  return epic_research_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_ResearchItem >*
Backup_Game::mutable_epic_research() {
  // @@protoc_insertion_point(field_mutable_list:ei.Backup.Game.epic_research)
  return &epic_research_;
}
inline const ::ei::Backup_ResearchItem& Backup_Game::_internal_epic_research(int index) const {
  return epic_research_.Get(index);
}
inline const ::ei::Backup_ResearchItem& Backup_Game::epic_research(int index) const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.epic_research)
  return _internal_epic_research(index);
}
inline ::ei::Backup_ResearchItem* Backup_Game::_internal_add_epic_research() {
  return epic_research_.Add();
}
inline ::ei::Backup_ResearchItem* Backup_Game::add_epic_research() {
  ::ei::Backup_ResearchItem* _add = _internal_add_epic_research();
  // @@protoc_insertion_point(field_add:ei.Backup.Game.epic_research)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_ResearchItem >&
Backup_Game::epic_research() const {
  // @@protoc_insertion_point(field_list:ei.Backup.Game.epic_research)
  return epic_research_;
}

// optional bool hyperloop_station = 29;
inline bool Backup_Game::_internal_has_hyperloop_station() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool Backup_Game::has_hyperloop_station() const {
  return _internal_has_hyperloop_station();
}
inline void Backup_Game::clear_hyperloop_station() {
  hyperloop_station_ = false;
  _has_bits_[0] &= ~0x00200000u;
}
inline bool Backup_Game::_internal_hyperloop_station() const {
  return hyperloop_station_;
}
inline bool Backup_Game::hyperloop_station() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.hyperloop_station)
  return _internal_hyperloop_station();
}
inline void Backup_Game::_internal_set_hyperloop_station(bool value) {
  _has_bits_[0] |= 0x00200000u;
  hyperloop_station_ = value;
}
inline void Backup_Game::set_hyperloop_station(bool value) {
  _internal_set_hyperloop_station(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.hyperloop_station)
}

// optional double next_daily_gift_time = 10;
inline bool Backup_Game::_internal_has_next_daily_gift_time() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Backup_Game::has_next_daily_gift_time() const {
  return _internal_has_next_daily_gift_time();
}
inline void Backup_Game::clear_next_daily_gift_time() {
  next_daily_gift_time_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double Backup_Game::_internal_next_daily_gift_time() const {
  return next_daily_gift_time_;
}
inline double Backup_Game::next_daily_gift_time() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.next_daily_gift_time)
  return _internal_next_daily_gift_time();
}
inline void Backup_Game::_internal_set_next_daily_gift_time(double value) {
  _has_bits_[0] |= 0x00000040u;
  next_daily_gift_time_ = value;
}
inline void Backup_Game::set_next_daily_gift_time(double value) {
  _internal_set_next_daily_gift_time(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.next_daily_gift_time)
}

// optional uint32 last_daily_gift_collected_day = 20;
inline bool Backup_Game::_internal_has_last_daily_gift_collected_day() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool Backup_Game::has_last_daily_gift_collected_day() const {
  return _internal_has_last_daily_gift_collected_day();
}
inline void Backup_Game::clear_last_daily_gift_collected_day() {
  last_daily_gift_collected_day_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline uint32_t Backup_Game::_internal_last_daily_gift_collected_day() const {
  return last_daily_gift_collected_day_;
}
inline uint32_t Backup_Game::last_daily_gift_collected_day() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.last_daily_gift_collected_day)
  return _internal_last_daily_gift_collected_day();
}
inline void Backup_Game::_internal_set_last_daily_gift_collected_day(uint32_t value) {
  _has_bits_[0] |= 0x00000800u;
  last_daily_gift_collected_day_ = value;
}
inline void Backup_Game::set_last_daily_gift_collected_day(uint32_t value) {
  _internal_set_last_daily_gift_collected_day(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.last_daily_gift_collected_day)
}

// optional uint32 num_daily_gifts_collected = 28;
inline bool Backup_Game::_internal_has_num_daily_gifts_collected() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool Backup_Game::has_num_daily_gifts_collected() const {
  return _internal_has_num_daily_gifts_collected();
}
inline void Backup_Game::clear_num_daily_gifts_collected() {
  num_daily_gifts_collected_ = 0u;
  _has_bits_[0] &= ~0x00020000u;
}
inline uint32_t Backup_Game::_internal_num_daily_gifts_collected() const {
  return num_daily_gifts_collected_;
}
inline uint32_t Backup_Game::num_daily_gifts_collected() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.num_daily_gifts_collected)
  return _internal_num_daily_gifts_collected();
}
inline void Backup_Game::_internal_set_num_daily_gifts_collected(uint32_t value) {
  _has_bits_[0] |= 0x00020000u;
  num_daily_gifts_collected_ = value;
}
inline void Backup_Game::set_num_daily_gifts_collected(uint32_t value) {
  _internal_set_num_daily_gifts_collected(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.num_daily_gifts_collected)
}

// repeated .ei.Backup.NewsHeadline news = 11;
inline int Backup_Game::_internal_news_size() const {
  return news_.size();
}
inline int Backup_Game::news_size() const {
  return _internal_news_size();
}
inline void Backup_Game::clear_news() {
  news_.Clear();
}
inline ::ei::Backup_NewsHeadline* Backup_Game::mutable_news(int index) {
  // @@protoc_insertion_point(field_mutable:ei.Backup.Game.news)
  return news_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_NewsHeadline >*
Backup_Game::mutable_news() {
  // @@protoc_insertion_point(field_mutable_list:ei.Backup.Game.news)
  return &news_;
}
inline const ::ei::Backup_NewsHeadline& Backup_Game::_internal_news(int index) const {
  return news_.Get(index);
}
inline const ::ei::Backup_NewsHeadline& Backup_Game::news(int index) const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.news)
  return _internal_news(index);
}
inline ::ei::Backup_NewsHeadline* Backup_Game::_internal_add_news() {
  return news_.Add();
}
inline ::ei::Backup_NewsHeadline* Backup_Game::add_news() {
  ::ei::Backup_NewsHeadline* _add = _internal_add_news();
  // @@protoc_insertion_point(field_add:ei.Backup.Game.news)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_NewsHeadline >&
Backup_Game::news() const {
  // @@protoc_insertion_point(field_list:ei.Backup.Game.news)
  return news_;
}

// optional double last_news_time = 12;
inline bool Backup_Game::_internal_has_last_news_time() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Backup_Game::has_last_news_time() const {
  return _internal_has_last_news_time();
}
inline void Backup_Game::clear_last_news_time() {
  last_news_time_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline double Backup_Game::_internal_last_news_time() const {
  return last_news_time_;
}
inline double Backup_Game::last_news_time() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.last_news_time)
  return _internal_last_news_time();
}
inline void Backup_Game::_internal_set_last_news_time(double value) {
  _has_bits_[0] |= 0x00000080u;
  last_news_time_ = value;
}
inline void Backup_Game::set_last_news_time(double value) {
  _internal_set_last_news_time(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.last_news_time)
}

// optional double current_multiplier = 13;
inline bool Backup_Game::_internal_has_current_multiplier() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Backup_Game::has_current_multiplier() const {
  return _internal_has_current_multiplier();
}
inline void Backup_Game::clear_current_multiplier() {
  current_multiplier_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline double Backup_Game::_internal_current_multiplier() const {
  return current_multiplier_;
}
inline double Backup_Game::current_multiplier() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.current_multiplier)
  return _internal_current_multiplier();
}
inline void Backup_Game::_internal_set_current_multiplier(double value) {
  _has_bits_[0] |= 0x00000100u;
  current_multiplier_ = value;
}
inline void Backup_Game::set_current_multiplier(double value) {
  _internal_set_current_multiplier(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.current_multiplier)
}

// optional double current_multiplier_expiration = 14;
inline bool Backup_Game::_internal_has_current_multiplier_expiration() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Backup_Game::has_current_multiplier_expiration() const {
  return _internal_has_current_multiplier_expiration();
}
inline void Backup_Game::clear_current_multiplier_expiration() {
  current_multiplier_expiration_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline double Backup_Game::_internal_current_multiplier_expiration() const {
  return current_multiplier_expiration_;
}
inline double Backup_Game::current_multiplier_expiration() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.current_multiplier_expiration)
  return _internal_current_multiplier_expiration();
}
inline void Backup_Game::_internal_set_current_multiplier_expiration(double value) {
  _has_bits_[0] |= 0x00000200u;
  current_multiplier_expiration_ = value;
}
inline void Backup_Game::set_current_multiplier_expiration(double value) {
  _internal_set_current_multiplier_expiration(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.current_multiplier_expiration)
}

// repeated .ei.Backup.AchievementInfo achievements = 15;
inline int Backup_Game::_internal_achievements_size() const {
  return achievements_.size();
}
inline int Backup_Game::achievements_size() const {
  return _internal_achievements_size();
}
inline void Backup_Game::clear_achievements() {
  achievements_.Clear();
}
inline ::ei::Backup_AchievementInfo* Backup_Game::mutable_achievements(int index) {
  // @@protoc_insertion_point(field_mutable:ei.Backup.Game.achievements)
  return achievements_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_AchievementInfo >*
Backup_Game::mutable_achievements() {
  // @@protoc_insertion_point(field_mutable_list:ei.Backup.Game.achievements)
  return &achievements_;
}
inline const ::ei::Backup_AchievementInfo& Backup_Game::_internal_achievements(int index) const {
  return achievements_.Get(index);
}
inline const ::ei::Backup_AchievementInfo& Backup_Game::achievements(int index) const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.achievements)
  return _internal_achievements(index);
}
inline ::ei::Backup_AchievementInfo* Backup_Game::_internal_add_achievements() {
  return achievements_.Add();
}
inline ::ei::Backup_AchievementInfo* Backup_Game::add_achievements() {
  ::ei::Backup_AchievementInfo* _add = _internal_add_achievements();
  // @@protoc_insertion_point(field_add:ei.Backup.Game.achievements)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_AchievementInfo >&
Backup_Game::achievements() const {
  // @@protoc_insertion_point(field_list:ei.Backup.Game.achievements)
  return achievements_;
}

// repeated uint64 max_farm_size_reached = 18;
inline int Backup_Game::_internal_max_farm_size_reached_size() const {
  return max_farm_size_reached_.size();
}
inline int Backup_Game::max_farm_size_reached_size() const {
  return _internal_max_farm_size_reached_size();
}
inline void Backup_Game::clear_max_farm_size_reached() {
  max_farm_size_reached_.Clear();
}
inline uint64_t Backup_Game::_internal_max_farm_size_reached(int index) const {
  return max_farm_size_reached_.Get(index);
}
inline uint64_t Backup_Game::max_farm_size_reached(int index) const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.max_farm_size_reached)
  return _internal_max_farm_size_reached(index);
}
inline void Backup_Game::set_max_farm_size_reached(int index, uint64_t value) {
  max_farm_size_reached_.Set(index, value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.max_farm_size_reached)
}
inline void Backup_Game::_internal_add_max_farm_size_reached(uint64_t value) {
  max_farm_size_reached_.Add(value);
}
inline void Backup_Game::add_max_farm_size_reached(uint64_t value) {
  _internal_add_max_farm_size_reached(value);
  // @@protoc_insertion_point(field_add:ei.Backup.Game.max_farm_size_reached)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Backup_Game::_internal_max_farm_size_reached() const {
  return max_farm_size_reached_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Backup_Game::max_farm_size_reached() const {
  // @@protoc_insertion_point(field_list:ei.Backup.Game.max_farm_size_reached)
  return _internal_max_farm_size_reached();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Backup_Game::_internal_mutable_max_farm_size_reached() {
  return &max_farm_size_reached_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Backup_Game::mutable_max_farm_size_reached() {
  // @@protoc_insertion_point(field_mutable_list:ei.Backup.Game.max_farm_size_reached)
  return _internal_mutable_max_farm_size_reached();
}

// repeated uint32 egg_medal_level = 19;
inline int Backup_Game::_internal_egg_medal_level_size() const {
  return egg_medal_level_.size();
}
inline int Backup_Game::egg_medal_level_size() const {
  return _internal_egg_medal_level_size();
}
inline void Backup_Game::clear_egg_medal_level() {
  egg_medal_level_.Clear();
}
inline uint32_t Backup_Game::_internal_egg_medal_level(int index) const {
  return egg_medal_level_.Get(index);
}
inline uint32_t Backup_Game::egg_medal_level(int index) const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.egg_medal_level)
  return _internal_egg_medal_level(index);
}
inline void Backup_Game::set_egg_medal_level(int index, uint32_t value) {
  egg_medal_level_.Set(index, value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.egg_medal_level)
}
inline void Backup_Game::_internal_add_egg_medal_level(uint32_t value) {
  egg_medal_level_.Add(value);
}
inline void Backup_Game::add_egg_medal_level(uint32_t value) {
  _internal_add_egg_medal_level(value);
  // @@protoc_insertion_point(field_add:ei.Backup.Game.egg_medal_level)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Backup_Game::_internal_egg_medal_level() const {
  return egg_medal_level_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Backup_Game::egg_medal_level() const {
  // @@protoc_insertion_point(field_list:ei.Backup.Game.egg_medal_level)
  return _internal_egg_medal_level();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Backup_Game::_internal_mutable_egg_medal_level() {
  return &egg_medal_level_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Backup_Game::mutable_egg_medal_level() {
  // @@protoc_insertion_point(field_mutable_list:ei.Backup.Game.egg_medal_level)
  return _internal_mutable_egg_medal_level();
}

// optional bool long_idle_notification_set = 25;
inline bool Backup_Game::_internal_has_long_idle_notification_set() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool Backup_Game::has_long_idle_notification_set() const {
  return _internal_has_long_idle_notification_set();
}
inline void Backup_Game::clear_long_idle_notification_set() {
  long_idle_notification_set_ = false;
  _has_bits_[0] &= ~0x00400000u;
}
inline bool Backup_Game::_internal_long_idle_notification_set() const {
  return long_idle_notification_set_;
}
inline bool Backup_Game::long_idle_notification_set() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.long_idle_notification_set)
  return _internal_long_idle_notification_set();
}
inline void Backup_Game::_internal_set_long_idle_notification_set(bool value) {
  _has_bits_[0] |= 0x00400000u;
  long_idle_notification_set_ = value;
}
inline void Backup_Game::set_long_idle_notification_set(bool value) {
  _internal_set_long_idle_notification_set(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.long_idle_notification_set)
}

// optional double long_idle_notification_threshold = 26;
inline bool Backup_Game::_internal_has_long_idle_notification_threshold() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool Backup_Game::has_long_idle_notification_threshold() const {
  return _internal_has_long_idle_notification_threshold();
}
inline void Backup_Game::clear_long_idle_notification_threshold() {
  long_idle_notification_threshold_ = 0;
  _has_bits_[0] &= ~0x00040000u;
}
inline double Backup_Game::_internal_long_idle_notification_threshold() const {
  return long_idle_notification_threshold_;
}
inline double Backup_Game::long_idle_notification_threshold() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.long_idle_notification_threshold)
  return _internal_long_idle_notification_threshold();
}
inline void Backup_Game::_internal_set_long_idle_notification_threshold(double value) {
  _has_bits_[0] |= 0x00040000u;
  long_idle_notification_threshold_ = value;
}
inline void Backup_Game::set_long_idle_notification_threshold(double value) {
  _internal_set_long_idle_notification_threshold(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.long_idle_notification_threshold)
}

// optional double long_idle_reward = 27;
inline bool Backup_Game::_internal_has_long_idle_reward() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool Backup_Game::has_long_idle_reward() const {
  return _internal_has_long_idle_reward();
}
inline void Backup_Game::clear_long_idle_reward() {
  long_idle_reward_ = 0;
  _has_bits_[0] &= ~0x00080000u;
}
inline double Backup_Game::_internal_long_idle_reward() const {
  return long_idle_reward_;
}
inline double Backup_Game::long_idle_reward() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.long_idle_reward)
  return _internal_long_idle_reward();
}
inline void Backup_Game::_internal_set_long_idle_reward(double value) {
  _has_bits_[0] |= 0x00080000u;
  long_idle_reward_ = value;
}
inline void Backup_Game::set_long_idle_reward(double value) {
  _internal_set_long_idle_reward(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.long_idle_reward)
}

// repeated .ei.Backup.OwnedBoost boosts = 30;
inline int Backup_Game::_internal_boosts_size() const {
  return boosts_.size();
}
inline int Backup_Game::boosts_size() const {
  return _internal_boosts_size();
}
inline void Backup_Game::clear_boosts() {
  boosts_.Clear();
}
inline ::ei::Backup_OwnedBoost* Backup_Game::mutable_boosts(int index) {
  // @@protoc_insertion_point(field_mutable:ei.Backup.Game.boosts)
  return boosts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_OwnedBoost >*
Backup_Game::mutable_boosts() {
  // @@protoc_insertion_point(field_mutable_list:ei.Backup.Game.boosts)
  return &boosts_;
}
inline const ::ei::Backup_OwnedBoost& Backup_Game::_internal_boosts(int index) const {
  return boosts_.Get(index);
}
inline const ::ei::Backup_OwnedBoost& Backup_Game::boosts(int index) const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.boosts)
  return _internal_boosts(index);
}
inline ::ei::Backup_OwnedBoost* Backup_Game::_internal_add_boosts() {
  return boosts_.Add();
}
inline ::ei::Backup_OwnedBoost* Backup_Game::add_boosts() {
  ::ei::Backup_OwnedBoost* _add = _internal_add_boosts();
  // @@protoc_insertion_point(field_add:ei.Backup.Game.boosts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_OwnedBoost >&
Backup_Game::boosts() const {
  // @@protoc_insertion_point(field_list:ei.Backup.Game.boosts)
  return boosts_;
}

// optional uint32 total_time_cheats_detected = 32;
inline bool Backup_Game::_internal_has_total_time_cheats_detected() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool Backup_Game::has_total_time_cheats_detected() const {
  return _internal_has_total_time_cheats_detected();
}
inline void Backup_Game::clear_total_time_cheats_detected() {
  total_time_cheats_detected_ = 0u;
  _has_bits_[0] &= ~0x01000000u;
}
inline uint32_t Backup_Game::_internal_total_time_cheats_detected() const {
  return total_time_cheats_detected_;
}
inline uint32_t Backup_Game::total_time_cheats_detected() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.total_time_cheats_detected)
  return _internal_total_time_cheats_detected();
}
inline void Backup_Game::_internal_set_total_time_cheats_detected(uint32_t value) {
  _has_bits_[0] |= 0x01000000u;
  total_time_cheats_detected_ = value;
}
inline void Backup_Game::set_total_time_cheats_detected(uint32_t value) {
  _internal_set_total_time_cheats_detected(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.total_time_cheats_detected)
}

// optional bool force_elite_contracts = 36;
inline bool Backup_Game::_internal_has_force_elite_contracts() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool Backup_Game::has_force_elite_contracts() const {
  return _internal_has_force_elite_contracts();
}
inline void Backup_Game::clear_force_elite_contracts() {
  force_elite_contracts_ = false;
  _has_bits_[0] &= ~0x00800000u;
}
inline bool Backup_Game::_internal_force_elite_contracts() const {
  return force_elite_contracts_;
}
inline bool Backup_Game::force_elite_contracts() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.force_elite_contracts)
  return _internal_force_elite_contracts();
}
inline void Backup_Game::_internal_set_force_elite_contracts(bool value) {
  _has_bits_[0] |= 0x00800000u;
  force_elite_contracts_ = value;
}
inline void Backup_Game::set_force_elite_contracts(bool value) {
  _internal_set_force_elite_contracts(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.force_elite_contracts)
}

// optional double new_player_event_end_time = 37;
inline bool Backup_Game::_internal_has_new_player_event_end_time() const {
  bool value = (_has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool Backup_Game::has_new_player_event_end_time() const {
  return _internal_has_new_player_event_end_time();
}
inline void Backup_Game::clear_new_player_event_end_time() {
  new_player_event_end_time_ = 0;
  _has_bits_[0] &= ~0x10000000u;
}
inline double Backup_Game::_internal_new_player_event_end_time() const {
  return new_player_event_end_time_;
}
inline double Backup_Game::new_player_event_end_time() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Game.new_player_event_end_time)
  return _internal_new_player_event_end_time();
}
inline void Backup_Game::_internal_set_new_player_event_end_time(double value) {
  _has_bits_[0] |= 0x10000000u;
  new_player_event_end_time_ = value;
}
inline void Backup_Game::set_new_player_event_end_time(double value) {
  _internal_set_new_player_event_end_time(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Game.new_player_event_end_time)
}

// -------------------------------------------------------------------

// Backup_Artifacts

// optional bool infusing = 1;
inline bool Backup_Artifacts::_internal_has_infusing() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Backup_Artifacts::has_infusing() const {
  return _internal_has_infusing();
}
inline void Backup_Artifacts::clear_infusing() {
  infusing_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool Backup_Artifacts::_internal_infusing() const {
  return infusing_;
}
inline bool Backup_Artifacts::infusing() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Artifacts.infusing)
  return _internal_infusing();
}
inline void Backup_Artifacts::_internal_set_infusing(bool value) {
  _has_bits_[0] |= 0x00000020u;
  infusing_ = value;
}
inline void Backup_Artifacts::set_infusing(bool value) {
  _internal_set_infusing(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Artifacts.infusing)
}

// optional .ei.ArtifactInventoryItem item_being_infused = 2;
inline bool Backup_Artifacts::_internal_has_item_being_infused() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || item_being_infused_ != nullptr);
  return value;
}
inline bool Backup_Artifacts::has_item_being_infused() const {
  return _internal_has_item_being_infused();
}
inline void Backup_Artifacts::clear_item_being_infused() {
  if (item_being_infused_ != nullptr) item_being_infused_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ei::ArtifactInventoryItem& Backup_Artifacts::_internal_item_being_infused() const {
  const ::ei::ArtifactInventoryItem* p = item_being_infused_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::ArtifactInventoryItem&>(
      ::ei::_ArtifactInventoryItem_default_instance_);
}
inline const ::ei::ArtifactInventoryItem& Backup_Artifacts::item_being_infused() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Artifacts.item_being_infused)
  return _internal_item_being_infused();
}
inline void Backup_Artifacts::unsafe_arena_set_allocated_item_being_infused(
    ::ei::ArtifactInventoryItem* item_being_infused) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item_being_infused_);
  }
  item_being_infused_ = item_being_infused;
  if (item_being_infused) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.Backup.Artifacts.item_being_infused)
}
inline ::ei::ArtifactInventoryItem* Backup_Artifacts::release_item_being_infused() {
  _has_bits_[0] &= ~0x00000001u;
  ::ei::ArtifactInventoryItem* temp = item_being_infused_;
  item_being_infused_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::ArtifactInventoryItem* Backup_Artifacts::unsafe_arena_release_item_being_infused() {
  // @@protoc_insertion_point(field_release:ei.Backup.Artifacts.item_being_infused)
  _has_bits_[0] &= ~0x00000001u;
  ::ei::ArtifactInventoryItem* temp = item_being_infused_;
  item_being_infused_ = nullptr;
  return temp;
}
inline ::ei::ArtifactInventoryItem* Backup_Artifacts::_internal_mutable_item_being_infused() {
  _has_bits_[0] |= 0x00000001u;
  if (item_being_infused_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::ArtifactInventoryItem>(GetArenaForAllocation());
    item_being_infused_ = p;
  }
  return item_being_infused_;
}
inline ::ei::ArtifactInventoryItem* Backup_Artifacts::mutable_item_being_infused() {
  ::ei::ArtifactInventoryItem* _msg = _internal_mutable_item_being_infused();
  // @@protoc_insertion_point(field_mutable:ei.Backup.Artifacts.item_being_infused)
  return _msg;
}
inline void Backup_Artifacts::set_allocated_item_being_infused(::ei::ArtifactInventoryItem* item_being_infused) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete item_being_infused_;
  }
  if (item_being_infused) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::ArtifactInventoryItem>::GetOwningArena(item_being_infused);
    if (message_arena != submessage_arena) {
      item_being_infused = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item_being_infused, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  item_being_infused_ = item_being_infused;
  // @@protoc_insertion_point(field_set_allocated:ei.Backup.Artifacts.item_being_infused)
}

// optional .ei.ArtifactSpec spec_being_infused = 13;
inline bool Backup_Artifacts::_internal_has_spec_being_infused() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || spec_being_infused_ != nullptr);
  return value;
}
inline bool Backup_Artifacts::has_spec_being_infused() const {
  return _internal_has_spec_being_infused();
}
inline void Backup_Artifacts::clear_spec_being_infused() {
  if (spec_being_infused_ != nullptr) spec_being_infused_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ei::ArtifactSpec& Backup_Artifacts::_internal_spec_being_infused() const {
  const ::ei::ArtifactSpec* p = spec_being_infused_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::ArtifactSpec&>(
      ::ei::_ArtifactSpec_default_instance_);
}
inline const ::ei::ArtifactSpec& Backup_Artifacts::spec_being_infused() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Artifacts.spec_being_infused)
  return _internal_spec_being_infused();
}
inline void Backup_Artifacts::unsafe_arena_set_allocated_spec_being_infused(
    ::ei::ArtifactSpec* spec_being_infused) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_being_infused_);
  }
  spec_being_infused_ = spec_being_infused;
  if (spec_being_infused) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.Backup.Artifacts.spec_being_infused)
}
inline ::ei::ArtifactSpec* Backup_Artifacts::release_spec_being_infused() {
  _has_bits_[0] &= ~0x00000002u;
  ::ei::ArtifactSpec* temp = spec_being_infused_;
  spec_being_infused_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::ArtifactSpec* Backup_Artifacts::unsafe_arena_release_spec_being_infused() {
  // @@protoc_insertion_point(field_release:ei.Backup.Artifacts.spec_being_infused)
  _has_bits_[0] &= ~0x00000002u;
  ::ei::ArtifactSpec* temp = spec_being_infused_;
  spec_being_infused_ = nullptr;
  return temp;
}
inline ::ei::ArtifactSpec* Backup_Artifacts::_internal_mutable_spec_being_infused() {
  _has_bits_[0] |= 0x00000002u;
  if (spec_being_infused_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::ArtifactSpec>(GetArenaForAllocation());
    spec_being_infused_ = p;
  }
  return spec_being_infused_;
}
inline ::ei::ArtifactSpec* Backup_Artifacts::mutable_spec_being_infused() {
  ::ei::ArtifactSpec* _msg = _internal_mutable_spec_being_infused();
  // @@protoc_insertion_point(field_mutable:ei.Backup.Artifacts.spec_being_infused)
  return _msg;
}
inline void Backup_Artifacts::set_allocated_spec_being_infused(::ei::ArtifactSpec* spec_being_infused) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_being_infused_;
  }
  if (spec_being_infused) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::ArtifactSpec>::GetOwningArena(spec_being_infused);
    if (message_arena != submessage_arena) {
      spec_being_infused = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec_being_infused, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  spec_being_infused_ = spec_being_infused;
  // @@protoc_insertion_point(field_set_allocated:ei.Backup.Artifacts.spec_being_infused)
}

// optional .ei.Egg egg_type_infusing = 3;
inline bool Backup_Artifacts::_internal_has_egg_type_infusing() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Backup_Artifacts::has_egg_type_infusing() const {
  return _internal_has_egg_type_infusing();
}
inline void Backup_Artifacts::clear_egg_type_infusing() {
  egg_type_infusing_ = 1;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::ei::Egg Backup_Artifacts::_internal_egg_type_infusing() const {
  return static_cast< ::ei::Egg >(egg_type_infusing_);
}
inline ::ei::Egg Backup_Artifacts::egg_type_infusing() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Artifacts.egg_type_infusing)
  return _internal_egg_type_infusing();
}
inline void Backup_Artifacts::_internal_set_egg_type_infusing(::ei::Egg value) {
  assert(::ei::Egg_IsValid(value));
  _has_bits_[0] |= 0x00001000u;
  egg_type_infusing_ = value;
}
inline void Backup_Artifacts::set_egg_type_infusing(::ei::Egg value) {
  _internal_set_egg_type_infusing(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Artifacts.egg_type_infusing)
}

// optional double infusing_eggs_required = 4;
inline bool Backup_Artifacts::_internal_has_infusing_eggs_required() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Backup_Artifacts::has_infusing_eggs_required() const {
  return _internal_has_infusing_eggs_required();
}
inline void Backup_Artifacts::clear_infusing_eggs_required() {
  infusing_eggs_required_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double Backup_Artifacts::_internal_infusing_eggs_required() const {
  return infusing_eggs_required_;
}
inline double Backup_Artifacts::infusing_eggs_required() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Artifacts.infusing_eggs_required)
  return _internal_infusing_eggs_required();
}
inline void Backup_Artifacts::_internal_set_infusing_eggs_required(double value) {
  _has_bits_[0] |= 0x00000004u;
  infusing_eggs_required_ = value;
}
inline void Backup_Artifacts::set_infusing_eggs_required(double value) {
  _internal_set_infusing_eggs_required(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Artifacts.infusing_eggs_required)
}

// optional double eggs_infused = 5;
inline bool Backup_Artifacts::_internal_has_eggs_infused() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Backup_Artifacts::has_eggs_infused() const {
  return _internal_has_eggs_infused();
}
inline void Backup_Artifacts::clear_eggs_infused() {
  eggs_infused_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double Backup_Artifacts::_internal_eggs_infused() const {
  return eggs_infused_;
}
inline double Backup_Artifacts::eggs_infused() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Artifacts.eggs_infused)
  return _internal_eggs_infused();
}
inline void Backup_Artifacts::_internal_set_eggs_infused(double value) {
  _has_bits_[0] |= 0x00000008u;
  eggs_infused_ = value;
}
inline void Backup_Artifacts::set_eggs_infused(double value) {
  _internal_set_eggs_infused(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Artifacts.eggs_infused)
}

// optional double flow_percentage_artifacts = 6 [default = 0.5];
inline bool Backup_Artifacts::_internal_has_flow_percentage_artifacts() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool Backup_Artifacts::has_flow_percentage_artifacts() const {
  return _internal_has_flow_percentage_artifacts();
}
inline void Backup_Artifacts::clear_flow_percentage_artifacts() {
  flow_percentage_artifacts_ = 0.5;
  _has_bits_[0] &= ~0x00000800u;
}
inline double Backup_Artifacts::_internal_flow_percentage_artifacts() const {
  return flow_percentage_artifacts_;
}
inline double Backup_Artifacts::flow_percentage_artifacts() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Artifacts.flow_percentage_artifacts)
  return _internal_flow_percentage_artifacts();
}
inline void Backup_Artifacts::_internal_set_flow_percentage_artifacts(double value) {
  _has_bits_[0] |= 0x00000800u;
  flow_percentage_artifacts_ = value;
}
inline void Backup_Artifacts::set_flow_percentage_artifacts(double value) {
  _internal_set_flow_percentage_artifacts(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Artifacts.flow_percentage_artifacts)
}

// optional bool fueling_enabled = 7 [default = true];
inline bool Backup_Artifacts::_internal_has_fueling_enabled() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Backup_Artifacts::has_fueling_enabled() const {
  return _internal_has_fueling_enabled();
}
inline void Backup_Artifacts::clear_fueling_enabled() {
  fueling_enabled_ = true;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool Backup_Artifacts::_internal_fueling_enabled() const {
  return fueling_enabled_;
}
inline bool Backup_Artifacts::fueling_enabled() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Artifacts.fueling_enabled)
  return _internal_fueling_enabled();
}
inline void Backup_Artifacts::_internal_set_fueling_enabled(bool value) {
  _has_bits_[0] |= 0x00002000u;
  fueling_enabled_ = value;
}
inline void Backup_Artifacts::set_fueling_enabled(bool value) {
  _internal_set_fueling_enabled(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Artifacts.fueling_enabled)
}

// optional bool tank_filling_enabled = 14;
inline bool Backup_Artifacts::_internal_has_tank_filling_enabled() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Backup_Artifacts::has_tank_filling_enabled() const {
  return _internal_has_tank_filling_enabled();
}
inline void Backup_Artifacts::clear_tank_filling_enabled() {
  tank_filling_enabled_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool Backup_Artifacts::_internal_tank_filling_enabled() const {
  return tank_filling_enabled_;
}
inline bool Backup_Artifacts::tank_filling_enabled() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Artifacts.tank_filling_enabled)
  return _internal_tank_filling_enabled();
}
inline void Backup_Artifacts::_internal_set_tank_filling_enabled(bool value) {
  _has_bits_[0] |= 0x00000040u;
  tank_filling_enabled_ = value;
}
inline void Backup_Artifacts::set_tank_filling_enabled(bool value) {
  _internal_set_tank_filling_enabled(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Artifacts.tank_filling_enabled)
}

// optional uint32 tank_level = 15;
inline bool Backup_Artifacts::_internal_has_tank_level() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Backup_Artifacts::has_tank_level() const {
  return _internal_has_tank_level();
}
inline void Backup_Artifacts::clear_tank_level() {
  tank_level_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline uint32_t Backup_Artifacts::_internal_tank_level() const {
  return tank_level_;
}
inline uint32_t Backup_Artifacts::tank_level() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Artifacts.tank_level)
  return _internal_tank_level();
}
inline void Backup_Artifacts::_internal_set_tank_level(uint32_t value) {
  _has_bits_[0] |= 0x00000400u;
  tank_level_ = value;
}
inline void Backup_Artifacts::set_tank_level(uint32_t value) {
  _internal_set_tank_level(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Artifacts.tank_level)
}

// repeated double tank_fuels = 16;
inline int Backup_Artifacts::_internal_tank_fuels_size() const {
  return tank_fuels_.size();
}
inline int Backup_Artifacts::tank_fuels_size() const {
  return _internal_tank_fuels_size();
}
inline void Backup_Artifacts::clear_tank_fuels() {
  tank_fuels_.Clear();
}
inline double Backup_Artifacts::_internal_tank_fuels(int index) const {
  return tank_fuels_.Get(index);
}
inline double Backup_Artifacts::tank_fuels(int index) const {
  // @@protoc_insertion_point(field_get:ei.Backup.Artifacts.tank_fuels)
  return _internal_tank_fuels(index);
}
inline void Backup_Artifacts::set_tank_fuels(int index, double value) {
  tank_fuels_.Set(index, value);
  // @@protoc_insertion_point(field_set:ei.Backup.Artifacts.tank_fuels)
}
inline void Backup_Artifacts::_internal_add_tank_fuels(double value) {
  tank_fuels_.Add(value);
}
inline void Backup_Artifacts::add_tank_fuels(double value) {
  _internal_add_tank_fuels(value);
  // @@protoc_insertion_point(field_add:ei.Backup.Artifacts.tank_fuels)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Backup_Artifacts::_internal_tank_fuels() const {
  return tank_fuels_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Backup_Artifacts::tank_fuels() const {
  // @@protoc_insertion_point(field_list:ei.Backup.Artifacts.tank_fuels)
  return _internal_tank_fuels();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Backup_Artifacts::_internal_mutable_tank_fuels() {
  return &tank_fuels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Backup_Artifacts::mutable_tank_fuels() {
  // @@protoc_insertion_point(field_mutable_list:ei.Backup.Artifacts.tank_fuels)
  return _internal_mutable_tank_fuels();
}

// optional .ei.MissionInfo.Spaceship last_fueled_ship = 9;
inline bool Backup_Artifacts::_internal_has_last_fueled_ship() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Backup_Artifacts::has_last_fueled_ship() const {
  return _internal_has_last_fueled_ship();
}
inline void Backup_Artifacts::clear_last_fueled_ship() {
  last_fueled_ship_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::ei::MissionInfo_Spaceship Backup_Artifacts::_internal_last_fueled_ship() const {
  return static_cast< ::ei::MissionInfo_Spaceship >(last_fueled_ship_);
}
inline ::ei::MissionInfo_Spaceship Backup_Artifacts::last_fueled_ship() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Artifacts.last_fueled_ship)
  return _internal_last_fueled_ship();
}
inline void Backup_Artifacts::_internal_set_last_fueled_ship(::ei::MissionInfo_Spaceship value) {
  assert(::ei::MissionInfo_Spaceship_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  last_fueled_ship_ = value;
}
inline void Backup_Artifacts::set_last_fueled_ship(::ei::MissionInfo_Spaceship value) {
  _internal_set_last_fueled_ship(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Artifacts.last_fueled_ship)
}

// optional double inventory_score = 10;
inline bool Backup_Artifacts::_internal_has_inventory_score() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Backup_Artifacts::has_inventory_score() const {
  return _internal_has_inventory_score();
}
inline void Backup_Artifacts::clear_inventory_score() {
  inventory_score_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline double Backup_Artifacts::_internal_inventory_score() const {
  return inventory_score_;
}
inline double Backup_Artifacts::inventory_score() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Artifacts.inventory_score)
  return _internal_inventory_score();
}
inline void Backup_Artifacts::_internal_set_inventory_score(double value) {
  _has_bits_[0] |= 0x00000200u;
  inventory_score_ = value;
}
inline void Backup_Artifacts::set_inventory_score(double value) {
  _internal_set_inventory_score(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Artifacts.inventory_score)
}

// optional bool enabled = 11;
inline bool Backup_Artifacts::_internal_has_enabled() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Backup_Artifacts::has_enabled() const {
  return _internal_has_enabled();
}
inline void Backup_Artifacts::clear_enabled() {
  enabled_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool Backup_Artifacts::_internal_enabled() const {
  return enabled_;
}
inline bool Backup_Artifacts::enabled() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Artifacts.enabled)
  return _internal_enabled();
}
inline void Backup_Artifacts::_internal_set_enabled(bool value) {
  _has_bits_[0] |= 0x00000080u;
  enabled_ = value;
}
inline void Backup_Artifacts::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Artifacts.enabled)
}

// optional bool intro_shown = 12;
inline bool Backup_Artifacts::_internal_has_intro_shown() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Backup_Artifacts::has_intro_shown() const {
  return _internal_has_intro_shown();
}
inline void Backup_Artifacts::clear_intro_shown() {
  intro_shown_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool Backup_Artifacts::_internal_intro_shown() const {
  return intro_shown_;
}
inline bool Backup_Artifacts::intro_shown() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Artifacts.intro_shown)
  return _internal_intro_shown();
}
inline void Backup_Artifacts::_internal_set_intro_shown(bool value) {
  _has_bits_[0] |= 0x00000100u;
  intro_shown_ = value;
}
inline void Backup_Artifacts::set_intro_shown(bool value) {
  _internal_set_intro_shown(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Artifacts.intro_shown)
}

// optional bool infusing_enabled_DEPRECATED = 8 [default = true];
inline bool Backup_Artifacts::_internal_has_infusing_enabled_deprecated() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Backup_Artifacts::has_infusing_enabled_deprecated() const {
  return _internal_has_infusing_enabled_deprecated();
}
inline void Backup_Artifacts::clear_infusing_enabled_deprecated() {
  infusing_enabled_deprecated_ = true;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool Backup_Artifacts::_internal_infusing_enabled_deprecated() const {
  return infusing_enabled_deprecated_;
}
inline bool Backup_Artifacts::infusing_enabled_deprecated() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Artifacts.infusing_enabled_DEPRECATED)
  return _internal_infusing_enabled_deprecated();
}
inline void Backup_Artifacts::_internal_set_infusing_enabled_deprecated(bool value) {
  _has_bits_[0] |= 0x00004000u;
  infusing_enabled_deprecated_ = value;
}
inline void Backup_Artifacts::set_infusing_enabled_deprecated(bool value) {
  _internal_set_infusing_enabled_deprecated(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Artifacts.infusing_enabled_DEPRECATED)
}

// -------------------------------------------------------------------

// Backup_Shells

// optional bool intro_alert = 1;
inline bool Backup_Shells::_internal_has_intro_alert() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Backup_Shells::has_intro_alert() const {
  return _internal_has_intro_alert();
}
inline void Backup_Shells::clear_intro_alert() {
  intro_alert_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool Backup_Shells::_internal_intro_alert() const {
  return intro_alert_;
}
inline bool Backup_Shells::intro_alert() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Shells.intro_alert)
  return _internal_intro_alert();
}
inline void Backup_Shells::_internal_set_intro_alert(bool value) {
  _has_bits_[0] |= 0x00000001u;
  intro_alert_ = value;
}
inline void Backup_Shells::set_intro_alert(bool value) {
  _internal_set_intro_alert(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Shells.intro_alert)
}

// optional bool contracts_intro_alert = 2;
inline bool Backup_Shells::_internal_has_contracts_intro_alert() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Backup_Shells::has_contracts_intro_alert() const {
  return _internal_has_contracts_intro_alert();
}
inline void Backup_Shells::clear_contracts_intro_alert() {
  contracts_intro_alert_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool Backup_Shells::_internal_contracts_intro_alert() const {
  return contracts_intro_alert_;
}
inline bool Backup_Shells::contracts_intro_alert() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Shells.contracts_intro_alert)
  return _internal_contracts_intro_alert();
}
inline void Backup_Shells::_internal_set_contracts_intro_alert(bool value) {
  _has_bits_[0] |= 0x00000002u;
  contracts_intro_alert_ = value;
}
inline void Backup_Shells::set_contracts_intro_alert(bool value) {
  _internal_set_contracts_intro_alert(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Shells.contracts_intro_alert)
}

// repeated int32 num_new = 3;
inline int Backup_Shells::_internal_num_new_size() const {
  return num_new_.size();
}
inline int Backup_Shells::num_new_size() const {
  return _internal_num_new_size();
}
inline void Backup_Shells::clear_num_new() {
  num_new_.Clear();
}
inline int32_t Backup_Shells::_internal_num_new(int index) const {
  return num_new_.Get(index);
}
inline int32_t Backup_Shells::num_new(int index) const {
  // @@protoc_insertion_point(field_get:ei.Backup.Shells.num_new)
  return _internal_num_new(index);
}
inline void Backup_Shells::set_num_new(int index, int32_t value) {
  num_new_.Set(index, value);
  // @@protoc_insertion_point(field_set:ei.Backup.Shells.num_new)
}
inline void Backup_Shells::_internal_add_num_new(int32_t value) {
  num_new_.Add(value);
}
inline void Backup_Shells::add_num_new(int32_t value) {
  _internal_add_num_new(value);
  // @@protoc_insertion_point(field_add:ei.Backup.Shells.num_new)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Backup_Shells::_internal_num_new() const {
  return num_new_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Backup_Shells::num_new() const {
  // @@protoc_insertion_point(field_list:ei.Backup.Shells.num_new)
  return _internal_num_new();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Backup_Shells::_internal_mutable_num_new() {
  return &num_new_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Backup_Shells::mutable_num_new() {
  // @@protoc_insertion_point(field_mutable_list:ei.Backup.Shells.num_new)
  return _internal_mutable_num_new();
}

// -------------------------------------------------------------------

// Backup_Simulation

// optional .ei.Egg egg_type = 1;
inline bool Backup_Simulation::_internal_has_egg_type() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool Backup_Simulation::has_egg_type() const {
  return _internal_has_egg_type();
}
inline void Backup_Simulation::clear_egg_type() {
  egg_type_ = 1;
  _has_bits_[0] &= ~0x00200000u;
}
inline ::ei::Egg Backup_Simulation::_internal_egg_type() const {
  return static_cast< ::ei::Egg >(egg_type_);
}
inline ::ei::Egg Backup_Simulation::egg_type() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Simulation.egg_type)
  return _internal_egg_type();
}
inline void Backup_Simulation::_internal_set_egg_type(::ei::Egg value) {
  assert(::ei::Egg_IsValid(value));
  _has_bits_[0] |= 0x00200000u;
  egg_type_ = value;
}
inline void Backup_Simulation::set_egg_type(::ei::Egg value) {
  _internal_set_egg_type(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Simulation.egg_type)
}

// optional .ei.FarmType farm_type = 19;
inline bool Backup_Simulation::_internal_has_farm_type() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool Backup_Simulation::has_farm_type() const {
  return _internal_has_farm_type();
}
inline void Backup_Simulation::clear_farm_type() {
  farm_type_ = 1;
  _has_bits_[0] &= ~0x00400000u;
}
inline ::ei::FarmType Backup_Simulation::_internal_farm_type() const {
  return static_cast< ::ei::FarmType >(farm_type_);
}
inline ::ei::FarmType Backup_Simulation::farm_type() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Simulation.farm_type)
  return _internal_farm_type();
}
inline void Backup_Simulation::_internal_set_farm_type(::ei::FarmType value) {
  assert(::ei::FarmType_IsValid(value));
  _has_bits_[0] |= 0x00400000u;
  farm_type_ = value;
}
inline void Backup_Simulation::set_farm_type(::ei::FarmType value) {
  _internal_set_farm_type(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Simulation.farm_type)
}

// optional string contract_id = 20;
inline bool Backup_Simulation::_internal_has_contract_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Backup_Simulation::has_contract_id() const {
  return _internal_has_contract_id();
}
inline void Backup_Simulation::clear_contract_id() {
  contract_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Backup_Simulation::contract_id() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Simulation.contract_id)
  return _internal_contract_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Backup_Simulation::set_contract_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 contract_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.Backup.Simulation.contract_id)
}
inline std::string* Backup_Simulation::mutable_contract_id() {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:ei.Backup.Simulation.contract_id)
  return _s;
}
inline const std::string& Backup_Simulation::_internal_contract_id() const {
  return contract_id_.Get();
}
inline void Backup_Simulation::_internal_set_contract_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  contract_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Backup_Simulation::_internal_mutable_contract_id() {
  _has_bits_[0] |= 0x00000001u;
  return contract_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Backup_Simulation::release_contract_id() {
  // @@protoc_insertion_point(field_release:ei.Backup.Simulation.contract_id)
  if (!_internal_has_contract_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = contract_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Backup_Simulation::set_allocated_contract_id(std::string* contract_id) {
  if (contract_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  contract_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contract_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.Backup.Simulation.contract_id)
}

// optional double cash_earned = 2;
inline bool Backup_Simulation::_internal_has_cash_earned() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Backup_Simulation::has_cash_earned() const {
  return _internal_has_cash_earned();
}
inline void Backup_Simulation::clear_cash_earned() {
  cash_earned_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Backup_Simulation::_internal_cash_earned() const {
  return cash_earned_;
}
inline double Backup_Simulation::cash_earned() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Simulation.cash_earned)
  return _internal_cash_earned();
}
inline void Backup_Simulation::_internal_set_cash_earned(double value) {
  _has_bits_[0] |= 0x00000002u;
  cash_earned_ = value;
}
inline void Backup_Simulation::set_cash_earned(double value) {
  _internal_set_cash_earned(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Simulation.cash_earned)
}

// optional double cash_spent = 3;
inline bool Backup_Simulation::_internal_has_cash_spent() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Backup_Simulation::has_cash_spent() const {
  return _internal_has_cash_spent();
}
inline void Backup_Simulation::clear_cash_spent() {
  cash_spent_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double Backup_Simulation::_internal_cash_spent() const {
  return cash_spent_;
}
inline double Backup_Simulation::cash_spent() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Simulation.cash_spent)
  return _internal_cash_spent();
}
inline void Backup_Simulation::_internal_set_cash_spent(double value) {
  _has_bits_[0] |= 0x00000004u;
  cash_spent_ = value;
}
inline void Backup_Simulation::set_cash_spent(double value) {
  _internal_set_cash_spent(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Simulation.cash_spent)
}

// optional double unclaimed_cash = 4;
inline bool Backup_Simulation::_internal_has_unclaimed_cash() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Backup_Simulation::has_unclaimed_cash() const {
  return _internal_has_unclaimed_cash();
}
inline void Backup_Simulation::clear_unclaimed_cash() {
  unclaimed_cash_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double Backup_Simulation::_internal_unclaimed_cash() const {
  return unclaimed_cash_;
}
inline double Backup_Simulation::unclaimed_cash() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Simulation.unclaimed_cash)
  return _internal_unclaimed_cash();
}
inline void Backup_Simulation::_internal_set_unclaimed_cash(double value) {
  _has_bits_[0] |= 0x00000008u;
  unclaimed_cash_ = value;
}
inline void Backup_Simulation::set_unclaimed_cash(double value) {
  _internal_set_unclaimed_cash(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Simulation.unclaimed_cash)
}

// optional double last_step_time = 5;
inline bool Backup_Simulation::_internal_has_last_step_time() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Backup_Simulation::has_last_step_time() const {
  return _internal_has_last_step_time();
}
inline void Backup_Simulation::clear_last_step_time() {
  last_step_time_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double Backup_Simulation::_internal_last_step_time() const {
  return last_step_time_;
}
inline double Backup_Simulation::last_step_time() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Simulation.last_step_time)
  return _internal_last_step_time();
}
inline void Backup_Simulation::_internal_set_last_step_time(double value) {
  _has_bits_[0] |= 0x00000010u;
  last_step_time_ = value;
}
inline void Backup_Simulation::set_last_step_time(double value) {
  _internal_set_last_step_time(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Simulation.last_step_time)
}

// optional uint64 num_chickens = 6;
inline bool Backup_Simulation::_internal_has_num_chickens() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Backup_Simulation::has_num_chickens() const {
  return _internal_has_num_chickens();
}
inline void Backup_Simulation::clear_num_chickens() {
  num_chickens_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000020u;
}
inline uint64_t Backup_Simulation::_internal_num_chickens() const {
  return num_chickens_;
}
inline uint64_t Backup_Simulation::num_chickens() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Simulation.num_chickens)
  return _internal_num_chickens();
}
inline void Backup_Simulation::_internal_set_num_chickens(uint64_t value) {
  _has_bits_[0] |= 0x00000020u;
  num_chickens_ = value;
}
inline void Backup_Simulation::set_num_chickens(uint64_t value) {
  _internal_set_num_chickens(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Simulation.num_chickens)
}

// optional uint64 num_chickens_unsettled = 7;
inline bool Backup_Simulation::_internal_has_num_chickens_unsettled() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Backup_Simulation::has_num_chickens_unsettled() const {
  return _internal_has_num_chickens_unsettled();
}
inline void Backup_Simulation::clear_num_chickens_unsettled() {
  num_chickens_unsettled_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000040u;
}
inline uint64_t Backup_Simulation::_internal_num_chickens_unsettled() const {
  return num_chickens_unsettled_;
}
inline uint64_t Backup_Simulation::num_chickens_unsettled() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Simulation.num_chickens_unsettled)
  return _internal_num_chickens_unsettled();
}
inline void Backup_Simulation::_internal_set_num_chickens_unsettled(uint64_t value) {
  _has_bits_[0] |= 0x00000040u;
  num_chickens_unsettled_ = value;
}
inline void Backup_Simulation::set_num_chickens_unsettled(uint64_t value) {
  _internal_set_num_chickens_unsettled(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Simulation.num_chickens_unsettled)
}

// optional uint64 num_chickens_running = 8;
inline bool Backup_Simulation::_internal_has_num_chickens_running() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Backup_Simulation::has_num_chickens_running() const {
  return _internal_has_num_chickens_running();
}
inline void Backup_Simulation::clear_num_chickens_running() {
  num_chickens_running_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000080u;
}
inline uint64_t Backup_Simulation::_internal_num_chickens_running() const {
  return num_chickens_running_;
}
inline uint64_t Backup_Simulation::num_chickens_running() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Simulation.num_chickens_running)
  return _internal_num_chickens_running();
}
inline void Backup_Simulation::_internal_set_num_chickens_running(uint64_t value) {
  _has_bits_[0] |= 0x00000080u;
  num_chickens_running_ = value;
}
inline void Backup_Simulation::set_num_chickens_running(uint64_t value) {
  _internal_set_num_chickens_running(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Simulation.num_chickens_running)
}

// optional double eggs_laid = 9;
inline bool Backup_Simulation::_internal_has_eggs_laid() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Backup_Simulation::has_eggs_laid() const {
  return _internal_has_eggs_laid();
}
inline void Backup_Simulation::clear_eggs_laid() {
  eggs_laid_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline double Backup_Simulation::_internal_eggs_laid() const {
  return eggs_laid_;
}
inline double Backup_Simulation::eggs_laid() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Simulation.eggs_laid)
  return _internal_eggs_laid();
}
inline void Backup_Simulation::_internal_set_eggs_laid(double value) {
  _has_bits_[0] |= 0x00000100u;
  eggs_laid_ = value;
}
inline void Backup_Simulation::set_eggs_laid(double value) {
  _internal_set_eggs_laid(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Simulation.eggs_laid)
}

// optional double eggs_shipped = 30;
inline bool Backup_Simulation::_internal_has_eggs_shipped() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool Backup_Simulation::has_eggs_shipped() const {
  return _internal_has_eggs_shipped();
}
inline void Backup_Simulation::clear_eggs_shipped() {
  eggs_shipped_ = 0;
  _has_bits_[0] &= ~0x00080000u;
}
inline double Backup_Simulation::_internal_eggs_shipped() const {
  return eggs_shipped_;
}
inline double Backup_Simulation::eggs_shipped() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Simulation.eggs_shipped)
  return _internal_eggs_shipped();
}
inline void Backup_Simulation::_internal_set_eggs_shipped(double value) {
  _has_bits_[0] |= 0x00080000u;
  eggs_shipped_ = value;
}
inline void Backup_Simulation::set_eggs_shipped(double value) {
  _internal_set_eggs_shipped(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Simulation.eggs_shipped)
}

// optional double eggs_paid_for = 10;
inline bool Backup_Simulation::_internal_has_eggs_paid_for() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Backup_Simulation::has_eggs_paid_for() const {
  return _internal_has_eggs_paid_for();
}
inline void Backup_Simulation::clear_eggs_paid_for() {
  eggs_paid_for_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline double Backup_Simulation::_internal_eggs_paid_for() const {
  return eggs_paid_for_;
}
inline double Backup_Simulation::eggs_paid_for() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Simulation.eggs_paid_for)
  return _internal_eggs_paid_for();
}
inline void Backup_Simulation::_internal_set_eggs_paid_for(double value) {
  _has_bits_[0] |= 0x00000200u;
  eggs_paid_for_ = value;
}
inline void Backup_Simulation::set_eggs_paid_for(double value) {
  _internal_set_eggs_paid_for(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Simulation.eggs_paid_for)
}

// optional uint32 silos_owned = 11;
inline bool Backup_Simulation::_internal_has_silos_owned() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool Backup_Simulation::has_silos_owned() const {
  return _internal_has_silos_owned();
}
inline void Backup_Simulation::clear_silos_owned() {
  silos_owned_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline uint32_t Backup_Simulation::_internal_silos_owned() const {
  return silos_owned_;
}
inline uint32_t Backup_Simulation::silos_owned() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Simulation.silos_owned)
  return _internal_silos_owned();
}
inline void Backup_Simulation::_internal_set_silos_owned(uint32_t value) {
  _has_bits_[0] |= 0x00000800u;
  silos_owned_ = value;
}
inline void Backup_Simulation::set_silos_owned(uint32_t value) {
  _internal_set_silos_owned(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Simulation.silos_owned)
}

// repeated uint32 habs = 12;
inline int Backup_Simulation::_internal_habs_size() const {
  return habs_.size();
}
inline int Backup_Simulation::habs_size() const {
  return _internal_habs_size();
}
inline void Backup_Simulation::clear_habs() {
  habs_.Clear();
}
inline uint32_t Backup_Simulation::_internal_habs(int index) const {
  return habs_.Get(index);
}
inline uint32_t Backup_Simulation::habs(int index) const {
  // @@protoc_insertion_point(field_get:ei.Backup.Simulation.habs)
  return _internal_habs(index);
}
inline void Backup_Simulation::set_habs(int index, uint32_t value) {
  habs_.Set(index, value);
  // @@protoc_insertion_point(field_set:ei.Backup.Simulation.habs)
}
inline void Backup_Simulation::_internal_add_habs(uint32_t value) {
  habs_.Add(value);
}
inline void Backup_Simulation::add_habs(uint32_t value) {
  _internal_add_habs(value);
  // @@protoc_insertion_point(field_add:ei.Backup.Simulation.habs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Backup_Simulation::_internal_habs() const {
  return habs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Backup_Simulation::habs() const {
  // @@protoc_insertion_point(field_list:ei.Backup.Simulation.habs)
  return _internal_habs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Backup_Simulation::_internal_mutable_habs() {
  return &habs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Backup_Simulation::mutable_habs() {
  // @@protoc_insertion_point(field_mutable_list:ei.Backup.Simulation.habs)
  return _internal_mutable_habs();
}

// repeated uint64 hab_population = 13;
inline int Backup_Simulation::_internal_hab_population_size() const {
  return hab_population_.size();
}
inline int Backup_Simulation::hab_population_size() const {
  return _internal_hab_population_size();
}
inline void Backup_Simulation::clear_hab_population() {
  hab_population_.Clear();
}
inline uint64_t Backup_Simulation::_internal_hab_population(int index) const {
  return hab_population_.Get(index);
}
inline uint64_t Backup_Simulation::hab_population(int index) const {
  // @@protoc_insertion_point(field_get:ei.Backup.Simulation.hab_population)
  return _internal_hab_population(index);
}
inline void Backup_Simulation::set_hab_population(int index, uint64_t value) {
  hab_population_.Set(index, value);
  // @@protoc_insertion_point(field_set:ei.Backup.Simulation.hab_population)
}
inline void Backup_Simulation::_internal_add_hab_population(uint64_t value) {
  hab_population_.Add(value);
}
inline void Backup_Simulation::add_hab_population(uint64_t value) {
  _internal_add_hab_population(value);
  // @@protoc_insertion_point(field_add:ei.Backup.Simulation.hab_population)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Backup_Simulation::_internal_hab_population() const {
  return hab_population_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Backup_Simulation::hab_population() const {
  // @@protoc_insertion_point(field_list:ei.Backup.Simulation.hab_population)
  return _internal_hab_population();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Backup_Simulation::_internal_mutable_hab_population() {
  return &hab_population_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Backup_Simulation::mutable_hab_population() {
  // @@protoc_insertion_point(field_mutable_list:ei.Backup.Simulation.hab_population)
  return _internal_mutable_hab_population();
}

// repeated uint64 hab_population_indound = 14;
inline int Backup_Simulation::_internal_hab_population_indound_size() const {
  return hab_population_indound_.size();
}
inline int Backup_Simulation::hab_population_indound_size() const {
  return _internal_hab_population_indound_size();
}
inline void Backup_Simulation::clear_hab_population_indound() {
  hab_population_indound_.Clear();
}
inline uint64_t Backup_Simulation::_internal_hab_population_indound(int index) const {
  return hab_population_indound_.Get(index);
}
inline uint64_t Backup_Simulation::hab_population_indound(int index) const {
  // @@protoc_insertion_point(field_get:ei.Backup.Simulation.hab_population_indound)
  return _internal_hab_population_indound(index);
}
inline void Backup_Simulation::set_hab_population_indound(int index, uint64_t value) {
  hab_population_indound_.Set(index, value);
  // @@protoc_insertion_point(field_set:ei.Backup.Simulation.hab_population_indound)
}
inline void Backup_Simulation::_internal_add_hab_population_indound(uint64_t value) {
  hab_population_indound_.Add(value);
}
inline void Backup_Simulation::add_hab_population_indound(uint64_t value) {
  _internal_add_hab_population_indound(value);
  // @@protoc_insertion_point(field_add:ei.Backup.Simulation.hab_population_indound)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Backup_Simulation::_internal_hab_population_indound() const {
  return hab_population_indound_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Backup_Simulation::hab_population_indound() const {
  // @@protoc_insertion_point(field_list:ei.Backup.Simulation.hab_population_indound)
  return _internal_hab_population_indound();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Backup_Simulation::_internal_mutable_hab_population_indound() {
  return &hab_population_indound_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Backup_Simulation::mutable_hab_population_indound() {
  // @@protoc_insertion_point(field_mutable_list:ei.Backup.Simulation.hab_population_indound)
  return _internal_mutable_hab_population_indound();
}

// repeated double hab_incubator_popuplation = 15;
inline int Backup_Simulation::_internal_hab_incubator_popuplation_size() const {
  return hab_incubator_popuplation_.size();
}
inline int Backup_Simulation::hab_incubator_popuplation_size() const {
  return _internal_hab_incubator_popuplation_size();
}
inline void Backup_Simulation::clear_hab_incubator_popuplation() {
  hab_incubator_popuplation_.Clear();
}
inline double Backup_Simulation::_internal_hab_incubator_popuplation(int index) const {
  return hab_incubator_popuplation_.Get(index);
}
inline double Backup_Simulation::hab_incubator_popuplation(int index) const {
  // @@protoc_insertion_point(field_get:ei.Backup.Simulation.hab_incubator_popuplation)
  return _internal_hab_incubator_popuplation(index);
}
inline void Backup_Simulation::set_hab_incubator_popuplation(int index, double value) {
  hab_incubator_popuplation_.Set(index, value);
  // @@protoc_insertion_point(field_set:ei.Backup.Simulation.hab_incubator_popuplation)
}
inline void Backup_Simulation::_internal_add_hab_incubator_popuplation(double value) {
  hab_incubator_popuplation_.Add(value);
}
inline void Backup_Simulation::add_hab_incubator_popuplation(double value) {
  _internal_add_hab_incubator_popuplation(value);
  // @@protoc_insertion_point(field_add:ei.Backup.Simulation.hab_incubator_popuplation)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Backup_Simulation::_internal_hab_incubator_popuplation() const {
  return hab_incubator_popuplation_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Backup_Simulation::hab_incubator_popuplation() const {
  // @@protoc_insertion_point(field_list:ei.Backup.Simulation.hab_incubator_popuplation)
  return _internal_hab_incubator_popuplation();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Backup_Simulation::_internal_mutable_hab_incubator_popuplation() {
  return &hab_incubator_popuplation_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Backup_Simulation::mutable_hab_incubator_popuplation() {
  // @@protoc_insertion_point(field_mutable_list:ei.Backup.Simulation.hab_incubator_popuplation)
  return _internal_mutable_hab_incubator_popuplation();
}

// optional double hatchery_population = 16;
inline bool Backup_Simulation::_internal_has_hatchery_population() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Backup_Simulation::has_hatchery_population() const {
  return _internal_has_hatchery_population();
}
inline void Backup_Simulation::clear_hatchery_population() {
  hatchery_population_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline double Backup_Simulation::_internal_hatchery_population() const {
  return hatchery_population_;
}
inline double Backup_Simulation::hatchery_population() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Simulation.hatchery_population)
  return _internal_hatchery_population();
}
inline void Backup_Simulation::_internal_set_hatchery_population(double value) {
  _has_bits_[0] |= 0x00000400u;
  hatchery_population_ = value;
}
inline void Backup_Simulation::set_hatchery_population(double value) {
  _internal_set_hatchery_population(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Simulation.hatchery_population)
}

// repeated uint32 vehicles = 17;
inline int Backup_Simulation::_internal_vehicles_size() const {
  return vehicles_.size();
}
inline int Backup_Simulation::vehicles_size() const {
  return _internal_vehicles_size();
}
inline void Backup_Simulation::clear_vehicles() {
  vehicles_.Clear();
}
inline uint32_t Backup_Simulation::_internal_vehicles(int index) const {
  return vehicles_.Get(index);
}
inline uint32_t Backup_Simulation::vehicles(int index) const {
  // @@protoc_insertion_point(field_get:ei.Backup.Simulation.vehicles)
  return _internal_vehicles(index);
}
inline void Backup_Simulation::set_vehicles(int index, uint32_t value) {
  vehicles_.Set(index, value);
  // @@protoc_insertion_point(field_set:ei.Backup.Simulation.vehicles)
}
inline void Backup_Simulation::_internal_add_vehicles(uint32_t value) {
  vehicles_.Add(value);
}
inline void Backup_Simulation::add_vehicles(uint32_t value) {
  _internal_add_vehicles(value);
  // @@protoc_insertion_point(field_add:ei.Backup.Simulation.vehicles)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Backup_Simulation::_internal_vehicles() const {
  return vehicles_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Backup_Simulation::vehicles() const {
  // @@protoc_insertion_point(field_list:ei.Backup.Simulation.vehicles)
  return _internal_vehicles();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Backup_Simulation::_internal_mutable_vehicles() {
  return &vehicles_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Backup_Simulation::mutable_vehicles() {
  // @@protoc_insertion_point(field_mutable_list:ei.Backup.Simulation.vehicles)
  return _internal_mutable_vehicles();
}

// repeated uint32 train_length = 21;
inline int Backup_Simulation::_internal_train_length_size() const {
  return train_length_.size();
}
inline int Backup_Simulation::train_length_size() const {
  return _internal_train_length_size();
}
inline void Backup_Simulation::clear_train_length() {
  train_length_.Clear();
}
inline uint32_t Backup_Simulation::_internal_train_length(int index) const {
  return train_length_.Get(index);
}
inline uint32_t Backup_Simulation::train_length(int index) const {
  // @@protoc_insertion_point(field_get:ei.Backup.Simulation.train_length)
  return _internal_train_length(index);
}
inline void Backup_Simulation::set_train_length(int index, uint32_t value) {
  train_length_.Set(index, value);
  // @@protoc_insertion_point(field_set:ei.Backup.Simulation.train_length)
}
inline void Backup_Simulation::_internal_add_train_length(uint32_t value) {
  train_length_.Add(value);
}
inline void Backup_Simulation::add_train_length(uint32_t value) {
  _internal_add_train_length(value);
  // @@protoc_insertion_point(field_add:ei.Backup.Simulation.train_length)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Backup_Simulation::_internal_train_length() const {
  return train_length_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Backup_Simulation::train_length() const {
  // @@protoc_insertion_point(field_list:ei.Backup.Simulation.train_length)
  return _internal_train_length();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Backup_Simulation::_internal_mutable_train_length() {
  return &train_length_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Backup_Simulation::mutable_train_length() {
  // @@protoc_insertion_point(field_mutable_list:ei.Backup.Simulation.train_length)
  return _internal_mutable_train_length();
}

// repeated .ei.Backup.ResearchItem common_research = 18;
inline int Backup_Simulation::_internal_common_research_size() const {
  return common_research_.size();
}
inline int Backup_Simulation::common_research_size() const {
  return _internal_common_research_size();
}
inline void Backup_Simulation::clear_common_research() {
  common_research_.Clear();
}
inline ::ei::Backup_ResearchItem* Backup_Simulation::mutable_common_research(int index) {
  // @@protoc_insertion_point(field_mutable:ei.Backup.Simulation.common_research)
  return common_research_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_ResearchItem >*
Backup_Simulation::mutable_common_research() {
  // @@protoc_insertion_point(field_mutable_list:ei.Backup.Simulation.common_research)
  return &common_research_;
}
inline const ::ei::Backup_ResearchItem& Backup_Simulation::_internal_common_research(int index) const {
  return common_research_.Get(index);
}
inline const ::ei::Backup_ResearchItem& Backup_Simulation::common_research(int index) const {
  // @@protoc_insertion_point(field_get:ei.Backup.Simulation.common_research)
  return _internal_common_research(index);
}
inline ::ei::Backup_ResearchItem* Backup_Simulation::_internal_add_common_research() {
  return common_research_.Add();
}
inline ::ei::Backup_ResearchItem* Backup_Simulation::add_common_research() {
  ::ei::Backup_ResearchItem* _add = _internal_add_common_research();
  // @@protoc_insertion_point(field_add:ei.Backup.Simulation.common_research)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_ResearchItem >&
Backup_Simulation::common_research() const {
  // @@protoc_insertion_point(field_list:ei.Backup.Simulation.common_research)
  return common_research_;
}

// repeated .ei.Backup.ActiveBoost active_boosts = 22;
inline int Backup_Simulation::_internal_active_boosts_size() const {
  return active_boosts_.size();
}
inline int Backup_Simulation::active_boosts_size() const {
  return _internal_active_boosts_size();
}
inline void Backup_Simulation::clear_active_boosts() {
  active_boosts_.Clear();
}
inline ::ei::Backup_ActiveBoost* Backup_Simulation::mutable_active_boosts(int index) {
  // @@protoc_insertion_point(field_mutable:ei.Backup.Simulation.active_boosts)
  return active_boosts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_ActiveBoost >*
Backup_Simulation::mutable_active_boosts() {
  // @@protoc_insertion_point(field_mutable_list:ei.Backup.Simulation.active_boosts)
  return &active_boosts_;
}
inline const ::ei::Backup_ActiveBoost& Backup_Simulation::_internal_active_boosts(int index) const {
  return active_boosts_.Get(index);
}
inline const ::ei::Backup_ActiveBoost& Backup_Simulation::active_boosts(int index) const {
  // @@protoc_insertion_point(field_get:ei.Backup.Simulation.active_boosts)
  return _internal_active_boosts(index);
}
inline ::ei::Backup_ActiveBoost* Backup_Simulation::_internal_add_active_boosts() {
  return active_boosts_.Add();
}
inline ::ei::Backup_ActiveBoost* Backup_Simulation::add_active_boosts() {
  ::ei::Backup_ActiveBoost* _add = _internal_add_active_boosts();
  // @@protoc_insertion_point(field_add:ei.Backup.Simulation.active_boosts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_ActiveBoost >&
Backup_Simulation::active_boosts() const {
  // @@protoc_insertion_point(field_list:ei.Backup.Simulation.active_boosts)
  return active_boosts_;
}

// optional double last_cash_boost_time = 31;
inline bool Backup_Simulation::_internal_has_last_cash_boost_time() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool Backup_Simulation::has_last_cash_boost_time() const {
  return _internal_has_last_cash_boost_time();
}
inline void Backup_Simulation::clear_last_cash_boost_time() {
  last_cash_boost_time_ = 0;
  _has_bits_[0] &= ~0x00100000u;
}
inline double Backup_Simulation::_internal_last_cash_boost_time() const {
  return last_cash_boost_time_;
}
inline double Backup_Simulation::last_cash_boost_time() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Simulation.last_cash_boost_time)
  return _internal_last_cash_boost_time();
}
inline void Backup_Simulation::_internal_set_last_cash_boost_time(double value) {
  _has_bits_[0] |= 0x00100000u;
  last_cash_boost_time_ = value;
}
inline void Backup_Simulation::set_last_cash_boost_time(double value) {
  _internal_set_last_cash_boost_time(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Simulation.last_cash_boost_time)
}

// optional uint32 time_cheats_detected = 23;
inline bool Backup_Simulation::_internal_has_time_cheats_detected() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Backup_Simulation::has_time_cheats_detected() const {
  return _internal_has_time_cheats_detected();
}
inline void Backup_Simulation::clear_time_cheats_detected() {
  time_cheats_detected_ = 0u;
  _has_bits_[0] &= ~0x00001000u;
}
inline uint32_t Backup_Simulation::_internal_time_cheats_detected() const {
  return time_cheats_detected_;
}
inline uint32_t Backup_Simulation::time_cheats_detected() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Simulation.time_cheats_detected)
  return _internal_time_cheats_detected();
}
inline void Backup_Simulation::_internal_set_time_cheats_detected(uint32_t value) {
  _has_bits_[0] |= 0x00001000u;
  time_cheats_detected_ = value;
}
inline void Backup_Simulation::set_time_cheats_detected(uint32_t value) {
  _internal_set_time_cheats_detected(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Simulation.time_cheats_detected)
}

// optional double time_cheat_debt = 24;
inline bool Backup_Simulation::_internal_has_time_cheat_debt() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Backup_Simulation::has_time_cheat_debt() const {
  return _internal_has_time_cheat_debt();
}
inline void Backup_Simulation::clear_time_cheat_debt() {
  time_cheat_debt_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline double Backup_Simulation::_internal_time_cheat_debt() const {
  return time_cheat_debt_;
}
inline double Backup_Simulation::time_cheat_debt() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Simulation.time_cheat_debt)
  return _internal_time_cheat_debt();
}
inline void Backup_Simulation::_internal_set_time_cheat_debt(double value) {
  _has_bits_[0] |= 0x00002000u;
  time_cheat_debt_ = value;
}
inline void Backup_Simulation::set_time_cheat_debt(double value) {
  _internal_set_time_cheat_debt(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Simulation.time_cheat_debt)
}

// optional uint32 boost_tokens_received = 25;
inline bool Backup_Simulation::_internal_has_boost_tokens_received() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Backup_Simulation::has_boost_tokens_received() const {
  return _internal_has_boost_tokens_received();
}
inline void Backup_Simulation::clear_boost_tokens_received() {
  boost_tokens_received_ = 0u;
  _has_bits_[0] &= ~0x00004000u;
}
inline uint32_t Backup_Simulation::_internal_boost_tokens_received() const {
  return boost_tokens_received_;
}
inline uint32_t Backup_Simulation::boost_tokens_received() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Simulation.boost_tokens_received)
  return _internal_boost_tokens_received();
}
inline void Backup_Simulation::_internal_set_boost_tokens_received(uint32_t value) {
  _has_bits_[0] |= 0x00004000u;
  boost_tokens_received_ = value;
}
inline void Backup_Simulation::set_boost_tokens_received(uint32_t value) {
  _internal_set_boost_tokens_received(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Simulation.boost_tokens_received)
}

// optional uint32 boost_tokens_spent = 26;
inline bool Backup_Simulation::_internal_has_boost_tokens_spent() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool Backup_Simulation::has_boost_tokens_spent() const {
  return _internal_has_boost_tokens_spent();
}
inline void Backup_Simulation::clear_boost_tokens_spent() {
  boost_tokens_spent_ = 0u;
  _has_bits_[0] &= ~0x00008000u;
}
inline uint32_t Backup_Simulation::_internal_boost_tokens_spent() const {
  return boost_tokens_spent_;
}
inline uint32_t Backup_Simulation::boost_tokens_spent() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Simulation.boost_tokens_spent)
  return _internal_boost_tokens_spent();
}
inline void Backup_Simulation::_internal_set_boost_tokens_spent(uint32_t value) {
  _has_bits_[0] |= 0x00008000u;
  boost_tokens_spent_ = value;
}
inline void Backup_Simulation::set_boost_tokens_spent(uint32_t value) {
  _internal_set_boost_tokens_spent(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Simulation.boost_tokens_spent)
}

// optional uint32 boost_tokens_given = 28;
inline bool Backup_Simulation::_internal_has_boost_tokens_given() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool Backup_Simulation::has_boost_tokens_given() const {
  return _internal_has_boost_tokens_given();
}
inline void Backup_Simulation::clear_boost_tokens_given() {
  boost_tokens_given_ = 0u;
  _has_bits_[0] &= ~0x00020000u;
}
inline uint32_t Backup_Simulation::_internal_boost_tokens_given() const {
  return boost_tokens_given_;
}
inline uint32_t Backup_Simulation::boost_tokens_given() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Simulation.boost_tokens_given)
  return _internal_boost_tokens_given();
}
inline void Backup_Simulation::_internal_set_boost_tokens_given(uint32_t value) {
  _has_bits_[0] |= 0x00020000u;
  boost_tokens_given_ = value;
}
inline void Backup_Simulation::set_boost_tokens_given(uint32_t value) {
  _internal_set_boost_tokens_given(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Simulation.boost_tokens_given)
}

// optional uint32 unclaimed_boost_tokens = 27;
inline bool Backup_Simulation::_internal_has_unclaimed_boost_tokens() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool Backup_Simulation::has_unclaimed_boost_tokens() const {
  return _internal_has_unclaimed_boost_tokens();
}
inline void Backup_Simulation::clear_unclaimed_boost_tokens() {
  unclaimed_boost_tokens_ = 0u;
  _has_bits_[0] &= ~0x00010000u;
}
inline uint32_t Backup_Simulation::_internal_unclaimed_boost_tokens() const {
  return unclaimed_boost_tokens_;
}
inline uint32_t Backup_Simulation::unclaimed_boost_tokens() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Simulation.unclaimed_boost_tokens)
  return _internal_unclaimed_boost_tokens();
}
inline void Backup_Simulation::_internal_set_unclaimed_boost_tokens(uint32_t value) {
  _has_bits_[0] |= 0x00010000u;
  unclaimed_boost_tokens_ = value;
}
inline void Backup_Simulation::set_unclaimed_boost_tokens(uint32_t value) {
  _internal_set_unclaimed_boost_tokens(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Simulation.unclaimed_boost_tokens)
}

// optional double gametime_until_next_boost_token = 29;
inline bool Backup_Simulation::_internal_has_gametime_until_next_boost_token() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool Backup_Simulation::has_gametime_until_next_boost_token() const {
  return _internal_has_gametime_until_next_boost_token();
}
inline void Backup_Simulation::clear_gametime_until_next_boost_token() {
  gametime_until_next_boost_token_ = 0;
  _has_bits_[0] &= ~0x00040000u;
}
inline double Backup_Simulation::_internal_gametime_until_next_boost_token() const {
  return gametime_until_next_boost_token_;
}
inline double Backup_Simulation::gametime_until_next_boost_token() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Simulation.gametime_until_next_boost_token)
  return _internal_gametime_until_next_boost_token();
}
inline void Backup_Simulation::_internal_set_gametime_until_next_boost_token(double value) {
  _has_bits_[0] |= 0x00040000u;
  gametime_until_next_boost_token_ = value;
}
inline void Backup_Simulation::set_gametime_until_next_boost_token(double value) {
  _internal_set_gametime_until_next_boost_token(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Simulation.gametime_until_next_boost_token)
}

// -------------------------------------------------------------------

// Backup_Mission

// optional string current_mission = 1;
inline bool Backup_Mission::_internal_has_current_mission() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Backup_Mission::has_current_mission() const {
  return _internal_has_current_mission();
}
inline void Backup_Mission::clear_current_mission() {
  current_mission_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Backup_Mission::current_mission() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Mission.current_mission)
  return _internal_current_mission();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Backup_Mission::set_current_mission(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 current_mission_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.Backup.Mission.current_mission)
}
inline std::string* Backup_Mission::mutable_current_mission() {
  std::string* _s = _internal_mutable_current_mission();
  // @@protoc_insertion_point(field_mutable:ei.Backup.Mission.current_mission)
  return _s;
}
inline const std::string& Backup_Mission::_internal_current_mission() const {
  return current_mission_.Get();
}
inline void Backup_Mission::_internal_set_current_mission(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  current_mission_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Backup_Mission::_internal_mutable_current_mission() {
  _has_bits_[0] |= 0x00000001u;
  return current_mission_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Backup_Mission::release_current_mission() {
  // @@protoc_insertion_point(field_release:ei.Backup.Mission.current_mission)
  if (!_internal_has_current_mission()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = current_mission_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (current_mission_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    current_mission_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Backup_Mission::set_allocated_current_mission(std::string* current_mission) {
  if (current_mission != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  current_mission_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), current_mission,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (current_mission_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    current_mission_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.Backup.Mission.current_mission)
}

// optional double reference_value = 2;
inline bool Backup_Mission::_internal_has_reference_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Backup_Mission::has_reference_value() const {
  return _internal_has_reference_value();
}
inline void Backup_Mission::clear_reference_value() {
  reference_value_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Backup_Mission::_internal_reference_value() const {
  return reference_value_;
}
inline double Backup_Mission::reference_value() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Mission.reference_value)
  return _internal_reference_value();
}
inline void Backup_Mission::_internal_set_reference_value(double value) {
  _has_bits_[0] |= 0x00000002u;
  reference_value_ = value;
}
inline void Backup_Mission::set_reference_value(double value) {
  _internal_set_reference_value(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Mission.reference_value)
}

// repeated string current_missions = 4;
inline int Backup_Mission::_internal_current_missions_size() const {
  return current_missions_.size();
}
inline int Backup_Mission::current_missions_size() const {
  return _internal_current_missions_size();
}
inline void Backup_Mission::clear_current_missions() {
  current_missions_.Clear();
}
inline std::string* Backup_Mission::add_current_missions() {
  std::string* _s = _internal_add_current_missions();
  // @@protoc_insertion_point(field_add_mutable:ei.Backup.Mission.current_missions)
  return _s;
}
inline const std::string& Backup_Mission::_internal_current_missions(int index) const {
  return current_missions_.Get(index);
}
inline const std::string& Backup_Mission::current_missions(int index) const {
  // @@protoc_insertion_point(field_get:ei.Backup.Mission.current_missions)
  return _internal_current_missions(index);
}
inline std::string* Backup_Mission::mutable_current_missions(int index) {
  // @@protoc_insertion_point(field_mutable:ei.Backup.Mission.current_missions)
  return current_missions_.Mutable(index);
}
inline void Backup_Mission::set_current_missions(int index, const std::string& value) {
  current_missions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Mission.current_missions)
}
inline void Backup_Mission::set_current_missions(int index, std::string&& value) {
  current_missions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ei.Backup.Mission.current_missions)
}
inline void Backup_Mission::set_current_missions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  current_missions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ei.Backup.Mission.current_missions)
}
inline void Backup_Mission::set_current_missions(int index, const char* value, size_t size) {
  current_missions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ei.Backup.Mission.current_missions)
}
inline std::string* Backup_Mission::_internal_add_current_missions() {
  return current_missions_.Add();
}
inline void Backup_Mission::add_current_missions(const std::string& value) {
  current_missions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ei.Backup.Mission.current_missions)
}
inline void Backup_Mission::add_current_missions(std::string&& value) {
  current_missions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ei.Backup.Mission.current_missions)
}
inline void Backup_Mission::add_current_missions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  current_missions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ei.Backup.Mission.current_missions)
}
inline void Backup_Mission::add_current_missions(const char* value, size_t size) {
  current_missions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ei.Backup.Mission.current_missions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Backup_Mission::current_missions() const {
  // @@protoc_insertion_point(field_list:ei.Backup.Mission.current_missions)
  return current_missions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Backup_Mission::mutable_current_missions() {
  // @@protoc_insertion_point(field_mutable_list:ei.Backup.Mission.current_missions)
  return &current_missions_;
}

// repeated .ei.Backup.MissionInfo missions = 3;
inline int Backup_Mission::_internal_missions_size() const {
  return missions_.size();
}
inline int Backup_Mission::missions_size() const {
  return _internal_missions_size();
}
inline void Backup_Mission::clear_missions() {
  missions_.Clear();
}
inline ::ei::Backup_MissionInfo* Backup_Mission::mutable_missions(int index) {
  // @@protoc_insertion_point(field_mutable:ei.Backup.Mission.missions)
  return missions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_MissionInfo >*
Backup_Mission::mutable_missions() {
  // @@protoc_insertion_point(field_mutable_list:ei.Backup.Mission.missions)
  return &missions_;
}
inline const ::ei::Backup_MissionInfo& Backup_Mission::_internal_missions(int index) const {
  return missions_.Get(index);
}
inline const ::ei::Backup_MissionInfo& Backup_Mission::missions(int index) const {
  // @@protoc_insertion_point(field_get:ei.Backup.Mission.missions)
  return _internal_missions(index);
}
inline ::ei::Backup_MissionInfo* Backup_Mission::_internal_add_missions() {
  return missions_.Add();
}
inline ::ei::Backup_MissionInfo* Backup_Mission::add_missions() {
  ::ei::Backup_MissionInfo* _add = _internal_add_missions();
  // @@protoc_insertion_point(field_add:ei.Backup.Mission.missions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_MissionInfo >&
Backup_Mission::missions() const {
  // @@protoc_insertion_point(field_list:ei.Backup.Mission.missions)
  return missions_;
}

// -------------------------------------------------------------------

// Backup_Misc

// optional bool chicken_btn_pref_big = 1;
inline bool Backup_Misc::_internal_has_chicken_btn_pref_big() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Backup_Misc::has_chicken_btn_pref_big() const {
  return _internal_has_chicken_btn_pref_big();
}
inline void Backup_Misc::clear_chicken_btn_pref_big() {
  chicken_btn_pref_big_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool Backup_Misc::_internal_chicken_btn_pref_big() const {
  return chicken_btn_pref_big_;
}
inline bool Backup_Misc::chicken_btn_pref_big() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Misc.chicken_btn_pref_big)
  return _internal_chicken_btn_pref_big();
}
inline void Backup_Misc::_internal_set_chicken_btn_pref_big(bool value) {
  _has_bits_[0] |= 0x00000010u;
  chicken_btn_pref_big_ = value;
}
inline void Backup_Misc::set_chicken_btn_pref_big(bool value) {
  _internal_set_chicken_btn_pref_big(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Misc.chicken_btn_pref_big)
}

// optional bool free_hatchery_refill_given = 2;
inline bool Backup_Misc::_internal_has_free_hatchery_refill_given() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Backup_Misc::has_free_hatchery_refill_given() const {
  return _internal_has_free_hatchery_refill_given();
}
inline void Backup_Misc::clear_free_hatchery_refill_given() {
  free_hatchery_refill_given_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool Backup_Misc::_internal_free_hatchery_refill_given() const {
  return free_hatchery_refill_given_;
}
inline bool Backup_Misc::free_hatchery_refill_given() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Misc.free_hatchery_refill_given)
  return _internal_free_hatchery_refill_given();
}
inline void Backup_Misc::_internal_set_free_hatchery_refill_given(bool value) {
  _has_bits_[0] |= 0x00000020u;
  free_hatchery_refill_given_ = value;
}
inline void Backup_Misc::set_free_hatchery_refill_given(bool value) {
  _internal_set_free_hatchery_refill_given(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Misc.free_hatchery_refill_given)
}

// optional double last_share_farm_value = 3 [default = 10000000];
inline bool Backup_Misc::_internal_has_last_share_farm_value() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool Backup_Misc::has_last_share_farm_value() const {
  return _internal_has_last_share_farm_value();
}
inline void Backup_Misc::clear_last_share_farm_value() {
  last_share_farm_value_ = 10000000;
  _has_bits_[0] &= ~0x00010000u;
}
inline double Backup_Misc::_internal_last_share_farm_value() const {
  return last_share_farm_value_;
}
inline double Backup_Misc::last_share_farm_value() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Misc.last_share_farm_value)
  return _internal_last_share_farm_value();
}
inline void Backup_Misc::_internal_set_last_share_farm_value(double value) {
  _has_bits_[0] |= 0x00010000u;
  last_share_farm_value_ = value;
}
inline void Backup_Misc::set_last_share_farm_value(double value) {
  _internal_set_last_share_farm_value(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Misc.last_share_farm_value)
}

// optional double last_share_swarm_farm_value = 4 [default = 10000000];
inline bool Backup_Misc::_internal_has_last_share_swarm_farm_value() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool Backup_Misc::has_last_share_swarm_farm_value() const {
  return _internal_has_last_share_swarm_farm_value();
}
inline void Backup_Misc::clear_last_share_swarm_farm_value() {
  last_share_swarm_farm_value_ = 10000000;
  _has_bits_[0] &= ~0x00020000u;
}
inline double Backup_Misc::_internal_last_share_swarm_farm_value() const {
  return last_share_swarm_farm_value_;
}
inline double Backup_Misc::last_share_swarm_farm_value() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Misc.last_share_swarm_farm_value)
  return _internal_last_share_swarm_farm_value();
}
inline void Backup_Misc::_internal_set_last_share_swarm_farm_value(double value) {
  _has_bits_[0] |= 0x00020000u;
  last_share_swarm_farm_value_ = value;
}
inline void Backup_Misc::set_last_share_swarm_farm_value(double value) {
  _internal_set_last_share_swarm_farm_value(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Misc.last_share_swarm_farm_value)
}

// optional double last_share_swarm_size = 5 [default = 140];
inline bool Backup_Misc::_internal_has_last_share_swarm_size() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool Backup_Misc::has_last_share_swarm_size() const {
  return _internal_has_last_share_swarm_size();
}
inline void Backup_Misc::clear_last_share_swarm_size() {
  last_share_swarm_size_ = 140;
  _has_bits_[0] &= ~0x00040000u;
}
inline double Backup_Misc::_internal_last_share_swarm_size() const {
  return last_share_swarm_size_;
}
inline double Backup_Misc::last_share_swarm_size() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Misc.last_share_swarm_size)
  return _internal_last_share_swarm_size();
}
inline void Backup_Misc::_internal_set_last_share_swarm_size(double value) {
  _has_bits_[0] |= 0x00040000u;
  last_share_swarm_size_ = value;
}
inline void Backup_Misc::set_last_share_swarm_size(double value) {
  _internal_set_last_share_swarm_size(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Misc.last_share_swarm_size)
}

// optional uint64 last_prestige_alert_soul_eggs_DEPRECATED = 10 [default = 45];
inline bool Backup_Misc::_internal_has_last_prestige_alert_soul_eggs_deprecated() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool Backup_Misc::has_last_prestige_alert_soul_eggs_deprecated() const {
  return _internal_has_last_prestige_alert_soul_eggs_deprecated();
}
inline void Backup_Misc::clear_last_prestige_alert_soul_eggs_deprecated() {
  last_prestige_alert_soul_eggs_deprecated_ = uint64_t{45u};
  _has_bits_[0] &= ~0x00080000u;
}
inline uint64_t Backup_Misc::_internal_last_prestige_alert_soul_eggs_deprecated() const {
  return last_prestige_alert_soul_eggs_deprecated_;
}
inline uint64_t Backup_Misc::last_prestige_alert_soul_eggs_deprecated() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Misc.last_prestige_alert_soul_eggs_DEPRECATED)
  return _internal_last_prestige_alert_soul_eggs_deprecated();
}
inline void Backup_Misc::_internal_set_last_prestige_alert_soul_eggs_deprecated(uint64_t value) {
  _has_bits_[0] |= 0x00080000u;
  last_prestige_alert_soul_eggs_deprecated_ = value;
}
inline void Backup_Misc::set_last_prestige_alert_soul_eggs_deprecated(uint64_t value) {
  _internal_set_last_prestige_alert_soul_eggs_deprecated(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Misc.last_prestige_alert_soul_eggs_DEPRECATED)
}

// optional uint64 friend_rank = 6;
inline bool Backup_Misc::_internal_has_friend_rank() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Backup_Misc::has_friend_rank() const {
  return _internal_has_friend_rank();
}
inline void Backup_Misc::clear_friend_rank() {
  friend_rank_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t Backup_Misc::_internal_friend_rank() const {
  return friend_rank_;
}
inline uint64_t Backup_Misc::friend_rank() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Misc.friend_rank)
  return _internal_friend_rank();
}
inline void Backup_Misc::_internal_set_friend_rank(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  friend_rank_ = value;
}
inline void Backup_Misc::set_friend_rank(uint64_t value) {
  _internal_set_friend_rank(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Misc.friend_rank)
}

// optional uint64 friend_rank_pop = 7;
inline bool Backup_Misc::_internal_has_friend_rank_pop() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Backup_Misc::has_friend_rank_pop() const {
  return _internal_has_friend_rank_pop();
}
inline void Backup_Misc::clear_friend_rank_pop() {
  friend_rank_pop_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t Backup_Misc::_internal_friend_rank_pop() const {
  return friend_rank_pop_;
}
inline uint64_t Backup_Misc::friend_rank_pop() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Misc.friend_rank_pop)
  return _internal_friend_rank_pop();
}
inline void Backup_Misc::_internal_set_friend_rank_pop(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  friend_rank_pop_ = value;
}
inline void Backup_Misc::set_friend_rank_pop(uint64_t value) {
  _internal_set_friend_rank_pop(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Misc.friend_rank_pop)
}

// optional uint64 global_rank = 8;
inline bool Backup_Misc::_internal_has_global_rank() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Backup_Misc::has_global_rank() const {
  return _internal_has_global_rank();
}
inline void Backup_Misc::clear_global_rank() {
  global_rank_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t Backup_Misc::_internal_global_rank() const {
  return global_rank_;
}
inline uint64_t Backup_Misc::global_rank() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Misc.global_rank)
  return _internal_global_rank();
}
inline void Backup_Misc::_internal_set_global_rank(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  global_rank_ = value;
}
inline void Backup_Misc::set_global_rank(uint64_t value) {
  _internal_set_global_rank(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Misc.global_rank)
}

// optional uint64 global_rank_pop = 9;
inline bool Backup_Misc::_internal_has_global_rank_pop() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Backup_Misc::has_global_rank_pop() const {
  return _internal_has_global_rank_pop();
}
inline void Backup_Misc::clear_global_rank_pop() {
  global_rank_pop_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t Backup_Misc::_internal_global_rank_pop() const {
  return global_rank_pop_;
}
inline uint64_t Backup_Misc::global_rank_pop() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Misc.global_rank_pop)
  return _internal_global_rank_pop();
}
inline void Backup_Misc::_internal_set_global_rank_pop(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  global_rank_pop_ = value;
}
inline void Backup_Misc::set_global_rank_pop(uint64_t value) {
  _internal_set_global_rank_pop(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Misc.global_rank_pop)
}

// optional bool challenges_alert = 20;
inline bool Backup_Misc::_internal_has_challenges_alert() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Backup_Misc::has_challenges_alert() const {
  return _internal_has_challenges_alert();
}
inline void Backup_Misc::clear_challenges_alert() {
  challenges_alert_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool Backup_Misc::_internal_challenges_alert() const {
  return challenges_alert_;
}
inline bool Backup_Misc::challenges_alert() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Misc.challenges_alert)
  return _internal_challenges_alert();
}
inline void Backup_Misc::_internal_set_challenges_alert(bool value) {
  _has_bits_[0] |= 0x00000040u;
  challenges_alert_ = value;
}
inline void Backup_Misc::set_challenges_alert(bool value) {
  _internal_set_challenges_alert(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Misc.challenges_alert)
}

// optional bool trophy_alert = 11;
inline bool Backup_Misc::_internal_has_trophy_alert() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Backup_Misc::has_trophy_alert() const {
  return _internal_has_trophy_alert();
}
inline void Backup_Misc::clear_trophy_alert() {
  trophy_alert_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool Backup_Misc::_internal_trophy_alert() const {
  return trophy_alert_;
}
inline bool Backup_Misc::trophy_alert() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Misc.trophy_alert)
  return _internal_trophy_alert();
}
inline void Backup_Misc::_internal_set_trophy_alert(bool value) {
  _has_bits_[0] |= 0x00000080u;
  trophy_alert_ = value;
}
inline void Backup_Misc::set_trophy_alert(bool value) {
  _internal_set_trophy_alert(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Misc.trophy_alert)
}

// optional bool ar_alert = 12;
inline bool Backup_Misc::_internal_has_ar_alert() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Backup_Misc::has_ar_alert() const {
  return _internal_has_ar_alert();
}
inline void Backup_Misc::clear_ar_alert() {
  ar_alert_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool Backup_Misc::_internal_ar_alert() const {
  return ar_alert_;
}
inline bool Backup_Misc::ar_alert() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Misc.ar_alert)
  return _internal_ar_alert();
}
inline void Backup_Misc::_internal_set_ar_alert(bool value) {
  _has_bits_[0] |= 0x00000100u;
  ar_alert_ = value;
}
inline void Backup_Misc::set_ar_alert(bool value) {
  _internal_set_ar_alert(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Misc.ar_alert)
}

// optional bool contracts_alert = 13;
inline bool Backup_Misc::_internal_has_contracts_alert() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Backup_Misc::has_contracts_alert() const {
  return _internal_has_contracts_alert();
}
inline void Backup_Misc::clear_contracts_alert() {
  contracts_alert_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool Backup_Misc::_internal_contracts_alert() const {
  return contracts_alert_;
}
inline bool Backup_Misc::contracts_alert() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Misc.contracts_alert)
  return _internal_contracts_alert();
}
inline void Backup_Misc::_internal_set_contracts_alert(bool value) {
  _has_bits_[0] |= 0x00000200u;
  contracts_alert_ = value;
}
inline void Backup_Misc::set_contracts_alert(bool value) {
  _internal_set_contracts_alert(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Misc.contracts_alert)
}

// optional bool coop_alert = 14;
inline bool Backup_Misc::_internal_has_coop_alert() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Backup_Misc::has_coop_alert() const {
  return _internal_has_coop_alert();
}
inline void Backup_Misc::clear_coop_alert() {
  coop_alert_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool Backup_Misc::_internal_coop_alert() const {
  return coop_alert_;
}
inline bool Backup_Misc::coop_alert() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Misc.coop_alert)
  return _internal_coop_alert();
}
inline void Backup_Misc::_internal_set_coop_alert(bool value) {
  _has_bits_[0] |= 0x00000400u;
  coop_alert_ = value;
}
inline void Backup_Misc::set_coop_alert(bool value) {
  _internal_set_coop_alert(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Misc.coop_alert)
}

// optional bool switch_alert = 15;
inline bool Backup_Misc::_internal_has_switch_alert() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool Backup_Misc::has_switch_alert() const {
  return _internal_has_switch_alert();
}
inline void Backup_Misc::clear_switch_alert() {
  switch_alert_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool Backup_Misc::_internal_switch_alert() const {
  return switch_alert_;
}
inline bool Backup_Misc::switch_alert() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Misc.switch_alert)
  return _internal_switch_alert();
}
inline void Backup_Misc::_internal_set_switch_alert(bool value) {
  _has_bits_[0] |= 0x00000800u;
  switch_alert_ = value;
}
inline void Backup_Misc::set_switch_alert(bool value) {
  _internal_set_switch_alert(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Misc.switch_alert)
}

// optional bool egg_of_prophecy_alert = 16;
inline bool Backup_Misc::_internal_has_egg_of_prophecy_alert() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Backup_Misc::has_egg_of_prophecy_alert() const {
  return _internal_has_egg_of_prophecy_alert();
}
inline void Backup_Misc::clear_egg_of_prophecy_alert() {
  egg_of_prophecy_alert_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool Backup_Misc::_internal_egg_of_prophecy_alert() const {
  return egg_of_prophecy_alert_;
}
inline bool Backup_Misc::egg_of_prophecy_alert() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Misc.egg_of_prophecy_alert)
  return _internal_egg_of_prophecy_alert();
}
inline void Backup_Misc::_internal_set_egg_of_prophecy_alert(bool value) {
  _has_bits_[0] |= 0x00001000u;
  egg_of_prophecy_alert_ = value;
}
inline void Backup_Misc::set_egg_of_prophecy_alert(bool value) {
  _internal_set_egg_of_prophecy_alert(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Misc.egg_of_prophecy_alert)
}

// optional bool boost_token_alert = 17;
inline bool Backup_Misc::_internal_has_boost_token_alert() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Backup_Misc::has_boost_token_alert() const {
  return _internal_has_boost_token_alert();
}
inline void Backup_Misc::clear_boost_token_alert() {
  boost_token_alert_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool Backup_Misc::_internal_boost_token_alert() const {
  return boost_token_alert_;
}
inline bool Backup_Misc::boost_token_alert() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Misc.boost_token_alert)
  return _internal_boost_token_alert();
}
inline void Backup_Misc::_internal_set_boost_token_alert(bool value) {
  _has_bits_[0] |= 0x00002000u;
  boost_token_alert_ = value;
}
inline void Backup_Misc::set_boost_token_alert(bool value) {
  _internal_set_boost_token_alert(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Misc.boost_token_alert)
}

// optional bool soul_egg_alert = 18;
inline bool Backup_Misc::_internal_has_soul_egg_alert() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Backup_Misc::has_soul_egg_alert() const {
  return _internal_has_soul_egg_alert();
}
inline void Backup_Misc::clear_soul_egg_alert() {
  soul_egg_alert_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool Backup_Misc::_internal_soul_egg_alert() const {
  return soul_egg_alert_;
}
inline bool Backup_Misc::soul_egg_alert() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Misc.soul_egg_alert)
  return _internal_soul_egg_alert();
}
inline void Backup_Misc::_internal_set_soul_egg_alert(bool value) {
  _has_bits_[0] |= 0x00004000u;
  soul_egg_alert_ = value;
}
inline void Backup_Misc::set_soul_egg_alert(bool value) {
  _internal_set_soul_egg_alert(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Misc.soul_egg_alert)
}

// optional bool backup_reminder_alert = 19;
inline bool Backup_Misc::_internal_has_backup_reminder_alert() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool Backup_Misc::has_backup_reminder_alert() const {
  return _internal_has_backup_reminder_alert();
}
inline void Backup_Misc::clear_backup_reminder_alert() {
  backup_reminder_alert_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool Backup_Misc::_internal_backup_reminder_alert() const {
  return backup_reminder_alert_;
}
inline bool Backup_Misc::backup_reminder_alert() const {
  // @@protoc_insertion_point(field_get:ei.Backup.Misc.backup_reminder_alert)
  return _internal_backup_reminder_alert();
}
inline void Backup_Misc::_internal_set_backup_reminder_alert(bool value) {
  _has_bits_[0] |= 0x00008000u;
  backup_reminder_alert_ = value;
}
inline void Backup_Misc::set_backup_reminder_alert(bool value) {
  _internal_set_backup_reminder_alert(value);
  // @@protoc_insertion_point(field_set:ei.Backup.Misc.backup_reminder_alert)
}

// -------------------------------------------------------------------

// Backup_ResearchItem

// optional string id = 1;
inline bool Backup_ResearchItem::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Backup_ResearchItem::has_id() const {
  return _internal_has_id();
}
inline void Backup_ResearchItem::clear_id() {
  id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Backup_ResearchItem::id() const {
  // @@protoc_insertion_point(field_get:ei.Backup.ResearchItem.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Backup_ResearchItem::set_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.Backup.ResearchItem.id)
}
inline std::string* Backup_ResearchItem::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ei.Backup.ResearchItem.id)
  return _s;
}
inline const std::string& Backup_ResearchItem::_internal_id() const {
  return id_.Get();
}
inline void Backup_ResearchItem::_internal_set_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Backup_ResearchItem::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Backup_ResearchItem::release_id() {
  // @@protoc_insertion_point(field_release:ei.Backup.ResearchItem.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Backup_ResearchItem::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.Backup.ResearchItem.id)
}

// optional uint32 level = 2;
inline bool Backup_ResearchItem::_internal_has_level() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Backup_ResearchItem::has_level() const {
  return _internal_has_level();
}
inline void Backup_ResearchItem::clear_level() {
  level_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t Backup_ResearchItem::_internal_level() const {
  return level_;
}
inline uint32_t Backup_ResearchItem::level() const {
  // @@protoc_insertion_point(field_get:ei.Backup.ResearchItem.level)
  return _internal_level();
}
inline void Backup_ResearchItem::_internal_set_level(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  level_ = value;
}
inline void Backup_ResearchItem::set_level(uint32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:ei.Backup.ResearchItem.level)
}

// -------------------------------------------------------------------

// Backup_NewsHeadline

// optional string id = 1;
inline bool Backup_NewsHeadline::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Backup_NewsHeadline::has_id() const {
  return _internal_has_id();
}
inline void Backup_NewsHeadline::clear_id() {
  id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Backup_NewsHeadline::id() const {
  // @@protoc_insertion_point(field_get:ei.Backup.NewsHeadline.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Backup_NewsHeadline::set_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.Backup.NewsHeadline.id)
}
inline std::string* Backup_NewsHeadline::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ei.Backup.NewsHeadline.id)
  return _s;
}
inline const std::string& Backup_NewsHeadline::_internal_id() const {
  return id_.Get();
}
inline void Backup_NewsHeadline::_internal_set_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Backup_NewsHeadline::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Backup_NewsHeadline::release_id() {
  // @@protoc_insertion_point(field_release:ei.Backup.NewsHeadline.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Backup_NewsHeadline::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.Backup.NewsHeadline.id)
}

// optional bool read = 2;
inline bool Backup_NewsHeadline::_internal_has_read() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Backup_NewsHeadline::has_read() const {
  return _internal_has_read();
}
inline void Backup_NewsHeadline::clear_read() {
  read_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool Backup_NewsHeadline::_internal_read() const {
  return read_;
}
inline bool Backup_NewsHeadline::read() const {
  // @@protoc_insertion_point(field_get:ei.Backup.NewsHeadline.read)
  return _internal_read();
}
inline void Backup_NewsHeadline::_internal_set_read(bool value) {
  _has_bits_[0] |= 0x00000002u;
  read_ = value;
}
inline void Backup_NewsHeadline::set_read(bool value) {
  _internal_set_read(value);
  // @@protoc_insertion_point(field_set:ei.Backup.NewsHeadline.read)
}

// -------------------------------------------------------------------

// Backup_AchievementInfo

// optional string id = 1;
inline bool Backup_AchievementInfo::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Backup_AchievementInfo::has_id() const {
  return _internal_has_id();
}
inline void Backup_AchievementInfo::clear_id() {
  id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Backup_AchievementInfo::id() const {
  // @@protoc_insertion_point(field_get:ei.Backup.AchievementInfo.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Backup_AchievementInfo::set_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.Backup.AchievementInfo.id)
}
inline std::string* Backup_AchievementInfo::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ei.Backup.AchievementInfo.id)
  return _s;
}
inline const std::string& Backup_AchievementInfo::_internal_id() const {
  return id_.Get();
}
inline void Backup_AchievementInfo::_internal_set_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Backup_AchievementInfo::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Backup_AchievementInfo::release_id() {
  // @@protoc_insertion_point(field_release:ei.Backup.AchievementInfo.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Backup_AchievementInfo::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.Backup.AchievementInfo.id)
}

// optional bool achieved = 2;
inline bool Backup_AchievementInfo::_internal_has_achieved() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Backup_AchievementInfo::has_achieved() const {
  return _internal_has_achieved();
}
inline void Backup_AchievementInfo::clear_achieved() {
  achieved_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool Backup_AchievementInfo::_internal_achieved() const {
  return achieved_;
}
inline bool Backup_AchievementInfo::achieved() const {
  // @@protoc_insertion_point(field_get:ei.Backup.AchievementInfo.achieved)
  return _internal_achieved();
}
inline void Backup_AchievementInfo::_internal_set_achieved(bool value) {
  _has_bits_[0] |= 0x00000002u;
  achieved_ = value;
}
inline void Backup_AchievementInfo::set_achieved(bool value) {
  _internal_set_achieved(value);
  // @@protoc_insertion_point(field_set:ei.Backup.AchievementInfo.achieved)
}

// -------------------------------------------------------------------

// Backup_ActiveBoost

// optional string boost_id = 1;
inline bool Backup_ActiveBoost::_internal_has_boost_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Backup_ActiveBoost::has_boost_id() const {
  return _internal_has_boost_id();
}
inline void Backup_ActiveBoost::clear_boost_id() {
  boost_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Backup_ActiveBoost::boost_id() const {
  // @@protoc_insertion_point(field_get:ei.Backup.ActiveBoost.boost_id)
  return _internal_boost_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Backup_ActiveBoost::set_boost_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 boost_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.Backup.ActiveBoost.boost_id)
}
inline std::string* Backup_ActiveBoost::mutable_boost_id() {
  std::string* _s = _internal_mutable_boost_id();
  // @@protoc_insertion_point(field_mutable:ei.Backup.ActiveBoost.boost_id)
  return _s;
}
inline const std::string& Backup_ActiveBoost::_internal_boost_id() const {
  return boost_id_.Get();
}
inline void Backup_ActiveBoost::_internal_set_boost_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  boost_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Backup_ActiveBoost::_internal_mutable_boost_id() {
  _has_bits_[0] |= 0x00000001u;
  return boost_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Backup_ActiveBoost::release_boost_id() {
  // @@protoc_insertion_point(field_release:ei.Backup.ActiveBoost.boost_id)
  if (!_internal_has_boost_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = boost_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (boost_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    boost_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Backup_ActiveBoost::set_allocated_boost_id(std::string* boost_id) {
  if (boost_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  boost_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), boost_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (boost_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    boost_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.Backup.ActiveBoost.boost_id)
}

// optional double time_remaining = 2;
inline bool Backup_ActiveBoost::_internal_has_time_remaining() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Backup_ActiveBoost::has_time_remaining() const {
  return _internal_has_time_remaining();
}
inline void Backup_ActiveBoost::clear_time_remaining() {
  time_remaining_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Backup_ActiveBoost::_internal_time_remaining() const {
  return time_remaining_;
}
inline double Backup_ActiveBoost::time_remaining() const {
  // @@protoc_insertion_point(field_get:ei.Backup.ActiveBoost.time_remaining)
  return _internal_time_remaining();
}
inline void Backup_ActiveBoost::_internal_set_time_remaining(double value) {
  _has_bits_[0] |= 0x00000002u;
  time_remaining_ = value;
}
inline void Backup_ActiveBoost::set_time_remaining(double value) {
  _internal_set_time_remaining(value);
  // @@protoc_insertion_point(field_set:ei.Backup.ActiveBoost.time_remaining)
}

// optional double reference_value = 3;
inline bool Backup_ActiveBoost::_internal_has_reference_value() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Backup_ActiveBoost::has_reference_value() const {
  return _internal_has_reference_value();
}
inline void Backup_ActiveBoost::clear_reference_value() {
  reference_value_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double Backup_ActiveBoost::_internal_reference_value() const {
  return reference_value_;
}
inline double Backup_ActiveBoost::reference_value() const {
  // @@protoc_insertion_point(field_get:ei.Backup.ActiveBoost.reference_value)
  return _internal_reference_value();
}
inline void Backup_ActiveBoost::_internal_set_reference_value(double value) {
  _has_bits_[0] |= 0x00000004u;
  reference_value_ = value;
}
inline void Backup_ActiveBoost::set_reference_value(double value) {
  _internal_set_reference_value(value);
  // @@protoc_insertion_point(field_set:ei.Backup.ActiveBoost.reference_value)
}

// -------------------------------------------------------------------

// Backup_OwnedBoost

// optional string boost_id = 1;
inline bool Backup_OwnedBoost::_internal_has_boost_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Backup_OwnedBoost::has_boost_id() const {
  return _internal_has_boost_id();
}
inline void Backup_OwnedBoost::clear_boost_id() {
  boost_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Backup_OwnedBoost::boost_id() const {
  // @@protoc_insertion_point(field_get:ei.Backup.OwnedBoost.boost_id)
  return _internal_boost_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Backup_OwnedBoost::set_boost_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 boost_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.Backup.OwnedBoost.boost_id)
}
inline std::string* Backup_OwnedBoost::mutable_boost_id() {
  std::string* _s = _internal_mutable_boost_id();
  // @@protoc_insertion_point(field_mutable:ei.Backup.OwnedBoost.boost_id)
  return _s;
}
inline const std::string& Backup_OwnedBoost::_internal_boost_id() const {
  return boost_id_.Get();
}
inline void Backup_OwnedBoost::_internal_set_boost_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  boost_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Backup_OwnedBoost::_internal_mutable_boost_id() {
  _has_bits_[0] |= 0x00000001u;
  return boost_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Backup_OwnedBoost::release_boost_id() {
  // @@protoc_insertion_point(field_release:ei.Backup.OwnedBoost.boost_id)
  if (!_internal_has_boost_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = boost_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (boost_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    boost_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Backup_OwnedBoost::set_allocated_boost_id(std::string* boost_id) {
  if (boost_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  boost_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), boost_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (boost_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    boost_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.Backup.OwnedBoost.boost_id)
}

// optional uint32 count = 2;
inline bool Backup_OwnedBoost::_internal_has_count() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Backup_OwnedBoost::has_count() const {
  return _internal_has_count();
}
inline void Backup_OwnedBoost::clear_count() {
  count_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t Backup_OwnedBoost::_internal_count() const {
  return count_;
}
inline uint32_t Backup_OwnedBoost::count() const {
  // @@protoc_insertion_point(field_get:ei.Backup.OwnedBoost.count)
  return _internal_count();
}
inline void Backup_OwnedBoost::_internal_set_count(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  count_ = value;
}
inline void Backup_OwnedBoost::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:ei.Backup.OwnedBoost.count)
}

// -------------------------------------------------------------------

// Backup_MissionInfo

// optional string id = 1;
inline bool Backup_MissionInfo::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Backup_MissionInfo::has_id() const {
  return _internal_has_id();
}
inline void Backup_MissionInfo::clear_id() {
  id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Backup_MissionInfo::id() const {
  // @@protoc_insertion_point(field_get:ei.Backup.MissionInfo.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Backup_MissionInfo::set_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.Backup.MissionInfo.id)
}
inline std::string* Backup_MissionInfo::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ei.Backup.MissionInfo.id)
  return _s;
}
inline const std::string& Backup_MissionInfo::_internal_id() const {
  return id_.Get();
}
inline void Backup_MissionInfo::_internal_set_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Backup_MissionInfo::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Backup_MissionInfo::release_id() {
  // @@protoc_insertion_point(field_release:ei.Backup.MissionInfo.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Backup_MissionInfo::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.Backup.MissionInfo.id)
}

// optional bool completed = 2;
inline bool Backup_MissionInfo::_internal_has_completed() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Backup_MissionInfo::has_completed() const {
  return _internal_has_completed();
}
inline void Backup_MissionInfo::clear_completed() {
  completed_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Backup_MissionInfo::_internal_completed() const {
  return completed_;
}
inline bool Backup_MissionInfo::completed() const {
  // @@protoc_insertion_point(field_get:ei.Backup.MissionInfo.completed)
  return _internal_completed();
}
inline void Backup_MissionInfo::_internal_set_completed(bool value) {
  _has_bits_[0] |= 0x00000004u;
  completed_ = value;
}
inline void Backup_MissionInfo::set_completed(bool value) {
  _internal_set_completed(value);
  // @@protoc_insertion_point(field_set:ei.Backup.MissionInfo.completed)
}

// optional double reference_value = 3;
inline bool Backup_MissionInfo::_internal_has_reference_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Backup_MissionInfo::has_reference_value() const {
  return _internal_has_reference_value();
}
inline void Backup_MissionInfo::clear_reference_value() {
  reference_value_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Backup_MissionInfo::_internal_reference_value() const {
  return reference_value_;
}
inline double Backup_MissionInfo::reference_value() const {
  // @@protoc_insertion_point(field_get:ei.Backup.MissionInfo.reference_value)
  return _internal_reference_value();
}
inline void Backup_MissionInfo::_internal_set_reference_value(double value) {
  _has_bits_[0] |= 0x00000002u;
  reference_value_ = value;
}
inline void Backup_MissionInfo::set_reference_value(double value) {
  _internal_set_reference_value(value);
  // @@protoc_insertion_point(field_set:ei.Backup.MissionInfo.reference_value)
}

// -------------------------------------------------------------------

// Backup

// optional string user_id = 1;
inline bool Backup::_internal_has_user_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Backup::has_user_id() const {
  return _internal_has_user_id();
}
inline void Backup::clear_user_id() {
  user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Backup::user_id() const {
  // @@protoc_insertion_point(field_get:ei.Backup.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Backup::set_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.Backup.user_id)
}
inline std::string* Backup::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:ei.Backup.user_id)
  return _s;
}
inline const std::string& Backup::_internal_user_id() const {
  return user_id_.Get();
}
inline void Backup::_internal_set_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Backup::_internal_mutable_user_id() {
  _has_bits_[0] |= 0x00000001u;
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Backup::release_user_id() {
  // @@protoc_insertion_point(field_release:ei.Backup.user_id)
  if (!_internal_has_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Backup::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.Backup.user_id)
}

// optional string ei_user_id = 18;
inline bool Backup::_internal_has_ei_user_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Backup::has_ei_user_id() const {
  return _internal_has_ei_user_id();
}
inline void Backup::clear_ei_user_id() {
  ei_user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& Backup::ei_user_id() const {
  // @@protoc_insertion_point(field_get:ei.Backup.ei_user_id)
  return _internal_ei_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Backup::set_ei_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 ei_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.Backup.ei_user_id)
}
inline std::string* Backup::mutable_ei_user_id() {
  std::string* _s = _internal_mutable_ei_user_id();
  // @@protoc_insertion_point(field_mutable:ei.Backup.ei_user_id)
  return _s;
}
inline const std::string& Backup::_internal_ei_user_id() const {
  return ei_user_id_.Get();
}
inline void Backup::_internal_set_ei_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  ei_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Backup::_internal_mutable_ei_user_id() {
  _has_bits_[0] |= 0x00000010u;
  return ei_user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Backup::release_ei_user_id() {
  // @@protoc_insertion_point(field_release:ei.Backup.ei_user_id)
  if (!_internal_has_ei_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = ei_user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ei_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ei_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Backup::set_allocated_ei_user_id(std::string* ei_user_id) {
  if (ei_user_id != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  ei_user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ei_user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ei_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ei_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.Backup.ei_user_id)
}

// optional string game_services_id = 16;
inline bool Backup::_internal_has_game_services_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Backup::has_game_services_id() const {
  return _internal_has_game_services_id();
}
inline void Backup::clear_game_services_id() {
  game_services_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Backup::game_services_id() const {
  // @@protoc_insertion_point(field_get:ei.Backup.game_services_id)
  return _internal_game_services_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Backup::set_game_services_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 game_services_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.Backup.game_services_id)
}
inline std::string* Backup::mutable_game_services_id() {
  std::string* _s = _internal_mutable_game_services_id();
  // @@protoc_insertion_point(field_mutable:ei.Backup.game_services_id)
  return _s;
}
inline const std::string& Backup::_internal_game_services_id() const {
  return game_services_id_.Get();
}
inline void Backup::_internal_set_game_services_id(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  game_services_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Backup::_internal_mutable_game_services_id() {
  _has_bits_[0] |= 0x00000004u;
  return game_services_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Backup::release_game_services_id() {
  // @@protoc_insertion_point(field_release:ei.Backup.game_services_id)
  if (!_internal_has_game_services_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = game_services_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (game_services_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    game_services_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Backup::set_allocated_game_services_id(std::string* game_services_id) {
  if (game_services_id != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  game_services_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), game_services_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (game_services_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    game_services_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.Backup.game_services_id)
}

// optional string device_id = 17;
inline bool Backup::_internal_has_device_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Backup::has_device_id() const {
  return _internal_has_device_id();
}
inline void Backup::clear_device_id() {
  device_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Backup::device_id() const {
  // @@protoc_insertion_point(field_get:ei.Backup.device_id)
  return _internal_device_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Backup::set_device_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 device_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.Backup.device_id)
}
inline std::string* Backup::mutable_device_id() {
  std::string* _s = _internal_mutable_device_id();
  // @@protoc_insertion_point(field_mutable:ei.Backup.device_id)
  return _s;
}
inline const std::string& Backup::_internal_device_id() const {
  return device_id_.Get();
}
inline void Backup::_internal_set_device_id(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  device_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Backup::_internal_mutable_device_id() {
  _has_bits_[0] |= 0x00000008u;
  return device_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Backup::release_device_id() {
  // @@protoc_insertion_point(field_release:ei.Backup.device_id)
  if (!_internal_has_device_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = device_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Backup::set_allocated_device_id(std::string* device_id) {
  if (device_id != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  device_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.Backup.device_id)
}

// optional string user_name = 2;
inline bool Backup::_internal_has_user_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Backup::has_user_name() const {
  return _internal_has_user_name();
}
inline void Backup::clear_user_name() {
  user_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Backup::user_name() const {
  // @@protoc_insertion_point(field_get:ei.Backup.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Backup::set_user_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 user_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.Backup.user_name)
}
inline std::string* Backup::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:ei.Backup.user_name)
  return _s;
}
inline const std::string& Backup::_internal_user_name() const {
  return user_name_.Get();
}
inline void Backup::_internal_set_user_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  user_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Backup::_internal_mutable_user_name() {
  _has_bits_[0] |= 0x00000002u;
  return user_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Backup::release_user_name() {
  // @@protoc_insertion_point(field_release:ei.Backup.user_name)
  if (!_internal_has_user_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = user_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Backup::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  user_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.Backup.user_name)
}

// optional double approx_time = 3;
inline bool Backup::_internal_has_approx_time() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool Backup::has_approx_time() const {
  return _internal_has_approx_time();
}
inline void Backup::clear_approx_time() {
  approx_time_ = 0;
  _has_bits_[0] &= ~0x00040000u;
}
inline double Backup::_internal_approx_time() const {
  return approx_time_;
}
inline double Backup::approx_time() const {
  // @@protoc_insertion_point(field_get:ei.Backup.approx_time)
  return _internal_approx_time();
}
inline void Backup::_internal_set_approx_time(double value) {
  _has_bits_[0] |= 0x00040000u;
  approx_time_ = value;
}
inline void Backup::set_approx_time(double value) {
  _internal_set_approx_time(value);
  // @@protoc_insertion_point(field_set:ei.Backup.approx_time)
}

// optional uint32 version = 21 [default = 0];
inline bool Backup::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool Backup::has_version() const {
  return _internal_has_version();
}
inline void Backup::clear_version() {
  version_ = 0u;
  _has_bits_[0] &= ~0x00080000u;
}
inline uint32_t Backup::_internal_version() const {
  return version_;
}
inline uint32_t Backup::version() const {
  // @@protoc_insertion_point(field_get:ei.Backup.version)
  return _internal_version();
}
inline void Backup::_internal_set_version(uint32_t value) {
  _has_bits_[0] |= 0x00080000u;
  version_ = value;
}
inline void Backup::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:ei.Backup.version)
}

// optional bool force_offer_backup = 20;
inline bool Backup::_internal_has_force_offer_backup() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool Backup::has_force_offer_backup() const {
  return _internal_has_force_offer_backup();
}
inline void Backup::clear_force_offer_backup() {
  force_offer_backup_ = false;
  _has_bits_[0] &= ~0x00100000u;
}
inline bool Backup::_internal_force_offer_backup() const {
  return force_offer_backup_;
}
inline bool Backup::force_offer_backup() const {
  // @@protoc_insertion_point(field_get:ei.Backup.force_offer_backup)
  return _internal_force_offer_backup();
}
inline void Backup::_internal_set_force_offer_backup(bool value) {
  _has_bits_[0] |= 0x00100000u;
  force_offer_backup_ = value;
}
inline void Backup::set_force_offer_backup(bool value) {
  _internal_set_force_offer_backup(value);
  // @@protoc_insertion_point(field_set:ei.Backup.force_offer_backup)
}

// optional bool force_backup = 22;
inline bool Backup::_internal_has_force_backup() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool Backup::has_force_backup() const {
  return _internal_has_force_backup();
}
inline void Backup::clear_force_backup() {
  force_backup_ = false;
  _has_bits_[0] &= ~0x00200000u;
}
inline bool Backup::_internal_force_backup() const {
  return force_backup_;
}
inline bool Backup::force_backup() const {
  // @@protoc_insertion_point(field_get:ei.Backup.force_backup)
  return _internal_force_backup();
}
inline void Backup::_internal_set_force_backup(bool value) {
  _has_bits_[0] |= 0x00200000u;
  force_backup_ = value;
}
inline void Backup::set_force_backup(bool value) {
  _internal_set_force_backup(value);
  // @@protoc_insertion_point(field_set:ei.Backup.force_backup)
}

// optional .ei.Backup.Settings settings = 4;
inline bool Backup::_internal_has_settings() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || settings_ != nullptr);
  return value;
}
inline bool Backup::has_settings() const {
  return _internal_has_settings();
}
inline void Backup::clear_settings() {
  if (settings_ != nullptr) settings_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::ei::Backup_Settings& Backup::_internal_settings() const {
  const ::ei::Backup_Settings* p = settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::Backup_Settings&>(
      ::ei::_Backup_Settings_default_instance_);
}
inline const ::ei::Backup_Settings& Backup::settings() const {
  // @@protoc_insertion_point(field_get:ei.Backup.settings)
  return _internal_settings();
}
inline void Backup::unsafe_arena_set_allocated_settings(
    ::ei::Backup_Settings* settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(settings_);
  }
  settings_ = settings;
  if (settings) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.Backup.settings)
}
inline ::ei::Backup_Settings* Backup::release_settings() {
  _has_bits_[0] &= ~0x00000040u;
  ::ei::Backup_Settings* temp = settings_;
  settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::Backup_Settings* Backup::unsafe_arena_release_settings() {
  // @@protoc_insertion_point(field_release:ei.Backup.settings)
  _has_bits_[0] &= ~0x00000040u;
  ::ei::Backup_Settings* temp = settings_;
  settings_ = nullptr;
  return temp;
}
inline ::ei::Backup_Settings* Backup::_internal_mutable_settings() {
  _has_bits_[0] |= 0x00000040u;
  if (settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::Backup_Settings>(GetArenaForAllocation());
    settings_ = p;
  }
  return settings_;
}
inline ::ei::Backup_Settings* Backup::mutable_settings() {
  ::ei::Backup_Settings* _msg = _internal_mutable_settings();
  // @@protoc_insertion_point(field_mutable:ei.Backup.settings)
  return _msg;
}
inline void Backup::set_allocated_settings(::ei::Backup_Settings* settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete settings_;
  }
  if (settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::Backup_Settings>::GetOwningArena(settings);
    if (message_arena != submessage_arena) {
      settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, settings, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  settings_ = settings;
  // @@protoc_insertion_point(field_set_allocated:ei.Backup.settings)
}

// optional .ei.Backup.Tutorial tutorial = 5;
inline bool Backup::_internal_has_tutorial() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || tutorial_ != nullptr);
  return value;
}
inline bool Backup::has_tutorial() const {
  return _internal_has_tutorial();
}
inline void Backup::clear_tutorial() {
  if (tutorial_ != nullptr) tutorial_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::ei::Backup_Tutorial& Backup::_internal_tutorial() const {
  const ::ei::Backup_Tutorial* p = tutorial_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::Backup_Tutorial&>(
      ::ei::_Backup_Tutorial_default_instance_);
}
inline const ::ei::Backup_Tutorial& Backup::tutorial() const {
  // @@protoc_insertion_point(field_get:ei.Backup.tutorial)
  return _internal_tutorial();
}
inline void Backup::unsafe_arena_set_allocated_tutorial(
    ::ei::Backup_Tutorial* tutorial) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tutorial_);
  }
  tutorial_ = tutorial;
  if (tutorial) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.Backup.tutorial)
}
inline ::ei::Backup_Tutorial* Backup::release_tutorial() {
  _has_bits_[0] &= ~0x00000080u;
  ::ei::Backup_Tutorial* temp = tutorial_;
  tutorial_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::Backup_Tutorial* Backup::unsafe_arena_release_tutorial() {
  // @@protoc_insertion_point(field_release:ei.Backup.tutorial)
  _has_bits_[0] &= ~0x00000080u;
  ::ei::Backup_Tutorial* temp = tutorial_;
  tutorial_ = nullptr;
  return temp;
}
inline ::ei::Backup_Tutorial* Backup::_internal_mutable_tutorial() {
  _has_bits_[0] |= 0x00000080u;
  if (tutorial_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::Backup_Tutorial>(GetArenaForAllocation());
    tutorial_ = p;
  }
  return tutorial_;
}
inline ::ei::Backup_Tutorial* Backup::mutable_tutorial() {
  ::ei::Backup_Tutorial* _msg = _internal_mutable_tutorial();
  // @@protoc_insertion_point(field_mutable:ei.Backup.tutorial)
  return _msg;
}
inline void Backup::set_allocated_tutorial(::ei::Backup_Tutorial* tutorial) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete tutorial_;
  }
  if (tutorial) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::Backup_Tutorial>::GetOwningArena(tutorial);
    if (message_arena != submessage_arena) {
      tutorial = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tutorial, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  tutorial_ = tutorial;
  // @@protoc_insertion_point(field_set_allocated:ei.Backup.tutorial)
}

// optional .ei.Backup.Stats stats = 6;
inline bool Backup::_internal_has_stats() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || stats_ != nullptr);
  return value;
}
inline bool Backup::has_stats() const {
  return _internal_has_stats();
}
inline void Backup::clear_stats() {
  if (stats_ != nullptr) stats_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::ei::Backup_Stats& Backup::_internal_stats() const {
  const ::ei::Backup_Stats* p = stats_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::Backup_Stats&>(
      ::ei::_Backup_Stats_default_instance_);
}
inline const ::ei::Backup_Stats& Backup::stats() const {
  // @@protoc_insertion_point(field_get:ei.Backup.stats)
  return _internal_stats();
}
inline void Backup::unsafe_arena_set_allocated_stats(
    ::ei::Backup_Stats* stats) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stats_);
  }
  stats_ = stats;
  if (stats) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.Backup.stats)
}
inline ::ei::Backup_Stats* Backup::release_stats() {
  _has_bits_[0] &= ~0x00000100u;
  ::ei::Backup_Stats* temp = stats_;
  stats_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::Backup_Stats* Backup::unsafe_arena_release_stats() {
  // @@protoc_insertion_point(field_release:ei.Backup.stats)
  _has_bits_[0] &= ~0x00000100u;
  ::ei::Backup_Stats* temp = stats_;
  stats_ = nullptr;
  return temp;
}
inline ::ei::Backup_Stats* Backup::_internal_mutable_stats() {
  _has_bits_[0] |= 0x00000100u;
  if (stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::Backup_Stats>(GetArenaForAllocation());
    stats_ = p;
  }
  return stats_;
}
inline ::ei::Backup_Stats* Backup::mutable_stats() {
  ::ei::Backup_Stats* _msg = _internal_mutable_stats();
  // @@protoc_insertion_point(field_mutable:ei.Backup.stats)
  return _msg;
}
inline void Backup::set_allocated_stats(::ei::Backup_Stats* stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete stats_;
  }
  if (stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::Backup_Stats>::GetOwningArena(stats);
    if (message_arena != submessage_arena) {
      stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stats, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  stats_ = stats;
  // @@protoc_insertion_point(field_set_allocated:ei.Backup.stats)
}

// optional .ei.Backup.Game game = 7;
inline bool Backup::_internal_has_game() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || game_ != nullptr);
  return value;
}
inline bool Backup::has_game() const {
  return _internal_has_game();
}
inline void Backup::clear_game() {
  if (game_ != nullptr) game_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::ei::Backup_Game& Backup::_internal_game() const {
  const ::ei::Backup_Game* p = game_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::Backup_Game&>(
      ::ei::_Backup_Game_default_instance_);
}
inline const ::ei::Backup_Game& Backup::game() const {
  // @@protoc_insertion_point(field_get:ei.Backup.game)
  return _internal_game();
}
inline void Backup::unsafe_arena_set_allocated_game(
    ::ei::Backup_Game* game) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(game_);
  }
  game_ = game;
  if (game) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.Backup.game)
}
inline ::ei::Backup_Game* Backup::release_game() {
  _has_bits_[0] &= ~0x00000200u;
  ::ei::Backup_Game* temp = game_;
  game_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::Backup_Game* Backup::unsafe_arena_release_game() {
  // @@protoc_insertion_point(field_release:ei.Backup.game)
  _has_bits_[0] &= ~0x00000200u;
  ::ei::Backup_Game* temp = game_;
  game_ = nullptr;
  return temp;
}
inline ::ei::Backup_Game* Backup::_internal_mutable_game() {
  _has_bits_[0] |= 0x00000200u;
  if (game_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::Backup_Game>(GetArenaForAllocation());
    game_ = p;
  }
  return game_;
}
inline ::ei::Backup_Game* Backup::mutable_game() {
  ::ei::Backup_Game* _msg = _internal_mutable_game();
  // @@protoc_insertion_point(field_mutable:ei.Backup.game)
  return _msg;
}
inline void Backup::set_allocated_game(::ei::Backup_Game* game) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete game_;
  }
  if (game) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::Backup_Game>::GetOwningArena(game);
    if (message_arena != submessage_arena) {
      game = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, game, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  game_ = game;
  // @@protoc_insertion_point(field_set_allocated:ei.Backup.game)
}

// optional .ei.Backup.Artifacts artifacts = 14;
inline bool Backup::_internal_has_artifacts() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || artifacts_ != nullptr);
  return value;
}
inline bool Backup::has_artifacts() const {
  return _internal_has_artifacts();
}
inline void Backup::clear_artifacts() {
  if (artifacts_ != nullptr) artifacts_->Clear();
  _has_bits_[0] &= ~0x00004000u;
}
inline const ::ei::Backup_Artifacts& Backup::_internal_artifacts() const {
  const ::ei::Backup_Artifacts* p = artifacts_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::Backup_Artifacts&>(
      ::ei::_Backup_Artifacts_default_instance_);
}
inline const ::ei::Backup_Artifacts& Backup::artifacts() const {
  // @@protoc_insertion_point(field_get:ei.Backup.artifacts)
  return _internal_artifacts();
}
inline void Backup::unsafe_arena_set_allocated_artifacts(
    ::ei::Backup_Artifacts* artifacts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(artifacts_);
  }
  artifacts_ = artifacts;
  if (artifacts) {
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.Backup.artifacts)
}
inline ::ei::Backup_Artifacts* Backup::release_artifacts() {
  _has_bits_[0] &= ~0x00004000u;
  ::ei::Backup_Artifacts* temp = artifacts_;
  artifacts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::Backup_Artifacts* Backup::unsafe_arena_release_artifacts() {
  // @@protoc_insertion_point(field_release:ei.Backup.artifacts)
  _has_bits_[0] &= ~0x00004000u;
  ::ei::Backup_Artifacts* temp = artifacts_;
  artifacts_ = nullptr;
  return temp;
}
inline ::ei::Backup_Artifacts* Backup::_internal_mutable_artifacts() {
  _has_bits_[0] |= 0x00004000u;
  if (artifacts_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::Backup_Artifacts>(GetArenaForAllocation());
    artifacts_ = p;
  }
  return artifacts_;
}
inline ::ei::Backup_Artifacts* Backup::mutable_artifacts() {
  ::ei::Backup_Artifacts* _msg = _internal_mutable_artifacts();
  // @@protoc_insertion_point(field_mutable:ei.Backup.artifacts)
  return _msg;
}
inline void Backup::set_allocated_artifacts(::ei::Backup_Artifacts* artifacts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete artifacts_;
  }
  if (artifacts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::Backup_Artifacts>::GetOwningArena(artifacts);
    if (message_arena != submessage_arena) {
      artifacts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, artifacts, submessage_arena);
    }
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  artifacts_ = artifacts;
  // @@protoc_insertion_point(field_set_allocated:ei.Backup.artifacts)
}

// optional .ei.Backup.Shells shells = 25;
inline bool Backup::_internal_has_shells() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || shells_ != nullptr);
  return value;
}
inline bool Backup::has_shells() const {
  return _internal_has_shells();
}
inline void Backup::clear_shells() {
  if (shells_ != nullptr) shells_->Clear();
  _has_bits_[0] &= ~0x00020000u;
}
inline const ::ei::Backup_Shells& Backup::_internal_shells() const {
  const ::ei::Backup_Shells* p = shells_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::Backup_Shells&>(
      ::ei::_Backup_Shells_default_instance_);
}
inline const ::ei::Backup_Shells& Backup::shells() const {
  // @@protoc_insertion_point(field_get:ei.Backup.shells)
  return _internal_shells();
}
inline void Backup::unsafe_arena_set_allocated_shells(
    ::ei::Backup_Shells* shells) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(shells_);
  }
  shells_ = shells;
  if (shells) {
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.Backup.shells)
}
inline ::ei::Backup_Shells* Backup::release_shells() {
  _has_bits_[0] &= ~0x00020000u;
  ::ei::Backup_Shells* temp = shells_;
  shells_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::Backup_Shells* Backup::unsafe_arena_release_shells() {
  // @@protoc_insertion_point(field_release:ei.Backup.shells)
  _has_bits_[0] &= ~0x00020000u;
  ::ei::Backup_Shells* temp = shells_;
  shells_ = nullptr;
  return temp;
}
inline ::ei::Backup_Shells* Backup::_internal_mutable_shells() {
  _has_bits_[0] |= 0x00020000u;
  if (shells_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::Backup_Shells>(GetArenaForAllocation());
    shells_ = p;
  }
  return shells_;
}
inline ::ei::Backup_Shells* Backup::mutable_shells() {
  ::ei::Backup_Shells* _msg = _internal_mutable_shells();
  // @@protoc_insertion_point(field_mutable:ei.Backup.shells)
  return _msg;
}
inline void Backup::set_allocated_shells(::ei::Backup_Shells* shells) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete shells_;
  }
  if (shells) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::Backup_Shells>::GetOwningArena(shells);
    if (message_arena != submessage_arena) {
      shells = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shells, submessage_arena);
    }
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  shells_ = shells;
  // @@protoc_insertion_point(field_set_allocated:ei.Backup.shells)
}

// optional .ei.Backup.Simulation sim = 8;
inline bool Backup::_internal_has_sim() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || sim_ != nullptr);
  return value;
}
inline bool Backup::has_sim() const {
  return _internal_has_sim();
}
inline void Backup::clear_sim() {
  if (sim_ != nullptr) sim_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::ei::Backup_Simulation& Backup::_internal_sim() const {
  const ::ei::Backup_Simulation* p = sim_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::Backup_Simulation&>(
      ::ei::_Backup_Simulation_default_instance_);
}
inline const ::ei::Backup_Simulation& Backup::sim() const {
  // @@protoc_insertion_point(field_get:ei.Backup.sim)
  return _internal_sim();
}
inline void Backup::unsafe_arena_set_allocated_sim(
    ::ei::Backup_Simulation* sim) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sim_);
  }
  sim_ = sim;
  if (sim) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.Backup.sim)
}
inline ::ei::Backup_Simulation* Backup::release_sim() {
  _has_bits_[0] &= ~0x00000400u;
  ::ei::Backup_Simulation* temp = sim_;
  sim_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::Backup_Simulation* Backup::unsafe_arena_release_sim() {
  // @@protoc_insertion_point(field_release:ei.Backup.sim)
  _has_bits_[0] &= ~0x00000400u;
  ::ei::Backup_Simulation* temp = sim_;
  sim_ = nullptr;
  return temp;
}
inline ::ei::Backup_Simulation* Backup::_internal_mutable_sim() {
  _has_bits_[0] |= 0x00000400u;
  if (sim_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::Backup_Simulation>(GetArenaForAllocation());
    sim_ = p;
  }
  return sim_;
}
inline ::ei::Backup_Simulation* Backup::mutable_sim() {
  ::ei::Backup_Simulation* _msg = _internal_mutable_sim();
  // @@protoc_insertion_point(field_mutable:ei.Backup.sim)
  return _msg;
}
inline void Backup::set_allocated_sim(::ei::Backup_Simulation* sim) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sim_;
  }
  if (sim) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::Backup_Simulation>::GetOwningArena(sim);
    if (message_arena != submessage_arena) {
      sim = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sim, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  sim_ = sim;
  // @@protoc_insertion_point(field_set_allocated:ei.Backup.sim)
}

// repeated .ei.Backup.Simulation farms = 12;
inline int Backup::_internal_farms_size() const {
  return farms_.size();
}
inline int Backup::farms_size() const {
  return _internal_farms_size();
}
inline void Backup::clear_farms() {
  farms_.Clear();
}
inline ::ei::Backup_Simulation* Backup::mutable_farms(int index) {
  // @@protoc_insertion_point(field_mutable:ei.Backup.farms)
  return farms_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_Simulation >*
Backup::mutable_farms() {
  // @@protoc_insertion_point(field_mutable_list:ei.Backup.farms)
  return &farms_;
}
inline const ::ei::Backup_Simulation& Backup::_internal_farms(int index) const {
  return farms_.Get(index);
}
inline const ::ei::Backup_Simulation& Backup::farms(int index) const {
  // @@protoc_insertion_point(field_get:ei.Backup.farms)
  return _internal_farms(index);
}
inline ::ei::Backup_Simulation* Backup::_internal_add_farms() {
  return farms_.Add();
}
inline ::ei::Backup_Simulation* Backup::add_farms() {
  ::ei::Backup_Simulation* _add = _internal_add_farms();
  // @@protoc_insertion_point(field_add:ei.Backup.farms)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_Simulation >&
Backup::farms() const {
  // @@protoc_insertion_point(field_list:ei.Backup.farms)
  return farms_;
}

// optional .ei.Backup.Mission mission = 9;
inline bool Backup::_internal_has_mission() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || mission_ != nullptr);
  return value;
}
inline bool Backup::has_mission() const {
  return _internal_has_mission();
}
inline void Backup::clear_mission() {
  if (mission_ != nullptr) mission_->Clear();
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::ei::Backup_Mission& Backup::_internal_mission() const {
  const ::ei::Backup_Mission* p = mission_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::Backup_Mission&>(
      ::ei::_Backup_Mission_default_instance_);
}
inline const ::ei::Backup_Mission& Backup::mission() const {
  // @@protoc_insertion_point(field_get:ei.Backup.mission)
  return _internal_mission();
}
inline void Backup::unsafe_arena_set_allocated_mission(
    ::ei::Backup_Mission* mission) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mission_);
  }
  mission_ = mission;
  if (mission) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.Backup.mission)
}
inline ::ei::Backup_Mission* Backup::release_mission() {
  _has_bits_[0] &= ~0x00000800u;
  ::ei::Backup_Mission* temp = mission_;
  mission_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::Backup_Mission* Backup::unsafe_arena_release_mission() {
  // @@protoc_insertion_point(field_release:ei.Backup.mission)
  _has_bits_[0] &= ~0x00000800u;
  ::ei::Backup_Mission* temp = mission_;
  mission_ = nullptr;
  return temp;
}
inline ::ei::Backup_Mission* Backup::_internal_mutable_mission() {
  _has_bits_[0] |= 0x00000800u;
  if (mission_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::Backup_Mission>(GetArenaForAllocation());
    mission_ = p;
  }
  return mission_;
}
inline ::ei::Backup_Mission* Backup::mutable_mission() {
  ::ei::Backup_Mission* _msg = _internal_mutable_mission();
  // @@protoc_insertion_point(field_mutable:ei.Backup.mission)
  return _msg;
}
inline void Backup::set_allocated_mission(::ei::Backup_Mission* mission) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete mission_;
  }
  if (mission) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::Backup_Mission>::GetOwningArena(mission);
    if (message_arena != submessage_arena) {
      mission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mission, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  mission_ = mission;
  // @@protoc_insertion_point(field_set_allocated:ei.Backup.mission)
}

// optional .ei.Backup.Misc misc = 10;
inline bool Backup::_internal_has_misc() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || misc_ != nullptr);
  return value;
}
inline bool Backup::has_misc() const {
  return _internal_has_misc();
}
inline void Backup::clear_misc() {
  if (misc_ != nullptr) misc_->Clear();
  _has_bits_[0] &= ~0x00001000u;
}
inline const ::ei::Backup_Misc& Backup::_internal_misc() const {
  const ::ei::Backup_Misc* p = misc_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::Backup_Misc&>(
      ::ei::_Backup_Misc_default_instance_);
}
inline const ::ei::Backup_Misc& Backup::misc() const {
  // @@protoc_insertion_point(field_get:ei.Backup.misc)
  return _internal_misc();
}
inline void Backup::unsafe_arena_set_allocated_misc(
    ::ei::Backup_Misc* misc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(misc_);
  }
  misc_ = misc;
  if (misc) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.Backup.misc)
}
inline ::ei::Backup_Misc* Backup::release_misc() {
  _has_bits_[0] &= ~0x00001000u;
  ::ei::Backup_Misc* temp = misc_;
  misc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::Backup_Misc* Backup::unsafe_arena_release_misc() {
  // @@protoc_insertion_point(field_release:ei.Backup.misc)
  _has_bits_[0] &= ~0x00001000u;
  ::ei::Backup_Misc* temp = misc_;
  misc_ = nullptr;
  return temp;
}
inline ::ei::Backup_Misc* Backup::_internal_mutable_misc() {
  _has_bits_[0] |= 0x00001000u;
  if (misc_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::Backup_Misc>(GetArenaForAllocation());
    misc_ = p;
  }
  return misc_;
}
inline ::ei::Backup_Misc* Backup::mutable_misc() {
  ::ei::Backup_Misc* _msg = _internal_mutable_misc();
  // @@protoc_insertion_point(field_mutable:ei.Backup.misc)
  return _msg;
}
inline void Backup::set_allocated_misc(::ei::Backup_Misc* misc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete misc_;
  }
  if (misc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::Backup_Misc>::GetOwningArena(misc);
    if (message_arena != submessage_arena) {
      misc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, misc, submessage_arena);
    }
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  misc_ = misc;
  // @@protoc_insertion_point(field_set_allocated:ei.Backup.misc)
}

// optional .ei.MyContracts contracts = 13;
inline bool Backup::_internal_has_contracts() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || contracts_ != nullptr);
  return value;
}
inline bool Backup::has_contracts() const {
  return _internal_has_contracts();
}
inline void Backup::clear_contracts() {
  if (contracts_ != nullptr) contracts_->Clear();
  _has_bits_[0] &= ~0x00002000u;
}
inline const ::ei::MyContracts& Backup::_internal_contracts() const {
  const ::ei::MyContracts* p = contracts_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::MyContracts&>(
      ::ei::_MyContracts_default_instance_);
}
inline const ::ei::MyContracts& Backup::contracts() const {
  // @@protoc_insertion_point(field_get:ei.Backup.contracts)
  return _internal_contracts();
}
inline void Backup::unsafe_arena_set_allocated_contracts(
    ::ei::MyContracts* contracts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(contracts_);
  }
  contracts_ = contracts;
  if (contracts) {
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.Backup.contracts)
}
inline ::ei::MyContracts* Backup::release_contracts() {
  _has_bits_[0] &= ~0x00002000u;
  ::ei::MyContracts* temp = contracts_;
  contracts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::MyContracts* Backup::unsafe_arena_release_contracts() {
  // @@protoc_insertion_point(field_release:ei.Backup.contracts)
  _has_bits_[0] &= ~0x00002000u;
  ::ei::MyContracts* temp = contracts_;
  contracts_ = nullptr;
  return temp;
}
inline ::ei::MyContracts* Backup::_internal_mutable_contracts() {
  _has_bits_[0] |= 0x00002000u;
  if (contracts_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::MyContracts>(GetArenaForAllocation());
    contracts_ = p;
  }
  return contracts_;
}
inline ::ei::MyContracts* Backup::mutable_contracts() {
  ::ei::MyContracts* _msg = _internal_mutable_contracts();
  // @@protoc_insertion_point(field_mutable:ei.Backup.contracts)
  return _msg;
}
inline void Backup::set_allocated_contracts(::ei::MyContracts* contracts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete contracts_;
  }
  if (contracts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::MyContracts>::GetOwningArena(contracts);
    if (message_arena != submessage_arena) {
      contracts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contracts, submessage_arena);
    }
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  contracts_ = contracts;
  // @@protoc_insertion_point(field_set_allocated:ei.Backup.contracts)
}

// optional .ei.ArtifactsDB artifacts_db = 15;
inline bool Backup::_internal_has_artifacts_db() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || artifacts_db_ != nullptr);
  return value;
}
inline bool Backup::has_artifacts_db() const {
  return _internal_has_artifacts_db();
}
inline void Backup::clear_artifacts_db() {
  if (artifacts_db_ != nullptr) artifacts_db_->Clear();
  _has_bits_[0] &= ~0x00008000u;
}
inline const ::ei::ArtifactsDB& Backup::_internal_artifacts_db() const {
  const ::ei::ArtifactsDB* p = artifacts_db_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::ArtifactsDB&>(
      ::ei::_ArtifactsDB_default_instance_);
}
inline const ::ei::ArtifactsDB& Backup::artifacts_db() const {
  // @@protoc_insertion_point(field_get:ei.Backup.artifacts_db)
  return _internal_artifacts_db();
}
inline void Backup::unsafe_arena_set_allocated_artifacts_db(
    ::ei::ArtifactsDB* artifacts_db) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(artifacts_db_);
  }
  artifacts_db_ = artifacts_db;
  if (artifacts_db) {
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.Backup.artifacts_db)
}
inline ::ei::ArtifactsDB* Backup::release_artifacts_db() {
  _has_bits_[0] &= ~0x00008000u;
  ::ei::ArtifactsDB* temp = artifacts_db_;
  artifacts_db_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::ArtifactsDB* Backup::unsafe_arena_release_artifacts_db() {
  // @@protoc_insertion_point(field_release:ei.Backup.artifacts_db)
  _has_bits_[0] &= ~0x00008000u;
  ::ei::ArtifactsDB* temp = artifacts_db_;
  artifacts_db_ = nullptr;
  return temp;
}
inline ::ei::ArtifactsDB* Backup::_internal_mutable_artifacts_db() {
  _has_bits_[0] |= 0x00008000u;
  if (artifacts_db_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::ArtifactsDB>(GetArenaForAllocation());
    artifacts_db_ = p;
  }
  return artifacts_db_;
}
inline ::ei::ArtifactsDB* Backup::mutable_artifacts_db() {
  ::ei::ArtifactsDB* _msg = _internal_mutable_artifacts_db();
  // @@protoc_insertion_point(field_mutable:ei.Backup.artifacts_db)
  return _msg;
}
inline void Backup::set_allocated_artifacts_db(::ei::ArtifactsDB* artifacts_db) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete artifacts_db_;
  }
  if (artifacts_db) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::ArtifactsDB>::GetOwningArena(artifacts_db);
    if (message_arena != submessage_arena) {
      artifacts_db = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, artifacts_db, submessage_arena);
    }
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  artifacts_db_ = artifacts_db;
  // @@protoc_insertion_point(field_set_allocated:ei.Backup.artifacts_db)
}

// optional .ei.ShellDB shell_db = 24;
inline bool Backup::_internal_has_shell_db() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || shell_db_ != nullptr);
  return value;
}
inline bool Backup::has_shell_db() const {
  return _internal_has_shell_db();
}
inline void Backup::clear_shell_db() {
  if (shell_db_ != nullptr) shell_db_->Clear();
  _has_bits_[0] &= ~0x00010000u;
}
inline const ::ei::ShellDB& Backup::_internal_shell_db() const {
  const ::ei::ShellDB* p = shell_db_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::ShellDB&>(
      ::ei::_ShellDB_default_instance_);
}
inline const ::ei::ShellDB& Backup::shell_db() const {
  // @@protoc_insertion_point(field_get:ei.Backup.shell_db)
  return _internal_shell_db();
}
inline void Backup::unsafe_arena_set_allocated_shell_db(
    ::ei::ShellDB* shell_db) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(shell_db_);
  }
  shell_db_ = shell_db;
  if (shell_db) {
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.Backup.shell_db)
}
inline ::ei::ShellDB* Backup::release_shell_db() {
  _has_bits_[0] &= ~0x00010000u;
  ::ei::ShellDB* temp = shell_db_;
  shell_db_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::ShellDB* Backup::unsafe_arena_release_shell_db() {
  // @@protoc_insertion_point(field_release:ei.Backup.shell_db)
  _has_bits_[0] &= ~0x00010000u;
  ::ei::ShellDB* temp = shell_db_;
  shell_db_ = nullptr;
  return temp;
}
inline ::ei::ShellDB* Backup::_internal_mutable_shell_db() {
  _has_bits_[0] |= 0x00010000u;
  if (shell_db_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::ShellDB>(GetArenaForAllocation());
    shell_db_ = p;
  }
  return shell_db_;
}
inline ::ei::ShellDB* Backup::mutable_shell_db() {
  ::ei::ShellDB* _msg = _internal_mutable_shell_db();
  // @@protoc_insertion_point(field_mutable:ei.Backup.shell_db)
  return _msg;
}
inline void Backup::set_allocated_shell_db(::ei::ShellDB* shell_db) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete shell_db_;
  }
  if (shell_db) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::ShellDB>::GetOwningArena(shell_db);
    if (message_arena != submessage_arena) {
      shell_db = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shell_db, submessage_arena);
    }
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  shell_db_ = shell_db;
  // @@protoc_insertion_point(field_set_allocated:ei.Backup.shell_db)
}

// repeated string read_mail_ids = 23;
inline int Backup::_internal_read_mail_ids_size() const {
  return read_mail_ids_.size();
}
inline int Backup::read_mail_ids_size() const {
  return _internal_read_mail_ids_size();
}
inline void Backup::clear_read_mail_ids() {
  read_mail_ids_.Clear();
}
inline std::string* Backup::add_read_mail_ids() {
  std::string* _s = _internal_add_read_mail_ids();
  // @@protoc_insertion_point(field_add_mutable:ei.Backup.read_mail_ids)
  return _s;
}
inline const std::string& Backup::_internal_read_mail_ids(int index) const {
  return read_mail_ids_.Get(index);
}
inline const std::string& Backup::read_mail_ids(int index) const {
  // @@protoc_insertion_point(field_get:ei.Backup.read_mail_ids)
  return _internal_read_mail_ids(index);
}
inline std::string* Backup::mutable_read_mail_ids(int index) {
  // @@protoc_insertion_point(field_mutable:ei.Backup.read_mail_ids)
  return read_mail_ids_.Mutable(index);
}
inline void Backup::set_read_mail_ids(int index, const std::string& value) {
  read_mail_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ei.Backup.read_mail_ids)
}
inline void Backup::set_read_mail_ids(int index, std::string&& value) {
  read_mail_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ei.Backup.read_mail_ids)
}
inline void Backup::set_read_mail_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  read_mail_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ei.Backup.read_mail_ids)
}
inline void Backup::set_read_mail_ids(int index, const char* value, size_t size) {
  read_mail_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ei.Backup.read_mail_ids)
}
inline std::string* Backup::_internal_add_read_mail_ids() {
  return read_mail_ids_.Add();
}
inline void Backup::add_read_mail_ids(const std::string& value) {
  read_mail_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ei.Backup.read_mail_ids)
}
inline void Backup::add_read_mail_ids(std::string&& value) {
  read_mail_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ei.Backup.read_mail_ids)
}
inline void Backup::add_read_mail_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  read_mail_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ei.Backup.read_mail_ids)
}
inline void Backup::add_read_mail_ids(const char* value, size_t size) {
  read_mail_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ei.Backup.read_mail_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Backup::read_mail_ids() const {
  // @@protoc_insertion_point(field_list:ei.Backup.read_mail_ids)
  return read_mail_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Backup::mutable_read_mail_ids() {
  // @@protoc_insertion_point(field_mutable_list:ei.Backup.read_mail_ids)
  return &read_mail_ids_;
}

// optional uint64 checksum = 100;
inline bool Backup::_internal_has_checksum() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool Backup::has_checksum() const {
  return _internal_has_checksum();
}
inline void Backup::clear_checksum() {
  checksum_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00400000u;
}
inline uint64_t Backup::_internal_checksum() const {
  return checksum_;
}
inline uint64_t Backup::checksum() const {
  // @@protoc_insertion_point(field_get:ei.Backup.checksum)
  return _internal_checksum();
}
inline void Backup::_internal_set_checksum(uint64_t value) {
  _has_bits_[0] |= 0x00400000u;
  checksum_ = value;
}
inline void Backup::set_checksum(uint64_t value) {
  _internal_set_checksum(value);
  // @@protoc_insertion_point(field_set:ei.Backup.checksum)
}

// optional string signature = 101;
inline bool Backup::_internal_has_signature() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Backup::has_signature() const {
  return _internal_has_signature();
}
inline void Backup::clear_signature() {
  signature_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& Backup::signature() const {
  // @@protoc_insertion_point(field_get:ei.Backup.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Backup::set_signature(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.Backup.signature)
}
inline std::string* Backup::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:ei.Backup.signature)
  return _s;
}
inline const std::string& Backup::_internal_signature() const {
  return signature_.Get();
}
inline void Backup::_internal_set_signature(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Backup::_internal_mutable_signature() {
  _has_bits_[0] |= 0x00000020u;
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Backup::release_signature() {
  // @@protoc_insertion_point(field_release:ei.Backup.signature)
  if (!_internal_has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = signature_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signature_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Backup::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signature_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.Backup.signature)
}

// -------------------------------------------------------------------

// EggIncFirstContactRequest

// optional .ei.BasicRequestInfo rinfo = 8;
inline bool EggIncFirstContactRequest::_internal_has_rinfo() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || rinfo_ != nullptr);
  return value;
}
inline bool EggIncFirstContactRequest::has_rinfo() const {
  return _internal_has_rinfo();
}
inline void EggIncFirstContactRequest::clear_rinfo() {
  if (rinfo_ != nullptr) rinfo_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::ei::BasicRequestInfo& EggIncFirstContactRequest::_internal_rinfo() const {
  const ::ei::BasicRequestInfo* p = rinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::BasicRequestInfo&>(
      ::ei::_BasicRequestInfo_default_instance_);
}
inline const ::ei::BasicRequestInfo& EggIncFirstContactRequest::rinfo() const {
  // @@protoc_insertion_point(field_get:ei.EggIncFirstContactRequest.rinfo)
  return _internal_rinfo();
}
inline void EggIncFirstContactRequest::unsafe_arena_set_allocated_rinfo(
    ::ei::BasicRequestInfo* rinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rinfo_);
  }
  rinfo_ = rinfo;
  if (rinfo) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.EggIncFirstContactRequest.rinfo)
}
inline ::ei::BasicRequestInfo* EggIncFirstContactRequest::release_rinfo() {
  _has_bits_[0] &= ~0x00000020u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::BasicRequestInfo* EggIncFirstContactRequest::unsafe_arena_release_rinfo() {
  // @@protoc_insertion_point(field_release:ei.EggIncFirstContactRequest.rinfo)
  _has_bits_[0] &= ~0x00000020u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
  return temp;
}
inline ::ei::BasicRequestInfo* EggIncFirstContactRequest::_internal_mutable_rinfo() {
  _has_bits_[0] |= 0x00000020u;
  if (rinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::BasicRequestInfo>(GetArenaForAllocation());
    rinfo_ = p;
  }
  return rinfo_;
}
inline ::ei::BasicRequestInfo* EggIncFirstContactRequest::mutable_rinfo() {
  ::ei::BasicRequestInfo* _msg = _internal_mutable_rinfo();
  // @@protoc_insertion_point(field_mutable:ei.EggIncFirstContactRequest.rinfo)
  return _msg;
}
inline void EggIncFirstContactRequest::set_allocated_rinfo(::ei::BasicRequestInfo* rinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rinfo_;
  }
  if (rinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::BasicRequestInfo>::GetOwningArena(rinfo);
    if (message_arena != submessage_arena) {
      rinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  rinfo_ = rinfo;
  // @@protoc_insertion_point(field_set_allocated:ei.EggIncFirstContactRequest.rinfo)
}

// optional string ei_user_id = 4;
inline bool EggIncFirstContactRequest::_internal_has_ei_user_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EggIncFirstContactRequest::has_ei_user_id() const {
  return _internal_has_ei_user_id();
}
inline void EggIncFirstContactRequest::clear_ei_user_id() {
  ei_user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& EggIncFirstContactRequest::ei_user_id() const {
  // @@protoc_insertion_point(field_get:ei.EggIncFirstContactRequest.ei_user_id)
  return _internal_ei_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EggIncFirstContactRequest::set_ei_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 ei_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.EggIncFirstContactRequest.ei_user_id)
}
inline std::string* EggIncFirstContactRequest::mutable_ei_user_id() {
  std::string* _s = _internal_mutable_ei_user_id();
  // @@protoc_insertion_point(field_mutable:ei.EggIncFirstContactRequest.ei_user_id)
  return _s;
}
inline const std::string& EggIncFirstContactRequest::_internal_ei_user_id() const {
  return ei_user_id_.Get();
}
inline void EggIncFirstContactRequest::_internal_set_ei_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  ei_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EggIncFirstContactRequest::_internal_mutable_ei_user_id() {
  _has_bits_[0] |= 0x00000002u;
  return ei_user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EggIncFirstContactRequest::release_ei_user_id() {
  // @@protoc_insertion_point(field_release:ei.EggIncFirstContactRequest.ei_user_id)
  if (!_internal_has_ei_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = ei_user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ei_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ei_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void EggIncFirstContactRequest::set_allocated_ei_user_id(std::string* ei_user_id) {
  if (ei_user_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ei_user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ei_user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ei_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ei_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.EggIncFirstContactRequest.ei_user_id)
}

// optional string user_id = 1;
inline bool EggIncFirstContactRequest::_internal_has_user_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EggIncFirstContactRequest::has_user_id() const {
  return _internal_has_user_id();
}
inline void EggIncFirstContactRequest::clear_user_id() {
  user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EggIncFirstContactRequest::user_id() const {
  // @@protoc_insertion_point(field_get:ei.EggIncFirstContactRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EggIncFirstContactRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.EggIncFirstContactRequest.user_id)
}
inline std::string* EggIncFirstContactRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:ei.EggIncFirstContactRequest.user_id)
  return _s;
}
inline const std::string& EggIncFirstContactRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void EggIncFirstContactRequest::_internal_set_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EggIncFirstContactRequest::_internal_mutable_user_id() {
  _has_bits_[0] |= 0x00000001u;
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EggIncFirstContactRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:ei.EggIncFirstContactRequest.user_id)
  if (!_internal_has_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void EggIncFirstContactRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.EggIncFirstContactRequest.user_id)
}

// optional string game_services_id = 7;
inline bool EggIncFirstContactRequest::_internal_has_game_services_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool EggIncFirstContactRequest::has_game_services_id() const {
  return _internal_has_game_services_id();
}
inline void EggIncFirstContactRequest::clear_game_services_id() {
  game_services_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& EggIncFirstContactRequest::game_services_id() const {
  // @@protoc_insertion_point(field_get:ei.EggIncFirstContactRequest.game_services_id)
  return _internal_game_services_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EggIncFirstContactRequest::set_game_services_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 game_services_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.EggIncFirstContactRequest.game_services_id)
}
inline std::string* EggIncFirstContactRequest::mutable_game_services_id() {
  std::string* _s = _internal_mutable_game_services_id();
  // @@protoc_insertion_point(field_mutable:ei.EggIncFirstContactRequest.game_services_id)
  return _s;
}
inline const std::string& EggIncFirstContactRequest::_internal_game_services_id() const {
  return game_services_id_.Get();
}
inline void EggIncFirstContactRequest::_internal_set_game_services_id(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  game_services_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EggIncFirstContactRequest::_internal_mutable_game_services_id() {
  _has_bits_[0] |= 0x00000010u;
  return game_services_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EggIncFirstContactRequest::release_game_services_id() {
  // @@protoc_insertion_point(field_release:ei.EggIncFirstContactRequest.game_services_id)
  if (!_internal_has_game_services_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = game_services_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (game_services_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    game_services_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void EggIncFirstContactRequest::set_allocated_game_services_id(std::string* game_services_id) {
  if (game_services_id != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  game_services_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), game_services_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (game_services_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    game_services_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.EggIncFirstContactRequest.game_services_id)
}

// optional string device_id = 5;
inline bool EggIncFirstContactRequest::_internal_has_device_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool EggIncFirstContactRequest::has_device_id() const {
  return _internal_has_device_id();
}
inline void EggIncFirstContactRequest::clear_device_id() {
  device_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& EggIncFirstContactRequest::device_id() const {
  // @@protoc_insertion_point(field_get:ei.EggIncFirstContactRequest.device_id)
  return _internal_device_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EggIncFirstContactRequest::set_device_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 device_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.EggIncFirstContactRequest.device_id)
}
inline std::string* EggIncFirstContactRequest::mutable_device_id() {
  std::string* _s = _internal_mutable_device_id();
  // @@protoc_insertion_point(field_mutable:ei.EggIncFirstContactRequest.device_id)
  return _s;
}
inline const std::string& EggIncFirstContactRequest::_internal_device_id() const {
  return device_id_.Get();
}
inline void EggIncFirstContactRequest::_internal_set_device_id(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  device_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EggIncFirstContactRequest::_internal_mutable_device_id() {
  _has_bits_[0] |= 0x00000004u;
  return device_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EggIncFirstContactRequest::release_device_id() {
  // @@protoc_insertion_point(field_release:ei.EggIncFirstContactRequest.device_id)
  if (!_internal_has_device_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = device_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void EggIncFirstContactRequest::set_allocated_device_id(std::string* device_id) {
  if (device_id != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  device_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.EggIncFirstContactRequest.device_id)
}

// optional string username = 6;
inline bool EggIncFirstContactRequest::_internal_has_username() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool EggIncFirstContactRequest::has_username() const {
  return _internal_has_username();
}
inline void EggIncFirstContactRequest::clear_username() {
  username_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& EggIncFirstContactRequest::username() const {
  // @@protoc_insertion_point(field_get:ei.EggIncFirstContactRequest.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EggIncFirstContactRequest::set_username(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.EggIncFirstContactRequest.username)
}
inline std::string* EggIncFirstContactRequest::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:ei.EggIncFirstContactRequest.username)
  return _s;
}
inline const std::string& EggIncFirstContactRequest::_internal_username() const {
  return username_.Get();
}
inline void EggIncFirstContactRequest::_internal_set_username(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EggIncFirstContactRequest::_internal_mutable_username() {
  _has_bits_[0] |= 0x00000008u;
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EggIncFirstContactRequest::release_username() {
  // @@protoc_insertion_point(field_release:ei.EggIncFirstContactRequest.username)
  if (!_internal_has_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = username_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void EggIncFirstContactRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.EggIncFirstContactRequest.username)
}

// optional uint32 client_version = 2;
inline bool EggIncFirstContactRequest::_internal_has_client_version() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool EggIncFirstContactRequest::has_client_version() const {
  return _internal_has_client_version();
}
inline void EggIncFirstContactRequest::clear_client_version() {
  client_version_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t EggIncFirstContactRequest::_internal_client_version() const {
  return client_version_;
}
inline uint32_t EggIncFirstContactRequest::client_version() const {
  // @@protoc_insertion_point(field_get:ei.EggIncFirstContactRequest.client_version)
  return _internal_client_version();
}
inline void EggIncFirstContactRequest::_internal_set_client_version(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  client_version_ = value;
}
inline void EggIncFirstContactRequest::set_client_version(uint32_t value) {
  _internal_set_client_version(value);
  // @@protoc_insertion_point(field_set:ei.EggIncFirstContactRequest.client_version)
}

// optional .ei.Platform platform = 3;
inline bool EggIncFirstContactRequest::_internal_has_platform() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool EggIncFirstContactRequest::has_platform() const {
  return _internal_has_platform();
}
inline void EggIncFirstContactRequest::clear_platform() {
  platform_ = 1;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::ei::Platform EggIncFirstContactRequest::_internal_platform() const {
  return static_cast< ::ei::Platform >(platform_);
}
inline ::ei::Platform EggIncFirstContactRequest::platform() const {
  // @@protoc_insertion_point(field_get:ei.EggIncFirstContactRequest.platform)
  return _internal_platform();
}
inline void EggIncFirstContactRequest::_internal_set_platform(::ei::Platform value) {
  assert(::ei::Platform_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  platform_ = value;
}
inline void EggIncFirstContactRequest::set_platform(::ei::Platform value) {
  _internal_set_platform(value);
  // @@protoc_insertion_point(field_set:ei.EggIncFirstContactRequest.platform)
}

// -------------------------------------------------------------------

// EggIncFirstContactResponse

// optional string ei_user_id = 2;
inline bool EggIncFirstContactResponse::_internal_has_ei_user_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EggIncFirstContactResponse::has_ei_user_id() const {
  return _internal_has_ei_user_id();
}
inline void EggIncFirstContactResponse::clear_ei_user_id() {
  ei_user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EggIncFirstContactResponse::ei_user_id() const {
  // @@protoc_insertion_point(field_get:ei.EggIncFirstContactResponse.ei_user_id)
  return _internal_ei_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EggIncFirstContactResponse::set_ei_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 ei_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.EggIncFirstContactResponse.ei_user_id)
}
inline std::string* EggIncFirstContactResponse::mutable_ei_user_id() {
  std::string* _s = _internal_mutable_ei_user_id();
  // @@protoc_insertion_point(field_mutable:ei.EggIncFirstContactResponse.ei_user_id)
  return _s;
}
inline const std::string& EggIncFirstContactResponse::_internal_ei_user_id() const {
  return ei_user_id_.Get();
}
inline void EggIncFirstContactResponse::_internal_set_ei_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ei_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EggIncFirstContactResponse::_internal_mutable_ei_user_id() {
  _has_bits_[0] |= 0x00000001u;
  return ei_user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EggIncFirstContactResponse::release_ei_user_id() {
  // @@protoc_insertion_point(field_release:ei.EggIncFirstContactResponse.ei_user_id)
  if (!_internal_has_ei_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = ei_user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ei_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ei_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void EggIncFirstContactResponse::set_allocated_ei_user_id(std::string* ei_user_id) {
  if (ei_user_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ei_user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ei_user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ei_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ei_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.EggIncFirstContactResponse.ei_user_id)
}

// repeated string ids_transferred = 3;
inline int EggIncFirstContactResponse::_internal_ids_transferred_size() const {
  return ids_transferred_.size();
}
inline int EggIncFirstContactResponse::ids_transferred_size() const {
  return _internal_ids_transferred_size();
}
inline void EggIncFirstContactResponse::clear_ids_transferred() {
  ids_transferred_.Clear();
}
inline std::string* EggIncFirstContactResponse::add_ids_transferred() {
  std::string* _s = _internal_add_ids_transferred();
  // @@protoc_insertion_point(field_add_mutable:ei.EggIncFirstContactResponse.ids_transferred)
  return _s;
}
inline const std::string& EggIncFirstContactResponse::_internal_ids_transferred(int index) const {
  return ids_transferred_.Get(index);
}
inline const std::string& EggIncFirstContactResponse::ids_transferred(int index) const {
  // @@protoc_insertion_point(field_get:ei.EggIncFirstContactResponse.ids_transferred)
  return _internal_ids_transferred(index);
}
inline std::string* EggIncFirstContactResponse::mutable_ids_transferred(int index) {
  // @@protoc_insertion_point(field_mutable:ei.EggIncFirstContactResponse.ids_transferred)
  return ids_transferred_.Mutable(index);
}
inline void EggIncFirstContactResponse::set_ids_transferred(int index, const std::string& value) {
  ids_transferred_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ei.EggIncFirstContactResponse.ids_transferred)
}
inline void EggIncFirstContactResponse::set_ids_transferred(int index, std::string&& value) {
  ids_transferred_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ei.EggIncFirstContactResponse.ids_transferred)
}
inline void EggIncFirstContactResponse::set_ids_transferred(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ids_transferred_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ei.EggIncFirstContactResponse.ids_transferred)
}
inline void EggIncFirstContactResponse::set_ids_transferred(int index, const char* value, size_t size) {
  ids_transferred_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ei.EggIncFirstContactResponse.ids_transferred)
}
inline std::string* EggIncFirstContactResponse::_internal_add_ids_transferred() {
  return ids_transferred_.Add();
}
inline void EggIncFirstContactResponse::add_ids_transferred(const std::string& value) {
  ids_transferred_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ei.EggIncFirstContactResponse.ids_transferred)
}
inline void EggIncFirstContactResponse::add_ids_transferred(std::string&& value) {
  ids_transferred_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ei.EggIncFirstContactResponse.ids_transferred)
}
inline void EggIncFirstContactResponse::add_ids_transferred(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ids_transferred_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ei.EggIncFirstContactResponse.ids_transferred)
}
inline void EggIncFirstContactResponse::add_ids_transferred(const char* value, size_t size) {
  ids_transferred_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ei.EggIncFirstContactResponse.ids_transferred)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
EggIncFirstContactResponse::ids_transferred() const {
  // @@protoc_insertion_point(field_list:ei.EggIncFirstContactResponse.ids_transferred)
  return ids_transferred_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
EggIncFirstContactResponse::mutable_ids_transferred() {
  // @@protoc_insertion_point(field_mutable_list:ei.EggIncFirstContactResponse.ids_transferred)
  return &ids_transferred_;
}

// optional uint32 error_code = 4 [default = 0];
inline bool EggIncFirstContactResponse::_internal_has_error_code() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool EggIncFirstContactResponse::has_error_code() const {
  return _internal_has_error_code();
}
inline void EggIncFirstContactResponse::clear_error_code() {
  error_code_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t EggIncFirstContactResponse::_internal_error_code() const {
  return error_code_;
}
inline uint32_t EggIncFirstContactResponse::error_code() const {
  // @@protoc_insertion_point(field_get:ei.EggIncFirstContactResponse.error_code)
  return _internal_error_code();
}
inline void EggIncFirstContactResponse::_internal_set_error_code(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  error_code_ = value;
}
inline void EggIncFirstContactResponse::set_error_code(uint32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:ei.EggIncFirstContactResponse.error_code)
}

// optional string error_message = 5;
inline bool EggIncFirstContactResponse::_internal_has_error_message() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EggIncFirstContactResponse::has_error_message() const {
  return _internal_has_error_message();
}
inline void EggIncFirstContactResponse::clear_error_message() {
  error_message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& EggIncFirstContactResponse::error_message() const {
  // @@protoc_insertion_point(field_get:ei.EggIncFirstContactResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EggIncFirstContactResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.EggIncFirstContactResponse.error_message)
}
inline std::string* EggIncFirstContactResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:ei.EggIncFirstContactResponse.error_message)
  return _s;
}
inline const std::string& EggIncFirstContactResponse::_internal_error_message() const {
  return error_message_.Get();
}
inline void EggIncFirstContactResponse::_internal_set_error_message(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EggIncFirstContactResponse::_internal_mutable_error_message() {
  _has_bits_[0] |= 0x00000002u;
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EggIncFirstContactResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:ei.EggIncFirstContactResponse.error_message)
  if (!_internal_has_error_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = error_message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void EggIncFirstContactResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.EggIncFirstContactResponse.error_message)
}

// optional .ei.Backup backup = 1;
inline bool EggIncFirstContactResponse::_internal_has_backup() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || backup_ != nullptr);
  return value;
}
inline bool EggIncFirstContactResponse::has_backup() const {
  return _internal_has_backup();
}
inline void EggIncFirstContactResponse::clear_backup() {
  if (backup_ != nullptr) backup_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ei::Backup& EggIncFirstContactResponse::_internal_backup() const {
  const ::ei::Backup* p = backup_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::Backup&>(
      ::ei::_Backup_default_instance_);
}
inline const ::ei::Backup& EggIncFirstContactResponse::backup() const {
  // @@protoc_insertion_point(field_get:ei.EggIncFirstContactResponse.backup)
  return _internal_backup();
}
inline void EggIncFirstContactResponse::unsafe_arena_set_allocated_backup(
    ::ei::Backup* backup) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(backup_);
  }
  backup_ = backup;
  if (backup) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.EggIncFirstContactResponse.backup)
}
inline ::ei::Backup* EggIncFirstContactResponse::release_backup() {
  _has_bits_[0] &= ~0x00000004u;
  ::ei::Backup* temp = backup_;
  backup_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::Backup* EggIncFirstContactResponse::unsafe_arena_release_backup() {
  // @@protoc_insertion_point(field_release:ei.EggIncFirstContactResponse.backup)
  _has_bits_[0] &= ~0x00000004u;
  ::ei::Backup* temp = backup_;
  backup_ = nullptr;
  return temp;
}
inline ::ei::Backup* EggIncFirstContactResponse::_internal_mutable_backup() {
  _has_bits_[0] |= 0x00000004u;
  if (backup_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::Backup>(GetArenaForAllocation());
    backup_ = p;
  }
  return backup_;
}
inline ::ei::Backup* EggIncFirstContactResponse::mutable_backup() {
  ::ei::Backup* _msg = _internal_mutable_backup();
  // @@protoc_insertion_point(field_mutable:ei.EggIncFirstContactResponse.backup)
  return _msg;
}
inline void EggIncFirstContactResponse::set_allocated_backup(::ei::Backup* backup) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete backup_;
  }
  if (backup) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::Backup>::GetOwningArena(backup);
    if (message_arena != submessage_arena) {
      backup = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, backup, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  backup_ = backup;
  // @@protoc_insertion_point(field_set_allocated:ei.EggIncFirstContactResponse.backup)
}

// -------------------------------------------------------------------

// EggIncAdConfig

// repeated .ei.AdNetwork network_priority = 1;
inline int EggIncAdConfig::_internal_network_priority_size() const {
  return network_priority_.size();
}
inline int EggIncAdConfig::network_priority_size() const {
  return _internal_network_priority_size();
}
inline void EggIncAdConfig::clear_network_priority() {
  network_priority_.Clear();
}
inline ::ei::AdNetwork EggIncAdConfig::_internal_network_priority(int index) const {
  return static_cast< ::ei::AdNetwork >(network_priority_.Get(index));
}
inline ::ei::AdNetwork EggIncAdConfig::network_priority(int index) const {
  // @@protoc_insertion_point(field_get:ei.EggIncAdConfig.network_priority)
  return _internal_network_priority(index);
}
inline void EggIncAdConfig::set_network_priority(int index, ::ei::AdNetwork value) {
  assert(::ei::AdNetwork_IsValid(value));
  network_priority_.Set(index, value);
  // @@protoc_insertion_point(field_set:ei.EggIncAdConfig.network_priority)
}
inline void EggIncAdConfig::_internal_add_network_priority(::ei::AdNetwork value) {
  assert(::ei::AdNetwork_IsValid(value));
  network_priority_.Add(value);
}
inline void EggIncAdConfig::add_network_priority(::ei::AdNetwork value) {
  _internal_add_network_priority(value);
  // @@protoc_insertion_point(field_add:ei.EggIncAdConfig.network_priority)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
EggIncAdConfig::network_priority() const {
  // @@protoc_insertion_point(field_list:ei.EggIncAdConfig.network_priority)
  return network_priority_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
EggIncAdConfig::_internal_mutable_network_priority() {
  return &network_priority_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
EggIncAdConfig::mutable_network_priority() {
  // @@protoc_insertion_point(field_mutable_list:ei.EggIncAdConfig.network_priority)
  return _internal_mutable_network_priority();
}

// -------------------------------------------------------------------

// DailyGiftInfo

// optional uint32 current_day = 1;
inline bool DailyGiftInfo::_internal_has_current_day() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DailyGiftInfo::has_current_day() const {
  return _internal_has_current_day();
}
inline void DailyGiftInfo::clear_current_day() {
  current_day_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t DailyGiftInfo::_internal_current_day() const {
  return current_day_;
}
inline uint32_t DailyGiftInfo::current_day() const {
  // @@protoc_insertion_point(field_get:ei.DailyGiftInfo.current_day)
  return _internal_current_day();
}
inline void DailyGiftInfo::_internal_set_current_day(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  current_day_ = value;
}
inline void DailyGiftInfo::set_current_day(uint32_t value) {
  _internal_set_current_day(value);
  // @@protoc_insertion_point(field_set:ei.DailyGiftInfo.current_day)
}

// optional double seconds_to_next_day = 2;
inline bool DailyGiftInfo::_internal_has_seconds_to_next_day() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DailyGiftInfo::has_seconds_to_next_day() const {
  return _internal_has_seconds_to_next_day();
}
inline void DailyGiftInfo::clear_seconds_to_next_day() {
  seconds_to_next_day_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double DailyGiftInfo::_internal_seconds_to_next_day() const {
  return seconds_to_next_day_;
}
inline double DailyGiftInfo::seconds_to_next_day() const {
  // @@protoc_insertion_point(field_get:ei.DailyGiftInfo.seconds_to_next_day)
  return _internal_seconds_to_next_day();
}
inline void DailyGiftInfo::_internal_set_seconds_to_next_day(double value) {
  _has_bits_[0] |= 0x00000001u;
  seconds_to_next_day_ = value;
}
inline void DailyGiftInfo::set_seconds_to_next_day(double value) {
  _internal_set_seconds_to_next_day(value);
  // @@protoc_insertion_point(field_set:ei.DailyGiftInfo.seconds_to_next_day)
}

// -------------------------------------------------------------------

// SalesInfoRequest

// optional string user_id = 1;
inline bool SalesInfoRequest::_internal_has_user_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SalesInfoRequest::has_user_id() const {
  return _internal_has_user_id();
}
inline void SalesInfoRequest::clear_user_id() {
  user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SalesInfoRequest::user_id() const {
  // @@protoc_insertion_point(field_get:ei.SalesInfoRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SalesInfoRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.SalesInfoRequest.user_id)
}
inline std::string* SalesInfoRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:ei.SalesInfoRequest.user_id)
  return _s;
}
inline const std::string& SalesInfoRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void SalesInfoRequest::_internal_set_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SalesInfoRequest::_internal_mutable_user_id() {
  _has_bits_[0] |= 0x00000001u;
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SalesInfoRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:ei.SalesInfoRequest.user_id)
  if (!_internal_has_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SalesInfoRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.SalesInfoRequest.user_id)
}

// optional bool piggy_full = 2;
inline bool SalesInfoRequest::_internal_has_piggy_full() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SalesInfoRequest::has_piggy_full() const {
  return _internal_has_piggy_full();
}
inline void SalesInfoRequest::clear_piggy_full() {
  piggy_full_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool SalesInfoRequest::_internal_piggy_full() const {
  return piggy_full_;
}
inline bool SalesInfoRequest::piggy_full() const {
  // @@protoc_insertion_point(field_get:ei.SalesInfoRequest.piggy_full)
  return _internal_piggy_full();
}
inline void SalesInfoRequest::_internal_set_piggy_full(bool value) {
  _has_bits_[0] |= 0x00000004u;
  piggy_full_ = value;
}
inline void SalesInfoRequest::set_piggy_full(bool value) {
  _internal_set_piggy_full(value);
  // @@protoc_insertion_point(field_set:ei.SalesInfoRequest.piggy_full)
}

// optional bool piggy_found_full = 3;
inline bool SalesInfoRequest::_internal_has_piggy_found_full() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SalesInfoRequest::has_piggy_found_full() const {
  return _internal_has_piggy_found_full();
}
inline void SalesInfoRequest::clear_piggy_found_full() {
  piggy_found_full_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool SalesInfoRequest::_internal_piggy_found_full() const {
  return piggy_found_full_;
}
inline bool SalesInfoRequest::piggy_found_full() const {
  // @@protoc_insertion_point(field_get:ei.SalesInfoRequest.piggy_found_full)
  return _internal_piggy_found_full();
}
inline void SalesInfoRequest::_internal_set_piggy_found_full(bool value) {
  _has_bits_[0] |= 0x00000008u;
  piggy_found_full_ = value;
}
inline void SalesInfoRequest::set_piggy_found_full(bool value) {
  _internal_set_piggy_found_full(value);
  // @@protoc_insertion_point(field_set:ei.SalesInfoRequest.piggy_found_full)
}

// optional double seconds_full_realtime = 4;
inline bool SalesInfoRequest::_internal_has_seconds_full_realtime() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SalesInfoRequest::has_seconds_full_realtime() const {
  return _internal_has_seconds_full_realtime();
}
inline void SalesInfoRequest::clear_seconds_full_realtime() {
  seconds_full_realtime_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double SalesInfoRequest::_internal_seconds_full_realtime() const {
  return seconds_full_realtime_;
}
inline double SalesInfoRequest::seconds_full_realtime() const {
  // @@protoc_insertion_point(field_get:ei.SalesInfoRequest.seconds_full_realtime)
  return _internal_seconds_full_realtime();
}
inline void SalesInfoRequest::_internal_set_seconds_full_realtime(double value) {
  _has_bits_[0] |= 0x00000002u;
  seconds_full_realtime_ = value;
}
inline void SalesInfoRequest::set_seconds_full_realtime(double value) {
  _internal_set_seconds_full_realtime(value);
  // @@protoc_insertion_point(field_set:ei.SalesInfoRequest.seconds_full_realtime)
}

// optional double seconds_full_gametime = 5;
inline bool SalesInfoRequest::_internal_has_seconds_full_gametime() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SalesInfoRequest::has_seconds_full_gametime() const {
  return _internal_has_seconds_full_gametime();
}
inline void SalesInfoRequest::clear_seconds_full_gametime() {
  seconds_full_gametime_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double SalesInfoRequest::_internal_seconds_full_gametime() const {
  return seconds_full_gametime_;
}
inline double SalesInfoRequest::seconds_full_gametime() const {
  // @@protoc_insertion_point(field_get:ei.SalesInfoRequest.seconds_full_gametime)
  return _internal_seconds_full_gametime();
}
inline void SalesInfoRequest::_internal_set_seconds_full_gametime(double value) {
  _has_bits_[0] |= 0x00000020u;
  seconds_full_gametime_ = value;
}
inline void SalesInfoRequest::set_seconds_full_gametime(double value) {
  _internal_set_seconds_full_gametime(value);
  // @@protoc_insertion_point(field_set:ei.SalesInfoRequest.seconds_full_gametime)
}

// optional uint32 lost_increments = 7;
inline bool SalesInfoRequest::_internal_has_lost_increments() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SalesInfoRequest::has_lost_increments() const {
  return _internal_has_lost_increments();
}
inline void SalesInfoRequest::clear_lost_increments() {
  lost_increments_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t SalesInfoRequest::_internal_lost_increments() const {
  return lost_increments_;
}
inline uint32_t SalesInfoRequest::lost_increments() const {
  // @@protoc_insertion_point(field_get:ei.SalesInfoRequest.lost_increments)
  return _internal_lost_increments();
}
inline void SalesInfoRequest::_internal_set_lost_increments(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  lost_increments_ = value;
}
inline void SalesInfoRequest::set_lost_increments(uint32_t value) {
  _internal_set_lost_increments(value);
  // @@protoc_insertion_point(field_set:ei.SalesInfoRequest.lost_increments)
}

// optional uint32 current_client_version = 10;
inline bool SalesInfoRequest::_internal_has_current_client_version() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool SalesInfoRequest::has_current_client_version() const {
  return _internal_has_current_client_version();
}
inline void SalesInfoRequest::clear_current_client_version() {
  current_client_version_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t SalesInfoRequest::_internal_current_client_version() const {
  return current_client_version_;
}
inline uint32_t SalesInfoRequest::current_client_version() const {
  // @@protoc_insertion_point(field_get:ei.SalesInfoRequest.current_client_version)
  return _internal_current_client_version();
}
inline void SalesInfoRequest::_internal_set_current_client_version(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  current_client_version_ = value;
}
inline void SalesInfoRequest::set_current_client_version(uint32_t value) {
  _internal_set_current_client_version(value);
  // @@protoc_insertion_point(field_set:ei.SalesInfoRequest.current_client_version)
}

// -------------------------------------------------------------------

// IAPSaleEntry

// optional string product_id = 1;
inline bool IAPSaleEntry::_internal_has_product_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IAPSaleEntry::has_product_id() const {
  return _internal_has_product_id();
}
inline void IAPSaleEntry::clear_product_id() {
  product_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IAPSaleEntry::product_id() const {
  // @@protoc_insertion_point(field_get:ei.IAPSaleEntry.product_id)
  return _internal_product_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IAPSaleEntry::set_product_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 product_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.IAPSaleEntry.product_id)
}
inline std::string* IAPSaleEntry::mutable_product_id() {
  std::string* _s = _internal_mutable_product_id();
  // @@protoc_insertion_point(field_mutable:ei.IAPSaleEntry.product_id)
  return _s;
}
inline const std::string& IAPSaleEntry::_internal_product_id() const {
  return product_id_.Get();
}
inline void IAPSaleEntry::_internal_set_product_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  product_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IAPSaleEntry::_internal_mutable_product_id() {
  _has_bits_[0] |= 0x00000001u;
  return product_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IAPSaleEntry::release_product_id() {
  // @@protoc_insertion_point(field_release:ei.IAPSaleEntry.product_id)
  if (!_internal_has_product_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = product_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (product_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    product_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void IAPSaleEntry::set_allocated_product_id(std::string* product_id) {
  if (product_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  product_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), product_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (product_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    product_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.IAPSaleEntry.product_id)
}

// optional double seconds_remaining = 2;
inline bool IAPSaleEntry::_internal_has_seconds_remaining() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool IAPSaleEntry::has_seconds_remaining() const {
  return _internal_has_seconds_remaining();
}
inline void IAPSaleEntry::clear_seconds_remaining() {
  seconds_remaining_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double IAPSaleEntry::_internal_seconds_remaining() const {
  return seconds_remaining_;
}
inline double IAPSaleEntry::seconds_remaining() const {
  // @@protoc_insertion_point(field_get:ei.IAPSaleEntry.seconds_remaining)
  return _internal_seconds_remaining();
}
inline void IAPSaleEntry::_internal_set_seconds_remaining(double value) {
  _has_bits_[0] |= 0x00000008u;
  seconds_remaining_ = value;
}
inline void IAPSaleEntry::set_seconds_remaining(double value) {
  _internal_set_seconds_remaining(value);
  // @@protoc_insertion_point(field_set:ei.IAPSaleEntry.seconds_remaining)
}

// optional string discount_string = 3;
inline bool IAPSaleEntry::_internal_has_discount_string() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool IAPSaleEntry::has_discount_string() const {
  return _internal_has_discount_string();
}
inline void IAPSaleEntry::clear_discount_string() {
  discount_string_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& IAPSaleEntry::discount_string() const {
  // @@protoc_insertion_point(field_get:ei.IAPSaleEntry.discount_string)
  return _internal_discount_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IAPSaleEntry::set_discount_string(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 discount_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.IAPSaleEntry.discount_string)
}
inline std::string* IAPSaleEntry::mutable_discount_string() {
  std::string* _s = _internal_mutable_discount_string();
  // @@protoc_insertion_point(field_mutable:ei.IAPSaleEntry.discount_string)
  return _s;
}
inline const std::string& IAPSaleEntry::_internal_discount_string() const {
  return discount_string_.Get();
}
inline void IAPSaleEntry::_internal_set_discount_string(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  discount_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IAPSaleEntry::_internal_mutable_discount_string() {
  _has_bits_[0] |= 0x00000002u;
  return discount_string_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IAPSaleEntry::release_discount_string() {
  // @@protoc_insertion_point(field_release:ei.IAPSaleEntry.discount_string)
  if (!_internal_has_discount_string()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = discount_string_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (discount_string_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    discount_string_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void IAPSaleEntry::set_allocated_discount_string(std::string* discount_string) {
  if (discount_string != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  discount_string_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), discount_string,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (discount_string_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    discount_string_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.IAPSaleEntry.discount_string)
}

// optional string sale_id = 4;
inline bool IAPSaleEntry::_internal_has_sale_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool IAPSaleEntry::has_sale_id() const {
  return _internal_has_sale_id();
}
inline void IAPSaleEntry::clear_sale_id() {
  sale_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& IAPSaleEntry::sale_id() const {
  // @@protoc_insertion_point(field_get:ei.IAPSaleEntry.sale_id)
  return _internal_sale_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IAPSaleEntry::set_sale_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 sale_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.IAPSaleEntry.sale_id)
}
inline std::string* IAPSaleEntry::mutable_sale_id() {
  std::string* _s = _internal_mutable_sale_id();
  // @@protoc_insertion_point(field_mutable:ei.IAPSaleEntry.sale_id)
  return _s;
}
inline const std::string& IAPSaleEntry::_internal_sale_id() const {
  return sale_id_.Get();
}
inline void IAPSaleEntry::_internal_set_sale_id(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  sale_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IAPSaleEntry::_internal_mutable_sale_id() {
  _has_bits_[0] |= 0x00000004u;
  return sale_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IAPSaleEntry::release_sale_id() {
  // @@protoc_insertion_point(field_release:ei.IAPSaleEntry.sale_id)
  if (!_internal_has_sale_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = sale_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sale_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sale_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void IAPSaleEntry::set_allocated_sale_id(std::string* sale_id) {
  if (sale_id != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  sale_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sale_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sale_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sale_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.IAPSaleEntry.sale_id)
}

// -------------------------------------------------------------------

// SalesInfo

// repeated .ei.IAPSaleEntry sales = 1;
inline int SalesInfo::_internal_sales_size() const {
  return sales_.size();
}
inline int SalesInfo::sales_size() const {
  return _internal_sales_size();
}
inline void SalesInfo::clear_sales() {
  sales_.Clear();
}
inline ::ei::IAPSaleEntry* SalesInfo::mutable_sales(int index) {
  // @@protoc_insertion_point(field_mutable:ei.SalesInfo.sales)
  return sales_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::IAPSaleEntry >*
SalesInfo::mutable_sales() {
  // @@protoc_insertion_point(field_mutable_list:ei.SalesInfo.sales)
  return &sales_;
}
inline const ::ei::IAPSaleEntry& SalesInfo::_internal_sales(int index) const {
  return sales_.Get(index);
}
inline const ::ei::IAPSaleEntry& SalesInfo::sales(int index) const {
  // @@protoc_insertion_point(field_get:ei.SalesInfo.sales)
  return _internal_sales(index);
}
inline ::ei::IAPSaleEntry* SalesInfo::_internal_add_sales() {
  return sales_.Add();
}
inline ::ei::IAPSaleEntry* SalesInfo::add_sales() {
  ::ei::IAPSaleEntry* _add = _internal_add_sales();
  // @@protoc_insertion_point(field_add:ei.SalesInfo.sales)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::IAPSaleEntry >&
SalesInfo::sales() const {
  // @@protoc_insertion_point(field_list:ei.SalesInfo.sales)
  return sales_;
}

// -------------------------------------------------------------------

// EggIncEvent

// optional string identifier = 1;
inline bool EggIncEvent::_internal_has_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EggIncEvent::has_identifier() const {
  return _internal_has_identifier();
}
inline void EggIncEvent::clear_identifier() {
  identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EggIncEvent::identifier() const {
  // @@protoc_insertion_point(field_get:ei.EggIncEvent.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EggIncEvent::set_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.EggIncEvent.identifier)
}
inline std::string* EggIncEvent::mutable_identifier() {
  std::string* _s = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:ei.EggIncEvent.identifier)
  return _s;
}
inline const std::string& EggIncEvent::_internal_identifier() const {
  return identifier_.Get();
}
inline void EggIncEvent::_internal_set_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EggIncEvent::_internal_mutable_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EggIncEvent::release_identifier() {
  // @@protoc_insertion_point(field_release:ei.EggIncEvent.identifier)
  if (!_internal_has_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void EggIncEvent::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.EggIncEvent.identifier)
}

// optional double seconds_remaining = 2;
inline bool EggIncEvent::_internal_has_seconds_remaining() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool EggIncEvent::has_seconds_remaining() const {
  return _internal_has_seconds_remaining();
}
inline void EggIncEvent::clear_seconds_remaining() {
  seconds_remaining_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double EggIncEvent::_internal_seconds_remaining() const {
  return seconds_remaining_;
}
inline double EggIncEvent::seconds_remaining() const {
  // @@protoc_insertion_point(field_get:ei.EggIncEvent.seconds_remaining)
  return _internal_seconds_remaining();
}
inline void EggIncEvent::_internal_set_seconds_remaining(double value) {
  _has_bits_[0] |= 0x00000008u;
  seconds_remaining_ = value;
}
inline void EggIncEvent::set_seconds_remaining(double value) {
  _internal_set_seconds_remaining(value);
  // @@protoc_insertion_point(field_set:ei.EggIncEvent.seconds_remaining)
}

// optional string type = 3;
inline bool EggIncEvent::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EggIncEvent::has_type() const {
  return _internal_has_type();
}
inline void EggIncEvent::clear_type() {
  type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& EggIncEvent::type() const {
  // @@protoc_insertion_point(field_get:ei.EggIncEvent.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EggIncEvent::set_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.EggIncEvent.type)
}
inline std::string* EggIncEvent::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:ei.EggIncEvent.type)
  return _s;
}
inline const std::string& EggIncEvent::_internal_type() const {
  return type_.Get();
}
inline void EggIncEvent::_internal_set_type(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EggIncEvent::_internal_mutable_type() {
  _has_bits_[0] |= 0x00000002u;
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EggIncEvent::release_type() {
  // @@protoc_insertion_point(field_release:ei.EggIncEvent.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void EggIncEvent::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.EggIncEvent.type)
}

// optional double multiplier = 4;
inline bool EggIncEvent::_internal_has_multiplier() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool EggIncEvent::has_multiplier() const {
  return _internal_has_multiplier();
}
inline void EggIncEvent::clear_multiplier() {
  multiplier_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double EggIncEvent::_internal_multiplier() const {
  return multiplier_;
}
inline double EggIncEvent::multiplier() const {
  // @@protoc_insertion_point(field_get:ei.EggIncEvent.multiplier)
  return _internal_multiplier();
}
inline void EggIncEvent::_internal_set_multiplier(double value) {
  _has_bits_[0] |= 0x00000010u;
  multiplier_ = value;
}
inline void EggIncEvent::set_multiplier(double value) {
  _internal_set_multiplier(value);
  // @@protoc_insertion_point(field_set:ei.EggIncEvent.multiplier)
}

// optional string subtitle = 5;
inline bool EggIncEvent::_internal_has_subtitle() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool EggIncEvent::has_subtitle() const {
  return _internal_has_subtitle();
}
inline void EggIncEvent::clear_subtitle() {
  subtitle_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& EggIncEvent::subtitle() const {
  // @@protoc_insertion_point(field_get:ei.EggIncEvent.subtitle)
  return _internal_subtitle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EggIncEvent::set_subtitle(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 subtitle_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.EggIncEvent.subtitle)
}
inline std::string* EggIncEvent::mutable_subtitle() {
  std::string* _s = _internal_mutable_subtitle();
  // @@protoc_insertion_point(field_mutable:ei.EggIncEvent.subtitle)
  return _s;
}
inline const std::string& EggIncEvent::_internal_subtitle() const {
  return subtitle_.Get();
}
inline void EggIncEvent::_internal_set_subtitle(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  subtitle_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EggIncEvent::_internal_mutable_subtitle() {
  _has_bits_[0] |= 0x00000004u;
  return subtitle_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EggIncEvent::release_subtitle() {
  // @@protoc_insertion_point(field_release:ei.EggIncEvent.subtitle)
  if (!_internal_has_subtitle()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = subtitle_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (subtitle_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    subtitle_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void EggIncEvent::set_allocated_subtitle(std::string* subtitle) {
  if (subtitle != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  subtitle_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), subtitle,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (subtitle_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    subtitle_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.EggIncEvent.subtitle)
}

// optional double start_time = 6;
inline bool EggIncEvent::_internal_has_start_time() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool EggIncEvent::has_start_time() const {
  return _internal_has_start_time();
}
inline void EggIncEvent::clear_start_time() {
  start_time_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double EggIncEvent::_internal_start_time() const {
  return start_time_;
}
inline double EggIncEvent::start_time() const {
  // @@protoc_insertion_point(field_get:ei.EggIncEvent.start_time)
  return _internal_start_time();
}
inline void EggIncEvent::_internal_set_start_time(double value) {
  _has_bits_[0] |= 0x00000020u;
  start_time_ = value;
}
inline void EggIncEvent::set_start_time(double value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:ei.EggIncEvent.start_time)
}

// optional double duration = 7;
inline bool EggIncEvent::_internal_has_duration() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool EggIncEvent::has_duration() const {
  return _internal_has_duration();
}
inline void EggIncEvent::clear_duration() {
  duration_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double EggIncEvent::_internal_duration() const {
  return duration_;
}
inline double EggIncEvent::duration() const {
  // @@protoc_insertion_point(field_get:ei.EggIncEvent.duration)
  return _internal_duration();
}
inline void EggIncEvent::_internal_set_duration(double value) {
  _has_bits_[0] |= 0x00000040u;
  duration_ = value;
}
inline void EggIncEvent::set_duration(double value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:ei.EggIncEvent.duration)
}

// -------------------------------------------------------------------

// EggIncCurrentEvents

// repeated .ei.EggIncEvent events = 1;
inline int EggIncCurrentEvents::_internal_events_size() const {
  return events_.size();
}
inline int EggIncCurrentEvents::events_size() const {
  return _internal_events_size();
}
inline void EggIncCurrentEvents::clear_events() {
  events_.Clear();
}
inline ::ei::EggIncEvent* EggIncCurrentEvents::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:ei.EggIncCurrentEvents.events)
  return events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::EggIncEvent >*
EggIncCurrentEvents::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:ei.EggIncCurrentEvents.events)
  return &events_;
}
inline const ::ei::EggIncEvent& EggIncCurrentEvents::_internal_events(int index) const {
  return events_.Get(index);
}
inline const ::ei::EggIncEvent& EggIncCurrentEvents::events(int index) const {
  // @@protoc_insertion_point(field_get:ei.EggIncCurrentEvents.events)
  return _internal_events(index);
}
inline ::ei::EggIncEvent* EggIncCurrentEvents::_internal_add_events() {
  return events_.Add();
}
inline ::ei::EggIncEvent* EggIncCurrentEvents::add_events() {
  ::ei::EggIncEvent* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:ei.EggIncCurrentEvents.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::EggIncEvent >&
EggIncCurrentEvents::events() const {
  // @@protoc_insertion_point(field_list:ei.EggIncCurrentEvents.events)
  return events_;
}

// -------------------------------------------------------------------

// DeviceInfo

// optional string device_id = 1;
inline bool DeviceInfo::_internal_has_device_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceInfo::has_device_id() const {
  return _internal_has_device_id();
}
inline void DeviceInfo::clear_device_id() {
  device_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceInfo::device_id() const {
  // @@protoc_insertion_point(field_get:ei.DeviceInfo.device_id)
  return _internal_device_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInfo::set_device_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 device_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.DeviceInfo.device_id)
}
inline std::string* DeviceInfo::mutable_device_id() {
  std::string* _s = _internal_mutable_device_id();
  // @@protoc_insertion_point(field_mutable:ei.DeviceInfo.device_id)
  return _s;
}
inline const std::string& DeviceInfo::_internal_device_id() const {
  return device_id_.Get();
}
inline void DeviceInfo::_internal_set_device_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  device_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceInfo::_internal_mutable_device_id() {
  _has_bits_[0] |= 0x00000001u;
  return device_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceInfo::release_device_id() {
  // @@protoc_insertion_point(field_release:ei.DeviceInfo.device_id)
  if (!_internal_has_device_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = device_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceInfo::set_allocated_device_id(std::string* device_id) {
  if (device_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  device_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.DeviceInfo.device_id)
}

// optional string advertising_id = 13;
inline bool DeviceInfo::_internal_has_advertising_id() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool DeviceInfo::has_advertising_id() const {
  return _internal_has_advertising_id();
}
inline void DeviceInfo::clear_advertising_id() {
  advertising_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000400u;
}
inline const std::string& DeviceInfo::advertising_id() const {
  // @@protoc_insertion_point(field_get:ei.DeviceInfo.advertising_id)
  return _internal_advertising_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInfo::set_advertising_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000400u;
 advertising_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.DeviceInfo.advertising_id)
}
inline std::string* DeviceInfo::mutable_advertising_id() {
  std::string* _s = _internal_mutable_advertising_id();
  // @@protoc_insertion_point(field_mutable:ei.DeviceInfo.advertising_id)
  return _s;
}
inline const std::string& DeviceInfo::_internal_advertising_id() const {
  return advertising_id_.Get();
}
inline void DeviceInfo::_internal_set_advertising_id(const std::string& value) {
  _has_bits_[0] |= 0x00000400u;
  advertising_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceInfo::_internal_mutable_advertising_id() {
  _has_bits_[0] |= 0x00000400u;
  return advertising_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceInfo::release_advertising_id() {
  // @@protoc_insertion_point(field_release:ei.DeviceInfo.advertising_id)
  if (!_internal_has_advertising_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000400u;
  auto* p = advertising_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (advertising_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    advertising_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceInfo::set_allocated_advertising_id(std::string* advertising_id) {
  if (advertising_id != nullptr) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  advertising_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), advertising_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (advertising_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    advertising_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.DeviceInfo.advertising_id)
}

// optional string platform = 2;
inline bool DeviceInfo::_internal_has_platform() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeviceInfo::has_platform() const {
  return _internal_has_platform();
}
inline void DeviceInfo::clear_platform() {
  platform_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DeviceInfo::platform() const {
  // @@protoc_insertion_point(field_get:ei.DeviceInfo.platform)
  return _internal_platform();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInfo::set_platform(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 platform_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.DeviceInfo.platform)
}
inline std::string* DeviceInfo::mutable_platform() {
  std::string* _s = _internal_mutable_platform();
  // @@protoc_insertion_point(field_mutable:ei.DeviceInfo.platform)
  return _s;
}
inline const std::string& DeviceInfo::_internal_platform() const {
  return platform_.Get();
}
inline void DeviceInfo::_internal_set_platform(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  platform_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceInfo::_internal_mutable_platform() {
  _has_bits_[0] |= 0x00000002u;
  return platform_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceInfo::release_platform() {
  // @@protoc_insertion_point(field_release:ei.DeviceInfo.platform)
  if (!_internal_has_platform()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = platform_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (platform_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    platform_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceInfo::set_allocated_platform(std::string* platform) {
  if (platform != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  platform_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), platform,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (platform_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    platform_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.DeviceInfo.platform)
}

// optional string form_factor = 3;
inline bool DeviceInfo::_internal_has_form_factor() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DeviceInfo::has_form_factor() const {
  return _internal_has_form_factor();
}
inline void DeviceInfo::clear_form_factor() {
  form_factor_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DeviceInfo::form_factor() const {
  // @@protoc_insertion_point(field_get:ei.DeviceInfo.form_factor)
  return _internal_form_factor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInfo::set_form_factor(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 form_factor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.DeviceInfo.form_factor)
}
inline std::string* DeviceInfo::mutable_form_factor() {
  std::string* _s = _internal_mutable_form_factor();
  // @@protoc_insertion_point(field_mutable:ei.DeviceInfo.form_factor)
  return _s;
}
inline const std::string& DeviceInfo::_internal_form_factor() const {
  return form_factor_.Get();
}
inline void DeviceInfo::_internal_set_form_factor(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  form_factor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceInfo::_internal_mutable_form_factor() {
  _has_bits_[0] |= 0x00000004u;
  return form_factor_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceInfo::release_form_factor() {
  // @@protoc_insertion_point(field_release:ei.DeviceInfo.form_factor)
  if (!_internal_has_form_factor()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = form_factor_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (form_factor_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    form_factor_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceInfo::set_allocated_form_factor(std::string* form_factor) {
  if (form_factor != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  form_factor_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), form_factor,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (form_factor_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    form_factor_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.DeviceInfo.form_factor)
}

// optional string device_name = 4;
inline bool DeviceInfo::_internal_has_device_name() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DeviceInfo::has_device_name() const {
  return _internal_has_device_name();
}
inline void DeviceInfo::clear_device_name() {
  device_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DeviceInfo::device_name() const {
  // @@protoc_insertion_point(field_get:ei.DeviceInfo.device_name)
  return _internal_device_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInfo::set_device_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 device_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.DeviceInfo.device_name)
}
inline std::string* DeviceInfo::mutable_device_name() {
  std::string* _s = _internal_mutable_device_name();
  // @@protoc_insertion_point(field_mutable:ei.DeviceInfo.device_name)
  return _s;
}
inline const std::string& DeviceInfo::_internal_device_name() const {
  return device_name_.Get();
}
inline void DeviceInfo::_internal_set_device_name(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  device_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceInfo::_internal_mutable_device_name() {
  _has_bits_[0] |= 0x00000008u;
  return device_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceInfo::release_device_name() {
  // @@protoc_insertion_point(field_release:ei.DeviceInfo.device_name)
  if (!_internal_has_device_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = device_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceInfo::set_allocated_device_name(std::string* device_name) {
  if (device_name != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  device_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.DeviceInfo.device_name)
}

// optional string platform_version = 5;
inline bool DeviceInfo::_internal_has_platform_version() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DeviceInfo::has_platform_version() const {
  return _internal_has_platform_version();
}
inline void DeviceInfo::clear_platform_version() {
  platform_version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& DeviceInfo::platform_version() const {
  // @@protoc_insertion_point(field_get:ei.DeviceInfo.platform_version)
  return _internal_platform_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInfo::set_platform_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 platform_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.DeviceInfo.platform_version)
}
inline std::string* DeviceInfo::mutable_platform_version() {
  std::string* _s = _internal_mutable_platform_version();
  // @@protoc_insertion_point(field_mutable:ei.DeviceInfo.platform_version)
  return _s;
}
inline const std::string& DeviceInfo::_internal_platform_version() const {
  return platform_version_.Get();
}
inline void DeviceInfo::_internal_set_platform_version(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  platform_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceInfo::_internal_mutable_platform_version() {
  _has_bits_[0] |= 0x00000010u;
  return platform_version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceInfo::release_platform_version() {
  // @@protoc_insertion_point(field_release:ei.DeviceInfo.platform_version)
  if (!_internal_has_platform_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = platform_version_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (platform_version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    platform_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceInfo::set_allocated_platform_version(std::string* platform_version) {
  if (platform_version != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  platform_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), platform_version,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (platform_version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    platform_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.DeviceInfo.platform_version)
}

// optional string locale_country = 6;
inline bool DeviceInfo::_internal_has_locale_country() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DeviceInfo::has_locale_country() const {
  return _internal_has_locale_country();
}
inline void DeviceInfo::clear_locale_country() {
  locale_country_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& DeviceInfo::locale_country() const {
  // @@protoc_insertion_point(field_get:ei.DeviceInfo.locale_country)
  return _internal_locale_country();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInfo::set_locale_country(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 locale_country_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.DeviceInfo.locale_country)
}
inline std::string* DeviceInfo::mutable_locale_country() {
  std::string* _s = _internal_mutable_locale_country();
  // @@protoc_insertion_point(field_mutable:ei.DeviceInfo.locale_country)
  return _s;
}
inline const std::string& DeviceInfo::_internal_locale_country() const {
  return locale_country_.Get();
}
inline void DeviceInfo::_internal_set_locale_country(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  locale_country_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceInfo::_internal_mutable_locale_country() {
  _has_bits_[0] |= 0x00000020u;
  return locale_country_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceInfo::release_locale_country() {
  // @@protoc_insertion_point(field_release:ei.DeviceInfo.locale_country)
  if (!_internal_has_locale_country()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = locale_country_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (locale_country_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    locale_country_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceInfo::set_allocated_locale_country(std::string* locale_country) {
  if (locale_country != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  locale_country_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), locale_country,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (locale_country_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    locale_country_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.DeviceInfo.locale_country)
}

// optional string locale_language = 7;
inline bool DeviceInfo::_internal_has_locale_language() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DeviceInfo::has_locale_language() const {
  return _internal_has_locale_language();
}
inline void DeviceInfo::clear_locale_language() {
  locale_language_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& DeviceInfo::locale_language() const {
  // @@protoc_insertion_point(field_get:ei.DeviceInfo.locale_language)
  return _internal_locale_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInfo::set_locale_language(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 locale_language_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.DeviceInfo.locale_language)
}
inline std::string* DeviceInfo::mutable_locale_language() {
  std::string* _s = _internal_mutable_locale_language();
  // @@protoc_insertion_point(field_mutable:ei.DeviceInfo.locale_language)
  return _s;
}
inline const std::string& DeviceInfo::_internal_locale_language() const {
  return locale_language_.Get();
}
inline void DeviceInfo::_internal_set_locale_language(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  locale_language_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceInfo::_internal_mutable_locale_language() {
  _has_bits_[0] |= 0x00000040u;
  return locale_language_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceInfo::release_locale_language() {
  // @@protoc_insertion_point(field_release:ei.DeviceInfo.locale_language)
  if (!_internal_has_locale_language()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = locale_language_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (locale_language_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    locale_language_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceInfo::set_allocated_locale_language(std::string* locale_language) {
  if (locale_language != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  locale_language_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), locale_language,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (locale_language_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    locale_language_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.DeviceInfo.locale_language)
}

// optional string gpu_vendor = 8;
inline bool DeviceInfo::_internal_has_gpu_vendor() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool DeviceInfo::has_gpu_vendor() const {
  return _internal_has_gpu_vendor();
}
inline void DeviceInfo::clear_gpu_vendor() {
  gpu_vendor_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& DeviceInfo::gpu_vendor() const {
  // @@protoc_insertion_point(field_get:ei.DeviceInfo.gpu_vendor)
  return _internal_gpu_vendor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInfo::set_gpu_vendor(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 gpu_vendor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.DeviceInfo.gpu_vendor)
}
inline std::string* DeviceInfo::mutable_gpu_vendor() {
  std::string* _s = _internal_mutable_gpu_vendor();
  // @@protoc_insertion_point(field_mutable:ei.DeviceInfo.gpu_vendor)
  return _s;
}
inline const std::string& DeviceInfo::_internal_gpu_vendor() const {
  return gpu_vendor_.Get();
}
inline void DeviceInfo::_internal_set_gpu_vendor(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  gpu_vendor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceInfo::_internal_mutable_gpu_vendor() {
  _has_bits_[0] |= 0x00000080u;
  return gpu_vendor_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceInfo::release_gpu_vendor() {
  // @@protoc_insertion_point(field_release:ei.DeviceInfo.gpu_vendor)
  if (!_internal_has_gpu_vendor()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  auto* p = gpu_vendor_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (gpu_vendor_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    gpu_vendor_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceInfo::set_allocated_gpu_vendor(std::string* gpu_vendor) {
  if (gpu_vendor != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  gpu_vendor_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gpu_vendor,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (gpu_vendor_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    gpu_vendor_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.DeviceInfo.gpu_vendor)
}

// optional string gpu_model = 9;
inline bool DeviceInfo::_internal_has_gpu_model() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool DeviceInfo::has_gpu_model() const {
  return _internal_has_gpu_model();
}
inline void DeviceInfo::clear_gpu_model() {
  gpu_model_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& DeviceInfo::gpu_model() const {
  // @@protoc_insertion_point(field_get:ei.DeviceInfo.gpu_model)
  return _internal_gpu_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInfo::set_gpu_model(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000100u;
 gpu_model_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.DeviceInfo.gpu_model)
}
inline std::string* DeviceInfo::mutable_gpu_model() {
  std::string* _s = _internal_mutable_gpu_model();
  // @@protoc_insertion_point(field_mutable:ei.DeviceInfo.gpu_model)
  return _s;
}
inline const std::string& DeviceInfo::_internal_gpu_model() const {
  return gpu_model_.Get();
}
inline void DeviceInfo::_internal_set_gpu_model(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  gpu_model_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceInfo::_internal_mutable_gpu_model() {
  _has_bits_[0] |= 0x00000100u;
  return gpu_model_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceInfo::release_gpu_model() {
  // @@protoc_insertion_point(field_release:ei.DeviceInfo.gpu_model)
  if (!_internal_has_gpu_model()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  auto* p = gpu_model_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (gpu_model_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    gpu_model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceInfo::set_allocated_gpu_model(std::string* gpu_model) {
  if (gpu_model != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  gpu_model_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gpu_model,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (gpu_model_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    gpu_model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.DeviceInfo.gpu_model)
}

// optional string device_bucket = 10;
inline bool DeviceInfo::_internal_has_device_bucket() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool DeviceInfo::has_device_bucket() const {
  return _internal_has_device_bucket();
}
inline void DeviceInfo::clear_device_bucket() {
  device_bucket_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000200u;
}
inline const std::string& DeviceInfo::device_bucket() const {
  // @@protoc_insertion_point(field_get:ei.DeviceInfo.device_bucket)
  return _internal_device_bucket();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInfo::set_device_bucket(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000200u;
 device_bucket_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.DeviceInfo.device_bucket)
}
inline std::string* DeviceInfo::mutable_device_bucket() {
  std::string* _s = _internal_mutable_device_bucket();
  // @@protoc_insertion_point(field_mutable:ei.DeviceInfo.device_bucket)
  return _s;
}
inline const std::string& DeviceInfo::_internal_device_bucket() const {
  return device_bucket_.Get();
}
inline void DeviceInfo::_internal_set_device_bucket(const std::string& value) {
  _has_bits_[0] |= 0x00000200u;
  device_bucket_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceInfo::_internal_mutable_device_bucket() {
  _has_bits_[0] |= 0x00000200u;
  return device_bucket_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceInfo::release_device_bucket() {
  // @@protoc_insertion_point(field_release:ei.DeviceInfo.device_bucket)
  if (!_internal_has_device_bucket()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000200u;
  auto* p = device_bucket_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_bucket_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_bucket_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceInfo::set_allocated_device_bucket(std::string* device_bucket) {
  if (device_bucket != nullptr) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  device_bucket_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_bucket,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_bucket_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_bucket_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.DeviceInfo.device_bucket)
}

// optional uint32 screen_width = 11;
inline bool DeviceInfo::_internal_has_screen_width() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool DeviceInfo::has_screen_width() const {
  return _internal_has_screen_width();
}
inline void DeviceInfo::clear_screen_width() {
  screen_width_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline uint32_t DeviceInfo::_internal_screen_width() const {
  return screen_width_;
}
inline uint32_t DeviceInfo::screen_width() const {
  // @@protoc_insertion_point(field_get:ei.DeviceInfo.screen_width)
  return _internal_screen_width();
}
inline void DeviceInfo::_internal_set_screen_width(uint32_t value) {
  _has_bits_[0] |= 0x00000800u;
  screen_width_ = value;
}
inline void DeviceInfo::set_screen_width(uint32_t value) {
  _internal_set_screen_width(value);
  // @@protoc_insertion_point(field_set:ei.DeviceInfo.screen_width)
}

// optional uint32 screen_height = 12;
inline bool DeviceInfo::_internal_has_screen_height() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool DeviceInfo::has_screen_height() const {
  return _internal_has_screen_height();
}
inline void DeviceInfo::clear_screen_height() {
  screen_height_ = 0u;
  _has_bits_[0] &= ~0x00001000u;
}
inline uint32_t DeviceInfo::_internal_screen_height() const {
  return screen_height_;
}
inline uint32_t DeviceInfo::screen_height() const {
  // @@protoc_insertion_point(field_get:ei.DeviceInfo.screen_height)
  return _internal_screen_height();
}
inline void DeviceInfo::_internal_set_screen_height(uint32_t value) {
  _has_bits_[0] |= 0x00001000u;
  screen_height_ = value;
}
inline void DeviceInfo::set_screen_height(uint32_t value) {
  _internal_set_screen_height(value);
  // @@protoc_insertion_point(field_set:ei.DeviceInfo.screen_height)
}

// -------------------------------------------------------------------

// AppInfo

// optional string version_str = 1;
inline bool AppInfo::_internal_has_version_str() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AppInfo::has_version_str() const {
  return _internal_has_version_str();
}
inline void AppInfo::clear_version_str() {
  version_str_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppInfo::version_str() const {
  // @@protoc_insertion_point(field_get:ei.AppInfo.version_str)
  return _internal_version_str();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppInfo::set_version_str(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 version_str_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AppInfo.version_str)
}
inline std::string* AppInfo::mutable_version_str() {
  std::string* _s = _internal_mutable_version_str();
  // @@protoc_insertion_point(field_mutable:ei.AppInfo.version_str)
  return _s;
}
inline const std::string& AppInfo::_internal_version_str() const {
  return version_str_.Get();
}
inline void AppInfo::_internal_set_version_str(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  version_str_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AppInfo::_internal_mutable_version_str() {
  _has_bits_[0] |= 0x00000001u;
  return version_str_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppInfo::release_version_str() {
  // @@protoc_insertion_point(field_release:ei.AppInfo.version_str)
  if (!_internal_has_version_str()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = version_str_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_str_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    version_str_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AppInfo::set_allocated_version_str(std::string* version_str) {
  if (version_str != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  version_str_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version_str,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_str_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    version_str_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AppInfo.version_str)
}

// optional uint32 sessions = 2;
inline bool AppInfo::_internal_has_sessions() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AppInfo::has_sessions() const {
  return _internal_has_sessions();
}
inline void AppInfo::clear_sessions() {
  sessions_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t AppInfo::_internal_sessions() const {
  return sessions_;
}
inline uint32_t AppInfo::sessions() const {
  // @@protoc_insertion_point(field_get:ei.AppInfo.sessions)
  return _internal_sessions();
}
inline void AppInfo::_internal_set_sessions(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  sessions_ = value;
}
inline void AppInfo::set_sessions(uint32_t value) {
  _internal_set_sessions(value);
  // @@protoc_insertion_point(field_set:ei.AppInfo.sessions)
}

// optional uint32 num_prestiges = 3;
inline bool AppInfo::_internal_has_num_prestiges() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AppInfo::has_num_prestiges() const {
  return _internal_has_num_prestiges();
}
inline void AppInfo::clear_num_prestiges() {
  num_prestiges_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t AppInfo::_internal_num_prestiges() const {
  return num_prestiges_;
}
inline uint32_t AppInfo::num_prestiges() const {
  // @@protoc_insertion_point(field_get:ei.AppInfo.num_prestiges)
  return _internal_num_prestiges();
}
inline void AppInfo::_internal_set_num_prestiges(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  num_prestiges_ = value;
}
inline void AppInfo::set_num_prestiges(uint32_t value) {
  _internal_set_num_prestiges(value);
  // @@protoc_insertion_point(field_set:ei.AppInfo.num_prestiges)
}

// optional uint64 soul_eggs = 4;
inline bool AppInfo::_internal_has_soul_eggs() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AppInfo::has_soul_eggs() const {
  return _internal_has_soul_eggs();
}
inline void AppInfo::clear_soul_eggs() {
  soul_eggs_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000010u;
}
inline uint64_t AppInfo::_internal_soul_eggs() const {
  return soul_eggs_;
}
inline uint64_t AppInfo::soul_eggs() const {
  // @@protoc_insertion_point(field_get:ei.AppInfo.soul_eggs)
  return _internal_soul_eggs();
}
inline void AppInfo::_internal_set_soul_eggs(uint64_t value) {
  _has_bits_[0] |= 0x00000010u;
  soul_eggs_ = value;
}
inline void AppInfo::set_soul_eggs(uint64_t value) {
  _internal_set_soul_eggs(value);
  // @@protoc_insertion_point(field_set:ei.AppInfo.soul_eggs)
}

// optional uint32 current_egg = 5;
inline bool AppInfo::_internal_has_current_egg() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool AppInfo::has_current_egg() const {
  return _internal_has_current_egg();
}
inline void AppInfo::clear_current_egg() {
  current_egg_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t AppInfo::_internal_current_egg() const {
  return current_egg_;
}
inline uint32_t AppInfo::current_egg() const {
  // @@protoc_insertion_point(field_get:ei.AppInfo.current_egg)
  return _internal_current_egg();
}
inline void AppInfo::_internal_set_current_egg(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  current_egg_ = value;
}
inline void AppInfo::set_current_egg(uint32_t value) {
  _internal_set_current_egg(value);
  // @@protoc_insertion_point(field_set:ei.AppInfo.current_egg)
}

// optional uint64 gold_earned = 6;
inline bool AppInfo::_internal_has_gold_earned() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool AppInfo::has_gold_earned() const {
  return _internal_has_gold_earned();
}
inline void AppInfo::clear_gold_earned() {
  gold_earned_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000020u;
}
inline uint64_t AppInfo::_internal_gold_earned() const {
  return gold_earned_;
}
inline uint64_t AppInfo::gold_earned() const {
  // @@protoc_insertion_point(field_get:ei.AppInfo.gold_earned)
  return _internal_gold_earned();
}
inline void AppInfo::_internal_set_gold_earned(uint64_t value) {
  _has_bits_[0] |= 0x00000020u;
  gold_earned_ = value;
}
inline void AppInfo::set_gold_earned(uint64_t value) {
  _internal_set_gold_earned(value);
  // @@protoc_insertion_point(field_set:ei.AppInfo.gold_earned)
}

// optional uint64 gold_spent = 7;
inline bool AppInfo::_internal_has_gold_spent() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool AppInfo::has_gold_spent() const {
  return _internal_has_gold_spent();
}
inline void AppInfo::clear_gold_spent() {
  gold_spent_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000100u;
}
inline uint64_t AppInfo::_internal_gold_spent() const {
  return gold_spent_;
}
inline uint64_t AppInfo::gold_spent() const {
  // @@protoc_insertion_point(field_get:ei.AppInfo.gold_spent)
  return _internal_gold_spent();
}
inline void AppInfo::_internal_set_gold_spent(uint64_t value) {
  _has_bits_[0] |= 0x00000100u;
  gold_spent_ = value;
}
inline void AppInfo::set_gold_spent(uint64_t value) {
  _internal_set_gold_spent(value);
  // @@protoc_insertion_point(field_set:ei.AppInfo.gold_spent)
}

// optional uint32 current_mission = 8;
inline bool AppInfo::_internal_has_current_mission() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool AppInfo::has_current_mission() const {
  return _internal_has_current_mission();
}
inline void AppInfo::clear_current_mission() {
  current_mission_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline uint32_t AppInfo::_internal_current_mission() const {
  return current_mission_;
}
inline uint32_t AppInfo::current_mission() const {
  // @@protoc_insertion_point(field_get:ei.AppInfo.current_mission)
  return _internal_current_mission();
}
inline void AppInfo::_internal_set_current_mission(uint32_t value) {
  _has_bits_[0] |= 0x00000080u;
  current_mission_ = value;
}
inline void AppInfo::set_current_mission(uint32_t value) {
  _internal_set_current_mission(value);
  // @@protoc_insertion_point(field_set:ei.AppInfo.current_mission)
}

// optional uint32 piggy_size = 9;
inline bool AppInfo::_internal_has_piggy_size() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool AppInfo::has_piggy_size() const {
  return _internal_has_piggy_size();
}
inline void AppInfo::clear_piggy_size() {
  piggy_size_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline uint32_t AppInfo::_internal_piggy_size() const {
  return piggy_size_;
}
inline uint32_t AppInfo::piggy_size() const {
  // @@protoc_insertion_point(field_get:ei.AppInfo.piggy_size)
  return _internal_piggy_size();
}
inline void AppInfo::_internal_set_piggy_size(uint32_t value) {
  _has_bits_[0] |= 0x00000400u;
  piggy_size_ = value;
}
inline void AppInfo::set_piggy_size(uint32_t value) {
  _internal_set_piggy_size(value);
  // @@protoc_insertion_point(field_set:ei.AppInfo.piggy_size)
}

// optional uint64 num_piggy_breaks = 10;
inline bool AppInfo::_internal_has_num_piggy_breaks() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool AppInfo::has_num_piggy_breaks() const {
  return _internal_has_num_piggy_breaks();
}
inline void AppInfo::clear_num_piggy_breaks() {
  num_piggy_breaks_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000200u;
}
inline uint64_t AppInfo::_internal_num_piggy_breaks() const {
  return num_piggy_breaks_;
}
inline uint64_t AppInfo::num_piggy_breaks() const {
  // @@protoc_insertion_point(field_get:ei.AppInfo.num_piggy_breaks)
  return _internal_num_piggy_breaks();
}
inline void AppInfo::_internal_set_num_piggy_breaks(uint64_t value) {
  _has_bits_[0] |= 0x00000200u;
  num_piggy_breaks_ = value;
}
inline void AppInfo::set_num_piggy_breaks(uint64_t value) {
  _internal_set_num_piggy_breaks(value);
  // @@protoc_insertion_point(field_set:ei.AppInfo.num_piggy_breaks)
}

// optional uint64 verified_piggy_breaks = 29;
inline bool AppInfo::_internal_has_verified_piggy_breaks() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool AppInfo::has_verified_piggy_breaks() const {
  return _internal_has_verified_piggy_breaks();
}
inline void AppInfo::clear_verified_piggy_breaks() {
  verified_piggy_breaks_ = uint64_t{0u};
  _has_bits_[0] &= ~0x02000000u;
}
inline uint64_t AppInfo::_internal_verified_piggy_breaks() const {
  return verified_piggy_breaks_;
}
inline uint64_t AppInfo::verified_piggy_breaks() const {
  // @@protoc_insertion_point(field_get:ei.AppInfo.verified_piggy_breaks)
  return _internal_verified_piggy_breaks();
}
inline void AppInfo::_internal_set_verified_piggy_breaks(uint64_t value) {
  _has_bits_[0] |= 0x02000000u;
  verified_piggy_breaks_ = value;
}
inline void AppInfo::set_verified_piggy_breaks(uint64_t value) {
  _internal_set_verified_piggy_breaks(value);
  // @@protoc_insertion_point(field_set:ei.AppInfo.verified_piggy_breaks)
}

// optional uint64 iap_packs_purchased = 11;
inline bool AppInfo::_internal_has_iap_packs_purchased() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool AppInfo::has_iap_packs_purchased() const {
  return _internal_has_iap_packs_purchased();
}
inline void AppInfo::clear_iap_packs_purchased() {
  iap_packs_purchased_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00001000u;
}
inline uint64_t AppInfo::_internal_iap_packs_purchased() const {
  return iap_packs_purchased_;
}
inline uint64_t AppInfo::iap_packs_purchased() const {
  // @@protoc_insertion_point(field_get:ei.AppInfo.iap_packs_purchased)
  return _internal_iap_packs_purchased();
}
inline void AppInfo::_internal_set_iap_packs_purchased(uint64_t value) {
  _has_bits_[0] |= 0x00001000u;
  iap_packs_purchased_ = value;
}
inline void AppInfo::set_iap_packs_purchased(uint64_t value) {
  _internal_set_iap_packs_purchased(value);
  // @@protoc_insertion_point(field_set:ei.AppInfo.iap_packs_purchased)
}

// optional uint32 permit_level = 12;
inline bool AppInfo::_internal_has_permit_level() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool AppInfo::has_permit_level() const {
  return _internal_has_permit_level();
}
inline void AppInfo::clear_permit_level() {
  permit_level_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline uint32_t AppInfo::_internal_permit_level() const {
  return permit_level_;
}
inline uint32_t AppInfo::permit_level() const {
  // @@protoc_insertion_point(field_get:ei.AppInfo.permit_level)
  return _internal_permit_level();
}
inline void AppInfo::_internal_set_permit_level(uint32_t value) {
  _has_bits_[0] |= 0x00000800u;
  permit_level_ = value;
}
inline void AppInfo::set_permit_level(uint32_t value) {
  _internal_set_permit_level(value);
  // @@protoc_insertion_point(field_set:ei.AppInfo.permit_level)
}

// optional uint64 video_doubler_uses = 15;
inline bool AppInfo::_internal_has_video_doubler_uses() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool AppInfo::has_video_doubler_uses() const {
  return _internal_has_video_doubler_uses();
}
inline void AppInfo::clear_video_doubler_uses() {
  video_doubler_uses_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00008000u;
}
inline uint64_t AppInfo::_internal_video_doubler_uses() const {
  return video_doubler_uses_;
}
inline uint64_t AppInfo::video_doubler_uses() const {
  // @@protoc_insertion_point(field_get:ei.AppInfo.video_doubler_uses)
  return _internal_video_doubler_uses();
}
inline void AppInfo::_internal_set_video_doubler_uses(uint64_t value) {
  _has_bits_[0] |= 0x00008000u;
  video_doubler_uses_ = value;
}
inline void AppInfo::set_video_doubler_uses(uint64_t value) {
  _internal_set_video_doubler_uses(value);
  // @@protoc_insertion_point(field_set:ei.AppInfo.video_doubler_uses)
}

// optional uint64 drone_takedowns = 18;
inline bool AppInfo::_internal_has_drone_takedowns() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool AppInfo::has_drone_takedowns() const {
  return _internal_has_drone_takedowns();
}
inline void AppInfo::clear_drone_takedowns() {
  drone_takedowns_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00040000u;
}
inline uint64_t AppInfo::_internal_drone_takedowns() const {
  return drone_takedowns_;
}
inline uint64_t AppInfo::drone_takedowns() const {
  // @@protoc_insertion_point(field_get:ei.AppInfo.drone_takedowns)
  return _internal_drone_takedowns();
}
inline void AppInfo::_internal_set_drone_takedowns(uint64_t value) {
  _has_bits_[0] |= 0x00040000u;
  drone_takedowns_ = value;
}
inline void AppInfo::set_drone_takedowns(uint64_t value) {
  _internal_set_drone_takedowns(value);
  // @@protoc_insertion_point(field_set:ei.AppInfo.drone_takedowns)
}

// optional uint64 drone_takedowns_elite = 19;
inline bool AppInfo::_internal_has_drone_takedowns_elite() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool AppInfo::has_drone_takedowns_elite() const {
  return _internal_has_drone_takedowns_elite();
}
inline void AppInfo::clear_drone_takedowns_elite() {
  drone_takedowns_elite_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00080000u;
}
inline uint64_t AppInfo::_internal_drone_takedowns_elite() const {
  return drone_takedowns_elite_;
}
inline uint64_t AppInfo::drone_takedowns_elite() const {
  // @@protoc_insertion_point(field_get:ei.AppInfo.drone_takedowns_elite)
  return _internal_drone_takedowns_elite();
}
inline void AppInfo::_internal_set_drone_takedowns_elite(uint64_t value) {
  _has_bits_[0] |= 0x00080000u;
  drone_takedowns_elite_ = value;
}
inline void AppInfo::set_drone_takedowns_elite(uint64_t value) {
  _internal_set_drone_takedowns_elite(value);
  // @@protoc_insertion_point(field_set:ei.AppInfo.drone_takedowns_elite)
}

// optional bool trophies_unlocked = 20;
inline bool AppInfo::_internal_has_trophies_unlocked() const {
  bool value = (_has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool AppInfo::has_trophies_unlocked() const {
  return _internal_has_trophies_unlocked();
}
inline void AppInfo::clear_trophies_unlocked() {
  trophies_unlocked_ = false;
  _has_bits_[0] &= ~0x04000000u;
}
inline bool AppInfo::_internal_trophies_unlocked() const {
  return trophies_unlocked_;
}
inline bool AppInfo::trophies_unlocked() const {
  // @@protoc_insertion_point(field_get:ei.AppInfo.trophies_unlocked)
  return _internal_trophies_unlocked();
}
inline void AppInfo::_internal_set_trophies_unlocked(bool value) {
  _has_bits_[0] |= 0x04000000u;
  trophies_unlocked_ = value;
}
inline void AppInfo::set_trophies_unlocked(bool value) {
  _internal_set_trophies_unlocked(value);
  // @@protoc_insertion_point(field_set:ei.AppInfo.trophies_unlocked)
}

// optional float egg_level = 21;
inline bool AppInfo::_internal_has_egg_level() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool AppInfo::has_egg_level() const {
  return _internal_has_egg_level();
}
inline void AppInfo::clear_egg_level() {
  egg_level_ = 0;
  _has_bits_[0] &= ~0x00100000u;
}
inline float AppInfo::_internal_egg_level() const {
  return egg_level_;
}
inline float AppInfo::egg_level() const {
  // @@protoc_insertion_point(field_get:ei.AppInfo.egg_level)
  return _internal_egg_level();
}
inline void AppInfo::_internal_set_egg_level(float value) {
  _has_bits_[0] |= 0x00100000u;
  egg_level_ = value;
}
inline void AppInfo::set_egg_level(float value) {
  _internal_set_egg_level(value);
  // @@protoc_insertion_point(field_set:ei.AppInfo.egg_level)
}

// optional float struggle_factor = 22;
inline bool AppInfo::_internal_has_struggle_factor() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool AppInfo::has_struggle_factor() const {
  return _internal_has_struggle_factor();
}
inline void AppInfo::clear_struggle_factor() {
  struggle_factor_ = 0;
  _has_bits_[0] &= ~0x00200000u;
}
inline float AppInfo::_internal_struggle_factor() const {
  return struggle_factor_;
}
inline float AppInfo::struggle_factor() const {
  // @@protoc_insertion_point(field_get:ei.AppInfo.struggle_factor)
  return _internal_struggle_factor();
}
inline void AppInfo::_internal_set_struggle_factor(float value) {
  _has_bits_[0] |= 0x00200000u;
  struggle_factor_ = value;
}
inline void AppInfo::set_struggle_factor(float value) {
  _internal_set_struggle_factor(value);
  // @@protoc_insertion_point(field_set:ei.AppInfo.struggle_factor)
}

// optional bool piggy_full = 23;
inline bool AppInfo::_internal_has_piggy_full() const {
  bool value = (_has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool AppInfo::has_piggy_full() const {
  return _internal_has_piggy_full();
}
inline void AppInfo::clear_piggy_full() {
  piggy_full_ = false;
  _has_bits_[0] &= ~0x08000000u;
}
inline bool AppInfo::_internal_piggy_full() const {
  return piggy_full_;
}
inline bool AppInfo::piggy_full() const {
  // @@protoc_insertion_point(field_get:ei.AppInfo.piggy_full)
  return _internal_piggy_full();
}
inline void AppInfo::_internal_set_piggy_full(bool value) {
  _has_bits_[0] |= 0x08000000u;
  piggy_full_ = value;
}
inline void AppInfo::set_piggy_full(bool value) {
  _internal_set_piggy_full(value);
  // @@protoc_insertion_point(field_set:ei.AppInfo.piggy_full)
}

// optional bool piggy_found_full = 24;
inline bool AppInfo::_internal_has_piggy_found_full() const {
  bool value = (_has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool AppInfo::has_piggy_found_full() const {
  return _internal_has_piggy_found_full();
}
inline void AppInfo::clear_piggy_found_full() {
  piggy_found_full_ = false;
  _has_bits_[0] &= ~0x10000000u;
}
inline bool AppInfo::_internal_piggy_found_full() const {
  return piggy_found_full_;
}
inline bool AppInfo::piggy_found_full() const {
  // @@protoc_insertion_point(field_get:ei.AppInfo.piggy_found_full)
  return _internal_piggy_found_full();
}
inline void AppInfo::_internal_set_piggy_found_full(bool value) {
  _has_bits_[0] |= 0x10000000u;
  piggy_found_full_ = value;
}
inline void AppInfo::set_piggy_found_full(bool value) {
  _internal_set_piggy_found_full(value);
  // @@protoc_insertion_point(field_set:ei.AppInfo.piggy_found_full)
}

// optional double time_piggy_full_realtime = 25;
inline bool AppInfo::_internal_has_time_piggy_full_realtime() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool AppInfo::has_time_piggy_full_realtime() const {
  return _internal_has_time_piggy_full_realtime();
}
inline void AppInfo::clear_time_piggy_full_realtime() {
  time_piggy_full_realtime_ = 0;
  _has_bits_[0] &= ~0x00400000u;
}
inline double AppInfo::_internal_time_piggy_full_realtime() const {
  return time_piggy_full_realtime_;
}
inline double AppInfo::time_piggy_full_realtime() const {
  // @@protoc_insertion_point(field_get:ei.AppInfo.time_piggy_full_realtime)
  return _internal_time_piggy_full_realtime();
}
inline void AppInfo::_internal_set_time_piggy_full_realtime(double value) {
  _has_bits_[0] |= 0x00400000u;
  time_piggy_full_realtime_ = value;
}
inline void AppInfo::set_time_piggy_full_realtime(double value) {
  _internal_set_time_piggy_full_realtime(value);
  // @@protoc_insertion_point(field_set:ei.AppInfo.time_piggy_full_realtime)
}

// optional double time_piggy_full_gametime = 26;
inline bool AppInfo::_internal_has_time_piggy_full_gametime() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool AppInfo::has_time_piggy_full_gametime() const {
  return _internal_has_time_piggy_full_gametime();
}
inline void AppInfo::clear_time_piggy_full_gametime() {
  time_piggy_full_gametime_ = 0;
  _has_bits_[0] &= ~0x00800000u;
}
inline double AppInfo::_internal_time_piggy_full_gametime() const {
  return time_piggy_full_gametime_;
}
inline double AppInfo::time_piggy_full_gametime() const {
  // @@protoc_insertion_point(field_get:ei.AppInfo.time_piggy_full_gametime)
  return _internal_time_piggy_full_gametime();
}
inline void AppInfo::_internal_set_time_piggy_full_gametime(double value) {
  _has_bits_[0] |= 0x00800000u;
  time_piggy_full_gametime_ = value;
}
inline void AppInfo::set_time_piggy_full_gametime(double value) {
  _internal_set_time_piggy_full_gametime(value);
  // @@protoc_insertion_point(field_set:ei.AppInfo.time_piggy_full_gametime)
}

// optional uint64 lost_piggy_increments = 27;
inline bool AppInfo::_internal_has_lost_piggy_increments() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool AppInfo::has_lost_piggy_increments() const {
  return _internal_has_lost_piggy_increments();
}
inline void AppInfo::clear_lost_piggy_increments() {
  lost_piggy_increments_ = uint64_t{0u};
  _has_bits_[0] &= ~0x01000000u;
}
inline uint64_t AppInfo::_internal_lost_piggy_increments() const {
  return lost_piggy_increments_;
}
inline uint64_t AppInfo::lost_piggy_increments() const {
  // @@protoc_insertion_point(field_get:ei.AppInfo.lost_piggy_increments)
  return _internal_lost_piggy_increments();
}
inline void AppInfo::_internal_set_lost_piggy_increments(uint64_t value) {
  _has_bits_[0] |= 0x01000000u;
  lost_piggy_increments_ = value;
}
inline void AppInfo::set_lost_piggy_increments(uint64_t value) {
  _internal_set_lost_piggy_increments(value);
  // @@protoc_insertion_point(field_set:ei.AppInfo.lost_piggy_increments)
}

// optional string sale_id = 28;
inline bool AppInfo::_internal_has_sale_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AppInfo::has_sale_id() const {
  return _internal_has_sale_id();
}
inline void AppInfo::clear_sale_id() {
  sale_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AppInfo::sale_id() const {
  // @@protoc_insertion_point(field_get:ei.AppInfo.sale_id)
  return _internal_sale_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppInfo::set_sale_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 sale_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AppInfo.sale_id)
}
inline std::string* AppInfo::mutable_sale_id() {
  std::string* _s = _internal_mutable_sale_id();
  // @@protoc_insertion_point(field_mutable:ei.AppInfo.sale_id)
  return _s;
}
inline const std::string& AppInfo::_internal_sale_id() const {
  return sale_id_.Get();
}
inline void AppInfo::_internal_set_sale_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  sale_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AppInfo::_internal_mutable_sale_id() {
  _has_bits_[0] |= 0x00000002u;
  return sale_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppInfo::release_sale_id() {
  // @@protoc_insertion_point(field_release:ei.AppInfo.sale_id)
  if (!_internal_has_sale_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = sale_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sale_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sale_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AppInfo::set_allocated_sale_id(std::string* sale_id) {
  if (sale_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  sale_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sale_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sale_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sale_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AppInfo.sale_id)
}

// optional uint64 unlimited_chickens_uses = 13;
inline bool AppInfo::_internal_has_unlimited_chickens_uses() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool AppInfo::has_unlimited_chickens_uses() const {
  return _internal_has_unlimited_chickens_uses();
}
inline void AppInfo::clear_unlimited_chickens_uses() {
  unlimited_chickens_uses_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00002000u;
}
inline uint64_t AppInfo::_internal_unlimited_chickens_uses() const {
  return unlimited_chickens_uses_;
}
inline uint64_t AppInfo::unlimited_chickens_uses() const {
  // @@protoc_insertion_point(field_get:ei.AppInfo.unlimited_chickens_uses)
  return _internal_unlimited_chickens_uses();
}
inline void AppInfo::_internal_set_unlimited_chickens_uses(uint64_t value) {
  _has_bits_[0] |= 0x00002000u;
  unlimited_chickens_uses_ = value;
}
inline void AppInfo::set_unlimited_chickens_uses(uint64_t value) {
  _internal_set_unlimited_chickens_uses(value);
  // @@protoc_insertion_point(field_set:ei.AppInfo.unlimited_chickens_uses)
}

// optional uint64 refill_uses = 14;
inline bool AppInfo::_internal_has_refill_uses() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool AppInfo::has_refill_uses() const {
  return _internal_has_refill_uses();
}
inline void AppInfo::clear_refill_uses() {
  refill_uses_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00004000u;
}
inline uint64_t AppInfo::_internal_refill_uses() const {
  return refill_uses_;
}
inline uint64_t AppInfo::refill_uses() const {
  // @@protoc_insertion_point(field_get:ei.AppInfo.refill_uses)
  return _internal_refill_uses();
}
inline void AppInfo::_internal_set_refill_uses(uint64_t value) {
  _has_bits_[0] |= 0x00004000u;
  refill_uses_ = value;
}
inline void AppInfo::set_refill_uses(uint64_t value) {
  _internal_set_refill_uses(value);
  // @@protoc_insertion_point(field_set:ei.AppInfo.refill_uses)
}

// optional uint64 short_warp_uses = 16;
inline bool AppInfo::_internal_has_short_warp_uses() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool AppInfo::has_short_warp_uses() const {
  return _internal_has_short_warp_uses();
}
inline void AppInfo::clear_short_warp_uses() {
  short_warp_uses_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00010000u;
}
inline uint64_t AppInfo::_internal_short_warp_uses() const {
  return short_warp_uses_;
}
inline uint64_t AppInfo::short_warp_uses() const {
  // @@protoc_insertion_point(field_get:ei.AppInfo.short_warp_uses)
  return _internal_short_warp_uses();
}
inline void AppInfo::_internal_set_short_warp_uses(uint64_t value) {
  _has_bits_[0] |= 0x00010000u;
  short_warp_uses_ = value;
}
inline void AppInfo::set_short_warp_uses(uint64_t value) {
  _internal_set_short_warp_uses(value);
  // @@protoc_insertion_point(field_set:ei.AppInfo.short_warp_uses)
}

// optional uint64 long_warp_uses = 17;
inline bool AppInfo::_internal_has_long_warp_uses() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool AppInfo::has_long_warp_uses() const {
  return _internal_has_long_warp_uses();
}
inline void AppInfo::clear_long_warp_uses() {
  long_warp_uses_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00020000u;
}
inline uint64_t AppInfo::_internal_long_warp_uses() const {
  return long_warp_uses_;
}
inline uint64_t AppInfo::long_warp_uses() const {
  // @@protoc_insertion_point(field_get:ei.AppInfo.long_warp_uses)
  return _internal_long_warp_uses();
}
inline void AppInfo::_internal_set_long_warp_uses(uint64_t value) {
  _has_bits_[0] |= 0x00020000u;
  long_warp_uses_ = value;
}
inline void AppInfo::set_long_warp_uses(uint64_t value) {
  _internal_set_long_warp_uses(value);
  // @@protoc_insertion_point(field_set:ei.AppInfo.long_warp_uses)
}

// -------------------------------------------------------------------

// ActionKeyValuePair

// required string key = 1;
inline bool ActionKeyValuePair::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ActionKeyValuePair::has_key() const {
  return _internal_has_key();
}
inline void ActionKeyValuePair::clear_key() {
  key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ActionKeyValuePair::key() const {
  // @@protoc_insertion_point(field_get:ei.ActionKeyValuePair.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionKeyValuePair::set_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ActionKeyValuePair.key)
}
inline std::string* ActionKeyValuePair::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:ei.ActionKeyValuePair.key)
  return _s;
}
inline const std::string& ActionKeyValuePair::_internal_key() const {
  return key_.Get();
}
inline void ActionKeyValuePair::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActionKeyValuePair::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActionKeyValuePair::release_key() {
  // @@protoc_insertion_point(field_release:ei.ActionKeyValuePair.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ActionKeyValuePair::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ActionKeyValuePair.key)
}

// required string value = 2;
inline bool ActionKeyValuePair::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ActionKeyValuePair::has_value() const {
  return _internal_has_value();
}
inline void ActionKeyValuePair::clear_value() {
  value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ActionKeyValuePair::value() const {
  // @@protoc_insertion_point(field_get:ei.ActionKeyValuePair.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionKeyValuePair::set_value(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ActionKeyValuePair.value)
}
inline std::string* ActionKeyValuePair::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:ei.ActionKeyValuePair.value)
  return _s;
}
inline const std::string& ActionKeyValuePair::_internal_value() const {
  return value_.Get();
}
inline void ActionKeyValuePair::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ActionKeyValuePair::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ActionKeyValuePair::release_value() {
  // @@protoc_insertion_point(field_release:ei.ActionKeyValuePair.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ActionKeyValuePair::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ActionKeyValuePair.value)
}

// -------------------------------------------------------------------

// GenericAction

// optional string user_id = 1;
inline bool GenericAction::_internal_has_user_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GenericAction::has_user_id() const {
  return _internal_has_user_id();
}
inline void GenericAction::clear_user_id() {
  user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GenericAction::user_id() const {
  // @@protoc_insertion_point(field_get:ei.GenericAction.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenericAction::set_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.GenericAction.user_id)
}
inline std::string* GenericAction::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:ei.GenericAction.user_id)
  return _s;
}
inline const std::string& GenericAction::_internal_user_id() const {
  return user_id_.Get();
}
inline void GenericAction::_internal_set_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GenericAction::_internal_mutable_user_id() {
  _has_bits_[0] |= 0x00000001u;
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GenericAction::release_user_id() {
  // @@protoc_insertion_point(field_release:ei.GenericAction.user_id)
  if (!_internal_has_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GenericAction::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.GenericAction.user_id)
}

// optional string advertising_id = 7;
inline bool GenericAction::_internal_has_advertising_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GenericAction::has_advertising_id() const {
  return _internal_has_advertising_id();
}
inline void GenericAction::clear_advertising_id() {
  advertising_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& GenericAction::advertising_id() const {
  // @@protoc_insertion_point(field_get:ei.GenericAction.advertising_id)
  return _internal_advertising_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenericAction::set_advertising_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 advertising_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.GenericAction.advertising_id)
}
inline std::string* GenericAction::mutable_advertising_id() {
  std::string* _s = _internal_mutable_advertising_id();
  // @@protoc_insertion_point(field_mutable:ei.GenericAction.advertising_id)
  return _s;
}
inline const std::string& GenericAction::_internal_advertising_id() const {
  return advertising_id_.Get();
}
inline void GenericAction::_internal_set_advertising_id(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  advertising_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GenericAction::_internal_mutable_advertising_id() {
  _has_bits_[0] |= 0x00000004u;
  return advertising_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GenericAction::release_advertising_id() {
  // @@protoc_insertion_point(field_release:ei.GenericAction.advertising_id)
  if (!_internal_has_advertising_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = advertising_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (advertising_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    advertising_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GenericAction::set_allocated_advertising_id(std::string* advertising_id) {
  if (advertising_id != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  advertising_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), advertising_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (advertising_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    advertising_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.GenericAction.advertising_id)
}

// optional float approx_time_DEP = 2;
inline bool GenericAction::_internal_has_approx_time_dep() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool GenericAction::has_approx_time_dep() const {
  return _internal_has_approx_time_dep();
}
inline void GenericAction::clear_approx_time_dep() {
  approx_time_dep_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float GenericAction::_internal_approx_time_dep() const {
  return approx_time_dep_;
}
inline float GenericAction::approx_time_dep() const {
  // @@protoc_insertion_point(field_get:ei.GenericAction.approx_time_DEP)
  return _internal_approx_time_dep();
}
inline void GenericAction::_internal_set_approx_time_dep(float value) {
  _has_bits_[0] |= 0x00000040u;
  approx_time_dep_ = value;
}
inline void GenericAction::set_approx_time_dep(float value) {
  _internal_set_approx_time_dep(value);
  // @@protoc_insertion_point(field_set:ei.GenericAction.approx_time_DEP)
}

// optional double approx_time = 8;
inline bool GenericAction::_internal_has_approx_time() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool GenericAction::has_approx_time() const {
  return _internal_has_approx_time();
}
inline void GenericAction::clear_approx_time() {
  approx_time_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double GenericAction::_internal_approx_time() const {
  return approx_time_;
}
inline double GenericAction::approx_time() const {
  // @@protoc_insertion_point(field_get:ei.GenericAction.approx_time)
  return _internal_approx_time();
}
inline void GenericAction::_internal_set_approx_time(double value) {
  _has_bits_[0] |= 0x00000020u;
  approx_time_ = value;
}
inline void GenericAction::set_approx_time(double value) {
  _internal_set_approx_time(value);
  // @@protoc_insertion_point(field_set:ei.GenericAction.approx_time)
}

// optional string action_name = 3;
inline bool GenericAction::_internal_has_action_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GenericAction::has_action_name() const {
  return _internal_has_action_name();
}
inline void GenericAction::clear_action_name() {
  action_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GenericAction::action_name() const {
  // @@protoc_insertion_point(field_get:ei.GenericAction.action_name)
  return _internal_action_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenericAction::set_action_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 action_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.GenericAction.action_name)
}
inline std::string* GenericAction::mutable_action_name() {
  std::string* _s = _internal_mutable_action_name();
  // @@protoc_insertion_point(field_mutable:ei.GenericAction.action_name)
  return _s;
}
inline const std::string& GenericAction::_internal_action_name() const {
  return action_name_.Get();
}
inline void GenericAction::_internal_set_action_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  action_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GenericAction::_internal_mutable_action_name() {
  _has_bits_[0] |= 0x00000002u;
  return action_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GenericAction::release_action_name() {
  // @@protoc_insertion_point(field_release:ei.GenericAction.action_name)
  if (!_internal_has_action_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = action_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (action_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    action_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GenericAction::set_allocated_action_name(std::string* action_name) {
  if (action_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  action_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), action_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (action_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    action_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.GenericAction.action_name)
}

// repeated .ei.ActionKeyValuePair data = 4;
inline int GenericAction::_internal_data_size() const {
  return data_.size();
}
inline int GenericAction::data_size() const {
  return _internal_data_size();
}
inline void GenericAction::clear_data() {
  data_.Clear();
}
inline ::ei::ActionKeyValuePair* GenericAction::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:ei.GenericAction.data)
  return data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ActionKeyValuePair >*
GenericAction::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:ei.GenericAction.data)
  return &data_;
}
inline const ::ei::ActionKeyValuePair& GenericAction::_internal_data(int index) const {
  return data_.Get(index);
}
inline const ::ei::ActionKeyValuePair& GenericAction::data(int index) const {
  // @@protoc_insertion_point(field_get:ei.GenericAction.data)
  return _internal_data(index);
}
inline ::ei::ActionKeyValuePair* GenericAction::_internal_add_data() {
  return data_.Add();
}
inline ::ei::ActionKeyValuePair* GenericAction::add_data() {
  ::ei::ActionKeyValuePair* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:ei.GenericAction.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ActionKeyValuePair >&
GenericAction::data() const {
  // @@protoc_insertion_point(field_list:ei.GenericAction.data)
  return data_;
}

// optional .ei.AppInfo app = 5;
inline bool GenericAction::_internal_has_app() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || app_ != nullptr);
  return value;
}
inline bool GenericAction::has_app() const {
  return _internal_has_app();
}
inline void GenericAction::clear_app() {
  if (app_ != nullptr) app_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ei::AppInfo& GenericAction::_internal_app() const {
  const ::ei::AppInfo* p = app_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::AppInfo&>(
      ::ei::_AppInfo_default_instance_);
}
inline const ::ei::AppInfo& GenericAction::app() const {
  // @@protoc_insertion_point(field_get:ei.GenericAction.app)
  return _internal_app();
}
inline void GenericAction::unsafe_arena_set_allocated_app(
    ::ei::AppInfo* app) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(app_);
  }
  app_ = app;
  if (app) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.GenericAction.app)
}
inline ::ei::AppInfo* GenericAction::release_app() {
  _has_bits_[0] &= ~0x00000008u;
  ::ei::AppInfo* temp = app_;
  app_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::AppInfo* GenericAction::unsafe_arena_release_app() {
  // @@protoc_insertion_point(field_release:ei.GenericAction.app)
  _has_bits_[0] &= ~0x00000008u;
  ::ei::AppInfo* temp = app_;
  app_ = nullptr;
  return temp;
}
inline ::ei::AppInfo* GenericAction::_internal_mutable_app() {
  _has_bits_[0] |= 0x00000008u;
  if (app_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::AppInfo>(GetArenaForAllocation());
    app_ = p;
  }
  return app_;
}
inline ::ei::AppInfo* GenericAction::mutable_app() {
  ::ei::AppInfo* _msg = _internal_mutable_app();
  // @@protoc_insertion_point(field_mutable:ei.GenericAction.app)
  return _msg;
}
inline void GenericAction::set_allocated_app(::ei::AppInfo* app) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete app_;
  }
  if (app) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::AppInfo>::GetOwningArena(app);
    if (message_arena != submessage_arena) {
      app = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, app, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  app_ = app;
  // @@protoc_insertion_point(field_set_allocated:ei.GenericAction.app)
}

// optional .ei.DeviceInfo device = 6;
inline bool GenericAction::_internal_has_device() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || device_ != nullptr);
  return value;
}
inline bool GenericAction::has_device() const {
  return _internal_has_device();
}
inline void GenericAction::clear_device() {
  if (device_ != nullptr) device_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::ei::DeviceInfo& GenericAction::_internal_device() const {
  const ::ei::DeviceInfo* p = device_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::DeviceInfo&>(
      ::ei::_DeviceInfo_default_instance_);
}
inline const ::ei::DeviceInfo& GenericAction::device() const {
  // @@protoc_insertion_point(field_get:ei.GenericAction.device)
  return _internal_device();
}
inline void GenericAction::unsafe_arena_set_allocated_device(
    ::ei::DeviceInfo* device) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_);
  }
  device_ = device;
  if (device) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.GenericAction.device)
}
inline ::ei::DeviceInfo* GenericAction::release_device() {
  _has_bits_[0] &= ~0x00000010u;
  ::ei::DeviceInfo* temp = device_;
  device_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::DeviceInfo* GenericAction::unsafe_arena_release_device() {
  // @@protoc_insertion_point(field_release:ei.GenericAction.device)
  _has_bits_[0] &= ~0x00000010u;
  ::ei::DeviceInfo* temp = device_;
  device_ = nullptr;
  return temp;
}
inline ::ei::DeviceInfo* GenericAction::_internal_mutable_device() {
  _has_bits_[0] |= 0x00000010u;
  if (device_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::DeviceInfo>(GetArenaForAllocation());
    device_ = p;
  }
  return device_;
}
inline ::ei::DeviceInfo* GenericAction::mutable_device() {
  ::ei::DeviceInfo* _msg = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:ei.GenericAction.device)
  return _msg;
}
inline void GenericAction::set_allocated_device(::ei::DeviceInfo* device) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete device_;
  }
  if (device) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::DeviceInfo>::GetOwningArena(device);
    if (message_arena != submessage_arena) {
      device = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  device_ = device;
  // @@protoc_insertion_point(field_set_allocated:ei.GenericAction.device)
}

// -------------------------------------------------------------------

// GenericActionBatchRequest

// optional .ei.BasicRequestInfo rinfo = 1;
inline bool GenericActionBatchRequest::_internal_has_rinfo() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || rinfo_ != nullptr);
  return value;
}
inline bool GenericActionBatchRequest::has_rinfo() const {
  return _internal_has_rinfo();
}
inline void GenericActionBatchRequest::clear_rinfo() {
  if (rinfo_ != nullptr) rinfo_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ei::BasicRequestInfo& GenericActionBatchRequest::_internal_rinfo() const {
  const ::ei::BasicRequestInfo* p = rinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::BasicRequestInfo&>(
      ::ei::_BasicRequestInfo_default_instance_);
}
inline const ::ei::BasicRequestInfo& GenericActionBatchRequest::rinfo() const {
  // @@protoc_insertion_point(field_get:ei.GenericActionBatchRequest.rinfo)
  return _internal_rinfo();
}
inline void GenericActionBatchRequest::unsafe_arena_set_allocated_rinfo(
    ::ei::BasicRequestInfo* rinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rinfo_);
  }
  rinfo_ = rinfo;
  if (rinfo) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.GenericActionBatchRequest.rinfo)
}
inline ::ei::BasicRequestInfo* GenericActionBatchRequest::release_rinfo() {
  _has_bits_[0] &= ~0x00000001u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::BasicRequestInfo* GenericActionBatchRequest::unsafe_arena_release_rinfo() {
  // @@protoc_insertion_point(field_release:ei.GenericActionBatchRequest.rinfo)
  _has_bits_[0] &= ~0x00000001u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
  return temp;
}
inline ::ei::BasicRequestInfo* GenericActionBatchRequest::_internal_mutable_rinfo() {
  _has_bits_[0] |= 0x00000001u;
  if (rinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::BasicRequestInfo>(GetArenaForAllocation());
    rinfo_ = p;
  }
  return rinfo_;
}
inline ::ei::BasicRequestInfo* GenericActionBatchRequest::mutable_rinfo() {
  ::ei::BasicRequestInfo* _msg = _internal_mutable_rinfo();
  // @@protoc_insertion_point(field_mutable:ei.GenericActionBatchRequest.rinfo)
  return _msg;
}
inline void GenericActionBatchRequest::set_allocated_rinfo(::ei::BasicRequestInfo* rinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rinfo_;
  }
  if (rinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::BasicRequestInfo>::GetOwningArena(rinfo);
    if (message_arena != submessage_arena) {
      rinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  rinfo_ = rinfo;
  // @@protoc_insertion_point(field_set_allocated:ei.GenericActionBatchRequest.rinfo)
}

// repeated .ei.GenericAction actions = 2;
inline int GenericActionBatchRequest::_internal_actions_size() const {
  return actions_.size();
}
inline int GenericActionBatchRequest::actions_size() const {
  return _internal_actions_size();
}
inline void GenericActionBatchRequest::clear_actions() {
  actions_.Clear();
}
inline ::ei::GenericAction* GenericActionBatchRequest::mutable_actions(int index) {
  // @@protoc_insertion_point(field_mutable:ei.GenericActionBatchRequest.actions)
  return actions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::GenericAction >*
GenericActionBatchRequest::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_list:ei.GenericActionBatchRequest.actions)
  return &actions_;
}
inline const ::ei::GenericAction& GenericActionBatchRequest::_internal_actions(int index) const {
  return actions_.Get(index);
}
inline const ::ei::GenericAction& GenericActionBatchRequest::actions(int index) const {
  // @@protoc_insertion_point(field_get:ei.GenericActionBatchRequest.actions)
  return _internal_actions(index);
}
inline ::ei::GenericAction* GenericActionBatchRequest::_internal_add_actions() {
  return actions_.Add();
}
inline ::ei::GenericAction* GenericActionBatchRequest::add_actions() {
  ::ei::GenericAction* _add = _internal_add_actions();
  // @@protoc_insertion_point(field_add:ei.GenericActionBatchRequest.actions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::GenericAction >&
GenericActionBatchRequest::actions() const {
  // @@protoc_insertion_point(field_list:ei.GenericActionBatchRequest.actions)
  return actions_;
}

// -------------------------------------------------------------------

// VerifyPurchaseRequest

// optional .ei.BasicRequestInfo rinfo = 6;
inline bool VerifyPurchaseRequest::_internal_has_rinfo() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || rinfo_ != nullptr);
  return value;
}
inline bool VerifyPurchaseRequest::has_rinfo() const {
  return _internal_has_rinfo();
}
inline void VerifyPurchaseRequest::clear_rinfo() {
  if (rinfo_ != nullptr) rinfo_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::ei::BasicRequestInfo& VerifyPurchaseRequest::_internal_rinfo() const {
  const ::ei::BasicRequestInfo* p = rinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::BasicRequestInfo&>(
      ::ei::_BasicRequestInfo_default_instance_);
}
inline const ::ei::BasicRequestInfo& VerifyPurchaseRequest::rinfo() const {
  // @@protoc_insertion_point(field_get:ei.VerifyPurchaseRequest.rinfo)
  return _internal_rinfo();
}
inline void VerifyPurchaseRequest::unsafe_arena_set_allocated_rinfo(
    ::ei::BasicRequestInfo* rinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rinfo_);
  }
  rinfo_ = rinfo;
  if (rinfo) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.VerifyPurchaseRequest.rinfo)
}
inline ::ei::BasicRequestInfo* VerifyPurchaseRequest::release_rinfo() {
  _has_bits_[0] &= ~0x00000020u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::BasicRequestInfo* VerifyPurchaseRequest::unsafe_arena_release_rinfo() {
  // @@protoc_insertion_point(field_release:ei.VerifyPurchaseRequest.rinfo)
  _has_bits_[0] &= ~0x00000020u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
  return temp;
}
inline ::ei::BasicRequestInfo* VerifyPurchaseRequest::_internal_mutable_rinfo() {
  _has_bits_[0] |= 0x00000020u;
  if (rinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::BasicRequestInfo>(GetArenaForAllocation());
    rinfo_ = p;
  }
  return rinfo_;
}
inline ::ei::BasicRequestInfo* VerifyPurchaseRequest::mutable_rinfo() {
  ::ei::BasicRequestInfo* _msg = _internal_mutable_rinfo();
  // @@protoc_insertion_point(field_mutable:ei.VerifyPurchaseRequest.rinfo)
  return _msg;
}
inline void VerifyPurchaseRequest::set_allocated_rinfo(::ei::BasicRequestInfo* rinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rinfo_;
  }
  if (rinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::BasicRequestInfo>::GetOwningArena(rinfo);
    if (message_arena != submessage_arena) {
      rinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  rinfo_ = rinfo;
  // @@protoc_insertion_point(field_set_allocated:ei.VerifyPurchaseRequest.rinfo)
}

// optional string sku = 1;
inline bool VerifyPurchaseRequest::_internal_has_sku() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VerifyPurchaseRequest::has_sku() const {
  return _internal_has_sku();
}
inline void VerifyPurchaseRequest::clear_sku() {
  sku_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VerifyPurchaseRequest::sku() const {
  // @@protoc_insertion_point(field_get:ei.VerifyPurchaseRequest.sku)
  return _internal_sku();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VerifyPurchaseRequest::set_sku(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 sku_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.VerifyPurchaseRequest.sku)
}
inline std::string* VerifyPurchaseRequest::mutable_sku() {
  std::string* _s = _internal_mutable_sku();
  // @@protoc_insertion_point(field_mutable:ei.VerifyPurchaseRequest.sku)
  return _s;
}
inline const std::string& VerifyPurchaseRequest::_internal_sku() const {
  return sku_.Get();
}
inline void VerifyPurchaseRequest::_internal_set_sku(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  sku_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VerifyPurchaseRequest::_internal_mutable_sku() {
  _has_bits_[0] |= 0x00000001u;
  return sku_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VerifyPurchaseRequest::release_sku() {
  // @@protoc_insertion_point(field_release:ei.VerifyPurchaseRequest.sku)
  if (!_internal_has_sku()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = sku_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sku_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sku_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VerifyPurchaseRequest::set_allocated_sku(std::string* sku) {
  if (sku != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sku_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sku,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sku_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sku_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.VerifyPurchaseRequest.sku)
}

// optional string transaction_id = 2;
inline bool VerifyPurchaseRequest::_internal_has_transaction_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VerifyPurchaseRequest::has_transaction_id() const {
  return _internal_has_transaction_id();
}
inline void VerifyPurchaseRequest::clear_transaction_id() {
  transaction_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& VerifyPurchaseRequest::transaction_id() const {
  // @@protoc_insertion_point(field_get:ei.VerifyPurchaseRequest.transaction_id)
  return _internal_transaction_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VerifyPurchaseRequest::set_transaction_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 transaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.VerifyPurchaseRequest.transaction_id)
}
inline std::string* VerifyPurchaseRequest::mutable_transaction_id() {
  std::string* _s = _internal_mutable_transaction_id();
  // @@protoc_insertion_point(field_mutable:ei.VerifyPurchaseRequest.transaction_id)
  return _s;
}
inline const std::string& VerifyPurchaseRequest::_internal_transaction_id() const {
  return transaction_id_.Get();
}
inline void VerifyPurchaseRequest::_internal_set_transaction_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  transaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VerifyPurchaseRequest::_internal_mutable_transaction_id() {
  _has_bits_[0] |= 0x00000002u;
  return transaction_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VerifyPurchaseRequest::release_transaction_id() {
  // @@protoc_insertion_point(field_release:ei.VerifyPurchaseRequest.transaction_id)
  if (!_internal_has_transaction_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = transaction_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (transaction_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    transaction_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VerifyPurchaseRequest::set_allocated_transaction_id(std::string* transaction_id) {
  if (transaction_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  transaction_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transaction_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (transaction_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    transaction_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.VerifyPurchaseRequest.transaction_id)
}

// optional string receipt = 3;
inline bool VerifyPurchaseRequest::_internal_has_receipt() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VerifyPurchaseRequest::has_receipt() const {
  return _internal_has_receipt();
}
inline void VerifyPurchaseRequest::clear_receipt() {
  receipt_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& VerifyPurchaseRequest::receipt() const {
  // @@protoc_insertion_point(field_get:ei.VerifyPurchaseRequest.receipt)
  return _internal_receipt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VerifyPurchaseRequest::set_receipt(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 receipt_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.VerifyPurchaseRequest.receipt)
}
inline std::string* VerifyPurchaseRequest::mutable_receipt() {
  std::string* _s = _internal_mutable_receipt();
  // @@protoc_insertion_point(field_mutable:ei.VerifyPurchaseRequest.receipt)
  return _s;
}
inline const std::string& VerifyPurchaseRequest::_internal_receipt() const {
  return receipt_.Get();
}
inline void VerifyPurchaseRequest::_internal_set_receipt(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  receipt_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VerifyPurchaseRequest::_internal_mutable_receipt() {
  _has_bits_[0] |= 0x00000004u;
  return receipt_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VerifyPurchaseRequest::release_receipt() {
  // @@protoc_insertion_point(field_release:ei.VerifyPurchaseRequest.receipt)
  if (!_internal_has_receipt()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = receipt_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (receipt_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    receipt_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VerifyPurchaseRequest::set_allocated_receipt(std::string* receipt) {
  if (receipt != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  receipt_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), receipt,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (receipt_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    receipt_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.VerifyPurchaseRequest.receipt)
}

// optional string platform = 4;
inline bool VerifyPurchaseRequest::_internal_has_platform() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool VerifyPurchaseRequest::has_platform() const {
  return _internal_has_platform();
}
inline void VerifyPurchaseRequest::clear_platform() {
  platform_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& VerifyPurchaseRequest::platform() const {
  // @@protoc_insertion_point(field_get:ei.VerifyPurchaseRequest.platform)
  return _internal_platform();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VerifyPurchaseRequest::set_platform(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 platform_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.VerifyPurchaseRequest.platform)
}
inline std::string* VerifyPurchaseRequest::mutable_platform() {
  std::string* _s = _internal_mutable_platform();
  // @@protoc_insertion_point(field_mutable:ei.VerifyPurchaseRequest.platform)
  return _s;
}
inline const std::string& VerifyPurchaseRequest::_internal_platform() const {
  return platform_.Get();
}
inline void VerifyPurchaseRequest::_internal_set_platform(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  platform_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VerifyPurchaseRequest::_internal_mutable_platform() {
  _has_bits_[0] |= 0x00000008u;
  return platform_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VerifyPurchaseRequest::release_platform() {
  // @@protoc_insertion_point(field_release:ei.VerifyPurchaseRequest.platform)
  if (!_internal_has_platform()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = platform_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (platform_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    platform_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VerifyPurchaseRequest::set_allocated_platform(std::string* platform) {
  if (platform != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  platform_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), platform,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (platform_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    platform_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.VerifyPurchaseRequest.platform)
}

// optional bool sandbox = 7;
inline bool VerifyPurchaseRequest::_internal_has_sandbox() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool VerifyPurchaseRequest::has_sandbox() const {
  return _internal_has_sandbox();
}
inline void VerifyPurchaseRequest::clear_sandbox() {
  sandbox_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool VerifyPurchaseRequest::_internal_sandbox() const {
  return sandbox_;
}
inline bool VerifyPurchaseRequest::sandbox() const {
  // @@protoc_insertion_point(field_get:ei.VerifyPurchaseRequest.sandbox)
  return _internal_sandbox();
}
inline void VerifyPurchaseRequest::_internal_set_sandbox(bool value) {
  _has_bits_[0] |= 0x00000040u;
  sandbox_ = value;
}
inline void VerifyPurchaseRequest::set_sandbox(bool value) {
  _internal_set_sandbox(value);
  // @@protoc_insertion_point(field_set:ei.VerifyPurchaseRequest.sandbox)
}

// optional .ei.GenericAction log = 5;
inline bool VerifyPurchaseRequest::_internal_has_log() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || log_ != nullptr);
  return value;
}
inline bool VerifyPurchaseRequest::has_log() const {
  return _internal_has_log();
}
inline void VerifyPurchaseRequest::clear_log() {
  if (log_ != nullptr) log_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::ei::GenericAction& VerifyPurchaseRequest::_internal_log() const {
  const ::ei::GenericAction* p = log_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::GenericAction&>(
      ::ei::_GenericAction_default_instance_);
}
inline const ::ei::GenericAction& VerifyPurchaseRequest::log() const {
  // @@protoc_insertion_point(field_get:ei.VerifyPurchaseRequest.log)
  return _internal_log();
}
inline void VerifyPurchaseRequest::unsafe_arena_set_allocated_log(
    ::ei::GenericAction* log) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(log_);
  }
  log_ = log;
  if (log) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.VerifyPurchaseRequest.log)
}
inline ::ei::GenericAction* VerifyPurchaseRequest::release_log() {
  _has_bits_[0] &= ~0x00000010u;
  ::ei::GenericAction* temp = log_;
  log_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::GenericAction* VerifyPurchaseRequest::unsafe_arena_release_log() {
  // @@protoc_insertion_point(field_release:ei.VerifyPurchaseRequest.log)
  _has_bits_[0] &= ~0x00000010u;
  ::ei::GenericAction* temp = log_;
  log_ = nullptr;
  return temp;
}
inline ::ei::GenericAction* VerifyPurchaseRequest::_internal_mutable_log() {
  _has_bits_[0] |= 0x00000010u;
  if (log_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::GenericAction>(GetArenaForAllocation());
    log_ = p;
  }
  return log_;
}
inline ::ei::GenericAction* VerifyPurchaseRequest::mutable_log() {
  ::ei::GenericAction* _msg = _internal_mutable_log();
  // @@protoc_insertion_point(field_mutable:ei.VerifyPurchaseRequest.log)
  return _msg;
}
inline void VerifyPurchaseRequest::set_allocated_log(::ei::GenericAction* log) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete log_;
  }
  if (log) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::GenericAction>::GetOwningArena(log);
    if (message_arena != submessage_arena) {
      log = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, log, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  log_ = log;
  // @@protoc_insertion_point(field_set_allocated:ei.VerifyPurchaseRequest.log)
}

// -------------------------------------------------------------------

// VerifyPurchaseResponse

// optional bool verified = 1;
inline bool VerifyPurchaseResponse::_internal_has_verified() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VerifyPurchaseResponse::has_verified() const {
  return _internal_has_verified();
}
inline void VerifyPurchaseResponse::clear_verified() {
  verified_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool VerifyPurchaseResponse::_internal_verified() const {
  return verified_;
}
inline bool VerifyPurchaseResponse::verified() const {
  // @@protoc_insertion_point(field_get:ei.VerifyPurchaseResponse.verified)
  return _internal_verified();
}
inline void VerifyPurchaseResponse::_internal_set_verified(bool value) {
  _has_bits_[0] |= 0x00000002u;
  verified_ = value;
}
inline void VerifyPurchaseResponse::set_verified(bool value) {
  _internal_set_verified(value);
  // @@protoc_insertion_point(field_set:ei.VerifyPurchaseResponse.verified)
}

// optional string message = 2;
inline bool VerifyPurchaseResponse::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VerifyPurchaseResponse::has_message() const {
  return _internal_has_message();
}
inline void VerifyPurchaseResponse::clear_message() {
  message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VerifyPurchaseResponse::message() const {
  // @@protoc_insertion_point(field_get:ei.VerifyPurchaseResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VerifyPurchaseResponse::set_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.VerifyPurchaseResponse.message)
}
inline std::string* VerifyPurchaseResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:ei.VerifyPurchaseResponse.message)
  return _s;
}
inline const std::string& VerifyPurchaseResponse::_internal_message() const {
  return message_.Get();
}
inline void VerifyPurchaseResponse::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VerifyPurchaseResponse::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VerifyPurchaseResponse::release_message() {
  // @@protoc_insertion_point(field_release:ei.VerifyPurchaseResponse.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VerifyPurchaseResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.VerifyPurchaseResponse.message)
}

// -------------------------------------------------------------------

// CurrencyFlowLog

// optional string user_id = 1;
inline bool CurrencyFlowLog::_internal_has_user_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CurrencyFlowLog::has_user_id() const {
  return _internal_has_user_id();
}
inline void CurrencyFlowLog::clear_user_id() {
  user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CurrencyFlowLog::user_id() const {
  // @@protoc_insertion_point(field_get:ei.CurrencyFlowLog.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CurrencyFlowLog::set_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.CurrencyFlowLog.user_id)
}
inline std::string* CurrencyFlowLog::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:ei.CurrencyFlowLog.user_id)
  return _s;
}
inline const std::string& CurrencyFlowLog::_internal_user_id() const {
  return user_id_.Get();
}
inline void CurrencyFlowLog::_internal_set_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CurrencyFlowLog::_internal_mutable_user_id() {
  _has_bits_[0] |= 0x00000001u;
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CurrencyFlowLog::release_user_id() {
  // @@protoc_insertion_point(field_release:ei.CurrencyFlowLog.user_id)
  if (!_internal_has_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CurrencyFlowLog::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.CurrencyFlowLog.user_id)
}

// optional double approx_time = 2;
inline bool CurrencyFlowLog::_internal_has_approx_time() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CurrencyFlowLog::has_approx_time() const {
  return _internal_has_approx_time();
}
inline void CurrencyFlowLog::clear_approx_time() {
  approx_time_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double CurrencyFlowLog::_internal_approx_time() const {
  return approx_time_;
}
inline double CurrencyFlowLog::approx_time() const {
  // @@protoc_insertion_point(field_get:ei.CurrencyFlowLog.approx_time)
  return _internal_approx_time();
}
inline void CurrencyFlowLog::_internal_set_approx_time(double value) {
  _has_bits_[0] |= 0x00000010u;
  approx_time_ = value;
}
inline void CurrencyFlowLog::set_approx_time(double value) {
  _internal_set_approx_time(value);
  // @@protoc_insertion_point(field_set:ei.CurrencyFlowLog.approx_time)
}

// optional .ei.RewardType currency = 3;
inline bool CurrencyFlowLog::_internal_has_currency() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CurrencyFlowLog::has_currency() const {
  return _internal_has_currency();
}
inline void CurrencyFlowLog::clear_currency() {
  currency_ = 1;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::ei::RewardType CurrencyFlowLog::_internal_currency() const {
  return static_cast< ::ei::RewardType >(currency_);
}
inline ::ei::RewardType CurrencyFlowLog::currency() const {
  // @@protoc_insertion_point(field_get:ei.CurrencyFlowLog.currency)
  return _internal_currency();
}
inline void CurrencyFlowLog::_internal_set_currency(::ei::RewardType value) {
  assert(::ei::RewardType_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  currency_ = value;
}
inline void CurrencyFlowLog::set_currency(::ei::RewardType value) {
  _internal_set_currency(value);
  // @@protoc_insertion_point(field_set:ei.CurrencyFlowLog.currency)
}

// optional int64 amount = 4;
inline bool CurrencyFlowLog::_internal_has_amount() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CurrencyFlowLog::has_amount() const {
  return _internal_has_amount();
}
inline void CurrencyFlowLog::clear_amount() {
  amount_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline int64_t CurrencyFlowLog::_internal_amount() const {
  return amount_;
}
inline int64_t CurrencyFlowLog::amount() const {
  // @@protoc_insertion_point(field_get:ei.CurrencyFlowLog.amount)
  return _internal_amount();
}
inline void CurrencyFlowLog::_internal_set_amount(int64_t value) {
  _has_bits_[0] |= 0x00000020u;
  amount_ = value;
}
inline void CurrencyFlowLog::set_amount(int64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:ei.CurrencyFlowLog.amount)
}

// optional string location = 5;
inline bool CurrencyFlowLog::_internal_has_location() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CurrencyFlowLog::has_location() const {
  return _internal_has_location();
}
inline void CurrencyFlowLog::clear_location() {
  location_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CurrencyFlowLog::location() const {
  // @@protoc_insertion_point(field_get:ei.CurrencyFlowLog.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CurrencyFlowLog::set_location(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.CurrencyFlowLog.location)
}
inline std::string* CurrencyFlowLog::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:ei.CurrencyFlowLog.location)
  return _s;
}
inline const std::string& CurrencyFlowLog::_internal_location() const {
  return location_.Get();
}
inline void CurrencyFlowLog::_internal_set_location(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CurrencyFlowLog::_internal_mutable_location() {
  _has_bits_[0] |= 0x00000002u;
  return location_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CurrencyFlowLog::release_location() {
  // @@protoc_insertion_point(field_release:ei.CurrencyFlowLog.location)
  if (!_internal_has_location()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = location_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    location_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CurrencyFlowLog::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  location_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), location,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    location_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.CurrencyFlowLog.location)
}

// optional string version = 6;
inline bool CurrencyFlowLog::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CurrencyFlowLog::has_version() const {
  return _internal_has_version();
}
inline void CurrencyFlowLog::clear_version() {
  version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CurrencyFlowLog::version() const {
  // @@protoc_insertion_point(field_get:ei.CurrencyFlowLog.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CurrencyFlowLog::set_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.CurrencyFlowLog.version)
}
inline std::string* CurrencyFlowLog::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:ei.CurrencyFlowLog.version)
  return _s;
}
inline const std::string& CurrencyFlowLog::_internal_version() const {
  return version_.Get();
}
inline void CurrencyFlowLog::_internal_set_version(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CurrencyFlowLog::_internal_mutable_version() {
  _has_bits_[0] |= 0x00000004u;
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CurrencyFlowLog::release_version() {
  // @@protoc_insertion_point(field_release:ei.CurrencyFlowLog.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = version_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CurrencyFlowLog::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.CurrencyFlowLog.version)
}

// optional string platform = 7;
inline bool CurrencyFlowLog::_internal_has_platform() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CurrencyFlowLog::has_platform() const {
  return _internal_has_platform();
}
inline void CurrencyFlowLog::clear_platform() {
  platform_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CurrencyFlowLog::platform() const {
  // @@protoc_insertion_point(field_get:ei.CurrencyFlowLog.platform)
  return _internal_platform();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CurrencyFlowLog::set_platform(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 platform_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.CurrencyFlowLog.platform)
}
inline std::string* CurrencyFlowLog::mutable_platform() {
  std::string* _s = _internal_mutable_platform();
  // @@protoc_insertion_point(field_mutable:ei.CurrencyFlowLog.platform)
  return _s;
}
inline const std::string& CurrencyFlowLog::_internal_platform() const {
  return platform_.Get();
}
inline void CurrencyFlowLog::_internal_set_platform(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  platform_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CurrencyFlowLog::_internal_mutable_platform() {
  _has_bits_[0] |= 0x00000008u;
  return platform_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CurrencyFlowLog::release_platform() {
  // @@protoc_insertion_point(field_release:ei.CurrencyFlowLog.platform)
  if (!_internal_has_platform()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = platform_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (platform_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    platform_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CurrencyFlowLog::set_allocated_platform(std::string* platform) {
  if (platform != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  platform_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), platform,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (platform_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    platform_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.CurrencyFlowLog.platform)
}

// -------------------------------------------------------------------

// CurrencyFlowBatchRequest

// optional .ei.BasicRequestInfo rinfo = 2;
inline bool CurrencyFlowBatchRequest::_internal_has_rinfo() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || rinfo_ != nullptr);
  return value;
}
inline bool CurrencyFlowBatchRequest::has_rinfo() const {
  return _internal_has_rinfo();
}
inline void CurrencyFlowBatchRequest::clear_rinfo() {
  if (rinfo_ != nullptr) rinfo_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ei::BasicRequestInfo& CurrencyFlowBatchRequest::_internal_rinfo() const {
  const ::ei::BasicRequestInfo* p = rinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::BasicRequestInfo&>(
      ::ei::_BasicRequestInfo_default_instance_);
}
inline const ::ei::BasicRequestInfo& CurrencyFlowBatchRequest::rinfo() const {
  // @@protoc_insertion_point(field_get:ei.CurrencyFlowBatchRequest.rinfo)
  return _internal_rinfo();
}
inline void CurrencyFlowBatchRequest::unsafe_arena_set_allocated_rinfo(
    ::ei::BasicRequestInfo* rinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rinfo_);
  }
  rinfo_ = rinfo;
  if (rinfo) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.CurrencyFlowBatchRequest.rinfo)
}
inline ::ei::BasicRequestInfo* CurrencyFlowBatchRequest::release_rinfo() {
  _has_bits_[0] &= ~0x00000001u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::BasicRequestInfo* CurrencyFlowBatchRequest::unsafe_arena_release_rinfo() {
  // @@protoc_insertion_point(field_release:ei.CurrencyFlowBatchRequest.rinfo)
  _has_bits_[0] &= ~0x00000001u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
  return temp;
}
inline ::ei::BasicRequestInfo* CurrencyFlowBatchRequest::_internal_mutable_rinfo() {
  _has_bits_[0] |= 0x00000001u;
  if (rinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::BasicRequestInfo>(GetArenaForAllocation());
    rinfo_ = p;
  }
  return rinfo_;
}
inline ::ei::BasicRequestInfo* CurrencyFlowBatchRequest::mutable_rinfo() {
  ::ei::BasicRequestInfo* _msg = _internal_mutable_rinfo();
  // @@protoc_insertion_point(field_mutable:ei.CurrencyFlowBatchRequest.rinfo)
  return _msg;
}
inline void CurrencyFlowBatchRequest::set_allocated_rinfo(::ei::BasicRequestInfo* rinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rinfo_;
  }
  if (rinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::BasicRequestInfo>::GetOwningArena(rinfo);
    if (message_arena != submessage_arena) {
      rinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  rinfo_ = rinfo;
  // @@protoc_insertion_point(field_set_allocated:ei.CurrencyFlowBatchRequest.rinfo)
}

// repeated .ei.CurrencyFlowLog logs = 1;
inline int CurrencyFlowBatchRequest::_internal_logs_size() const {
  return logs_.size();
}
inline int CurrencyFlowBatchRequest::logs_size() const {
  return _internal_logs_size();
}
inline void CurrencyFlowBatchRequest::clear_logs() {
  logs_.Clear();
}
inline ::ei::CurrencyFlowLog* CurrencyFlowBatchRequest::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:ei.CurrencyFlowBatchRequest.logs)
  return logs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::CurrencyFlowLog >*
CurrencyFlowBatchRequest::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:ei.CurrencyFlowBatchRequest.logs)
  return &logs_;
}
inline const ::ei::CurrencyFlowLog& CurrencyFlowBatchRequest::_internal_logs(int index) const {
  return logs_.Get(index);
}
inline const ::ei::CurrencyFlowLog& CurrencyFlowBatchRequest::logs(int index) const {
  // @@protoc_insertion_point(field_get:ei.CurrencyFlowBatchRequest.logs)
  return _internal_logs(index);
}
inline ::ei::CurrencyFlowLog* CurrencyFlowBatchRequest::_internal_add_logs() {
  return logs_.Add();
}
inline ::ei::CurrencyFlowLog* CurrencyFlowBatchRequest::add_logs() {
  ::ei::CurrencyFlowLog* _add = _internal_add_logs();
  // @@protoc_insertion_point(field_add:ei.CurrencyFlowBatchRequest.logs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::CurrencyFlowLog >&
CurrencyFlowBatchRequest::logs() const {
  // @@protoc_insertion_point(field_list:ei.CurrencyFlowBatchRequest.logs)
  return logs_;
}

// -------------------------------------------------------------------

// Reward

// optional .ei.RewardType reward_type = 1;
inline bool Reward::_internal_has_reward_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Reward::has_reward_type() const {
  return _internal_has_reward_type();
}
inline void Reward::clear_reward_type() {
  reward_type_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::ei::RewardType Reward::_internal_reward_type() const {
  return static_cast< ::ei::RewardType >(reward_type_);
}
inline ::ei::RewardType Reward::reward_type() const {
  // @@protoc_insertion_point(field_get:ei.Reward.reward_type)
  return _internal_reward_type();
}
inline void Reward::_internal_set_reward_type(::ei::RewardType value) {
  assert(::ei::RewardType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  reward_type_ = value;
}
inline void Reward::set_reward_type(::ei::RewardType value) {
  _internal_set_reward_type(value);
  // @@protoc_insertion_point(field_set:ei.Reward.reward_type)
}

// optional string reward_sub_type = 2;
inline bool Reward::_internal_has_reward_sub_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Reward::has_reward_sub_type() const {
  return _internal_has_reward_sub_type();
}
inline void Reward::clear_reward_sub_type() {
  reward_sub_type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Reward::reward_sub_type() const {
  // @@protoc_insertion_point(field_get:ei.Reward.reward_sub_type)
  return _internal_reward_sub_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Reward::set_reward_sub_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 reward_sub_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.Reward.reward_sub_type)
}
inline std::string* Reward::mutable_reward_sub_type() {
  std::string* _s = _internal_mutable_reward_sub_type();
  // @@protoc_insertion_point(field_mutable:ei.Reward.reward_sub_type)
  return _s;
}
inline const std::string& Reward::_internal_reward_sub_type() const {
  return reward_sub_type_.Get();
}
inline void Reward::_internal_set_reward_sub_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  reward_sub_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Reward::_internal_mutable_reward_sub_type() {
  _has_bits_[0] |= 0x00000001u;
  return reward_sub_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Reward::release_reward_sub_type() {
  // @@protoc_insertion_point(field_release:ei.Reward.reward_sub_type)
  if (!_internal_has_reward_sub_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = reward_sub_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (reward_sub_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    reward_sub_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Reward::set_allocated_reward_sub_type(std::string* reward_sub_type) {
  if (reward_sub_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  reward_sub_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reward_sub_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (reward_sub_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    reward_sub_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.Reward.reward_sub_type)
}

// optional double reward_amount = 3;
inline bool Reward::_internal_has_reward_amount() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Reward::has_reward_amount() const {
  return _internal_has_reward_amount();
}
inline void Reward::clear_reward_amount() {
  reward_amount_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Reward::_internal_reward_amount() const {
  return reward_amount_;
}
inline double Reward::reward_amount() const {
  // @@protoc_insertion_point(field_get:ei.Reward.reward_amount)
  return _internal_reward_amount();
}
inline void Reward::_internal_set_reward_amount(double value) {
  _has_bits_[0] |= 0x00000002u;
  reward_amount_ = value;
}
inline void Reward::set_reward_amount(double value) {
  _internal_set_reward_amount(value);
  // @@protoc_insertion_point(field_set:ei.Reward.reward_amount)
}

// -------------------------------------------------------------------

// Contract_Goal

// optional .ei.GoalType type = 1;
inline bool Contract_Goal::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Contract_Goal::has_type() const {
  return _internal_has_type();
}
inline void Contract_Goal::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::ei::GoalType Contract_Goal::_internal_type() const {
  return static_cast< ::ei::GoalType >(type_);
}
inline ::ei::GoalType Contract_Goal::type() const {
  // @@protoc_insertion_point(field_get:ei.Contract.Goal.type)
  return _internal_type();
}
inline void Contract_Goal::_internal_set_type(::ei::GoalType value) {
  assert(::ei::GoalType_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  type_ = value;
}
inline void Contract_Goal::set_type(::ei::GoalType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ei.Contract.Goal.type)
}

// optional double target_amount = 2;
inline bool Contract_Goal::_internal_has_target_amount() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Contract_Goal::has_target_amount() const {
  return _internal_has_target_amount();
}
inline void Contract_Goal::clear_target_amount() {
  target_amount_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Contract_Goal::_internal_target_amount() const {
  return target_amount_;
}
inline double Contract_Goal::target_amount() const {
  // @@protoc_insertion_point(field_get:ei.Contract.Goal.target_amount)
  return _internal_target_amount();
}
inline void Contract_Goal::_internal_set_target_amount(double value) {
  _has_bits_[0] |= 0x00000002u;
  target_amount_ = value;
}
inline void Contract_Goal::set_target_amount(double value) {
  _internal_set_target_amount(value);
  // @@protoc_insertion_point(field_set:ei.Contract.Goal.target_amount)
}

// optional .ei.RewardType reward_type = 3;
inline bool Contract_Goal::_internal_has_reward_type() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Contract_Goal::has_reward_type() const {
  return _internal_has_reward_type();
}
inline void Contract_Goal::clear_reward_type() {
  reward_type_ = 1;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::ei::RewardType Contract_Goal::_internal_reward_type() const {
  return static_cast< ::ei::RewardType >(reward_type_);
}
inline ::ei::RewardType Contract_Goal::reward_type() const {
  // @@protoc_insertion_point(field_get:ei.Contract.Goal.reward_type)
  return _internal_reward_type();
}
inline void Contract_Goal::_internal_set_reward_type(::ei::RewardType value) {
  assert(::ei::RewardType_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  reward_type_ = value;
}
inline void Contract_Goal::set_reward_type(::ei::RewardType value) {
  _internal_set_reward_type(value);
  // @@protoc_insertion_point(field_set:ei.Contract.Goal.reward_type)
}

// optional string reward_sub_type = 4;
inline bool Contract_Goal::_internal_has_reward_sub_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Contract_Goal::has_reward_sub_type() const {
  return _internal_has_reward_sub_type();
}
inline void Contract_Goal::clear_reward_sub_type() {
  reward_sub_type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Contract_Goal::reward_sub_type() const {
  // @@protoc_insertion_point(field_get:ei.Contract.Goal.reward_sub_type)
  return _internal_reward_sub_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Contract_Goal::set_reward_sub_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 reward_sub_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.Contract.Goal.reward_sub_type)
}
inline std::string* Contract_Goal::mutable_reward_sub_type() {
  std::string* _s = _internal_mutable_reward_sub_type();
  // @@protoc_insertion_point(field_mutable:ei.Contract.Goal.reward_sub_type)
  return _s;
}
inline const std::string& Contract_Goal::_internal_reward_sub_type() const {
  return reward_sub_type_.Get();
}
inline void Contract_Goal::_internal_set_reward_sub_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  reward_sub_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Contract_Goal::_internal_mutable_reward_sub_type() {
  _has_bits_[0] |= 0x00000001u;
  return reward_sub_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Contract_Goal::release_reward_sub_type() {
  // @@protoc_insertion_point(field_release:ei.Contract.Goal.reward_sub_type)
  if (!_internal_has_reward_sub_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = reward_sub_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (reward_sub_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    reward_sub_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Contract_Goal::set_allocated_reward_sub_type(std::string* reward_sub_type) {
  if (reward_sub_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  reward_sub_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reward_sub_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (reward_sub_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    reward_sub_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.Contract.Goal.reward_sub_type)
}

// optional double reward_amount = 5;
inline bool Contract_Goal::_internal_has_reward_amount() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Contract_Goal::has_reward_amount() const {
  return _internal_has_reward_amount();
}
inline void Contract_Goal::clear_reward_amount() {
  reward_amount_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double Contract_Goal::_internal_reward_amount() const {
  return reward_amount_;
}
inline double Contract_Goal::reward_amount() const {
  // @@protoc_insertion_point(field_get:ei.Contract.Goal.reward_amount)
  return _internal_reward_amount();
}
inline void Contract_Goal::_internal_set_reward_amount(double value) {
  _has_bits_[0] |= 0x00000004u;
  reward_amount_ = value;
}
inline void Contract_Goal::set_reward_amount(double value) {
  _internal_set_reward_amount(value);
  // @@protoc_insertion_point(field_set:ei.Contract.Goal.reward_amount)
}

// optional double target_soul_eggs = 6;
inline bool Contract_Goal::_internal_has_target_soul_eggs() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Contract_Goal::has_target_soul_eggs() const {
  return _internal_has_target_soul_eggs();
}
inline void Contract_Goal::clear_target_soul_eggs() {
  target_soul_eggs_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double Contract_Goal::_internal_target_soul_eggs() const {
  return target_soul_eggs_;
}
inline double Contract_Goal::target_soul_eggs() const {
  // @@protoc_insertion_point(field_get:ei.Contract.Goal.target_soul_eggs)
  return _internal_target_soul_eggs();
}
inline void Contract_Goal::_internal_set_target_soul_eggs(double value) {
  _has_bits_[0] |= 0x00000008u;
  target_soul_eggs_ = value;
}
inline void Contract_Goal::set_target_soul_eggs(double value) {
  _internal_set_target_soul_eggs(value);
  // @@protoc_insertion_point(field_set:ei.Contract.Goal.target_soul_eggs)
}

// -------------------------------------------------------------------

// Contract_GoalSet

// repeated .ei.Contract.Goal goals = 1;
inline int Contract_GoalSet::_internal_goals_size() const {
  return goals_.size();
}
inline int Contract_GoalSet::goals_size() const {
  return _internal_goals_size();
}
inline void Contract_GoalSet::clear_goals() {
  goals_.Clear();
}
inline ::ei::Contract_Goal* Contract_GoalSet::mutable_goals(int index) {
  // @@protoc_insertion_point(field_mutable:ei.Contract.GoalSet.goals)
  return goals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Contract_Goal >*
Contract_GoalSet::mutable_goals() {
  // @@protoc_insertion_point(field_mutable_list:ei.Contract.GoalSet.goals)
  return &goals_;
}
inline const ::ei::Contract_Goal& Contract_GoalSet::_internal_goals(int index) const {
  return goals_.Get(index);
}
inline const ::ei::Contract_Goal& Contract_GoalSet::goals(int index) const {
  // @@protoc_insertion_point(field_get:ei.Contract.GoalSet.goals)
  return _internal_goals(index);
}
inline ::ei::Contract_Goal* Contract_GoalSet::_internal_add_goals() {
  return goals_.Add();
}
inline ::ei::Contract_Goal* Contract_GoalSet::add_goals() {
  ::ei::Contract_Goal* _add = _internal_add_goals();
  // @@protoc_insertion_point(field_add:ei.Contract.GoalSet.goals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Contract_Goal >&
Contract_GoalSet::goals() const {
  // @@protoc_insertion_point(field_list:ei.Contract.GoalSet.goals)
  return goals_;
}

// -------------------------------------------------------------------

// Contract

// optional string identifier = 1;
inline bool Contract::_internal_has_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Contract::has_identifier() const {
  return _internal_has_identifier();
}
inline void Contract::clear_identifier() {
  identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Contract::identifier() const {
  // @@protoc_insertion_point(field_get:ei.Contract.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Contract::set_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.Contract.identifier)
}
inline std::string* Contract::mutable_identifier() {
  std::string* _s = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:ei.Contract.identifier)
  return _s;
}
inline const std::string& Contract::_internal_identifier() const {
  return identifier_.Get();
}
inline void Contract::_internal_set_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Contract::_internal_mutable_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Contract::release_identifier() {
  // @@protoc_insertion_point(field_release:ei.Contract.identifier)
  if (!_internal_has_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Contract::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.Contract.identifier)
}

// optional string name = 9;
inline bool Contract::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Contract::has_name() const {
  return _internal_has_name();
}
inline void Contract::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Contract::name() const {
  // @@protoc_insertion_point(field_get:ei.Contract.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Contract::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.Contract.name)
}
inline std::string* Contract::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ei.Contract.name)
  return _s;
}
inline const std::string& Contract::_internal_name() const {
  return name_.Get();
}
inline void Contract::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Contract::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000002u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Contract::release_name() {
  // @@protoc_insertion_point(field_release:ei.Contract.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Contract::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.Contract.name)
}

// optional string description = 10;
inline bool Contract::_internal_has_description() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Contract::has_description() const {
  return _internal_has_description();
}
inline void Contract::clear_description() {
  description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Contract::description() const {
  // @@protoc_insertion_point(field_get:ei.Contract.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Contract::set_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.Contract.description)
}
inline std::string* Contract::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:ei.Contract.description)
  return _s;
}
inline const std::string& Contract::_internal_description() const {
  return description_.Get();
}
inline void Contract::_internal_set_description(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Contract::_internal_mutable_description() {
  _has_bits_[0] |= 0x00000004u;
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Contract::release_description() {
  // @@protoc_insertion_point(field_release:ei.Contract.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = description_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Contract::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.Contract.description)
}

// optional .ei.Egg egg = 2;
inline bool Contract::_internal_has_egg() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Contract::has_egg() const {
  return _internal_has_egg();
}
inline void Contract::clear_egg() {
  egg_ = 1;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::ei::Egg Contract::_internal_egg() const {
  return static_cast< ::ei::Egg >(egg_);
}
inline ::ei::Egg Contract::egg() const {
  // @@protoc_insertion_point(field_get:ei.Contract.egg)
  return _internal_egg();
}
inline void Contract::_internal_set_egg(::ei::Egg value) {
  assert(::ei::Egg_IsValid(value));
  _has_bits_[0] |= 0x00001000u;
  egg_ = value;
}
inline void Contract::set_egg(::ei::Egg value) {
  _internal_set_egg(value);
  // @@protoc_insertion_point(field_set:ei.Contract.egg)
}

// repeated .ei.Contract.Goal goals = 3;
inline int Contract::_internal_goals_size() const {
  return goals_.size();
}
inline int Contract::goals_size() const {
  return _internal_goals_size();
}
inline void Contract::clear_goals() {
  goals_.Clear();
}
inline ::ei::Contract_Goal* Contract::mutable_goals(int index) {
  // @@protoc_insertion_point(field_mutable:ei.Contract.goals)
  return goals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Contract_Goal >*
Contract::mutable_goals() {
  // @@protoc_insertion_point(field_mutable_list:ei.Contract.goals)
  return &goals_;
}
inline const ::ei::Contract_Goal& Contract::_internal_goals(int index) const {
  return goals_.Get(index);
}
inline const ::ei::Contract_Goal& Contract::goals(int index) const {
  // @@protoc_insertion_point(field_get:ei.Contract.goals)
  return _internal_goals(index);
}
inline ::ei::Contract_Goal* Contract::_internal_add_goals() {
  return goals_.Add();
}
inline ::ei::Contract_Goal* Contract::add_goals() {
  ::ei::Contract_Goal* _add = _internal_add_goals();
  // @@protoc_insertion_point(field_add:ei.Contract.goals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Contract_Goal >&
Contract::goals() const {
  // @@protoc_insertion_point(field_list:ei.Contract.goals)
  return goals_;
}

// repeated .ei.Contract.GoalSet goal_sets = 16;
inline int Contract::_internal_goal_sets_size() const {
  return goal_sets_.size();
}
inline int Contract::goal_sets_size() const {
  return _internal_goal_sets_size();
}
inline void Contract::clear_goal_sets() {
  goal_sets_.Clear();
}
inline ::ei::Contract_GoalSet* Contract::mutable_goal_sets(int index) {
  // @@protoc_insertion_point(field_mutable:ei.Contract.goal_sets)
  return goal_sets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Contract_GoalSet >*
Contract::mutable_goal_sets() {
  // @@protoc_insertion_point(field_mutable_list:ei.Contract.goal_sets)
  return &goal_sets_;
}
inline const ::ei::Contract_GoalSet& Contract::_internal_goal_sets(int index) const {
  return goal_sets_.Get(index);
}
inline const ::ei::Contract_GoalSet& Contract::goal_sets(int index) const {
  // @@protoc_insertion_point(field_get:ei.Contract.goal_sets)
  return _internal_goal_sets(index);
}
inline ::ei::Contract_GoalSet* Contract::_internal_add_goal_sets() {
  return goal_sets_.Add();
}
inline ::ei::Contract_GoalSet* Contract::add_goal_sets() {
  ::ei::Contract_GoalSet* _add = _internal_add_goal_sets();
  // @@protoc_insertion_point(field_add:ei.Contract.goal_sets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Contract_GoalSet >&
Contract::goal_sets() const {
  // @@protoc_insertion_point(field_list:ei.Contract.goal_sets)
  return goal_sets_;
}

// optional bool coop_allowed = 4;
inline bool Contract::_internal_has_coop_allowed() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Contract::has_coop_allowed() const {
  return _internal_has_coop_allowed();
}
inline void Contract::clear_coop_allowed() {
  coop_allowed_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool Contract::_internal_coop_allowed() const {
  return coop_allowed_;
}
inline bool Contract::coop_allowed() const {
  // @@protoc_insertion_point(field_get:ei.Contract.coop_allowed)
  return _internal_coop_allowed();
}
inline void Contract::_internal_set_coop_allowed(bool value) {
  _has_bits_[0] |= 0x00000020u;
  coop_allowed_ = value;
}
inline void Contract::set_coop_allowed(bool value) {
  _internal_set_coop_allowed(value);
  // @@protoc_insertion_point(field_set:ei.Contract.coop_allowed)
}

// optional uint32 max_coop_size = 5;
inline bool Contract::_internal_has_max_coop_size() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Contract::has_max_coop_size() const {
  return _internal_has_max_coop_size();
}
inline void Contract::clear_max_coop_size() {
  max_coop_size_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t Contract::_internal_max_coop_size() const {
  return max_coop_size_;
}
inline uint32_t Contract::max_coop_size() const {
  // @@protoc_insertion_point(field_get:ei.Contract.max_coop_size)
  return _internal_max_coop_size();
}
inline void Contract::_internal_set_max_coop_size(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  max_coop_size_ = value;
}
inline void Contract::set_max_coop_size(uint32_t value) {
  _internal_set_max_coop_size(value);
  // @@protoc_insertion_point(field_set:ei.Contract.max_coop_size)
}

// optional uint32 max_boosts = 12;
inline bool Contract::_internal_has_max_boosts() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Contract::has_max_boosts() const {
  return _internal_has_max_boosts();
}
inline void Contract::clear_max_boosts() {
  max_boosts_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline uint32_t Contract::_internal_max_boosts() const {
  return max_boosts_;
}
inline uint32_t Contract::max_boosts() const {
  // @@protoc_insertion_point(field_get:ei.Contract.max_boosts)
  return _internal_max_boosts();
}
inline void Contract::_internal_set_max_boosts(uint32_t value) {
  _has_bits_[0] |= 0x00000200u;
  max_boosts_ = value;
}
inline void Contract::set_max_boosts(uint32_t value) {
  _internal_set_max_boosts(value);
  // @@protoc_insertion_point(field_set:ei.Contract.max_boosts)
}

// optional double minutes_per_token = 15 [default = 60];
inline bool Contract::_internal_has_minutes_per_token() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Contract::has_minutes_per_token() const {
  return _internal_has_minutes_per_token();
}
inline void Contract::clear_minutes_per_token() {
  minutes_per_token_ = 60;
  _has_bits_[0] &= ~0x00002000u;
}
inline double Contract::_internal_minutes_per_token() const {
  return minutes_per_token_;
}
inline double Contract::minutes_per_token() const {
  // @@protoc_insertion_point(field_get:ei.Contract.minutes_per_token)
  return _internal_minutes_per_token();
}
inline void Contract::_internal_set_minutes_per_token(double value) {
  _has_bits_[0] |= 0x00002000u;
  minutes_per_token_ = value;
}
inline void Contract::set_minutes_per_token(double value) {
  _internal_set_minutes_per_token(value);
  // @@protoc_insertion_point(field_set:ei.Contract.minutes_per_token)
}

// optional double chicken_run_cooldown_minutes = 18 [default = 60];
inline bool Contract::_internal_has_chicken_run_cooldown_minutes() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Contract::has_chicken_run_cooldown_minutes() const {
  return _internal_has_chicken_run_cooldown_minutes();
}
inline void Contract::clear_chicken_run_cooldown_minutes() {
  chicken_run_cooldown_minutes_ = 60;
  _has_bits_[0] &= ~0x00004000u;
}
inline double Contract::_internal_chicken_run_cooldown_minutes() const {
  return chicken_run_cooldown_minutes_;
}
inline double Contract::chicken_run_cooldown_minutes() const {
  // @@protoc_insertion_point(field_get:ei.Contract.chicken_run_cooldown_minutes)
  return _internal_chicken_run_cooldown_minutes();
}
inline void Contract::_internal_set_chicken_run_cooldown_minutes(double value) {
  _has_bits_[0] |= 0x00004000u;
  chicken_run_cooldown_minutes_ = value;
}
inline void Contract::set_chicken_run_cooldown_minutes(double value) {
  _internal_set_chicken_run_cooldown_minutes(value);
  // @@protoc_insertion_point(field_set:ei.Contract.chicken_run_cooldown_minutes)
}

// optional double start_time = 17;
inline bool Contract::_internal_has_start_time() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool Contract::has_start_time() const {
  return _internal_has_start_time();
}
inline void Contract::clear_start_time() {
  start_time_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline double Contract::_internal_start_time() const {
  return start_time_;
}
inline double Contract::start_time() const {
  // @@protoc_insertion_point(field_get:ei.Contract.start_time)
  return _internal_start_time();
}
inline void Contract::_internal_set_start_time(double value) {
  _has_bits_[0] |= 0x00000800u;
  start_time_ = value;
}
inline void Contract::set_start_time(double value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:ei.Contract.start_time)
}

// optional double expiration_time = 6;
inline bool Contract::_internal_has_expiration_time() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Contract::has_expiration_time() const {
  return _internal_has_expiration_time();
}
inline void Contract::clear_expiration_time() {
  expiration_time_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double Contract::_internal_expiration_time() const {
  return expiration_time_;
}
inline double Contract::expiration_time() const {
  // @@protoc_insertion_point(field_get:ei.Contract.expiration_time)
  return _internal_expiration_time();
}
inline void Contract::_internal_set_expiration_time(double value) {
  _has_bits_[0] |= 0x00000008u;
  expiration_time_ = value;
}
inline void Contract::set_expiration_time(double value) {
  _internal_set_expiration_time(value);
  // @@protoc_insertion_point(field_set:ei.Contract.expiration_time)
}

// optional double length_seconds = 7;
inline bool Contract::_internal_has_length_seconds() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Contract::has_length_seconds() const {
  return _internal_has_length_seconds();
}
inline void Contract::clear_length_seconds() {
  length_seconds_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline double Contract::_internal_length_seconds() const {
  return length_seconds_;
}
inline double Contract::length_seconds() const {
  // @@protoc_insertion_point(field_get:ei.Contract.length_seconds)
  return _internal_length_seconds();
}
inline void Contract::_internal_set_length_seconds(double value) {
  _has_bits_[0] |= 0x00000080u;
  length_seconds_ = value;
}
inline void Contract::set_length_seconds(double value) {
  _internal_set_length_seconds(value);
  // @@protoc_insertion_point(field_set:ei.Contract.length_seconds)
}

// optional double max_soul_eggs = 13;
inline bool Contract::_internal_has_max_soul_eggs() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Contract::has_max_soul_eggs() const {
  return _internal_has_max_soul_eggs();
}
inline void Contract::clear_max_soul_eggs() {
  max_soul_eggs_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline double Contract::_internal_max_soul_eggs() const {
  return max_soul_eggs_;
}
inline double Contract::max_soul_eggs() const {
  // @@protoc_insertion_point(field_get:ei.Contract.max_soul_eggs)
  return _internal_max_soul_eggs();
}
inline void Contract::_internal_set_max_soul_eggs(double value) {
  _has_bits_[0] |= 0x00000100u;
  max_soul_eggs_ = value;
}
inline void Contract::set_max_soul_eggs(double value) {
  _internal_set_max_soul_eggs(value);
  // @@protoc_insertion_point(field_set:ei.Contract.max_soul_eggs)
}

// optional uint32 min_client_version = 14;
inline bool Contract::_internal_has_min_client_version() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Contract::has_min_client_version() const {
  return _internal_has_min_client_version();
}
inline void Contract::clear_min_client_version() {
  min_client_version_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline uint32_t Contract::_internal_min_client_version() const {
  return min_client_version_;
}
inline uint32_t Contract::min_client_version() const {
  // @@protoc_insertion_point(field_get:ei.Contract.min_client_version)
  return _internal_min_client_version();
}
inline void Contract::_internal_set_min_client_version(uint32_t value) {
  _has_bits_[0] |= 0x00000400u;
  min_client_version_ = value;
}
inline void Contract::set_min_client_version(uint32_t value) {
  _internal_set_min_client_version(value);
  // @@protoc_insertion_point(field_set:ei.Contract.min_client_version)
}

// optional bool debug = 11;
inline bool Contract::_internal_has_debug() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Contract::has_debug() const {
  return _internal_has_debug();
}
inline void Contract::clear_debug() {
  debug_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool Contract::_internal_debug() const {
  return debug_;
}
inline bool Contract::debug() const {
  // @@protoc_insertion_point(field_get:ei.Contract.debug)
  return _internal_debug();
}
inline void Contract::_internal_set_debug(bool value) {
  _has_bits_[0] |= 0x00000040u;
  debug_ = value;
}
inline void Contract::set_debug(bool value) {
  _internal_set_debug(value);
  // @@protoc_insertion_point(field_set:ei.Contract.debug)
}

// -------------------------------------------------------------------

// BasicRequestInfo

// optional string ei_user_id = 1;
inline bool BasicRequestInfo::_internal_has_ei_user_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BasicRequestInfo::has_ei_user_id() const {
  return _internal_has_ei_user_id();
}
inline void BasicRequestInfo::clear_ei_user_id() {
  ei_user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BasicRequestInfo::ei_user_id() const {
  // @@protoc_insertion_point(field_get:ei.BasicRequestInfo.ei_user_id)
  return _internal_ei_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BasicRequestInfo::set_ei_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 ei_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.BasicRequestInfo.ei_user_id)
}
inline std::string* BasicRequestInfo::mutable_ei_user_id() {
  std::string* _s = _internal_mutable_ei_user_id();
  // @@protoc_insertion_point(field_mutable:ei.BasicRequestInfo.ei_user_id)
  return _s;
}
inline const std::string& BasicRequestInfo::_internal_ei_user_id() const {
  return ei_user_id_.Get();
}
inline void BasicRequestInfo::_internal_set_ei_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ei_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BasicRequestInfo::_internal_mutable_ei_user_id() {
  _has_bits_[0] |= 0x00000001u;
  return ei_user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BasicRequestInfo::release_ei_user_id() {
  // @@protoc_insertion_point(field_release:ei.BasicRequestInfo.ei_user_id)
  if (!_internal_has_ei_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = ei_user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ei_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ei_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BasicRequestInfo::set_allocated_ei_user_id(std::string* ei_user_id) {
  if (ei_user_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ei_user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ei_user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ei_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ei_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.BasicRequestInfo.ei_user_id)
}

// optional uint32 client_version = 2;
inline bool BasicRequestInfo::_internal_has_client_version() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool BasicRequestInfo::has_client_version() const {
  return _internal_has_client_version();
}
inline void BasicRequestInfo::clear_client_version() {
  client_version_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t BasicRequestInfo::_internal_client_version() const {
  return client_version_;
}
inline uint32_t BasicRequestInfo::client_version() const {
  // @@protoc_insertion_point(field_get:ei.BasicRequestInfo.client_version)
  return _internal_client_version();
}
inline void BasicRequestInfo::_internal_set_client_version(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  client_version_ = value;
}
inline void BasicRequestInfo::set_client_version(uint32_t value) {
  _internal_set_client_version(value);
  // @@protoc_insertion_point(field_set:ei.BasicRequestInfo.client_version)
}

// optional string version = 3;
inline bool BasicRequestInfo::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BasicRequestInfo::has_version() const {
  return _internal_has_version();
}
inline void BasicRequestInfo::clear_version() {
  version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BasicRequestInfo::version() const {
  // @@protoc_insertion_point(field_get:ei.BasicRequestInfo.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BasicRequestInfo::set_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.BasicRequestInfo.version)
}
inline std::string* BasicRequestInfo::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:ei.BasicRequestInfo.version)
  return _s;
}
inline const std::string& BasicRequestInfo::_internal_version() const {
  return version_.Get();
}
inline void BasicRequestInfo::_internal_set_version(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BasicRequestInfo::_internal_mutable_version() {
  _has_bits_[0] |= 0x00000002u;
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BasicRequestInfo::release_version() {
  // @@protoc_insertion_point(field_release:ei.BasicRequestInfo.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = version_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BasicRequestInfo::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.BasicRequestInfo.version)
}

// optional string build = 4;
inline bool BasicRequestInfo::_internal_has_build() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BasicRequestInfo::has_build() const {
  return _internal_has_build();
}
inline void BasicRequestInfo::clear_build() {
  build_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& BasicRequestInfo::build() const {
  // @@protoc_insertion_point(field_get:ei.BasicRequestInfo.build)
  return _internal_build();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BasicRequestInfo::set_build(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 build_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.BasicRequestInfo.build)
}
inline std::string* BasicRequestInfo::mutable_build() {
  std::string* _s = _internal_mutable_build();
  // @@protoc_insertion_point(field_mutable:ei.BasicRequestInfo.build)
  return _s;
}
inline const std::string& BasicRequestInfo::_internal_build() const {
  return build_.Get();
}
inline void BasicRequestInfo::_internal_set_build(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  build_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BasicRequestInfo::_internal_mutable_build() {
  _has_bits_[0] |= 0x00000004u;
  return build_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BasicRequestInfo::release_build() {
  // @@protoc_insertion_point(field_release:ei.BasicRequestInfo.build)
  if (!_internal_has_build()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = build_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (build_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    build_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BasicRequestInfo::set_allocated_build(std::string* build) {
  if (build != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  build_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), build,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (build_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    build_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.BasicRequestInfo.build)
}

// optional string platform = 5;
inline bool BasicRequestInfo::_internal_has_platform() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BasicRequestInfo::has_platform() const {
  return _internal_has_platform();
}
inline void BasicRequestInfo::clear_platform() {
  platform_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& BasicRequestInfo::platform() const {
  // @@protoc_insertion_point(field_get:ei.BasicRequestInfo.platform)
  return _internal_platform();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BasicRequestInfo::set_platform(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 platform_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.BasicRequestInfo.platform)
}
inline std::string* BasicRequestInfo::mutable_platform() {
  std::string* _s = _internal_mutable_platform();
  // @@protoc_insertion_point(field_mutable:ei.BasicRequestInfo.platform)
  return _s;
}
inline const std::string& BasicRequestInfo::_internal_platform() const {
  return platform_.Get();
}
inline void BasicRequestInfo::_internal_set_platform(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  platform_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BasicRequestInfo::_internal_mutable_platform() {
  _has_bits_[0] |= 0x00000008u;
  return platform_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BasicRequestInfo::release_platform() {
  // @@protoc_insertion_point(field_release:ei.BasicRequestInfo.platform)
  if (!_internal_has_platform()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = platform_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (platform_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    platform_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BasicRequestInfo::set_allocated_platform(std::string* platform) {
  if (platform != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  platform_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), platform,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (platform_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    platform_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.BasicRequestInfo.platform)
}

// optional string country = 6;
inline bool BasicRequestInfo::_internal_has_country() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BasicRequestInfo::has_country() const {
  return _internal_has_country();
}
inline void BasicRequestInfo::clear_country() {
  country_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& BasicRequestInfo::country() const {
  // @@protoc_insertion_point(field_get:ei.BasicRequestInfo.country)
  return _internal_country();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BasicRequestInfo::set_country(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 country_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.BasicRequestInfo.country)
}
inline std::string* BasicRequestInfo::mutable_country() {
  std::string* _s = _internal_mutable_country();
  // @@protoc_insertion_point(field_mutable:ei.BasicRequestInfo.country)
  return _s;
}
inline const std::string& BasicRequestInfo::_internal_country() const {
  return country_.Get();
}
inline void BasicRequestInfo::_internal_set_country(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  country_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BasicRequestInfo::_internal_mutable_country() {
  _has_bits_[0] |= 0x00000010u;
  return country_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BasicRequestInfo::release_country() {
  // @@protoc_insertion_point(field_release:ei.BasicRequestInfo.country)
  if (!_internal_has_country()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = country_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (country_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    country_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BasicRequestInfo::set_allocated_country(std::string* country) {
  if (country != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  country_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), country,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (country_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    country_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.BasicRequestInfo.country)
}

// optional string language = 7;
inline bool BasicRequestInfo::_internal_has_language() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool BasicRequestInfo::has_language() const {
  return _internal_has_language();
}
inline void BasicRequestInfo::clear_language() {
  language_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& BasicRequestInfo::language() const {
  // @@protoc_insertion_point(field_get:ei.BasicRequestInfo.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BasicRequestInfo::set_language(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 language_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.BasicRequestInfo.language)
}
inline std::string* BasicRequestInfo::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:ei.BasicRequestInfo.language)
  return _s;
}
inline const std::string& BasicRequestInfo::_internal_language() const {
  return language_.Get();
}
inline void BasicRequestInfo::_internal_set_language(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  language_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BasicRequestInfo::_internal_mutable_language() {
  _has_bits_[0] |= 0x00000020u;
  return language_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BasicRequestInfo::release_language() {
  // @@protoc_insertion_point(field_release:ei.BasicRequestInfo.language)
  if (!_internal_has_language()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = language_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (language_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    language_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BasicRequestInfo::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  language_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), language,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (language_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    language_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.BasicRequestInfo.language)
}

// optional bool debug = 8;
inline bool BasicRequestInfo::_internal_has_debug() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool BasicRequestInfo::has_debug() const {
  return _internal_has_debug();
}
inline void BasicRequestInfo::clear_debug() {
  debug_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool BasicRequestInfo::_internal_debug() const {
  return debug_;
}
inline bool BasicRequestInfo::debug() const {
  // @@protoc_insertion_point(field_get:ei.BasicRequestInfo.debug)
  return _internal_debug();
}
inline void BasicRequestInfo::_internal_set_debug(bool value) {
  _has_bits_[0] |= 0x00000080u;
  debug_ = value;
}
inline void BasicRequestInfo::set_debug(bool value) {
  _internal_set_debug(value);
  // @@protoc_insertion_point(field_set:ei.BasicRequestInfo.debug)
}

// -------------------------------------------------------------------

// ContractsRequest

// optional double soul_eggs = 1;
inline bool ContractsRequest::_internal_has_soul_eggs() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContractsRequest::has_soul_eggs() const {
  return _internal_has_soul_eggs();
}
inline void ContractsRequest::clear_soul_eggs() {
  soul_eggs_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double ContractsRequest::_internal_soul_eggs() const {
  return soul_eggs_;
}
inline double ContractsRequest::soul_eggs() const {
  // @@protoc_insertion_point(field_get:ei.ContractsRequest.soul_eggs)
  return _internal_soul_eggs();
}
inline void ContractsRequest::_internal_set_soul_eggs(double value) {
  _has_bits_[0] |= 0x00000001u;
  soul_eggs_ = value;
}
inline void ContractsRequest::set_soul_eggs(double value) {
  _internal_set_soul_eggs(value);
  // @@protoc_insertion_point(field_set:ei.ContractsRequest.soul_eggs)
}

// optional uint32 client_version = 5;
inline bool ContractsRequest::_internal_has_client_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContractsRequest::has_client_version() const {
  return _internal_has_client_version();
}
inline void ContractsRequest::clear_client_version() {
  client_version_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ContractsRequest::_internal_client_version() const {
  return client_version_;
}
inline uint32_t ContractsRequest::client_version() const {
  // @@protoc_insertion_point(field_get:ei.ContractsRequest.client_version)
  return _internal_client_version();
}
inline void ContractsRequest::_internal_set_client_version(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  client_version_ = value;
}
inline void ContractsRequest::set_client_version(uint32_t value) {
  _internal_set_client_version(value);
  // @@protoc_insertion_point(field_set:ei.ContractsRequest.client_version)
}

// -------------------------------------------------------------------

// ContractsResponse

// repeated .ei.Contract contracts = 1;
inline int ContractsResponse::_internal_contracts_size() const {
  return contracts_.size();
}
inline int ContractsResponse::contracts_size() const {
  return _internal_contracts_size();
}
inline void ContractsResponse::clear_contracts() {
  contracts_.Clear();
}
inline ::ei::Contract* ContractsResponse::mutable_contracts(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ContractsResponse.contracts)
  return contracts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Contract >*
ContractsResponse::mutable_contracts() {
  // @@protoc_insertion_point(field_mutable_list:ei.ContractsResponse.contracts)
  return &contracts_;
}
inline const ::ei::Contract& ContractsResponse::_internal_contracts(int index) const {
  return contracts_.Get(index);
}
inline const ::ei::Contract& ContractsResponse::contracts(int index) const {
  // @@protoc_insertion_point(field_get:ei.ContractsResponse.contracts)
  return _internal_contracts(index);
}
inline ::ei::Contract* ContractsResponse::_internal_add_contracts() {
  return contracts_.Add();
}
inline ::ei::Contract* ContractsResponse::add_contracts() {
  ::ei::Contract* _add = _internal_add_contracts();
  // @@protoc_insertion_point(field_add:ei.ContractsResponse.contracts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Contract >&
ContractsResponse::contracts() const {
  // @@protoc_insertion_point(field_list:ei.ContractsResponse.contracts)
  return contracts_;
}

// optional string warning_message = 4;
inline bool ContractsResponse::_internal_has_warning_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContractsResponse::has_warning_message() const {
  return _internal_has_warning_message();
}
inline void ContractsResponse::clear_warning_message() {
  warning_message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContractsResponse::warning_message() const {
  // @@protoc_insertion_point(field_get:ei.ContractsResponse.warning_message)
  return _internal_warning_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractsResponse::set_warning_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 warning_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ContractsResponse.warning_message)
}
inline std::string* ContractsResponse::mutable_warning_message() {
  std::string* _s = _internal_mutable_warning_message();
  // @@protoc_insertion_point(field_mutable:ei.ContractsResponse.warning_message)
  return _s;
}
inline const std::string& ContractsResponse::_internal_warning_message() const {
  return warning_message_.Get();
}
inline void ContractsResponse::_internal_set_warning_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  warning_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ContractsResponse::_internal_mutable_warning_message() {
  _has_bits_[0] |= 0x00000001u;
  return warning_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ContractsResponse::release_warning_message() {
  // @@protoc_insertion_point(field_release:ei.ContractsResponse.warning_message)
  if (!_internal_has_warning_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = warning_message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (warning_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    warning_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractsResponse::set_allocated_warning_message(std::string* warning_message) {
  if (warning_message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  warning_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), warning_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (warning_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    warning_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ContractsResponse.warning_message)
}

// optional double server_time = 2;
inline bool ContractsResponse::_internal_has_server_time() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContractsResponse::has_server_time() const {
  return _internal_has_server_time();
}
inline void ContractsResponse::clear_server_time() {
  server_time_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ContractsResponse::_internal_server_time() const {
  return server_time_;
}
inline double ContractsResponse::server_time() const {
  // @@protoc_insertion_point(field_get:ei.ContractsResponse.server_time)
  return _internal_server_time();
}
inline void ContractsResponse::_internal_set_server_time(double value) {
  _has_bits_[0] |= 0x00000002u;
  server_time_ = value;
}
inline void ContractsResponse::set_server_time(double value) {
  _internal_set_server_time(value);
  // @@protoc_insertion_point(field_set:ei.ContractsResponse.server_time)
}

// optional uint32 max_eop = 3 [default = 1000];
inline bool ContractsResponse::_internal_has_max_eop() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ContractsResponse::has_max_eop() const {
  return _internal_has_max_eop();
}
inline void ContractsResponse::clear_max_eop() {
  max_eop_ = 1000u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ContractsResponse::_internal_max_eop() const {
  return max_eop_;
}
inline uint32_t ContractsResponse::max_eop() const {
  // @@protoc_insertion_point(field_get:ei.ContractsResponse.max_eop)
  return _internal_max_eop();
}
inline void ContractsResponse::_internal_set_max_eop(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  max_eop_ = value;
}
inline void ContractsResponse::set_max_eop(uint32_t value) {
  _internal_set_max_eop(value);
  // @@protoc_insertion_point(field_set:ei.ContractsResponse.max_eop)
}

// -------------------------------------------------------------------

// ContractCoopStatusRequest

// optional .ei.BasicRequestInfo rinfo = 5;
inline bool ContractCoopStatusRequest::_internal_has_rinfo() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || rinfo_ != nullptr);
  return value;
}
inline bool ContractCoopStatusRequest::has_rinfo() const {
  return _internal_has_rinfo();
}
inline void ContractCoopStatusRequest::clear_rinfo() {
  if (rinfo_ != nullptr) rinfo_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ei::BasicRequestInfo& ContractCoopStatusRequest::_internal_rinfo() const {
  const ::ei::BasicRequestInfo* p = rinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::BasicRequestInfo&>(
      ::ei::_BasicRequestInfo_default_instance_);
}
inline const ::ei::BasicRequestInfo& ContractCoopStatusRequest::rinfo() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusRequest.rinfo)
  return _internal_rinfo();
}
inline void ContractCoopStatusRequest::unsafe_arena_set_allocated_rinfo(
    ::ei::BasicRequestInfo* rinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rinfo_);
  }
  rinfo_ = rinfo;
  if (rinfo) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.ContractCoopStatusRequest.rinfo)
}
inline ::ei::BasicRequestInfo* ContractCoopStatusRequest::release_rinfo() {
  _has_bits_[0] &= ~0x00000008u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::BasicRequestInfo* ContractCoopStatusRequest::unsafe_arena_release_rinfo() {
  // @@protoc_insertion_point(field_release:ei.ContractCoopStatusRequest.rinfo)
  _has_bits_[0] &= ~0x00000008u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
  return temp;
}
inline ::ei::BasicRequestInfo* ContractCoopStatusRequest::_internal_mutable_rinfo() {
  _has_bits_[0] |= 0x00000008u;
  if (rinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::BasicRequestInfo>(GetArenaForAllocation());
    rinfo_ = p;
  }
  return rinfo_;
}
inline ::ei::BasicRequestInfo* ContractCoopStatusRequest::mutable_rinfo() {
  ::ei::BasicRequestInfo* _msg = _internal_mutable_rinfo();
  // @@protoc_insertion_point(field_mutable:ei.ContractCoopStatusRequest.rinfo)
  return _msg;
}
inline void ContractCoopStatusRequest::set_allocated_rinfo(::ei::BasicRequestInfo* rinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rinfo_;
  }
  if (rinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::BasicRequestInfo>::GetOwningArena(rinfo);
    if (message_arena != submessage_arena) {
      rinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  rinfo_ = rinfo;
  // @@protoc_insertion_point(field_set_allocated:ei.ContractCoopStatusRequest.rinfo)
}

// optional string contract_identifier = 1;
inline bool ContractCoopStatusRequest::_internal_has_contract_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContractCoopStatusRequest::has_contract_identifier() const {
  return _internal_has_contract_identifier();
}
inline void ContractCoopStatusRequest::clear_contract_identifier() {
  contract_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContractCoopStatusRequest::contract_identifier() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusRequest.contract_identifier)
  return _internal_contract_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractCoopStatusRequest::set_contract_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 contract_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusRequest.contract_identifier)
}
inline std::string* ContractCoopStatusRequest::mutable_contract_identifier() {
  std::string* _s = _internal_mutable_contract_identifier();
  // @@protoc_insertion_point(field_mutable:ei.ContractCoopStatusRequest.contract_identifier)
  return _s;
}
inline const std::string& ContractCoopStatusRequest::_internal_contract_identifier() const {
  return contract_identifier_.Get();
}
inline void ContractCoopStatusRequest::_internal_set_contract_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  contract_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusRequest::_internal_mutable_contract_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return contract_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusRequest::release_contract_identifier() {
  // @@protoc_insertion_point(field_release:ei.ContractCoopStatusRequest.contract_identifier)
  if (!_internal_has_contract_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = contract_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractCoopStatusRequest::set_allocated_contract_identifier(std::string* contract_identifier) {
  if (contract_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  contract_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contract_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ContractCoopStatusRequest.contract_identifier)
}

// optional string coop_identifier = 2;
inline bool ContractCoopStatusRequest::_internal_has_coop_identifier() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContractCoopStatusRequest::has_coop_identifier() const {
  return _internal_has_coop_identifier();
}
inline void ContractCoopStatusRequest::clear_coop_identifier() {
  coop_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ContractCoopStatusRequest::coop_identifier() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusRequest.coop_identifier)
  return _internal_coop_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractCoopStatusRequest::set_coop_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 coop_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusRequest.coop_identifier)
}
inline std::string* ContractCoopStatusRequest::mutable_coop_identifier() {
  std::string* _s = _internal_mutable_coop_identifier();
  // @@protoc_insertion_point(field_mutable:ei.ContractCoopStatusRequest.coop_identifier)
  return _s;
}
inline const std::string& ContractCoopStatusRequest::_internal_coop_identifier() const {
  return coop_identifier_.Get();
}
inline void ContractCoopStatusRequest::_internal_set_coop_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  coop_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusRequest::_internal_mutable_coop_identifier() {
  _has_bits_[0] |= 0x00000002u;
  return coop_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusRequest::release_coop_identifier() {
  // @@protoc_insertion_point(field_release:ei.ContractCoopStatusRequest.coop_identifier)
  if (!_internal_has_coop_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = coop_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coop_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coop_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractCoopStatusRequest::set_allocated_coop_identifier(std::string* coop_identifier) {
  if (coop_identifier != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  coop_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), coop_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coop_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coop_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ContractCoopStatusRequest.coop_identifier)
}

// optional string user_id = 3;
inline bool ContractCoopStatusRequest::_internal_has_user_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ContractCoopStatusRequest::has_user_id() const {
  return _internal_has_user_id();
}
inline void ContractCoopStatusRequest::clear_user_id() {
  user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ContractCoopStatusRequest::user_id() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractCoopStatusRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusRequest.user_id)
}
inline std::string* ContractCoopStatusRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:ei.ContractCoopStatusRequest.user_id)
  return _s;
}
inline const std::string& ContractCoopStatusRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void ContractCoopStatusRequest::_internal_set_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusRequest::_internal_mutable_user_id() {
  _has_bits_[0] |= 0x00000004u;
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:ei.ContractCoopStatusRequest.user_id)
  if (!_internal_has_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractCoopStatusRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ContractCoopStatusRequest.user_id)
}

// optional uint32 client_version = 4;
inline bool ContractCoopStatusRequest::_internal_has_client_version() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ContractCoopStatusRequest::has_client_version() const {
  return _internal_has_client_version();
}
inline void ContractCoopStatusRequest::clear_client_version() {
  client_version_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t ContractCoopStatusRequest::_internal_client_version() const {
  return client_version_;
}
inline uint32_t ContractCoopStatusRequest::client_version() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusRequest.client_version)
  return _internal_client_version();
}
inline void ContractCoopStatusRequest::_internal_set_client_version(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  client_version_ = value;
}
inline void ContractCoopStatusRequest::set_client_version(uint32_t value) {
  _internal_set_client_version(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusRequest.client_version)
}

// -------------------------------------------------------------------

// FarmProductionParams

// optional double farm_population = 1;
inline bool FarmProductionParams::_internal_has_farm_population() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FarmProductionParams::has_farm_population() const {
  return _internal_has_farm_population();
}
inline void FarmProductionParams::clear_farm_population() {
  farm_population_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double FarmProductionParams::_internal_farm_population() const {
  return farm_population_;
}
inline double FarmProductionParams::farm_population() const {
  // @@protoc_insertion_point(field_get:ei.FarmProductionParams.farm_population)
  return _internal_farm_population();
}
inline void FarmProductionParams::_internal_set_farm_population(double value) {
  _has_bits_[0] |= 0x00000001u;
  farm_population_ = value;
}
inline void FarmProductionParams::set_farm_population(double value) {
  _internal_set_farm_population(value);
  // @@protoc_insertion_point(field_set:ei.FarmProductionParams.farm_population)
}

// optional double farm_capacity = 2;
inline bool FarmProductionParams::_internal_has_farm_capacity() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FarmProductionParams::has_farm_capacity() const {
  return _internal_has_farm_capacity();
}
inline void FarmProductionParams::clear_farm_capacity() {
  farm_capacity_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double FarmProductionParams::_internal_farm_capacity() const {
  return farm_capacity_;
}
inline double FarmProductionParams::farm_capacity() const {
  // @@protoc_insertion_point(field_get:ei.FarmProductionParams.farm_capacity)
  return _internal_farm_capacity();
}
inline void FarmProductionParams::_internal_set_farm_capacity(double value) {
  _has_bits_[0] |= 0x00000002u;
  farm_capacity_ = value;
}
inline void FarmProductionParams::set_farm_capacity(double value) {
  _internal_set_farm_capacity(value);
  // @@protoc_insertion_point(field_set:ei.FarmProductionParams.farm_capacity)
}

// optional double elr = 3;
inline bool FarmProductionParams::_internal_has_elr() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FarmProductionParams::has_elr() const {
  return _internal_has_elr();
}
inline void FarmProductionParams::clear_elr() {
  elr_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double FarmProductionParams::_internal_elr() const {
  return elr_;
}
inline double FarmProductionParams::elr() const {
  // @@protoc_insertion_point(field_get:ei.FarmProductionParams.elr)
  return _internal_elr();
}
inline void FarmProductionParams::_internal_set_elr(double value) {
  _has_bits_[0] |= 0x00000004u;
  elr_ = value;
}
inline void FarmProductionParams::set_elr(double value) {
  _internal_set_elr(value);
  // @@protoc_insertion_point(field_set:ei.FarmProductionParams.elr)
}

// optional double ihr = 4;
inline bool FarmProductionParams::_internal_has_ihr() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool FarmProductionParams::has_ihr() const {
  return _internal_has_ihr();
}
inline void FarmProductionParams::clear_ihr() {
  ihr_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double FarmProductionParams::_internal_ihr() const {
  return ihr_;
}
inline double FarmProductionParams::ihr() const {
  // @@protoc_insertion_point(field_get:ei.FarmProductionParams.ihr)
  return _internal_ihr();
}
inline void FarmProductionParams::_internal_set_ihr(double value) {
  _has_bits_[0] |= 0x00000008u;
  ihr_ = value;
}
inline void FarmProductionParams::set_ihr(double value) {
  _internal_set_ihr(value);
  // @@protoc_insertion_point(field_set:ei.FarmProductionParams.ihr)
}

// optional double sr = 5;
inline bool FarmProductionParams::_internal_has_sr() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool FarmProductionParams::has_sr() const {
  return _internal_has_sr();
}
inline void FarmProductionParams::clear_sr() {
  sr_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double FarmProductionParams::_internal_sr() const {
  return sr_;
}
inline double FarmProductionParams::sr() const {
  // @@protoc_insertion_point(field_get:ei.FarmProductionParams.sr)
  return _internal_sr();
}
inline void FarmProductionParams::_internal_set_sr(double value) {
  _has_bits_[0] |= 0x00000010u;
  sr_ = value;
}
inline void FarmProductionParams::set_sr(double value) {
  _internal_set_sr(value);
  // @@protoc_insertion_point(field_set:ei.FarmProductionParams.sr)
}

// optional double delivered = 6;
inline bool FarmProductionParams::_internal_has_delivered() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool FarmProductionParams::has_delivered() const {
  return _internal_has_delivered();
}
inline void FarmProductionParams::clear_delivered() {
  delivered_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double FarmProductionParams::_internal_delivered() const {
  return delivered_;
}
inline double FarmProductionParams::delivered() const {
  // @@protoc_insertion_point(field_get:ei.FarmProductionParams.delivered)
  return _internal_delivered();
}
inline void FarmProductionParams::_internal_set_delivered(double value) {
  _has_bits_[0] |= 0x00000020u;
  delivered_ = value;
}
inline void FarmProductionParams::set_delivered(double value) {
  _internal_set_delivered(value);
  // @@protoc_insertion_point(field_set:ei.FarmProductionParams.delivered)
}

// -------------------------------------------------------------------

// PlayerFarmInfo

// optional uint32 client_version = 20;
inline bool PlayerFarmInfo::_internal_has_client_version() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool PlayerFarmInfo::has_client_version() const {
  return _internal_has_client_version();
}
inline void PlayerFarmInfo::clear_client_version() {
  client_version_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline uint32_t PlayerFarmInfo::_internal_client_version() const {
  return client_version_;
}
inline uint32_t PlayerFarmInfo::client_version() const {
  // @@protoc_insertion_point(field_get:ei.PlayerFarmInfo.client_version)
  return _internal_client_version();
}
inline void PlayerFarmInfo::_internal_set_client_version(uint32_t value) {
  _has_bits_[0] |= 0x00000200u;
  client_version_ = value;
}
inline void PlayerFarmInfo::set_client_version(uint32_t value) {
  _internal_set_client_version(value);
  // @@protoc_insertion_point(field_set:ei.PlayerFarmInfo.client_version)
}

// optional double soul_eggs = 1;
inline bool PlayerFarmInfo::_internal_has_soul_eggs() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PlayerFarmInfo::has_soul_eggs() const {
  return _internal_has_soul_eggs();
}
inline void PlayerFarmInfo::clear_soul_eggs() {
  soul_eggs_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double PlayerFarmInfo::_internal_soul_eggs() const {
  return soul_eggs_;
}
inline double PlayerFarmInfo::soul_eggs() const {
  // @@protoc_insertion_point(field_get:ei.PlayerFarmInfo.soul_eggs)
  return _internal_soul_eggs();
}
inline void PlayerFarmInfo::_internal_set_soul_eggs(double value) {
  _has_bits_[0] |= 0x00000002u;
  soul_eggs_ = value;
}
inline void PlayerFarmInfo::set_soul_eggs(double value) {
  _internal_set_soul_eggs(value);
  // @@protoc_insertion_point(field_set:ei.PlayerFarmInfo.soul_eggs)
}

// optional uint64 eggs_of_prophecy = 2;
inline bool PlayerFarmInfo::_internal_has_eggs_of_prophecy() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PlayerFarmInfo::has_eggs_of_prophecy() const {
  return _internal_has_eggs_of_prophecy();
}
inline void PlayerFarmInfo::clear_eggs_of_prophecy() {
  eggs_of_prophecy_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t PlayerFarmInfo::_internal_eggs_of_prophecy() const {
  return eggs_of_prophecy_;
}
inline uint64_t PlayerFarmInfo::eggs_of_prophecy() const {
  // @@protoc_insertion_point(field_get:ei.PlayerFarmInfo.eggs_of_prophecy)
  return _internal_eggs_of_prophecy();
}
inline void PlayerFarmInfo::_internal_set_eggs_of_prophecy(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  eggs_of_prophecy_ = value;
}
inline void PlayerFarmInfo::set_eggs_of_prophecy(uint64_t value) {
  _internal_set_eggs_of_prophecy(value);
  // @@protoc_insertion_point(field_set:ei.PlayerFarmInfo.eggs_of_prophecy)
}

// optional uint32 permit_level = 3;
inline bool PlayerFarmInfo::_internal_has_permit_level() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PlayerFarmInfo::has_permit_level() const {
  return _internal_has_permit_level();
}
inline void PlayerFarmInfo::clear_permit_level() {
  permit_level_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t PlayerFarmInfo::_internal_permit_level() const {
  return permit_level_;
}
inline uint32_t PlayerFarmInfo::permit_level() const {
  // @@protoc_insertion_point(field_get:ei.PlayerFarmInfo.permit_level)
  return _internal_permit_level();
}
inline void PlayerFarmInfo::_internal_set_permit_level(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  permit_level_ = value;
}
inline void PlayerFarmInfo::set_permit_level(uint32_t value) {
  _internal_set_permit_level(value);
  // @@protoc_insertion_point(field_set:ei.PlayerFarmInfo.permit_level)
}

// optional bool hyperloop_station = 4;
inline bool PlayerFarmInfo::_internal_has_hyperloop_station() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PlayerFarmInfo::has_hyperloop_station() const {
  return _internal_has_hyperloop_station();
}
inline void PlayerFarmInfo::clear_hyperloop_station() {
  hyperloop_station_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool PlayerFarmInfo::_internal_hyperloop_station() const {
  return hyperloop_station_;
}
inline bool PlayerFarmInfo::hyperloop_station() const {
  // @@protoc_insertion_point(field_get:ei.PlayerFarmInfo.hyperloop_station)
  return _internal_hyperloop_station();
}
inline void PlayerFarmInfo::_internal_set_hyperloop_station(bool value) {
  _has_bits_[0] |= 0x00000010u;
  hyperloop_station_ = value;
}
inline void PlayerFarmInfo::set_hyperloop_station(bool value) {
  _internal_set_hyperloop_station(value);
  // @@protoc_insertion_point(field_set:ei.PlayerFarmInfo.hyperloop_station)
}

// repeated uint32 egg_medal_level = 5;
inline int PlayerFarmInfo::_internal_egg_medal_level_size() const {
  return egg_medal_level_.size();
}
inline int PlayerFarmInfo::egg_medal_level_size() const {
  return _internal_egg_medal_level_size();
}
inline void PlayerFarmInfo::clear_egg_medal_level() {
  egg_medal_level_.Clear();
}
inline uint32_t PlayerFarmInfo::_internal_egg_medal_level(int index) const {
  return egg_medal_level_.Get(index);
}
inline uint32_t PlayerFarmInfo::egg_medal_level(int index) const {
  // @@protoc_insertion_point(field_get:ei.PlayerFarmInfo.egg_medal_level)
  return _internal_egg_medal_level(index);
}
inline void PlayerFarmInfo::set_egg_medal_level(int index, uint32_t value) {
  egg_medal_level_.Set(index, value);
  // @@protoc_insertion_point(field_set:ei.PlayerFarmInfo.egg_medal_level)
}
inline void PlayerFarmInfo::_internal_add_egg_medal_level(uint32_t value) {
  egg_medal_level_.Add(value);
}
inline void PlayerFarmInfo::add_egg_medal_level(uint32_t value) {
  _internal_add_egg_medal_level(value);
  // @@protoc_insertion_point(field_add:ei.PlayerFarmInfo.egg_medal_level)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
PlayerFarmInfo::_internal_egg_medal_level() const {
  return egg_medal_level_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
PlayerFarmInfo::egg_medal_level() const {
  // @@protoc_insertion_point(field_list:ei.PlayerFarmInfo.egg_medal_level)
  return _internal_egg_medal_level();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
PlayerFarmInfo::_internal_mutable_egg_medal_level() {
  return &egg_medal_level_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
PlayerFarmInfo::mutable_egg_medal_level() {
  // @@protoc_insertion_point(field_mutable_list:ei.PlayerFarmInfo.egg_medal_level)
  return _internal_mutable_egg_medal_level();
}

// repeated .ei.Backup.ResearchItem epic_research = 6;
inline int PlayerFarmInfo::_internal_epic_research_size() const {
  return epic_research_.size();
}
inline int PlayerFarmInfo::epic_research_size() const {
  return _internal_epic_research_size();
}
inline void PlayerFarmInfo::clear_epic_research() {
  epic_research_.Clear();
}
inline ::ei::Backup_ResearchItem* PlayerFarmInfo::mutable_epic_research(int index) {
  // @@protoc_insertion_point(field_mutable:ei.PlayerFarmInfo.epic_research)
  return epic_research_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_ResearchItem >*
PlayerFarmInfo::mutable_epic_research() {
  // @@protoc_insertion_point(field_mutable_list:ei.PlayerFarmInfo.epic_research)
  return &epic_research_;
}
inline const ::ei::Backup_ResearchItem& PlayerFarmInfo::_internal_epic_research(int index) const {
  return epic_research_.Get(index);
}
inline const ::ei::Backup_ResearchItem& PlayerFarmInfo::epic_research(int index) const {
  // @@protoc_insertion_point(field_get:ei.PlayerFarmInfo.epic_research)
  return _internal_epic_research(index);
}
inline ::ei::Backup_ResearchItem* PlayerFarmInfo::_internal_add_epic_research() {
  return epic_research_.Add();
}
inline ::ei::Backup_ResearchItem* PlayerFarmInfo::add_epic_research() {
  ::ei::Backup_ResearchItem* _add = _internal_add_epic_research();
  // @@protoc_insertion_point(field_add:ei.PlayerFarmInfo.epic_research)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_ResearchItem >&
PlayerFarmInfo::epic_research() const {
  // @@protoc_insertion_point(field_list:ei.PlayerFarmInfo.epic_research)
  return epic_research_;
}

// optional .ei.Egg egg_type = 7;
inline bool PlayerFarmInfo::_internal_has_egg_type() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool PlayerFarmInfo::has_egg_type() const {
  return _internal_has_egg_type();
}
inline void PlayerFarmInfo::clear_egg_type() {
  egg_type_ = 1;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::ei::Egg PlayerFarmInfo::_internal_egg_type() const {
  return static_cast< ::ei::Egg >(egg_type_);
}
inline ::ei::Egg PlayerFarmInfo::egg_type() const {
  // @@protoc_insertion_point(field_get:ei.PlayerFarmInfo.egg_type)
  return _internal_egg_type();
}
inline void PlayerFarmInfo::_internal_set_egg_type(::ei::Egg value) {
  assert(::ei::Egg_IsValid(value));
  _has_bits_[0] |= 0x00000400u;
  egg_type_ = value;
}
inline void PlayerFarmInfo::set_egg_type(::ei::Egg value) {
  _internal_set_egg_type(value);
  // @@protoc_insertion_point(field_set:ei.PlayerFarmInfo.egg_type)
}

// optional double cash_on_hand = 8;
inline bool PlayerFarmInfo::_internal_has_cash_on_hand() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PlayerFarmInfo::has_cash_on_hand() const {
  return _internal_has_cash_on_hand();
}
inline void PlayerFarmInfo::clear_cash_on_hand() {
  cash_on_hand_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double PlayerFarmInfo::_internal_cash_on_hand() const {
  return cash_on_hand_;
}
inline double PlayerFarmInfo::cash_on_hand() const {
  // @@protoc_insertion_point(field_get:ei.PlayerFarmInfo.cash_on_hand)
  return _internal_cash_on_hand();
}
inline void PlayerFarmInfo::_internal_set_cash_on_hand(double value) {
  _has_bits_[0] |= 0x00000020u;
  cash_on_hand_ = value;
}
inline void PlayerFarmInfo::set_cash_on_hand(double value) {
  _internal_set_cash_on_hand(value);
  // @@protoc_insertion_point(field_set:ei.PlayerFarmInfo.cash_on_hand)
}

// repeated uint32 habs = 9;
inline int PlayerFarmInfo::_internal_habs_size() const {
  return habs_.size();
}
inline int PlayerFarmInfo::habs_size() const {
  return _internal_habs_size();
}
inline void PlayerFarmInfo::clear_habs() {
  habs_.Clear();
}
inline uint32_t PlayerFarmInfo::_internal_habs(int index) const {
  return habs_.Get(index);
}
inline uint32_t PlayerFarmInfo::habs(int index) const {
  // @@protoc_insertion_point(field_get:ei.PlayerFarmInfo.habs)
  return _internal_habs(index);
}
inline void PlayerFarmInfo::set_habs(int index, uint32_t value) {
  habs_.Set(index, value);
  // @@protoc_insertion_point(field_set:ei.PlayerFarmInfo.habs)
}
inline void PlayerFarmInfo::_internal_add_habs(uint32_t value) {
  habs_.Add(value);
}
inline void PlayerFarmInfo::add_habs(uint32_t value) {
  _internal_add_habs(value);
  // @@protoc_insertion_point(field_add:ei.PlayerFarmInfo.habs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
PlayerFarmInfo::_internal_habs() const {
  return habs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
PlayerFarmInfo::habs() const {
  // @@protoc_insertion_point(field_list:ei.PlayerFarmInfo.habs)
  return _internal_habs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
PlayerFarmInfo::_internal_mutable_habs() {
  return &habs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
PlayerFarmInfo::mutable_habs() {
  // @@protoc_insertion_point(field_mutable_list:ei.PlayerFarmInfo.habs)
  return _internal_mutable_habs();
}

// repeated uint64 hab_population = 10;
inline int PlayerFarmInfo::_internal_hab_population_size() const {
  return hab_population_.size();
}
inline int PlayerFarmInfo::hab_population_size() const {
  return _internal_hab_population_size();
}
inline void PlayerFarmInfo::clear_hab_population() {
  hab_population_.Clear();
}
inline uint64_t PlayerFarmInfo::_internal_hab_population(int index) const {
  return hab_population_.Get(index);
}
inline uint64_t PlayerFarmInfo::hab_population(int index) const {
  // @@protoc_insertion_point(field_get:ei.PlayerFarmInfo.hab_population)
  return _internal_hab_population(index);
}
inline void PlayerFarmInfo::set_hab_population(int index, uint64_t value) {
  hab_population_.Set(index, value);
  // @@protoc_insertion_point(field_set:ei.PlayerFarmInfo.hab_population)
}
inline void PlayerFarmInfo::_internal_add_hab_population(uint64_t value) {
  hab_population_.Add(value);
}
inline void PlayerFarmInfo::add_hab_population(uint64_t value) {
  _internal_add_hab_population(value);
  // @@protoc_insertion_point(field_add:ei.PlayerFarmInfo.hab_population)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
PlayerFarmInfo::_internal_hab_population() const {
  return hab_population_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
PlayerFarmInfo::hab_population() const {
  // @@protoc_insertion_point(field_list:ei.PlayerFarmInfo.hab_population)
  return _internal_hab_population();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
PlayerFarmInfo::_internal_mutable_hab_population() {
  return &hab_population_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
PlayerFarmInfo::mutable_hab_population() {
  // @@protoc_insertion_point(field_mutable_list:ei.PlayerFarmInfo.hab_population)
  return _internal_mutable_hab_population();
}

// repeated uint64 hab_capacity = 21;
inline int PlayerFarmInfo::_internal_hab_capacity_size() const {
  return hab_capacity_.size();
}
inline int PlayerFarmInfo::hab_capacity_size() const {
  return _internal_hab_capacity_size();
}
inline void PlayerFarmInfo::clear_hab_capacity() {
  hab_capacity_.Clear();
}
inline uint64_t PlayerFarmInfo::_internal_hab_capacity(int index) const {
  return hab_capacity_.Get(index);
}
inline uint64_t PlayerFarmInfo::hab_capacity(int index) const {
  // @@protoc_insertion_point(field_get:ei.PlayerFarmInfo.hab_capacity)
  return _internal_hab_capacity(index);
}
inline void PlayerFarmInfo::set_hab_capacity(int index, uint64_t value) {
  hab_capacity_.Set(index, value);
  // @@protoc_insertion_point(field_set:ei.PlayerFarmInfo.hab_capacity)
}
inline void PlayerFarmInfo::_internal_add_hab_capacity(uint64_t value) {
  hab_capacity_.Add(value);
}
inline void PlayerFarmInfo::add_hab_capacity(uint64_t value) {
  _internal_add_hab_capacity(value);
  // @@protoc_insertion_point(field_add:ei.PlayerFarmInfo.hab_capacity)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
PlayerFarmInfo::_internal_hab_capacity() const {
  return hab_capacity_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
PlayerFarmInfo::hab_capacity() const {
  // @@protoc_insertion_point(field_list:ei.PlayerFarmInfo.hab_capacity)
  return _internal_hab_capacity();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
PlayerFarmInfo::_internal_mutable_hab_capacity() {
  return &hab_capacity_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
PlayerFarmInfo::mutable_hab_capacity() {
  // @@protoc_insertion_point(field_mutable_list:ei.PlayerFarmInfo.hab_capacity)
  return _internal_mutable_hab_capacity();
}

// repeated uint32 vehicles = 11;
inline int PlayerFarmInfo::_internal_vehicles_size() const {
  return vehicles_.size();
}
inline int PlayerFarmInfo::vehicles_size() const {
  return _internal_vehicles_size();
}
inline void PlayerFarmInfo::clear_vehicles() {
  vehicles_.Clear();
}
inline uint32_t PlayerFarmInfo::_internal_vehicles(int index) const {
  return vehicles_.Get(index);
}
inline uint32_t PlayerFarmInfo::vehicles(int index) const {
  // @@protoc_insertion_point(field_get:ei.PlayerFarmInfo.vehicles)
  return _internal_vehicles(index);
}
inline void PlayerFarmInfo::set_vehicles(int index, uint32_t value) {
  vehicles_.Set(index, value);
  // @@protoc_insertion_point(field_set:ei.PlayerFarmInfo.vehicles)
}
inline void PlayerFarmInfo::_internal_add_vehicles(uint32_t value) {
  vehicles_.Add(value);
}
inline void PlayerFarmInfo::add_vehicles(uint32_t value) {
  _internal_add_vehicles(value);
  // @@protoc_insertion_point(field_add:ei.PlayerFarmInfo.vehicles)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
PlayerFarmInfo::_internal_vehicles() const {
  return vehicles_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
PlayerFarmInfo::vehicles() const {
  // @@protoc_insertion_point(field_list:ei.PlayerFarmInfo.vehicles)
  return _internal_vehicles();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
PlayerFarmInfo::_internal_mutable_vehicles() {
  return &vehicles_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
PlayerFarmInfo::mutable_vehicles() {
  // @@protoc_insertion_point(field_mutable_list:ei.PlayerFarmInfo.vehicles)
  return _internal_mutable_vehicles();
}

// repeated uint32 train_length = 12;
inline int PlayerFarmInfo::_internal_train_length_size() const {
  return train_length_.size();
}
inline int PlayerFarmInfo::train_length_size() const {
  return _internal_train_length_size();
}
inline void PlayerFarmInfo::clear_train_length() {
  train_length_.Clear();
}
inline uint32_t PlayerFarmInfo::_internal_train_length(int index) const {
  return train_length_.Get(index);
}
inline uint32_t PlayerFarmInfo::train_length(int index) const {
  // @@protoc_insertion_point(field_get:ei.PlayerFarmInfo.train_length)
  return _internal_train_length(index);
}
inline void PlayerFarmInfo::set_train_length(int index, uint32_t value) {
  train_length_.Set(index, value);
  // @@protoc_insertion_point(field_set:ei.PlayerFarmInfo.train_length)
}
inline void PlayerFarmInfo::_internal_add_train_length(uint32_t value) {
  train_length_.Add(value);
}
inline void PlayerFarmInfo::add_train_length(uint32_t value) {
  _internal_add_train_length(value);
  // @@protoc_insertion_point(field_add:ei.PlayerFarmInfo.train_length)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
PlayerFarmInfo::_internal_train_length() const {
  return train_length_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
PlayerFarmInfo::train_length() const {
  // @@protoc_insertion_point(field_list:ei.PlayerFarmInfo.train_length)
  return _internal_train_length();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
PlayerFarmInfo::_internal_mutable_train_length() {
  return &train_length_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
PlayerFarmInfo::mutable_train_length() {
  // @@protoc_insertion_point(field_mutable_list:ei.PlayerFarmInfo.train_length)
  return _internal_mutable_train_length();
}

// optional uint32 silos_owned = 13;
inline bool PlayerFarmInfo::_internal_has_silos_owned() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PlayerFarmInfo::has_silos_owned() const {
  return _internal_has_silos_owned();
}
inline void PlayerFarmInfo::clear_silos_owned() {
  silos_owned_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t PlayerFarmInfo::_internal_silos_owned() const {
  return silos_owned_;
}
inline uint32_t PlayerFarmInfo::silos_owned() const {
  // @@protoc_insertion_point(field_get:ei.PlayerFarmInfo.silos_owned)
  return _internal_silos_owned();
}
inline void PlayerFarmInfo::_internal_set_silos_owned(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  silos_owned_ = value;
}
inline void PlayerFarmInfo::set_silos_owned(uint32_t value) {
  _internal_set_silos_owned(value);
  // @@protoc_insertion_point(field_set:ei.PlayerFarmInfo.silos_owned)
}

// repeated .ei.Backup.ResearchItem common_research = 14;
inline int PlayerFarmInfo::_internal_common_research_size() const {
  return common_research_.size();
}
inline int PlayerFarmInfo::common_research_size() const {
  return _internal_common_research_size();
}
inline void PlayerFarmInfo::clear_common_research() {
  common_research_.Clear();
}
inline ::ei::Backup_ResearchItem* PlayerFarmInfo::mutable_common_research(int index) {
  // @@protoc_insertion_point(field_mutable:ei.PlayerFarmInfo.common_research)
  return common_research_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_ResearchItem >*
PlayerFarmInfo::mutable_common_research() {
  // @@protoc_insertion_point(field_mutable_list:ei.PlayerFarmInfo.common_research)
  return &common_research_;
}
inline const ::ei::Backup_ResearchItem& PlayerFarmInfo::_internal_common_research(int index) const {
  return common_research_.Get(index);
}
inline const ::ei::Backup_ResearchItem& PlayerFarmInfo::common_research(int index) const {
  // @@protoc_insertion_point(field_get:ei.PlayerFarmInfo.common_research)
  return _internal_common_research(index);
}
inline ::ei::Backup_ResearchItem* PlayerFarmInfo::_internal_add_common_research() {
  return common_research_.Add();
}
inline ::ei::Backup_ResearchItem* PlayerFarmInfo::add_common_research() {
  ::ei::Backup_ResearchItem* _add = _internal_add_common_research();
  // @@protoc_insertion_point(field_add:ei.PlayerFarmInfo.common_research)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_ResearchItem >&
PlayerFarmInfo::common_research() const {
  // @@protoc_insertion_point(field_list:ei.PlayerFarmInfo.common_research)
  return common_research_;
}

// repeated .ei.Backup.ActiveBoost active_boosts = 15;
inline int PlayerFarmInfo::_internal_active_boosts_size() const {
  return active_boosts_.size();
}
inline int PlayerFarmInfo::active_boosts_size() const {
  return _internal_active_boosts_size();
}
inline void PlayerFarmInfo::clear_active_boosts() {
  active_boosts_.Clear();
}
inline ::ei::Backup_ActiveBoost* PlayerFarmInfo::mutable_active_boosts(int index) {
  // @@protoc_insertion_point(field_mutable:ei.PlayerFarmInfo.active_boosts)
  return active_boosts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_ActiveBoost >*
PlayerFarmInfo::mutable_active_boosts() {
  // @@protoc_insertion_point(field_mutable_list:ei.PlayerFarmInfo.active_boosts)
  return &active_boosts_;
}
inline const ::ei::Backup_ActiveBoost& PlayerFarmInfo::_internal_active_boosts(int index) const {
  return active_boosts_.Get(index);
}
inline const ::ei::Backup_ActiveBoost& PlayerFarmInfo::active_boosts(int index) const {
  // @@protoc_insertion_point(field_get:ei.PlayerFarmInfo.active_boosts)
  return _internal_active_boosts(index);
}
inline ::ei::Backup_ActiveBoost* PlayerFarmInfo::_internal_add_active_boosts() {
  return active_boosts_.Add();
}
inline ::ei::Backup_ActiveBoost* PlayerFarmInfo::add_active_boosts() {
  ::ei::Backup_ActiveBoost* _add = _internal_add_active_boosts();
  // @@protoc_insertion_point(field_add:ei.PlayerFarmInfo.active_boosts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Backup_ActiveBoost >&
PlayerFarmInfo::active_boosts() const {
  // @@protoc_insertion_point(field_list:ei.PlayerFarmInfo.active_boosts)
  return active_boosts_;
}

// optional uint32 boost_tokens_on_hand = 16;
inline bool PlayerFarmInfo::_internal_has_boost_tokens_on_hand() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool PlayerFarmInfo::has_boost_tokens_on_hand() const {
  return _internal_has_boost_tokens_on_hand();
}
inline void PlayerFarmInfo::clear_boost_tokens_on_hand() {
  boost_tokens_on_hand_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline uint32_t PlayerFarmInfo::_internal_boost_tokens_on_hand() const {
  return boost_tokens_on_hand_;
}
inline uint32_t PlayerFarmInfo::boost_tokens_on_hand() const {
  // @@protoc_insertion_point(field_get:ei.PlayerFarmInfo.boost_tokens_on_hand)
  return _internal_boost_tokens_on_hand();
}
inline void PlayerFarmInfo::_internal_set_boost_tokens_on_hand(uint32_t value) {
  _has_bits_[0] |= 0x00000080u;
  boost_tokens_on_hand_ = value;
}
inline void PlayerFarmInfo::set_boost_tokens_on_hand(uint32_t value) {
  _internal_set_boost_tokens_on_hand(value);
  // @@protoc_insertion_point(field_set:ei.PlayerFarmInfo.boost_tokens_on_hand)
}

// repeated .ei.CompleteArtifact equipped_artifacts = 17;
inline int PlayerFarmInfo::_internal_equipped_artifacts_size() const {
  return equipped_artifacts_.size();
}
inline int PlayerFarmInfo::equipped_artifacts_size() const {
  return _internal_equipped_artifacts_size();
}
inline void PlayerFarmInfo::clear_equipped_artifacts() {
  equipped_artifacts_.Clear();
}
inline ::ei::CompleteArtifact* PlayerFarmInfo::mutable_equipped_artifacts(int index) {
  // @@protoc_insertion_point(field_mutable:ei.PlayerFarmInfo.equipped_artifacts)
  return equipped_artifacts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::CompleteArtifact >*
PlayerFarmInfo::mutable_equipped_artifacts() {
  // @@protoc_insertion_point(field_mutable_list:ei.PlayerFarmInfo.equipped_artifacts)
  return &equipped_artifacts_;
}
inline const ::ei::CompleteArtifact& PlayerFarmInfo::_internal_equipped_artifacts(int index) const {
  return equipped_artifacts_.Get(index);
}
inline const ::ei::CompleteArtifact& PlayerFarmInfo::equipped_artifacts(int index) const {
  // @@protoc_insertion_point(field_get:ei.PlayerFarmInfo.equipped_artifacts)
  return _internal_equipped_artifacts(index);
}
inline ::ei::CompleteArtifact* PlayerFarmInfo::_internal_add_equipped_artifacts() {
  return equipped_artifacts_.Add();
}
inline ::ei::CompleteArtifact* PlayerFarmInfo::add_equipped_artifacts() {
  ::ei::CompleteArtifact* _add = _internal_add_equipped_artifacts();
  // @@protoc_insertion_point(field_add:ei.PlayerFarmInfo.equipped_artifacts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::CompleteArtifact >&
PlayerFarmInfo::equipped_artifacts() const {
  // @@protoc_insertion_point(field_list:ei.PlayerFarmInfo.equipped_artifacts)
  return equipped_artifacts_;
}

// optional uint64 artifact_inventory_score = 18;
inline bool PlayerFarmInfo::_internal_has_artifact_inventory_score() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool PlayerFarmInfo::has_artifact_inventory_score() const {
  return _internal_has_artifact_inventory_score();
}
inline void PlayerFarmInfo::clear_artifact_inventory_score() {
  artifact_inventory_score_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000100u;
}
inline uint64_t PlayerFarmInfo::_internal_artifact_inventory_score() const {
  return artifact_inventory_score_;
}
inline uint64_t PlayerFarmInfo::artifact_inventory_score() const {
  // @@protoc_insertion_point(field_get:ei.PlayerFarmInfo.artifact_inventory_score)
  return _internal_artifact_inventory_score();
}
inline void PlayerFarmInfo::_internal_set_artifact_inventory_score(uint64_t value) {
  _has_bits_[0] |= 0x00000100u;
  artifact_inventory_score_ = value;
}
inline void PlayerFarmInfo::set_artifact_inventory_score(uint64_t value) {
  _internal_set_artifact_inventory_score(value);
  // @@protoc_insertion_point(field_set:ei.PlayerFarmInfo.artifact_inventory_score)
}

// optional .ei.ShellDB.FarmConfiguration farm_appearance = 19;
inline bool PlayerFarmInfo::_internal_has_farm_appearance() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || farm_appearance_ != nullptr);
  return value;
}
inline bool PlayerFarmInfo::has_farm_appearance() const {
  return _internal_has_farm_appearance();
}
inline void PlayerFarmInfo::clear_farm_appearance() {
  if (farm_appearance_ != nullptr) farm_appearance_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ei::ShellDB_FarmConfiguration& PlayerFarmInfo::_internal_farm_appearance() const {
  const ::ei::ShellDB_FarmConfiguration* p = farm_appearance_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::ShellDB_FarmConfiguration&>(
      ::ei::_ShellDB_FarmConfiguration_default_instance_);
}
inline const ::ei::ShellDB_FarmConfiguration& PlayerFarmInfo::farm_appearance() const {
  // @@protoc_insertion_point(field_get:ei.PlayerFarmInfo.farm_appearance)
  return _internal_farm_appearance();
}
inline void PlayerFarmInfo::unsafe_arena_set_allocated_farm_appearance(
    ::ei::ShellDB_FarmConfiguration* farm_appearance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(farm_appearance_);
  }
  farm_appearance_ = farm_appearance;
  if (farm_appearance) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.PlayerFarmInfo.farm_appearance)
}
inline ::ei::ShellDB_FarmConfiguration* PlayerFarmInfo::release_farm_appearance() {
  _has_bits_[0] &= ~0x00000001u;
  ::ei::ShellDB_FarmConfiguration* temp = farm_appearance_;
  farm_appearance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::ShellDB_FarmConfiguration* PlayerFarmInfo::unsafe_arena_release_farm_appearance() {
  // @@protoc_insertion_point(field_release:ei.PlayerFarmInfo.farm_appearance)
  _has_bits_[0] &= ~0x00000001u;
  ::ei::ShellDB_FarmConfiguration* temp = farm_appearance_;
  farm_appearance_ = nullptr;
  return temp;
}
inline ::ei::ShellDB_FarmConfiguration* PlayerFarmInfo::_internal_mutable_farm_appearance() {
  _has_bits_[0] |= 0x00000001u;
  if (farm_appearance_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::ShellDB_FarmConfiguration>(GetArenaForAllocation());
    farm_appearance_ = p;
  }
  return farm_appearance_;
}
inline ::ei::ShellDB_FarmConfiguration* PlayerFarmInfo::mutable_farm_appearance() {
  ::ei::ShellDB_FarmConfiguration* _msg = _internal_mutable_farm_appearance();
  // @@protoc_insertion_point(field_mutable:ei.PlayerFarmInfo.farm_appearance)
  return _msg;
}
inline void PlayerFarmInfo::set_allocated_farm_appearance(::ei::ShellDB_FarmConfiguration* farm_appearance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete farm_appearance_;
  }
  if (farm_appearance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::ShellDB_FarmConfiguration>::GetOwningArena(farm_appearance);
    if (message_arena != submessage_arena) {
      farm_appearance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, farm_appearance, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  farm_appearance_ = farm_appearance;
  // @@protoc_insertion_point(field_set_allocated:ei.PlayerFarmInfo.farm_appearance)
}

// -------------------------------------------------------------------

// ContractCoopStatusResponse_ContributionInfo

// optional string user_id = 1;
inline bool ContractCoopStatusResponse_ContributionInfo::_internal_has_user_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse_ContributionInfo::has_user_id() const {
  return _internal_has_user_id();
}
inline void ContractCoopStatusResponse_ContributionInfo::clear_user_id() {
  user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContractCoopStatusResponse_ContributionInfo::user_id() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.ContributionInfo.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractCoopStatusResponse_ContributionInfo::set_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.ContributionInfo.user_id)
}
inline std::string* ContractCoopStatusResponse_ContributionInfo::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:ei.ContractCoopStatusResponse.ContributionInfo.user_id)
  return _s;
}
inline const std::string& ContractCoopStatusResponse_ContributionInfo::_internal_user_id() const {
  return user_id_.Get();
}
inline void ContractCoopStatusResponse_ContributionInfo::_internal_set_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusResponse_ContributionInfo::_internal_mutable_user_id() {
  _has_bits_[0] |= 0x00000001u;
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusResponse_ContributionInfo::release_user_id() {
  // @@protoc_insertion_point(field_release:ei.ContractCoopStatusResponse.ContributionInfo.user_id)
  if (!_internal_has_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractCoopStatusResponse_ContributionInfo::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ContractCoopStatusResponse.ContributionInfo.user_id)
}

// optional string user_name = 2;
inline bool ContractCoopStatusResponse_ContributionInfo::_internal_has_user_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse_ContributionInfo::has_user_name() const {
  return _internal_has_user_name();
}
inline void ContractCoopStatusResponse_ContributionInfo::clear_user_name() {
  user_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ContractCoopStatusResponse_ContributionInfo::user_name() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.ContributionInfo.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractCoopStatusResponse_ContributionInfo::set_user_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 user_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.ContributionInfo.user_name)
}
inline std::string* ContractCoopStatusResponse_ContributionInfo::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:ei.ContractCoopStatusResponse.ContributionInfo.user_name)
  return _s;
}
inline const std::string& ContractCoopStatusResponse_ContributionInfo::_internal_user_name() const {
  return user_name_.Get();
}
inline void ContractCoopStatusResponse_ContributionInfo::_internal_set_user_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  user_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusResponse_ContributionInfo::_internal_mutable_user_name() {
  _has_bits_[0] |= 0x00000002u;
  return user_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusResponse_ContributionInfo::release_user_name() {
  // @@protoc_insertion_point(field_release:ei.ContractCoopStatusResponse.ContributionInfo.user_name)
  if (!_internal_has_user_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = user_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractCoopStatusResponse_ContributionInfo::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  user_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ContractCoopStatusResponse.ContributionInfo.user_name)
}

// optional string contract_identifier = 19;
inline bool ContractCoopStatusResponse_ContributionInfo::_internal_has_contract_identifier() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse_ContributionInfo::has_contract_identifier() const {
  return _internal_has_contract_identifier();
}
inline void ContractCoopStatusResponse_ContributionInfo::clear_contract_identifier() {
  contract_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ContractCoopStatusResponse_ContributionInfo::contract_identifier() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.ContributionInfo.contract_identifier)
  return _internal_contract_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractCoopStatusResponse_ContributionInfo::set_contract_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 contract_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.ContributionInfo.contract_identifier)
}
inline std::string* ContractCoopStatusResponse_ContributionInfo::mutable_contract_identifier() {
  std::string* _s = _internal_mutable_contract_identifier();
  // @@protoc_insertion_point(field_mutable:ei.ContractCoopStatusResponse.ContributionInfo.contract_identifier)
  return _s;
}
inline const std::string& ContractCoopStatusResponse_ContributionInfo::_internal_contract_identifier() const {
  return contract_identifier_.Get();
}
inline void ContractCoopStatusResponse_ContributionInfo::_internal_set_contract_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  contract_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusResponse_ContributionInfo::_internal_mutable_contract_identifier() {
  _has_bits_[0] |= 0x00000008u;
  return contract_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusResponse_ContributionInfo::release_contract_identifier() {
  // @@protoc_insertion_point(field_release:ei.ContractCoopStatusResponse.ContributionInfo.contract_identifier)
  if (!_internal_has_contract_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = contract_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractCoopStatusResponse_ContributionInfo::set_allocated_contract_identifier(std::string* contract_identifier) {
  if (contract_identifier != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  contract_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contract_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ContractCoopStatusResponse.ContributionInfo.contract_identifier)
}

// optional double contribution_amount = 3;
inline bool ContractCoopStatusResponse_ContributionInfo::_internal_has_contribution_amount() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse_ContributionInfo::has_contribution_amount() const {
  return _internal_has_contribution_amount();
}
inline void ContractCoopStatusResponse_ContributionInfo::clear_contribution_amount() {
  contribution_amount_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double ContractCoopStatusResponse_ContributionInfo::_internal_contribution_amount() const {
  return contribution_amount_;
}
inline double ContractCoopStatusResponse_ContributionInfo::contribution_amount() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.ContributionInfo.contribution_amount)
  return _internal_contribution_amount();
}
inline void ContractCoopStatusResponse_ContributionInfo::_internal_set_contribution_amount(double value) {
  _has_bits_[0] |= 0x00000040u;
  contribution_amount_ = value;
}
inline void ContractCoopStatusResponse_ContributionInfo::set_contribution_amount(double value) {
  _internal_set_contribution_amount(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.ContributionInfo.contribution_amount)
}

// optional double contribution_rate = 6;
inline bool ContractCoopStatusResponse_ContributionInfo::_internal_has_contribution_rate() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse_ContributionInfo::has_contribution_rate() const {
  return _internal_has_contribution_rate();
}
inline void ContractCoopStatusResponse_ContributionInfo::clear_contribution_rate() {
  contribution_rate_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline double ContractCoopStatusResponse_ContributionInfo::_internal_contribution_rate() const {
  return contribution_rate_;
}
inline double ContractCoopStatusResponse_ContributionInfo::contribution_rate() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.ContributionInfo.contribution_rate)
  return _internal_contribution_rate();
}
inline void ContractCoopStatusResponse_ContributionInfo::_internal_set_contribution_rate(double value) {
  _has_bits_[0] |= 0x00000080u;
  contribution_rate_ = value;
}
inline void ContractCoopStatusResponse_ContributionInfo::set_contribution_rate(double value) {
  _internal_set_contribution_rate(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.ContributionInfo.contribution_rate)
}

// optional double soul_power = 11;
inline bool ContractCoopStatusResponse_ContributionInfo::_internal_has_soul_power() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse_ContributionInfo::has_soul_power() const {
  return _internal_has_soul_power();
}
inline void ContractCoopStatusResponse_ContributionInfo::clear_soul_power() {
  soul_power_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline double ContractCoopStatusResponse_ContributionInfo::_internal_soul_power() const {
  return soul_power_;
}
inline double ContractCoopStatusResponse_ContributionInfo::soul_power() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.ContributionInfo.soul_power)
  return _internal_soul_power();
}
inline void ContractCoopStatusResponse_ContributionInfo::_internal_set_soul_power(double value) {
  _has_bits_[0] |= 0x00000400u;
  soul_power_ = value;
}
inline void ContractCoopStatusResponse_ContributionInfo::set_soul_power(double value) {
  _internal_set_soul_power(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.ContributionInfo.soul_power)
}

// optional .ei.FarmProductionParams production_params = 15;
inline bool ContractCoopStatusResponse_ContributionInfo::_internal_has_production_params() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || production_params_ != nullptr);
  return value;
}
inline bool ContractCoopStatusResponse_ContributionInfo::has_production_params() const {
  return _internal_has_production_params();
}
inline void ContractCoopStatusResponse_ContributionInfo::clear_production_params() {
  if (production_params_ != nullptr) production_params_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::ei::FarmProductionParams& ContractCoopStatusResponse_ContributionInfo::_internal_production_params() const {
  const ::ei::FarmProductionParams* p = production_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::FarmProductionParams&>(
      ::ei::_FarmProductionParams_default_instance_);
}
inline const ::ei::FarmProductionParams& ContractCoopStatusResponse_ContributionInfo::production_params() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.ContributionInfo.production_params)
  return _internal_production_params();
}
inline void ContractCoopStatusResponse_ContributionInfo::unsafe_arena_set_allocated_production_params(
    ::ei::FarmProductionParams* production_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(production_params_);
  }
  production_params_ = production_params;
  if (production_params) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.ContractCoopStatusResponse.ContributionInfo.production_params)
}
inline ::ei::FarmProductionParams* ContractCoopStatusResponse_ContributionInfo::release_production_params() {
  _has_bits_[0] &= ~0x00000010u;
  ::ei::FarmProductionParams* temp = production_params_;
  production_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::FarmProductionParams* ContractCoopStatusResponse_ContributionInfo::unsafe_arena_release_production_params() {
  // @@protoc_insertion_point(field_release:ei.ContractCoopStatusResponse.ContributionInfo.production_params)
  _has_bits_[0] &= ~0x00000010u;
  ::ei::FarmProductionParams* temp = production_params_;
  production_params_ = nullptr;
  return temp;
}
inline ::ei::FarmProductionParams* ContractCoopStatusResponse_ContributionInfo::_internal_mutable_production_params() {
  _has_bits_[0] |= 0x00000010u;
  if (production_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::FarmProductionParams>(GetArenaForAllocation());
    production_params_ = p;
  }
  return production_params_;
}
inline ::ei::FarmProductionParams* ContractCoopStatusResponse_ContributionInfo::mutable_production_params() {
  ::ei::FarmProductionParams* _msg = _internal_mutable_production_params();
  // @@protoc_insertion_point(field_mutable:ei.ContractCoopStatusResponse.ContributionInfo.production_params)
  return _msg;
}
inline void ContractCoopStatusResponse_ContributionInfo::set_allocated_production_params(::ei::FarmProductionParams* production_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete production_params_;
  }
  if (production_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::FarmProductionParams>::GetOwningArena(production_params);
    if (message_arena != submessage_arena) {
      production_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, production_params, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  production_params_ = production_params;
  // @@protoc_insertion_point(field_set_allocated:ei.ContractCoopStatusResponse.ContributionInfo.production_params)
}

// optional .ei.PlayerFarmInfo farm_info = 18;
inline bool ContractCoopStatusResponse_ContributionInfo::_internal_has_farm_info() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || farm_info_ != nullptr);
  return value;
}
inline bool ContractCoopStatusResponse_ContributionInfo::has_farm_info() const {
  return _internal_has_farm_info();
}
inline void ContractCoopStatusResponse_ContributionInfo::clear_farm_info() {
  if (farm_info_ != nullptr) farm_info_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::ei::PlayerFarmInfo& ContractCoopStatusResponse_ContributionInfo::_internal_farm_info() const {
  const ::ei::PlayerFarmInfo* p = farm_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::PlayerFarmInfo&>(
      ::ei::_PlayerFarmInfo_default_instance_);
}
inline const ::ei::PlayerFarmInfo& ContractCoopStatusResponse_ContributionInfo::farm_info() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.ContributionInfo.farm_info)
  return _internal_farm_info();
}
inline void ContractCoopStatusResponse_ContributionInfo::unsafe_arena_set_allocated_farm_info(
    ::ei::PlayerFarmInfo* farm_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(farm_info_);
  }
  farm_info_ = farm_info;
  if (farm_info) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.ContractCoopStatusResponse.ContributionInfo.farm_info)
}
inline ::ei::PlayerFarmInfo* ContractCoopStatusResponse_ContributionInfo::release_farm_info() {
  _has_bits_[0] &= ~0x00000020u;
  ::ei::PlayerFarmInfo* temp = farm_info_;
  farm_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::PlayerFarmInfo* ContractCoopStatusResponse_ContributionInfo::unsafe_arena_release_farm_info() {
  // @@protoc_insertion_point(field_release:ei.ContractCoopStatusResponse.ContributionInfo.farm_info)
  _has_bits_[0] &= ~0x00000020u;
  ::ei::PlayerFarmInfo* temp = farm_info_;
  farm_info_ = nullptr;
  return temp;
}
inline ::ei::PlayerFarmInfo* ContractCoopStatusResponse_ContributionInfo::_internal_mutable_farm_info() {
  _has_bits_[0] |= 0x00000020u;
  if (farm_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::PlayerFarmInfo>(GetArenaForAllocation());
    farm_info_ = p;
  }
  return farm_info_;
}
inline ::ei::PlayerFarmInfo* ContractCoopStatusResponse_ContributionInfo::mutable_farm_info() {
  ::ei::PlayerFarmInfo* _msg = _internal_mutable_farm_info();
  // @@protoc_insertion_point(field_mutable:ei.ContractCoopStatusResponse.ContributionInfo.farm_info)
  return _msg;
}
inline void ContractCoopStatusResponse_ContributionInfo::set_allocated_farm_info(::ei::PlayerFarmInfo* farm_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete farm_info_;
  }
  if (farm_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::PlayerFarmInfo>::GetOwningArena(farm_info);
    if (message_arena != submessage_arena) {
      farm_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, farm_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  farm_info_ = farm_info;
  // @@protoc_insertion_point(field_set_allocated:ei.ContractCoopStatusResponse.ContributionInfo.farm_info)
}

// optional int32 rank_change = 8;
inline bool ContractCoopStatusResponse_ContributionInfo::_internal_has_rank_change() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse_ContributionInfo::has_rank_change() const {
  return _internal_has_rank_change();
}
inline void ContractCoopStatusResponse_ContributionInfo::clear_rank_change() {
  rank_change_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline int32_t ContractCoopStatusResponse_ContributionInfo::_internal_rank_change() const {
  return rank_change_;
}
inline int32_t ContractCoopStatusResponse_ContributionInfo::rank_change() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.ContributionInfo.rank_change)
  return _internal_rank_change();
}
inline void ContractCoopStatusResponse_ContributionInfo::_internal_set_rank_change(int32_t value) {
  _has_bits_[0] |= 0x00000100u;
  rank_change_ = value;
}
inline void ContractCoopStatusResponse_ContributionInfo::set_rank_change(int32_t value) {
  _internal_set_rank_change(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.ContributionInfo.rank_change)
}

// optional bool active = 4;
inline bool ContractCoopStatusResponse_ContributionInfo::_internal_has_active() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse_ContributionInfo::has_active() const {
  return _internal_has_active();
}
inline void ContractCoopStatusResponse_ContributionInfo::clear_active() {
  active_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool ContractCoopStatusResponse_ContributionInfo::_internal_active() const {
  return active_;
}
inline bool ContractCoopStatusResponse_ContributionInfo::active() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.ContributionInfo.active)
  return _internal_active();
}
inline void ContractCoopStatusResponse_ContributionInfo::_internal_set_active(bool value) {
  _has_bits_[0] |= 0x00000800u;
  active_ = value;
}
inline void ContractCoopStatusResponse_ContributionInfo::set_active(bool value) {
  _internal_set_active(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.ContributionInfo.active)
}

// optional bool leech = 16;
inline bool ContractCoopStatusResponse_ContributionInfo::_internal_has_leech() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse_ContributionInfo::has_leech() const {
  return _internal_has_leech();
}
inline void ContractCoopStatusResponse_ContributionInfo::clear_leech() {
  leech_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool ContractCoopStatusResponse_ContributionInfo::_internal_leech() const {
  return leech_;
}
inline bool ContractCoopStatusResponse_ContributionInfo::leech() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.ContributionInfo.leech)
  return _internal_leech();
}
inline void ContractCoopStatusResponse_ContributionInfo::_internal_set_leech(bool value) {
  _has_bits_[0] |= 0x00001000u;
  leech_ = value;
}
inline void ContractCoopStatusResponse_ContributionInfo::set_leech(bool value) {
  _internal_set_leech(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.ContributionInfo.leech)
}

// optional bool time_cheat_detected = 7;
inline bool ContractCoopStatusResponse_ContributionInfo::_internal_has_time_cheat_detected() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse_ContributionInfo::has_time_cheat_detected() const {
  return _internal_has_time_cheat_detected();
}
inline void ContractCoopStatusResponse_ContributionInfo::clear_time_cheat_detected() {
  time_cheat_detected_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool ContractCoopStatusResponse_ContributionInfo::_internal_time_cheat_detected() const {
  return time_cheat_detected_;
}
inline bool ContractCoopStatusResponse_ContributionInfo::time_cheat_detected() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.ContributionInfo.time_cheat_detected)
  return _internal_time_cheat_detected();
}
inline void ContractCoopStatusResponse_ContributionInfo::_internal_set_time_cheat_detected(bool value) {
  _has_bits_[0] |= 0x00002000u;
  time_cheat_detected_ = value;
}
inline void ContractCoopStatusResponse_ContributionInfo::set_time_cheat_detected(bool value) {
  _internal_set_time_cheat_detected(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.ContributionInfo.time_cheat_detected)
}

// optional .ei.Platform platform = 5;
inline bool ContractCoopStatusResponse_ContributionInfo::_internal_has_platform() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse_ContributionInfo::has_platform() const {
  return _internal_has_platform();
}
inline void ContractCoopStatusResponse_ContributionInfo::clear_platform() {
  platform_ = 1;
  _has_bits_[0] &= ~0x00040000u;
}
inline ::ei::Platform ContractCoopStatusResponse_ContributionInfo::_internal_platform() const {
  return static_cast< ::ei::Platform >(platform_);
}
inline ::ei::Platform ContractCoopStatusResponse_ContributionInfo::platform() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.ContributionInfo.platform)
  return _internal_platform();
}
inline void ContractCoopStatusResponse_ContributionInfo::_internal_set_platform(::ei::Platform value) {
  assert(::ei::Platform_IsValid(value));
  _has_bits_[0] |= 0x00040000u;
  platform_ = value;
}
inline void ContractCoopStatusResponse_ContributionInfo::set_platform(::ei::Platform value) {
  _internal_set_platform(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.ContributionInfo.platform)
}

// optional string push_id = 9;
inline bool ContractCoopStatusResponse_ContributionInfo::_internal_has_push_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse_ContributionInfo::has_push_id() const {
  return _internal_has_push_id();
}
inline void ContractCoopStatusResponse_ContributionInfo::clear_push_id() {
  push_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ContractCoopStatusResponse_ContributionInfo::push_id() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.ContributionInfo.push_id)
  return _internal_push_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractCoopStatusResponse_ContributionInfo::set_push_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 push_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.ContributionInfo.push_id)
}
inline std::string* ContractCoopStatusResponse_ContributionInfo::mutable_push_id() {
  std::string* _s = _internal_mutable_push_id();
  // @@protoc_insertion_point(field_mutable:ei.ContractCoopStatusResponse.ContributionInfo.push_id)
  return _s;
}
inline const std::string& ContractCoopStatusResponse_ContributionInfo::_internal_push_id() const {
  return push_id_.Get();
}
inline void ContractCoopStatusResponse_ContributionInfo::_internal_set_push_id(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  push_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusResponse_ContributionInfo::_internal_mutable_push_id() {
  _has_bits_[0] |= 0x00000004u;
  return push_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusResponse_ContributionInfo::release_push_id() {
  // @@protoc_insertion_point(field_release:ei.ContractCoopStatusResponse.ContributionInfo.push_id)
  if (!_internal_has_push_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = push_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (push_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    push_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractCoopStatusResponse_ContributionInfo::set_allocated_push_id(std::string* push_id) {
  if (push_id != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  push_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), push_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (push_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    push_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ContractCoopStatusResponse.ContributionInfo.push_id)
}

// optional uint32 ban_votes = 10;
inline bool ContractCoopStatusResponse_ContributionInfo::_internal_has_ban_votes() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse_ContributionInfo::has_ban_votes() const {
  return _internal_has_ban_votes();
}
inline void ContractCoopStatusResponse_ContributionInfo::clear_ban_votes() {
  ban_votes_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline uint32_t ContractCoopStatusResponse_ContributionInfo::_internal_ban_votes() const {
  return ban_votes_;
}
inline uint32_t ContractCoopStatusResponse_ContributionInfo::ban_votes() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.ContributionInfo.ban_votes)
  return _internal_ban_votes();
}
inline void ContractCoopStatusResponse_ContributionInfo::_internal_set_ban_votes(uint32_t value) {
  _has_bits_[0] |= 0x00000200u;
  ban_votes_ = value;
}
inline void ContractCoopStatusResponse_ContributionInfo::set_ban_votes(uint32_t value) {
  _internal_set_ban_votes(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.ContributionInfo.ban_votes)
}

// optional bool autojoined = 17;
inline bool ContractCoopStatusResponse_ContributionInfo::_internal_has_autojoined() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse_ContributionInfo::has_autojoined() const {
  return _internal_has_autojoined();
}
inline void ContractCoopStatusResponse_ContributionInfo::clear_autojoined() {
  autojoined_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool ContractCoopStatusResponse_ContributionInfo::_internal_autojoined() const {
  return autojoined_;
}
inline bool ContractCoopStatusResponse_ContributionInfo::autojoined() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.ContributionInfo.autojoined)
  return _internal_autojoined();
}
inline void ContractCoopStatusResponse_ContributionInfo::_internal_set_autojoined(bool value) {
  _has_bits_[0] |= 0x00004000u;
  autojoined_ = value;
}
inline void ContractCoopStatusResponse_ContributionInfo::set_autojoined(bool value) {
  _internal_set_autojoined(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.ContributionInfo.autojoined)
}

// optional uint32 boost_tokens = 12;
inline bool ContractCoopStatusResponse_ContributionInfo::_internal_has_boost_tokens() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse_ContributionInfo::has_boost_tokens() const {
  return _internal_has_boost_tokens();
}
inline void ContractCoopStatusResponse_ContributionInfo::clear_boost_tokens() {
  boost_tokens_ = 0u;
  _has_bits_[0] &= ~0x00008000u;
}
inline uint32_t ContractCoopStatusResponse_ContributionInfo::_internal_boost_tokens() const {
  return boost_tokens_;
}
inline uint32_t ContractCoopStatusResponse_ContributionInfo::boost_tokens() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.ContributionInfo.boost_tokens)
  return _internal_boost_tokens();
}
inline void ContractCoopStatusResponse_ContributionInfo::_internal_set_boost_tokens(uint32_t value) {
  _has_bits_[0] |= 0x00008000u;
  boost_tokens_ = value;
}
inline void ContractCoopStatusResponse_ContributionInfo::set_boost_tokens(uint32_t value) {
  _internal_set_boost_tokens(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.ContributionInfo.boost_tokens)
}

// optional uint32 boost_tokens_spent = 14;
inline bool ContractCoopStatusResponse_ContributionInfo::_internal_has_boost_tokens_spent() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse_ContributionInfo::has_boost_tokens_spent() const {
  return _internal_has_boost_tokens_spent();
}
inline void ContractCoopStatusResponse_ContributionInfo::clear_boost_tokens_spent() {
  boost_tokens_spent_ = 0u;
  _has_bits_[0] &= ~0x00020000u;
}
inline uint32_t ContractCoopStatusResponse_ContributionInfo::_internal_boost_tokens_spent() const {
  return boost_tokens_spent_;
}
inline uint32_t ContractCoopStatusResponse_ContributionInfo::boost_tokens_spent() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.ContributionInfo.boost_tokens_spent)
  return _internal_boost_tokens_spent();
}
inline void ContractCoopStatusResponse_ContributionInfo::_internal_set_boost_tokens_spent(uint32_t value) {
  _has_bits_[0] |= 0x00020000u;
  boost_tokens_spent_ = value;
}
inline void ContractCoopStatusResponse_ContributionInfo::set_boost_tokens_spent(uint32_t value) {
  _internal_set_boost_tokens_spent(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.ContributionInfo.boost_tokens_spent)
}

// repeated .ei.CoopBuffState buff_history = 13;
inline int ContractCoopStatusResponse_ContributionInfo::_internal_buff_history_size() const {
  return buff_history_.size();
}
inline int ContractCoopStatusResponse_ContributionInfo::buff_history_size() const {
  return _internal_buff_history_size();
}
inline void ContractCoopStatusResponse_ContributionInfo::clear_buff_history() {
  buff_history_.Clear();
}
inline ::ei::CoopBuffState* ContractCoopStatusResponse_ContributionInfo::mutable_buff_history(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ContractCoopStatusResponse.ContributionInfo.buff_history)
  return buff_history_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::CoopBuffState >*
ContractCoopStatusResponse_ContributionInfo::mutable_buff_history() {
  // @@protoc_insertion_point(field_mutable_list:ei.ContractCoopStatusResponse.ContributionInfo.buff_history)
  return &buff_history_;
}
inline const ::ei::CoopBuffState& ContractCoopStatusResponse_ContributionInfo::_internal_buff_history(int index) const {
  return buff_history_.Get(index);
}
inline const ::ei::CoopBuffState& ContractCoopStatusResponse_ContributionInfo::buff_history(int index) const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.ContributionInfo.buff_history)
  return _internal_buff_history(index);
}
inline ::ei::CoopBuffState* ContractCoopStatusResponse_ContributionInfo::_internal_add_buff_history() {
  return buff_history_.Add();
}
inline ::ei::CoopBuffState* ContractCoopStatusResponse_ContributionInfo::add_buff_history() {
  ::ei::CoopBuffState* _add = _internal_add_buff_history();
  // @@protoc_insertion_point(field_add:ei.ContractCoopStatusResponse.ContributionInfo.buff_history)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::CoopBuffState >&
ContractCoopStatusResponse_ContributionInfo::buff_history() const {
  // @@protoc_insertion_point(field_list:ei.ContractCoopStatusResponse.ContributionInfo.buff_history)
  return buff_history_;
}

// optional double chicken_run_cooldown = 20;
inline bool ContractCoopStatusResponse_ContributionInfo::_internal_has_chicken_run_cooldown() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse_ContributionInfo::has_chicken_run_cooldown() const {
  return _internal_has_chicken_run_cooldown();
}
inline void ContractCoopStatusResponse_ContributionInfo::clear_chicken_run_cooldown() {
  chicken_run_cooldown_ = 0;
  _has_bits_[0] &= ~0x00010000u;
}
inline double ContractCoopStatusResponse_ContributionInfo::_internal_chicken_run_cooldown() const {
  return chicken_run_cooldown_;
}
inline double ContractCoopStatusResponse_ContributionInfo::chicken_run_cooldown() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.ContributionInfo.chicken_run_cooldown)
  return _internal_chicken_run_cooldown();
}
inline void ContractCoopStatusResponse_ContributionInfo::_internal_set_chicken_run_cooldown(double value) {
  _has_bits_[0] |= 0x00010000u;
  chicken_run_cooldown_ = value;
}
inline void ContractCoopStatusResponse_ContributionInfo::set_chicken_run_cooldown(double value) {
  _internal_set_chicken_run_cooldown(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.ContributionInfo.chicken_run_cooldown)
}

// -------------------------------------------------------------------

// ContractCoopStatusResponse_CoopGift

// optional string user_id = 1;
inline bool ContractCoopStatusResponse_CoopGift::_internal_has_user_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse_CoopGift::has_user_id() const {
  return _internal_has_user_id();
}
inline void ContractCoopStatusResponse_CoopGift::clear_user_id() {
  user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContractCoopStatusResponse_CoopGift::user_id() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.CoopGift.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractCoopStatusResponse_CoopGift::set_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.CoopGift.user_id)
}
inline std::string* ContractCoopStatusResponse_CoopGift::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:ei.ContractCoopStatusResponse.CoopGift.user_id)
  return _s;
}
inline const std::string& ContractCoopStatusResponse_CoopGift::_internal_user_id() const {
  return user_id_.Get();
}
inline void ContractCoopStatusResponse_CoopGift::_internal_set_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusResponse_CoopGift::_internal_mutable_user_id() {
  _has_bits_[0] |= 0x00000001u;
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusResponse_CoopGift::release_user_id() {
  // @@protoc_insertion_point(field_release:ei.ContractCoopStatusResponse.CoopGift.user_id)
  if (!_internal_has_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractCoopStatusResponse_CoopGift::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ContractCoopStatusResponse.CoopGift.user_id)
}

// optional string user_name = 3;
inline bool ContractCoopStatusResponse_CoopGift::_internal_has_user_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse_CoopGift::has_user_name() const {
  return _internal_has_user_name();
}
inline void ContractCoopStatusResponse_CoopGift::clear_user_name() {
  user_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ContractCoopStatusResponse_CoopGift::user_name() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.CoopGift.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractCoopStatusResponse_CoopGift::set_user_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 user_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.CoopGift.user_name)
}
inline std::string* ContractCoopStatusResponse_CoopGift::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:ei.ContractCoopStatusResponse.CoopGift.user_name)
  return _s;
}
inline const std::string& ContractCoopStatusResponse_CoopGift::_internal_user_name() const {
  return user_name_.Get();
}
inline void ContractCoopStatusResponse_CoopGift::_internal_set_user_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  user_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusResponse_CoopGift::_internal_mutable_user_name() {
  _has_bits_[0] |= 0x00000002u;
  return user_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusResponse_CoopGift::release_user_name() {
  // @@protoc_insertion_point(field_release:ei.ContractCoopStatusResponse.CoopGift.user_name)
  if (!_internal_has_user_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = user_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractCoopStatusResponse_CoopGift::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  user_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ContractCoopStatusResponse.CoopGift.user_name)
}

// optional uint32 amount = 2;
inline bool ContractCoopStatusResponse_CoopGift::_internal_has_amount() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse_CoopGift::has_amount() const {
  return _internal_has_amount();
}
inline void ContractCoopStatusResponse_CoopGift::clear_amount() {
  amount_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ContractCoopStatusResponse_CoopGift::_internal_amount() const {
  return amount_;
}
inline uint32_t ContractCoopStatusResponse_CoopGift::amount() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.CoopGift.amount)
  return _internal_amount();
}
inline void ContractCoopStatusResponse_CoopGift::_internal_set_amount(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  amount_ = value;
}
inline void ContractCoopStatusResponse_CoopGift::set_amount(uint32_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.CoopGift.amount)
}

// -------------------------------------------------------------------

// ContractCoopStatusResponse_ChickenRun

// optional string user_id = 1;
inline bool ContractCoopStatusResponse_ChickenRun::_internal_has_user_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse_ChickenRun::has_user_id() const {
  return _internal_has_user_id();
}
inline void ContractCoopStatusResponse_ChickenRun::clear_user_id() {
  user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContractCoopStatusResponse_ChickenRun::user_id() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.ChickenRun.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractCoopStatusResponse_ChickenRun::set_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.ChickenRun.user_id)
}
inline std::string* ContractCoopStatusResponse_ChickenRun::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:ei.ContractCoopStatusResponse.ChickenRun.user_id)
  return _s;
}
inline const std::string& ContractCoopStatusResponse_ChickenRun::_internal_user_id() const {
  return user_id_.Get();
}
inline void ContractCoopStatusResponse_ChickenRun::_internal_set_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusResponse_ChickenRun::_internal_mutable_user_id() {
  _has_bits_[0] |= 0x00000001u;
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusResponse_ChickenRun::release_user_id() {
  // @@protoc_insertion_point(field_release:ei.ContractCoopStatusResponse.ChickenRun.user_id)
  if (!_internal_has_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractCoopStatusResponse_ChickenRun::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ContractCoopStatusResponse.ChickenRun.user_id)
}

// optional string user_name = 3;
inline bool ContractCoopStatusResponse_ChickenRun::_internal_has_user_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse_ChickenRun::has_user_name() const {
  return _internal_has_user_name();
}
inline void ContractCoopStatusResponse_ChickenRun::clear_user_name() {
  user_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ContractCoopStatusResponse_ChickenRun::user_name() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.ChickenRun.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractCoopStatusResponse_ChickenRun::set_user_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 user_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.ChickenRun.user_name)
}
inline std::string* ContractCoopStatusResponse_ChickenRun::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:ei.ContractCoopStatusResponse.ChickenRun.user_name)
  return _s;
}
inline const std::string& ContractCoopStatusResponse_ChickenRun::_internal_user_name() const {
  return user_name_.Get();
}
inline void ContractCoopStatusResponse_ChickenRun::_internal_set_user_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  user_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusResponse_ChickenRun::_internal_mutable_user_name() {
  _has_bits_[0] |= 0x00000002u;
  return user_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusResponse_ChickenRun::release_user_name() {
  // @@protoc_insertion_point(field_release:ei.ContractCoopStatusResponse.ChickenRun.user_name)
  if (!_internal_has_user_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = user_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractCoopStatusResponse_ChickenRun::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  user_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ContractCoopStatusResponse.ChickenRun.user_name)
}

// optional uint64 amount = 2;
inline bool ContractCoopStatusResponse_ChickenRun::_internal_has_amount() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse_ChickenRun::has_amount() const {
  return _internal_has_amount();
}
inline void ContractCoopStatusResponse_ChickenRun::clear_amount() {
  amount_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t ContractCoopStatusResponse_ChickenRun::_internal_amount() const {
  return amount_;
}
inline uint64_t ContractCoopStatusResponse_ChickenRun::amount() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.ChickenRun.amount)
  return _internal_amount();
}
inline void ContractCoopStatusResponse_ChickenRun::_internal_set_amount(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  amount_ = value;
}
inline void ContractCoopStatusResponse_ChickenRun::set_amount(uint64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.ChickenRun.amount)
}

// -------------------------------------------------------------------

// ContractCoopStatusResponse

// optional string contract_identifier = 1;
inline bool ContractCoopStatusResponse::_internal_has_contract_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse::has_contract_identifier() const {
  return _internal_has_contract_identifier();
}
inline void ContractCoopStatusResponse::clear_contract_identifier() {
  contract_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContractCoopStatusResponse::contract_identifier() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.contract_identifier)
  return _internal_contract_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractCoopStatusResponse::set_contract_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 contract_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.contract_identifier)
}
inline std::string* ContractCoopStatusResponse::mutable_contract_identifier() {
  std::string* _s = _internal_mutable_contract_identifier();
  // @@protoc_insertion_point(field_mutable:ei.ContractCoopStatusResponse.contract_identifier)
  return _s;
}
inline const std::string& ContractCoopStatusResponse::_internal_contract_identifier() const {
  return contract_identifier_.Get();
}
inline void ContractCoopStatusResponse::_internal_set_contract_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  contract_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusResponse::_internal_mutable_contract_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return contract_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusResponse::release_contract_identifier() {
  // @@protoc_insertion_point(field_release:ei.ContractCoopStatusResponse.contract_identifier)
  if (!_internal_has_contract_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = contract_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractCoopStatusResponse::set_allocated_contract_identifier(std::string* contract_identifier) {
  if (contract_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  contract_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contract_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ContractCoopStatusResponse.contract_identifier)
}

// optional double total_amount = 2;
inline bool ContractCoopStatusResponse::_internal_has_total_amount() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse::has_total_amount() const {
  return _internal_has_total_amount();
}
inline void ContractCoopStatusResponse::clear_total_amount() {
  total_amount_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double ContractCoopStatusResponse::_internal_total_amount() const {
  return total_amount_;
}
inline double ContractCoopStatusResponse::total_amount() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.total_amount)
  return _internal_total_amount();
}
inline void ContractCoopStatusResponse::_internal_set_total_amount(double value) {
  _has_bits_[0] |= 0x00000008u;
  total_amount_ = value;
}
inline void ContractCoopStatusResponse::set_total_amount(double value) {
  _internal_set_total_amount(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.total_amount)
}

// optional string coop_identifier = 3;
inline bool ContractCoopStatusResponse::_internal_has_coop_identifier() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse::has_coop_identifier() const {
  return _internal_has_coop_identifier();
}
inline void ContractCoopStatusResponse::clear_coop_identifier() {
  coop_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ContractCoopStatusResponse::coop_identifier() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.coop_identifier)
  return _internal_coop_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractCoopStatusResponse::set_coop_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 coop_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.coop_identifier)
}
inline std::string* ContractCoopStatusResponse::mutable_coop_identifier() {
  std::string* _s = _internal_mutable_coop_identifier();
  // @@protoc_insertion_point(field_mutable:ei.ContractCoopStatusResponse.coop_identifier)
  return _s;
}
inline const std::string& ContractCoopStatusResponse::_internal_coop_identifier() const {
  return coop_identifier_.Get();
}
inline void ContractCoopStatusResponse::_internal_set_coop_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  coop_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusResponse::_internal_mutable_coop_identifier() {
  _has_bits_[0] |= 0x00000002u;
  return coop_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusResponse::release_coop_identifier() {
  // @@protoc_insertion_point(field_release:ei.ContractCoopStatusResponse.coop_identifier)
  if (!_internal_has_coop_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = coop_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coop_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coop_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractCoopStatusResponse::set_allocated_coop_identifier(std::string* coop_identifier) {
  if (coop_identifier != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  coop_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), coop_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coop_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coop_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ContractCoopStatusResponse.coop_identifier)
}

// repeated .ei.ContractCoopStatusResponse.ContributionInfo contributors = 4;
inline int ContractCoopStatusResponse::_internal_contributors_size() const {
  return contributors_.size();
}
inline int ContractCoopStatusResponse::contributors_size() const {
  return _internal_contributors_size();
}
inline void ContractCoopStatusResponse::clear_contributors() {
  contributors_.Clear();
}
inline ::ei::ContractCoopStatusResponse_ContributionInfo* ContractCoopStatusResponse::mutable_contributors(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ContractCoopStatusResponse.contributors)
  return contributors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ContractCoopStatusResponse_ContributionInfo >*
ContractCoopStatusResponse::mutable_contributors() {
  // @@protoc_insertion_point(field_mutable_list:ei.ContractCoopStatusResponse.contributors)
  return &contributors_;
}
inline const ::ei::ContractCoopStatusResponse_ContributionInfo& ContractCoopStatusResponse::_internal_contributors(int index) const {
  return contributors_.Get(index);
}
inline const ::ei::ContractCoopStatusResponse_ContributionInfo& ContractCoopStatusResponse::contributors(int index) const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.contributors)
  return _internal_contributors(index);
}
inline ::ei::ContractCoopStatusResponse_ContributionInfo* ContractCoopStatusResponse::_internal_add_contributors() {
  return contributors_.Add();
}
inline ::ei::ContractCoopStatusResponse_ContributionInfo* ContractCoopStatusResponse::add_contributors() {
  ::ei::ContractCoopStatusResponse_ContributionInfo* _add = _internal_add_contributors();
  // @@protoc_insertion_point(field_add:ei.ContractCoopStatusResponse.contributors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ContractCoopStatusResponse_ContributionInfo >&
ContractCoopStatusResponse::contributors() const {
  // @@protoc_insertion_point(field_list:ei.ContractCoopStatusResponse.contributors)
  return contributors_;
}

// optional bool auto_generated = 8;
inline bool ContractCoopStatusResponse::_internal_has_auto_generated() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse::has_auto_generated() const {
  return _internal_has_auto_generated();
}
inline void ContractCoopStatusResponse::clear_auto_generated() {
  auto_generated_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool ContractCoopStatusResponse::_internal_auto_generated() const {
  return auto_generated_;
}
inline bool ContractCoopStatusResponse::auto_generated() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.auto_generated)
  return _internal_auto_generated();
}
inline void ContractCoopStatusResponse::_internal_set_auto_generated(bool value) {
  _has_bits_[0] |= 0x00000080u;
  auto_generated_ = value;
}
inline void ContractCoopStatusResponse::set_auto_generated(bool value) {
  _internal_set_auto_generated(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.auto_generated)
}

// optional bool public = 10;
inline bool ContractCoopStatusResponse::_internal_has_public_() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse::has_public_() const {
  return _internal_has_public_();
}
inline void ContractCoopStatusResponse::clear_public_() {
  public__ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool ContractCoopStatusResponse::_internal_public_() const {
  return public__;
}
inline bool ContractCoopStatusResponse::public_() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.public)
  return _internal_public_();
}
inline void ContractCoopStatusResponse::_internal_set_public_(bool value) {
  _has_bits_[0] |= 0x00000100u;
  public__ = value;
}
inline void ContractCoopStatusResponse::set_public_(bool value) {
  _internal_set_public_(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.public)
}

// optional string creator_id = 9;
inline bool ContractCoopStatusResponse::_internal_has_creator_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse::has_creator_id() const {
  return _internal_has_creator_id();
}
inline void ContractCoopStatusResponse::clear_creator_id() {
  creator_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ContractCoopStatusResponse::creator_id() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.creator_id)
  return _internal_creator_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractCoopStatusResponse::set_creator_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 creator_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.creator_id)
}
inline std::string* ContractCoopStatusResponse::mutable_creator_id() {
  std::string* _s = _internal_mutable_creator_id();
  // @@protoc_insertion_point(field_mutable:ei.ContractCoopStatusResponse.creator_id)
  return _s;
}
inline const std::string& ContractCoopStatusResponse::_internal_creator_id() const {
  return creator_id_.Get();
}
inline void ContractCoopStatusResponse::_internal_set_creator_id(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  creator_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusResponse::_internal_mutable_creator_id() {
  _has_bits_[0] |= 0x00000004u;
  return creator_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusResponse::release_creator_id() {
  // @@protoc_insertion_point(field_release:ei.ContractCoopStatusResponse.creator_id)
  if (!_internal_has_creator_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = creator_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (creator_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    creator_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractCoopStatusResponse::set_allocated_creator_id(std::string* creator_id) {
  if (creator_id != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  creator_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), creator_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (creator_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    creator_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ContractCoopStatusResponse.creator_id)
}

// optional double seconds_remaining = 5;
inline bool ContractCoopStatusResponse::_internal_has_seconds_remaining() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse::has_seconds_remaining() const {
  return _internal_has_seconds_remaining();
}
inline void ContractCoopStatusResponse::clear_seconds_remaining() {
  seconds_remaining_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double ContractCoopStatusResponse::_internal_seconds_remaining() const {
  return seconds_remaining_;
}
inline double ContractCoopStatusResponse::seconds_remaining() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.seconds_remaining)
  return _internal_seconds_remaining();
}
inline void ContractCoopStatusResponse::_internal_set_seconds_remaining(double value) {
  _has_bits_[0] |= 0x00000010u;
  seconds_remaining_ = value;
}
inline void ContractCoopStatusResponse::set_seconds_remaining(double value) {
  _internal_set_seconds_remaining(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.seconds_remaining)
}

// optional bool all_members_reporting = 6;
inline bool ContractCoopStatusResponse::_internal_has_all_members_reporting() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse::has_all_members_reporting() const {
  return _internal_has_all_members_reporting();
}
inline void ContractCoopStatusResponse::clear_all_members_reporting() {
  all_members_reporting_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool ContractCoopStatusResponse::_internal_all_members_reporting() const {
  return all_members_reporting_;
}
inline bool ContractCoopStatusResponse::all_members_reporting() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.all_members_reporting)
  return _internal_all_members_reporting();
}
inline void ContractCoopStatusResponse::_internal_set_all_members_reporting(bool value) {
  _has_bits_[0] |= 0x00000200u;
  all_members_reporting_ = value;
}
inline void ContractCoopStatusResponse::set_all_members_reporting(bool value) {
  _internal_set_all_members_reporting(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.all_members_reporting)
}

// optional double grace_period_seconds_remaining = 7;
inline bool ContractCoopStatusResponse::_internal_has_grace_period_seconds_remaining() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse::has_grace_period_seconds_remaining() const {
  return _internal_has_grace_period_seconds_remaining();
}
inline void ContractCoopStatusResponse::clear_grace_period_seconds_remaining() {
  grace_period_seconds_remaining_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double ContractCoopStatusResponse::_internal_grace_period_seconds_remaining() const {
  return grace_period_seconds_remaining_;
}
inline double ContractCoopStatusResponse::grace_period_seconds_remaining() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.grace_period_seconds_remaining)
  return _internal_grace_period_seconds_remaining();
}
inline void ContractCoopStatusResponse::_internal_set_grace_period_seconds_remaining(double value) {
  _has_bits_[0] |= 0x00000020u;
  grace_period_seconds_remaining_ = value;
}
inline void ContractCoopStatusResponse::set_grace_period_seconds_remaining(double value) {
  _internal_set_grace_period_seconds_remaining(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.grace_period_seconds_remaining)
}

// repeated .ei.ContractCoopStatusResponse.CoopGift gifts = 11;
inline int ContractCoopStatusResponse::_internal_gifts_size() const {
  return gifts_.size();
}
inline int ContractCoopStatusResponse::gifts_size() const {
  return _internal_gifts_size();
}
inline void ContractCoopStatusResponse::clear_gifts() {
  gifts_.Clear();
}
inline ::ei::ContractCoopStatusResponse_CoopGift* ContractCoopStatusResponse::mutable_gifts(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ContractCoopStatusResponse.gifts)
  return gifts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ContractCoopStatusResponse_CoopGift >*
ContractCoopStatusResponse::mutable_gifts() {
  // @@protoc_insertion_point(field_mutable_list:ei.ContractCoopStatusResponse.gifts)
  return &gifts_;
}
inline const ::ei::ContractCoopStatusResponse_CoopGift& ContractCoopStatusResponse::_internal_gifts(int index) const {
  return gifts_.Get(index);
}
inline const ::ei::ContractCoopStatusResponse_CoopGift& ContractCoopStatusResponse::gifts(int index) const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.gifts)
  return _internal_gifts(index);
}
inline ::ei::ContractCoopStatusResponse_CoopGift* ContractCoopStatusResponse::_internal_add_gifts() {
  return gifts_.Add();
}
inline ::ei::ContractCoopStatusResponse_CoopGift* ContractCoopStatusResponse::add_gifts() {
  ::ei::ContractCoopStatusResponse_CoopGift* _add = _internal_add_gifts();
  // @@protoc_insertion_point(field_add:ei.ContractCoopStatusResponse.gifts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ContractCoopStatusResponse_CoopGift >&
ContractCoopStatusResponse::gifts() const {
  // @@protoc_insertion_point(field_list:ei.ContractCoopStatusResponse.gifts)
  return gifts_;
}

// repeated .ei.ContractCoopStatusResponse.ChickenRun chicken_runs = 13;
inline int ContractCoopStatusResponse::_internal_chicken_runs_size() const {
  return chicken_runs_.size();
}
inline int ContractCoopStatusResponse::chicken_runs_size() const {
  return _internal_chicken_runs_size();
}
inline void ContractCoopStatusResponse::clear_chicken_runs() {
  chicken_runs_.Clear();
}
inline ::ei::ContractCoopStatusResponse_ChickenRun* ContractCoopStatusResponse::mutable_chicken_runs(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ContractCoopStatusResponse.chicken_runs)
  return chicken_runs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ContractCoopStatusResponse_ChickenRun >*
ContractCoopStatusResponse::mutable_chicken_runs() {
  // @@protoc_insertion_point(field_mutable_list:ei.ContractCoopStatusResponse.chicken_runs)
  return &chicken_runs_;
}
inline const ::ei::ContractCoopStatusResponse_ChickenRun& ContractCoopStatusResponse::_internal_chicken_runs(int index) const {
  return chicken_runs_.Get(index);
}
inline const ::ei::ContractCoopStatusResponse_ChickenRun& ContractCoopStatusResponse::chicken_runs(int index) const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.chicken_runs)
  return _internal_chicken_runs(index);
}
inline ::ei::ContractCoopStatusResponse_ChickenRun* ContractCoopStatusResponse::_internal_add_chicken_runs() {
  return chicken_runs_.Add();
}
inline ::ei::ContractCoopStatusResponse_ChickenRun* ContractCoopStatusResponse::add_chicken_runs() {
  ::ei::ContractCoopStatusResponse_ChickenRun* _add = _internal_add_chicken_runs();
  // @@protoc_insertion_point(field_add:ei.ContractCoopStatusResponse.chicken_runs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ContractCoopStatusResponse_ChickenRun >&
ContractCoopStatusResponse::chicken_runs() const {
  // @@protoc_insertion_point(field_list:ei.ContractCoopStatusResponse.chicken_runs)
  return chicken_runs_;
}

// optional double local_timestamp = 12;
inline bool ContractCoopStatusResponse::_internal_has_local_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ContractCoopStatusResponse::has_local_timestamp() const {
  return _internal_has_local_timestamp();
}
inline void ContractCoopStatusResponse::clear_local_timestamp() {
  local_timestamp_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double ContractCoopStatusResponse::_internal_local_timestamp() const {
  return local_timestamp_;
}
inline double ContractCoopStatusResponse::local_timestamp() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusResponse.local_timestamp)
  return _internal_local_timestamp();
}
inline void ContractCoopStatusResponse::_internal_set_local_timestamp(double value) {
  _has_bits_[0] |= 0x00000040u;
  local_timestamp_ = value;
}
inline void ContractCoopStatusResponse::set_local_timestamp(double value) {
  _internal_set_local_timestamp(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusResponse.local_timestamp)
}

// -------------------------------------------------------------------

// LocalContract

// optional .ei.Contract contract = 1;
inline bool LocalContract::_internal_has_contract() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || contract_ != nullptr);
  return value;
}
inline bool LocalContract::has_contract() const {
  return _internal_has_contract();
}
inline void LocalContract::clear_contract() {
  if (contract_ != nullptr) contract_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ei::Contract& LocalContract::_internal_contract() const {
  const ::ei::Contract* p = contract_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::Contract&>(
      ::ei::_Contract_default_instance_);
}
inline const ::ei::Contract& LocalContract::contract() const {
  // @@protoc_insertion_point(field_get:ei.LocalContract.contract)
  return _internal_contract();
}
inline void LocalContract::unsafe_arena_set_allocated_contract(
    ::ei::Contract* contract) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(contract_);
  }
  contract_ = contract;
  if (contract) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.LocalContract.contract)
}
inline ::ei::Contract* LocalContract::release_contract() {
  _has_bits_[0] &= ~0x00000004u;
  ::ei::Contract* temp = contract_;
  contract_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::Contract* LocalContract::unsafe_arena_release_contract() {
  // @@protoc_insertion_point(field_release:ei.LocalContract.contract)
  _has_bits_[0] &= ~0x00000004u;
  ::ei::Contract* temp = contract_;
  contract_ = nullptr;
  return temp;
}
inline ::ei::Contract* LocalContract::_internal_mutable_contract() {
  _has_bits_[0] |= 0x00000004u;
  if (contract_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::Contract>(GetArenaForAllocation());
    contract_ = p;
  }
  return contract_;
}
inline ::ei::Contract* LocalContract::mutable_contract() {
  ::ei::Contract* _msg = _internal_mutable_contract();
  // @@protoc_insertion_point(field_mutable:ei.LocalContract.contract)
  return _msg;
}
inline void LocalContract::set_allocated_contract(::ei::Contract* contract) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete contract_;
  }
  if (contract) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::Contract>::GetOwningArena(contract);
    if (message_arena != submessage_arena) {
      contract = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contract, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  contract_ = contract;
  // @@protoc_insertion_point(field_set_allocated:ei.LocalContract.contract)
}

// optional string coop_identifier = 2;
inline bool LocalContract::_internal_has_coop_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LocalContract::has_coop_identifier() const {
  return _internal_has_coop_identifier();
}
inline void LocalContract::clear_coop_identifier() {
  coop_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LocalContract::coop_identifier() const {
  // @@protoc_insertion_point(field_get:ei.LocalContract.coop_identifier)
  return _internal_coop_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocalContract::set_coop_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 coop_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.LocalContract.coop_identifier)
}
inline std::string* LocalContract::mutable_coop_identifier() {
  std::string* _s = _internal_mutable_coop_identifier();
  // @@protoc_insertion_point(field_mutable:ei.LocalContract.coop_identifier)
  return _s;
}
inline const std::string& LocalContract::_internal_coop_identifier() const {
  return coop_identifier_.Get();
}
inline void LocalContract::_internal_set_coop_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  coop_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LocalContract::_internal_mutable_coop_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return coop_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LocalContract::release_coop_identifier() {
  // @@protoc_insertion_point(field_release:ei.LocalContract.coop_identifier)
  if (!_internal_has_coop_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = coop_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coop_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coop_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LocalContract::set_allocated_coop_identifier(std::string* coop_identifier) {
  if (coop_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  coop_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), coop_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coop_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coop_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.LocalContract.coop_identifier)
}

// optional bool accepted = 7;
inline bool LocalContract::_internal_has_accepted() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool LocalContract::has_accepted() const {
  return _internal_has_accepted();
}
inline void LocalContract::clear_accepted() {
  accepted_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool LocalContract::_internal_accepted() const {
  return accepted_;
}
inline bool LocalContract::accepted() const {
  // @@protoc_insertion_point(field_get:ei.LocalContract.accepted)
  return _internal_accepted();
}
inline void LocalContract::_internal_set_accepted(bool value) {
  _has_bits_[0] |= 0x00000040u;
  accepted_ = value;
}
inline void LocalContract::set_accepted(bool value) {
  _internal_set_accepted(value);
  // @@protoc_insertion_point(field_set:ei.LocalContract.accepted)
}

// optional double time_accepted = 3;
inline bool LocalContract::_internal_has_time_accepted() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LocalContract::has_time_accepted() const {
  return _internal_has_time_accepted();
}
inline void LocalContract::clear_time_accepted() {
  time_accepted_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double LocalContract::_internal_time_accepted() const {
  return time_accepted_;
}
inline double LocalContract::time_accepted() const {
  // @@protoc_insertion_point(field_get:ei.LocalContract.time_accepted)
  return _internal_time_accepted();
}
inline void LocalContract::_internal_set_time_accepted(double value) {
  _has_bits_[0] |= 0x00000008u;
  time_accepted_ = value;
}
inline void LocalContract::set_time_accepted(double value) {
  _internal_set_time_accepted(value);
  // @@protoc_insertion_point(field_set:ei.LocalContract.time_accepted)
}

// optional bool cancelled = 4;
inline bool LocalContract::_internal_has_cancelled() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool LocalContract::has_cancelled() const {
  return _internal_has_cancelled();
}
inline void LocalContract::clear_cancelled() {
  cancelled_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool LocalContract::_internal_cancelled() const {
  return cancelled_;
}
inline bool LocalContract::cancelled() const {
  // @@protoc_insertion_point(field_get:ei.LocalContract.cancelled)
  return _internal_cancelled();
}
inline void LocalContract::_internal_set_cancelled(bool value) {
  _has_bits_[0] |= 0x00000080u;
  cancelled_ = value;
}
inline void LocalContract::set_cancelled(bool value) {
  _internal_set_cancelled(value);
  // @@protoc_insertion_point(field_set:ei.LocalContract.cancelled)
}

// optional bool new = 8;
inline bool LocalContract::_internal_has_new_() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool LocalContract::has_new_() const {
  return _internal_has_new_();
}
inline void LocalContract::clear_new_() {
  new__ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool LocalContract::_internal_new_() const {
  return new__;
}
inline bool LocalContract::new_() const {
  // @@protoc_insertion_point(field_get:ei.LocalContract.new)
  return _internal_new_();
}
inline void LocalContract::_internal_set_new_(bool value) {
  _has_bits_[0] |= 0x00000100u;
  new__ = value;
}
inline void LocalContract::set_new_(bool value) {
  _internal_set_new_(value);
  // @@protoc_insertion_point(field_set:ei.LocalContract.new)
}

// optional double coop_shared_end_time = 5;
inline bool LocalContract::_internal_has_coop_shared_end_time() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LocalContract::has_coop_shared_end_time() const {
  return _internal_has_coop_shared_end_time();
}
inline void LocalContract::clear_coop_shared_end_time() {
  coop_shared_end_time_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double LocalContract::_internal_coop_shared_end_time() const {
  return coop_shared_end_time_;
}
inline double LocalContract::coop_shared_end_time() const {
  // @@protoc_insertion_point(field_get:ei.LocalContract.coop_shared_end_time)
  return _internal_coop_shared_end_time();
}
inline void LocalContract::_internal_set_coop_shared_end_time(double value) {
  _has_bits_[0] |= 0x00000010u;
  coop_shared_end_time_ = value;
}
inline void LocalContract::set_coop_shared_end_time(double value) {
  _internal_set_coop_shared_end_time(value);
  // @@protoc_insertion_point(field_set:ei.LocalContract.coop_shared_end_time)
}

// optional double coop_grace_period_end_time = 9;
inline bool LocalContract::_internal_has_coop_grace_period_end_time() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool LocalContract::has_coop_grace_period_end_time() const {
  return _internal_has_coop_grace_period_end_time();
}
inline void LocalContract::clear_coop_grace_period_end_time() {
  coop_grace_period_end_time_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline double LocalContract::_internal_coop_grace_period_end_time() const {
  return coop_grace_period_end_time_;
}
inline double LocalContract::coop_grace_period_end_time() const {
  // @@protoc_insertion_point(field_get:ei.LocalContract.coop_grace_period_end_time)
  return _internal_coop_grace_period_end_time();
}
inline void LocalContract::_internal_set_coop_grace_period_end_time(double value) {
  _has_bits_[0] |= 0x00000800u;
  coop_grace_period_end_time_ = value;
}
inline void LocalContract::set_coop_grace_period_end_time(double value) {
  _internal_set_coop_grace_period_end_time(value);
  // @@protoc_insertion_point(field_set:ei.LocalContract.coop_grace_period_end_time)
}

// optional bool coop_contribution_finalized = 10;
inline bool LocalContract::_internal_has_coop_contribution_finalized() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool LocalContract::has_coop_contribution_finalized() const {
  return _internal_has_coop_contribution_finalized();
}
inline void LocalContract::clear_coop_contribution_finalized() {
  coop_contribution_finalized_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool LocalContract::_internal_coop_contribution_finalized() const {
  return coop_contribution_finalized_;
}
inline bool LocalContract::coop_contribution_finalized() const {
  // @@protoc_insertion_point(field_get:ei.LocalContract.coop_contribution_finalized)
  return _internal_coop_contribution_finalized();
}
inline void LocalContract::_internal_set_coop_contribution_finalized(bool value) {
  _has_bits_[0] |= 0x00000200u;
  coop_contribution_finalized_ = value;
}
inline void LocalContract::set_coop_contribution_finalized(bool value) {
  _internal_set_coop_contribution_finalized(value);
  // @@protoc_insertion_point(field_set:ei.LocalContract.coop_contribution_finalized)
}

// optional double coop_last_uploaded_contribution = 11;
inline bool LocalContract::_internal_has_coop_last_uploaded_contribution() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool LocalContract::has_coop_last_uploaded_contribution() const {
  return _internal_has_coop_last_uploaded_contribution();
}
inline void LocalContract::clear_coop_last_uploaded_contribution() {
  coop_last_uploaded_contribution_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline double LocalContract::_internal_coop_last_uploaded_contribution() const {
  return coop_last_uploaded_contribution_;
}
inline double LocalContract::coop_last_uploaded_contribution() const {
  // @@protoc_insertion_point(field_get:ei.LocalContract.coop_last_uploaded_contribution)
  return _internal_coop_last_uploaded_contribution();
}
inline void LocalContract::_internal_set_coop_last_uploaded_contribution(double value) {
  _has_bits_[0] |= 0x00001000u;
  coop_last_uploaded_contribution_ = value;
}
inline void LocalContract::set_coop_last_uploaded_contribution(double value) {
  _internal_set_coop_last_uploaded_contribution(value);
  // @@protoc_insertion_point(field_set:ei.LocalContract.coop_last_uploaded_contribution)
}

// optional string coop_user_id = 13;
inline bool LocalContract::_internal_has_coop_user_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LocalContract::has_coop_user_id() const {
  return _internal_has_coop_user_id();
}
inline void LocalContract::clear_coop_user_id() {
  coop_user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LocalContract::coop_user_id() const {
  // @@protoc_insertion_point(field_get:ei.LocalContract.coop_user_id)
  return _internal_coop_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocalContract::set_coop_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 coop_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.LocalContract.coop_user_id)
}
inline std::string* LocalContract::mutable_coop_user_id() {
  std::string* _s = _internal_mutable_coop_user_id();
  // @@protoc_insertion_point(field_mutable:ei.LocalContract.coop_user_id)
  return _s;
}
inline const std::string& LocalContract::_internal_coop_user_id() const {
  return coop_user_id_.Get();
}
inline void LocalContract::_internal_set_coop_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  coop_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LocalContract::_internal_mutable_coop_user_id() {
  _has_bits_[0] |= 0x00000002u;
  return coop_user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LocalContract::release_coop_user_id() {
  // @@protoc_insertion_point(field_release:ei.LocalContract.coop_user_id)
  if (!_internal_has_coop_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = coop_user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coop_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coop_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LocalContract::set_allocated_coop_user_id(std::string* coop_user_id) {
  if (coop_user_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  coop_user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), coop_user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coop_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coop_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.LocalContract.coop_user_id)
}

// optional bool coop_share_farm = 17;
inline bool LocalContract::_internal_has_coop_share_farm() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool LocalContract::has_coop_share_farm() const {
  return _internal_has_coop_share_farm();
}
inline void LocalContract::clear_coop_share_farm() {
  coop_share_farm_ = false;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool LocalContract::_internal_coop_share_farm() const {
  return coop_share_farm_;
}
inline bool LocalContract::coop_share_farm() const {
  // @@protoc_insertion_point(field_get:ei.LocalContract.coop_share_farm)
  return _internal_coop_share_farm();
}
inline void LocalContract::_internal_set_coop_share_farm(bool value) {
  _has_bits_[0] |= 0x00010000u;
  coop_share_farm_ = value;
}
inline void LocalContract::set_coop_share_farm(bool value) {
  _internal_set_coop_share_farm(value);
  // @@protoc_insertion_point(field_set:ei.LocalContract.coop_share_farm)
}

// optional double last_amount_when_reward_given = 6;
inline bool LocalContract::_internal_has_last_amount_when_reward_given() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LocalContract::has_last_amount_when_reward_given() const {
  return _internal_has_last_amount_when_reward_given();
}
inline void LocalContract::clear_last_amount_when_reward_given() {
  last_amount_when_reward_given_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double LocalContract::_internal_last_amount_when_reward_given() const {
  return last_amount_when_reward_given_;
}
inline double LocalContract::last_amount_when_reward_given() const {
  // @@protoc_insertion_point(field_get:ei.LocalContract.last_amount_when_reward_given)
  return _internal_last_amount_when_reward_given();
}
inline void LocalContract::_internal_set_last_amount_when_reward_given(double value) {
  _has_bits_[0] |= 0x00000020u;
  last_amount_when_reward_given_ = value;
}
inline void LocalContract::set_last_amount_when_reward_given(double value) {
  _internal_set_last_amount_when_reward_given(value);
  // @@protoc_insertion_point(field_set:ei.LocalContract.last_amount_when_reward_given)
}

// optional uint32 num_goals_achieved = 14;
inline bool LocalContract::_internal_has_num_goals_achieved() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool LocalContract::has_num_goals_achieved() const {
  return _internal_has_num_goals_achieved();
}
inline void LocalContract::clear_num_goals_achieved() {
  num_goals_achieved_ = 0u;
  _has_bits_[0] &= ~0x00002000u;
}
inline uint32_t LocalContract::_internal_num_goals_achieved() const {
  return num_goals_achieved_;
}
inline uint32_t LocalContract::num_goals_achieved() const {
  // @@protoc_insertion_point(field_get:ei.LocalContract.num_goals_achieved)
  return _internal_num_goals_achieved();
}
inline void LocalContract::_internal_set_num_goals_achieved(uint32_t value) {
  _has_bits_[0] |= 0x00002000u;
  num_goals_achieved_ = value;
}
inline void LocalContract::set_num_goals_achieved(uint32_t value) {
  _internal_set_num_goals_achieved(value);
  // @@protoc_insertion_point(field_set:ei.LocalContract.num_goals_achieved)
}

// optional uint32 boosts_used = 12;
inline bool LocalContract::_internal_has_boosts_used() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool LocalContract::has_boosts_used() const {
  return _internal_has_boosts_used();
}
inline void LocalContract::clear_boosts_used() {
  boosts_used_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline uint32_t LocalContract::_internal_boosts_used() const {
  return boosts_used_;
}
inline uint32_t LocalContract::boosts_used() const {
  // @@protoc_insertion_point(field_get:ei.LocalContract.boosts_used)
  return _internal_boosts_used();
}
inline void LocalContract::_internal_set_boosts_used(uint32_t value) {
  _has_bits_[0] |= 0x00000400u;
  boosts_used_ = value;
}
inline void LocalContract::set_boosts_used(uint32_t value) {
  _internal_set_boosts_used(value);
  // @@protoc_insertion_point(field_set:ei.LocalContract.boosts_used)
}

// optional uint32 league = 15;
inline bool LocalContract::_internal_has_league() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool LocalContract::has_league() const {
  return _internal_has_league();
}
inline void LocalContract::clear_league() {
  league_ = 0u;
  _has_bits_[0] &= ~0x00004000u;
}
inline uint32_t LocalContract::_internal_league() const {
  return league_;
}
inline uint32_t LocalContract::league() const {
  // @@protoc_insertion_point(field_get:ei.LocalContract.league)
  return _internal_league();
}
inline void LocalContract::_internal_set_league(uint32_t value) {
  _has_bits_[0] |= 0x00004000u;
  league_ = value;
}
inline void LocalContract::set_league(uint32_t value) {
  _internal_set_league(value);
  // @@protoc_insertion_point(field_set:ei.LocalContract.league)
}

// optional double last_nag_time = 16;
inline bool LocalContract::_internal_has_last_nag_time() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool LocalContract::has_last_nag_time() const {
  return _internal_has_last_nag_time();
}
inline void LocalContract::clear_last_nag_time() {
  last_nag_time_ = 0;
  _has_bits_[0] &= ~0x00008000u;
}
inline double LocalContract::_internal_last_nag_time() const {
  return last_nag_time_;
}
inline double LocalContract::last_nag_time() const {
  // @@protoc_insertion_point(field_get:ei.LocalContract.last_nag_time)
  return _internal_last_nag_time();
}
inline void LocalContract::_internal_set_last_nag_time(double value) {
  _has_bits_[0] |= 0x00008000u;
  last_nag_time_ = value;
}
inline void LocalContract::set_last_nag_time(double value) {
  _internal_set_last_nag_time(value);
  // @@protoc_insertion_point(field_set:ei.LocalContract.last_nag_time)
}

// -------------------------------------------------------------------

// MyContracts

// repeated string contract_ids_seen = 3;
inline int MyContracts::_internal_contract_ids_seen_size() const {
  return contract_ids_seen_.size();
}
inline int MyContracts::contract_ids_seen_size() const {
  return _internal_contract_ids_seen_size();
}
inline void MyContracts::clear_contract_ids_seen() {
  contract_ids_seen_.Clear();
}
inline std::string* MyContracts::add_contract_ids_seen() {
  std::string* _s = _internal_add_contract_ids_seen();
  // @@protoc_insertion_point(field_add_mutable:ei.MyContracts.contract_ids_seen)
  return _s;
}
inline const std::string& MyContracts::_internal_contract_ids_seen(int index) const {
  return contract_ids_seen_.Get(index);
}
inline const std::string& MyContracts::contract_ids_seen(int index) const {
  // @@protoc_insertion_point(field_get:ei.MyContracts.contract_ids_seen)
  return _internal_contract_ids_seen(index);
}
inline std::string* MyContracts::mutable_contract_ids_seen(int index) {
  // @@protoc_insertion_point(field_mutable:ei.MyContracts.contract_ids_seen)
  return contract_ids_seen_.Mutable(index);
}
inline void MyContracts::set_contract_ids_seen(int index, const std::string& value) {
  contract_ids_seen_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ei.MyContracts.contract_ids_seen)
}
inline void MyContracts::set_contract_ids_seen(int index, std::string&& value) {
  contract_ids_seen_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ei.MyContracts.contract_ids_seen)
}
inline void MyContracts::set_contract_ids_seen(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  contract_ids_seen_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ei.MyContracts.contract_ids_seen)
}
inline void MyContracts::set_contract_ids_seen(int index, const char* value, size_t size) {
  contract_ids_seen_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ei.MyContracts.contract_ids_seen)
}
inline std::string* MyContracts::_internal_add_contract_ids_seen() {
  return contract_ids_seen_.Add();
}
inline void MyContracts::add_contract_ids_seen(const std::string& value) {
  contract_ids_seen_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ei.MyContracts.contract_ids_seen)
}
inline void MyContracts::add_contract_ids_seen(std::string&& value) {
  contract_ids_seen_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ei.MyContracts.contract_ids_seen)
}
inline void MyContracts::add_contract_ids_seen(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  contract_ids_seen_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ei.MyContracts.contract_ids_seen)
}
inline void MyContracts::add_contract_ids_seen(const char* value, size_t size) {
  contract_ids_seen_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ei.MyContracts.contract_ids_seen)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MyContracts::contract_ids_seen() const {
  // @@protoc_insertion_point(field_list:ei.MyContracts.contract_ids_seen)
  return contract_ids_seen_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MyContracts::mutable_contract_ids_seen() {
  // @@protoc_insertion_point(field_mutable_list:ei.MyContracts.contract_ids_seen)
  return &contract_ids_seen_;
}

// repeated .ei.LocalContract contracts = 1;
inline int MyContracts::_internal_contracts_size() const {
  return contracts_.size();
}
inline int MyContracts::contracts_size() const {
  return _internal_contracts_size();
}
inline void MyContracts::clear_contracts() {
  contracts_.Clear();
}
inline ::ei::LocalContract* MyContracts::mutable_contracts(int index) {
  // @@protoc_insertion_point(field_mutable:ei.MyContracts.contracts)
  return contracts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::LocalContract >*
MyContracts::mutable_contracts() {
  // @@protoc_insertion_point(field_mutable_list:ei.MyContracts.contracts)
  return &contracts_;
}
inline const ::ei::LocalContract& MyContracts::_internal_contracts(int index) const {
  return contracts_.Get(index);
}
inline const ::ei::LocalContract& MyContracts::contracts(int index) const {
  // @@protoc_insertion_point(field_get:ei.MyContracts.contracts)
  return _internal_contracts(index);
}
inline ::ei::LocalContract* MyContracts::_internal_add_contracts() {
  return contracts_.Add();
}
inline ::ei::LocalContract* MyContracts::add_contracts() {
  ::ei::LocalContract* _add = _internal_add_contracts();
  // @@protoc_insertion_point(field_add:ei.MyContracts.contracts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::LocalContract >&
MyContracts::contracts() const {
  // @@protoc_insertion_point(field_list:ei.MyContracts.contracts)
  return contracts_;
}

// repeated .ei.LocalContract archive = 2;
inline int MyContracts::_internal_archive_size() const {
  return archive_.size();
}
inline int MyContracts::archive_size() const {
  return _internal_archive_size();
}
inline void MyContracts::clear_archive() {
  archive_.Clear();
}
inline ::ei::LocalContract* MyContracts::mutable_archive(int index) {
  // @@protoc_insertion_point(field_mutable:ei.MyContracts.archive)
  return archive_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::LocalContract >*
MyContracts::mutable_archive() {
  // @@protoc_insertion_point(field_mutable_list:ei.MyContracts.archive)
  return &archive_;
}
inline const ::ei::LocalContract& MyContracts::_internal_archive(int index) const {
  return archive_.Get(index);
}
inline const ::ei::LocalContract& MyContracts::archive(int index) const {
  // @@protoc_insertion_point(field_get:ei.MyContracts.archive)
  return _internal_archive(index);
}
inline ::ei::LocalContract* MyContracts::_internal_add_archive() {
  return archive_.Add();
}
inline ::ei::LocalContract* MyContracts::add_archive() {
  ::ei::LocalContract* _add = _internal_add_archive();
  // @@protoc_insertion_point(field_add:ei.MyContracts.archive)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::LocalContract >&
MyContracts::archive() const {
  // @@protoc_insertion_point(field_list:ei.MyContracts.archive)
  return archive_;
}

// repeated .ei.ContractCoopStatusResponse current_coop_statuses = 4;
inline int MyContracts::_internal_current_coop_statuses_size() const {
  return current_coop_statuses_.size();
}
inline int MyContracts::current_coop_statuses_size() const {
  return _internal_current_coop_statuses_size();
}
inline void MyContracts::clear_current_coop_statuses() {
  current_coop_statuses_.Clear();
}
inline ::ei::ContractCoopStatusResponse* MyContracts::mutable_current_coop_statuses(int index) {
  // @@protoc_insertion_point(field_mutable:ei.MyContracts.current_coop_statuses)
  return current_coop_statuses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ContractCoopStatusResponse >*
MyContracts::mutable_current_coop_statuses() {
  // @@protoc_insertion_point(field_mutable_list:ei.MyContracts.current_coop_statuses)
  return &current_coop_statuses_;
}
inline const ::ei::ContractCoopStatusResponse& MyContracts::_internal_current_coop_statuses(int index) const {
  return current_coop_statuses_.Get(index);
}
inline const ::ei::ContractCoopStatusResponse& MyContracts::current_coop_statuses(int index) const {
  // @@protoc_insertion_point(field_get:ei.MyContracts.current_coop_statuses)
  return _internal_current_coop_statuses(index);
}
inline ::ei::ContractCoopStatusResponse* MyContracts::_internal_add_current_coop_statuses() {
  return current_coop_statuses_.Add();
}
inline ::ei::ContractCoopStatusResponse* MyContracts::add_current_coop_statuses() {
  ::ei::ContractCoopStatusResponse* _add = _internal_add_current_coop_statuses();
  // @@protoc_insertion_point(field_add:ei.MyContracts.current_coop_statuses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ContractCoopStatusResponse >&
MyContracts::current_coop_statuses() const {
  // @@protoc_insertion_point(field_list:ei.MyContracts.current_coop_statuses)
  return current_coop_statuses_;
}

// -------------------------------------------------------------------

// QueryCoopRequest

// optional .ei.BasicRequestInfo rinfo = 5;
inline bool QueryCoopRequest::_internal_has_rinfo() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || rinfo_ != nullptr);
  return value;
}
inline bool QueryCoopRequest::has_rinfo() const {
  return _internal_has_rinfo();
}
inline void QueryCoopRequest::clear_rinfo() {
  if (rinfo_ != nullptr) rinfo_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ei::BasicRequestInfo& QueryCoopRequest::_internal_rinfo() const {
  const ::ei::BasicRequestInfo* p = rinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::BasicRequestInfo&>(
      ::ei::_BasicRequestInfo_default_instance_);
}
inline const ::ei::BasicRequestInfo& QueryCoopRequest::rinfo() const {
  // @@protoc_insertion_point(field_get:ei.QueryCoopRequest.rinfo)
  return _internal_rinfo();
}
inline void QueryCoopRequest::unsafe_arena_set_allocated_rinfo(
    ::ei::BasicRequestInfo* rinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rinfo_);
  }
  rinfo_ = rinfo;
  if (rinfo) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.QueryCoopRequest.rinfo)
}
inline ::ei::BasicRequestInfo* QueryCoopRequest::release_rinfo() {
  _has_bits_[0] &= ~0x00000004u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::BasicRequestInfo* QueryCoopRequest::unsafe_arena_release_rinfo() {
  // @@protoc_insertion_point(field_release:ei.QueryCoopRequest.rinfo)
  _has_bits_[0] &= ~0x00000004u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
  return temp;
}
inline ::ei::BasicRequestInfo* QueryCoopRequest::_internal_mutable_rinfo() {
  _has_bits_[0] |= 0x00000004u;
  if (rinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::BasicRequestInfo>(GetArenaForAllocation());
    rinfo_ = p;
  }
  return rinfo_;
}
inline ::ei::BasicRequestInfo* QueryCoopRequest::mutable_rinfo() {
  ::ei::BasicRequestInfo* _msg = _internal_mutable_rinfo();
  // @@protoc_insertion_point(field_mutable:ei.QueryCoopRequest.rinfo)
  return _msg;
}
inline void QueryCoopRequest::set_allocated_rinfo(::ei::BasicRequestInfo* rinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rinfo_;
  }
  if (rinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::BasicRequestInfo>::GetOwningArena(rinfo);
    if (message_arena != submessage_arena) {
      rinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  rinfo_ = rinfo;
  // @@protoc_insertion_point(field_set_allocated:ei.QueryCoopRequest.rinfo)
}

// optional string contract_identifier = 1;
inline bool QueryCoopRequest::_internal_has_contract_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QueryCoopRequest::has_contract_identifier() const {
  return _internal_has_contract_identifier();
}
inline void QueryCoopRequest::clear_contract_identifier() {
  contract_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QueryCoopRequest::contract_identifier() const {
  // @@protoc_insertion_point(field_get:ei.QueryCoopRequest.contract_identifier)
  return _internal_contract_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryCoopRequest::set_contract_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 contract_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.QueryCoopRequest.contract_identifier)
}
inline std::string* QueryCoopRequest::mutable_contract_identifier() {
  std::string* _s = _internal_mutable_contract_identifier();
  // @@protoc_insertion_point(field_mutable:ei.QueryCoopRequest.contract_identifier)
  return _s;
}
inline const std::string& QueryCoopRequest::_internal_contract_identifier() const {
  return contract_identifier_.Get();
}
inline void QueryCoopRequest::_internal_set_contract_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  contract_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryCoopRequest::_internal_mutable_contract_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return contract_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryCoopRequest::release_contract_identifier() {
  // @@protoc_insertion_point(field_release:ei.QueryCoopRequest.contract_identifier)
  if (!_internal_has_contract_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = contract_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void QueryCoopRequest::set_allocated_contract_identifier(std::string* contract_identifier) {
  if (contract_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  contract_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contract_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.QueryCoopRequest.contract_identifier)
}

// optional string coop_identifier = 2;
inline bool QueryCoopRequest::_internal_has_coop_identifier() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool QueryCoopRequest::has_coop_identifier() const {
  return _internal_has_coop_identifier();
}
inline void QueryCoopRequest::clear_coop_identifier() {
  coop_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& QueryCoopRequest::coop_identifier() const {
  // @@protoc_insertion_point(field_get:ei.QueryCoopRequest.coop_identifier)
  return _internal_coop_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryCoopRequest::set_coop_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 coop_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.QueryCoopRequest.coop_identifier)
}
inline std::string* QueryCoopRequest::mutable_coop_identifier() {
  std::string* _s = _internal_mutable_coop_identifier();
  // @@protoc_insertion_point(field_mutable:ei.QueryCoopRequest.coop_identifier)
  return _s;
}
inline const std::string& QueryCoopRequest::_internal_coop_identifier() const {
  return coop_identifier_.Get();
}
inline void QueryCoopRequest::_internal_set_coop_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  coop_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryCoopRequest::_internal_mutable_coop_identifier() {
  _has_bits_[0] |= 0x00000002u;
  return coop_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryCoopRequest::release_coop_identifier() {
  // @@protoc_insertion_point(field_release:ei.QueryCoopRequest.coop_identifier)
  if (!_internal_has_coop_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = coop_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coop_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coop_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void QueryCoopRequest::set_allocated_coop_identifier(std::string* coop_identifier) {
  if (coop_identifier != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  coop_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), coop_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coop_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coop_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.QueryCoopRequest.coop_identifier)
}

// optional uint32 league = 4;
inline bool QueryCoopRequest::_internal_has_league() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool QueryCoopRequest::has_league() const {
  return _internal_has_league();
}
inline void QueryCoopRequest::clear_league() {
  league_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t QueryCoopRequest::_internal_league() const {
  return league_;
}
inline uint32_t QueryCoopRequest::league() const {
  // @@protoc_insertion_point(field_get:ei.QueryCoopRequest.league)
  return _internal_league();
}
inline void QueryCoopRequest::_internal_set_league(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  league_ = value;
}
inline void QueryCoopRequest::set_league(uint32_t value) {
  _internal_set_league(value);
  // @@protoc_insertion_point(field_set:ei.QueryCoopRequest.league)
}

// optional uint32 client_version = 3;
inline bool QueryCoopRequest::_internal_has_client_version() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool QueryCoopRequest::has_client_version() const {
  return _internal_has_client_version();
}
inline void QueryCoopRequest::clear_client_version() {
  client_version_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t QueryCoopRequest::_internal_client_version() const {
  return client_version_;
}
inline uint32_t QueryCoopRequest::client_version() const {
  // @@protoc_insertion_point(field_get:ei.QueryCoopRequest.client_version)
  return _internal_client_version();
}
inline void QueryCoopRequest::_internal_set_client_version(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  client_version_ = value;
}
inline void QueryCoopRequest::set_client_version(uint32_t value) {
  _internal_set_client_version(value);
  // @@protoc_insertion_point(field_set:ei.QueryCoopRequest.client_version)
}

// -------------------------------------------------------------------

// QueryCoopResponse

// optional bool exists = 1;
inline bool QueryCoopResponse::_internal_has_exists() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QueryCoopResponse::has_exists() const {
  return _internal_has_exists();
}
inline void QueryCoopResponse::clear_exists() {
  exists_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool QueryCoopResponse::_internal_exists() const {
  return exists_;
}
inline bool QueryCoopResponse::exists() const {
  // @@protoc_insertion_point(field_get:ei.QueryCoopResponse.exists)
  return _internal_exists();
}
inline void QueryCoopResponse::_internal_set_exists(bool value) {
  _has_bits_[0] |= 0x00000001u;
  exists_ = value;
}
inline void QueryCoopResponse::set_exists(bool value) {
  _internal_set_exists(value);
  // @@protoc_insertion_point(field_set:ei.QueryCoopResponse.exists)
}

// optional bool full = 2;
inline bool QueryCoopResponse::_internal_has_full() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool QueryCoopResponse::has_full() const {
  return _internal_has_full();
}
inline void QueryCoopResponse::clear_full() {
  full_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool QueryCoopResponse::_internal_full() const {
  return full_;
}
inline bool QueryCoopResponse::full() const {
  // @@protoc_insertion_point(field_get:ei.QueryCoopResponse.full)
  return _internal_full();
}
inline void QueryCoopResponse::_internal_set_full(bool value) {
  _has_bits_[0] |= 0x00000002u;
  full_ = value;
}
inline void QueryCoopResponse::set_full(bool value) {
  _internal_set_full(value);
  // @@protoc_insertion_point(field_set:ei.QueryCoopResponse.full)
}

// optional bool expired = 5;
inline bool QueryCoopResponse::_internal_has_expired() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool QueryCoopResponse::has_expired() const {
  return _internal_has_expired();
}
inline void QueryCoopResponse::clear_expired() {
  expired_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool QueryCoopResponse::_internal_expired() const {
  return expired_;
}
inline bool QueryCoopResponse::expired() const {
  // @@protoc_insertion_point(field_get:ei.QueryCoopResponse.expired)
  return _internal_expired();
}
inline void QueryCoopResponse::_internal_set_expired(bool value) {
  _has_bits_[0] |= 0x00000004u;
  expired_ = value;
}
inline void QueryCoopResponse::set_expired(bool value) {
  _internal_set_expired(value);
  // @@protoc_insertion_point(field_set:ei.QueryCoopResponse.expired)
}

// optional bool different_league = 4;
inline bool QueryCoopResponse::_internal_has_different_league() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool QueryCoopResponse::has_different_league() const {
  return _internal_has_different_league();
}
inline void QueryCoopResponse::clear_different_league() {
  different_league_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool QueryCoopResponse::_internal_different_league() const {
  return different_league_;
}
inline bool QueryCoopResponse::different_league() const {
  // @@protoc_insertion_point(field_get:ei.QueryCoopResponse.different_league)
  return _internal_different_league();
}
inline void QueryCoopResponse::_internal_set_different_league(bool value) {
  _has_bits_[0] |= 0x00000008u;
  different_league_ = value;
}
inline void QueryCoopResponse::set_different_league(bool value) {
  _internal_set_different_league(value);
  // @@protoc_insertion_point(field_set:ei.QueryCoopResponse.different_league)
}

// optional bool banned = 3;
inline bool QueryCoopResponse::_internal_has_banned() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool QueryCoopResponse::has_banned() const {
  return _internal_has_banned();
}
inline void QueryCoopResponse::clear_banned() {
  banned_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool QueryCoopResponse::_internal_banned() const {
  return banned_;
}
inline bool QueryCoopResponse::banned() const {
  // @@protoc_insertion_point(field_get:ei.QueryCoopResponse.banned)
  return _internal_banned();
}
inline void QueryCoopResponse::_internal_set_banned(bool value) {
  _has_bits_[0] |= 0x00000010u;
  banned_ = value;
}
inline void QueryCoopResponse::set_banned(bool value) {
  _internal_set_banned(value);
  // @@protoc_insertion_point(field_set:ei.QueryCoopResponse.banned)
}

// -------------------------------------------------------------------

// CreateCoopRequest

// optional .ei.BasicRequestInfo rinfo = 10;
inline bool CreateCoopRequest::_internal_has_rinfo() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || rinfo_ != nullptr);
  return value;
}
inline bool CreateCoopRequest::has_rinfo() const {
  return _internal_has_rinfo();
}
inline void CreateCoopRequest::clear_rinfo() {
  if (rinfo_ != nullptr) rinfo_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::ei::BasicRequestInfo& CreateCoopRequest::_internal_rinfo() const {
  const ::ei::BasicRequestInfo* p = rinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::BasicRequestInfo&>(
      ::ei::_BasicRequestInfo_default_instance_);
}
inline const ::ei::BasicRequestInfo& CreateCoopRequest::rinfo() const {
  // @@protoc_insertion_point(field_get:ei.CreateCoopRequest.rinfo)
  return _internal_rinfo();
}
inline void CreateCoopRequest::unsafe_arena_set_allocated_rinfo(
    ::ei::BasicRequestInfo* rinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rinfo_);
  }
  rinfo_ = rinfo;
  if (rinfo) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.CreateCoopRequest.rinfo)
}
inline ::ei::BasicRequestInfo* CreateCoopRequest::release_rinfo() {
  _has_bits_[0] &= ~0x00000010u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::BasicRequestInfo* CreateCoopRequest::unsafe_arena_release_rinfo() {
  // @@protoc_insertion_point(field_release:ei.CreateCoopRequest.rinfo)
  _has_bits_[0] &= ~0x00000010u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
  return temp;
}
inline ::ei::BasicRequestInfo* CreateCoopRequest::_internal_mutable_rinfo() {
  _has_bits_[0] |= 0x00000010u;
  if (rinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::BasicRequestInfo>(GetArenaForAllocation());
    rinfo_ = p;
  }
  return rinfo_;
}
inline ::ei::BasicRequestInfo* CreateCoopRequest::mutable_rinfo() {
  ::ei::BasicRequestInfo* _msg = _internal_mutable_rinfo();
  // @@protoc_insertion_point(field_mutable:ei.CreateCoopRequest.rinfo)
  return _msg;
}
inline void CreateCoopRequest::set_allocated_rinfo(::ei::BasicRequestInfo* rinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rinfo_;
  }
  if (rinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::BasicRequestInfo>::GetOwningArena(rinfo);
    if (message_arena != submessage_arena) {
      rinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  rinfo_ = rinfo;
  // @@protoc_insertion_point(field_set_allocated:ei.CreateCoopRequest.rinfo)
}

// optional string contract_identifier = 1;
inline bool CreateCoopRequest::_internal_has_contract_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CreateCoopRequest::has_contract_identifier() const {
  return _internal_has_contract_identifier();
}
inline void CreateCoopRequest::clear_contract_identifier() {
  contract_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CreateCoopRequest::contract_identifier() const {
  // @@protoc_insertion_point(field_get:ei.CreateCoopRequest.contract_identifier)
  return _internal_contract_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateCoopRequest::set_contract_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 contract_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.CreateCoopRequest.contract_identifier)
}
inline std::string* CreateCoopRequest::mutable_contract_identifier() {
  std::string* _s = _internal_mutable_contract_identifier();
  // @@protoc_insertion_point(field_mutable:ei.CreateCoopRequest.contract_identifier)
  return _s;
}
inline const std::string& CreateCoopRequest::_internal_contract_identifier() const {
  return contract_identifier_.Get();
}
inline void CreateCoopRequest::_internal_set_contract_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  contract_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateCoopRequest::_internal_mutable_contract_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return contract_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateCoopRequest::release_contract_identifier() {
  // @@protoc_insertion_point(field_release:ei.CreateCoopRequest.contract_identifier)
  if (!_internal_has_contract_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = contract_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CreateCoopRequest::set_allocated_contract_identifier(std::string* contract_identifier) {
  if (contract_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  contract_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contract_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.CreateCoopRequest.contract_identifier)
}

// optional string coop_identifier = 2;
inline bool CreateCoopRequest::_internal_has_coop_identifier() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CreateCoopRequest::has_coop_identifier() const {
  return _internal_has_coop_identifier();
}
inline void CreateCoopRequest::clear_coop_identifier() {
  coop_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CreateCoopRequest::coop_identifier() const {
  // @@protoc_insertion_point(field_get:ei.CreateCoopRequest.coop_identifier)
  return _internal_coop_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateCoopRequest::set_coop_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 coop_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.CreateCoopRequest.coop_identifier)
}
inline std::string* CreateCoopRequest::mutable_coop_identifier() {
  std::string* _s = _internal_mutable_coop_identifier();
  // @@protoc_insertion_point(field_mutable:ei.CreateCoopRequest.coop_identifier)
  return _s;
}
inline const std::string& CreateCoopRequest::_internal_coop_identifier() const {
  return coop_identifier_.Get();
}
inline void CreateCoopRequest::_internal_set_coop_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  coop_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateCoopRequest::_internal_mutable_coop_identifier() {
  _has_bits_[0] |= 0x00000002u;
  return coop_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateCoopRequest::release_coop_identifier() {
  // @@protoc_insertion_point(field_release:ei.CreateCoopRequest.coop_identifier)
  if (!_internal_has_coop_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = coop_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coop_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coop_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CreateCoopRequest::set_allocated_coop_identifier(std::string* coop_identifier) {
  if (coop_identifier != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  coop_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), coop_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coop_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coop_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.CreateCoopRequest.coop_identifier)
}

// optional double seconds_remaining = 3;
inline bool CreateCoopRequest::_internal_has_seconds_remaining() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CreateCoopRequest::has_seconds_remaining() const {
  return _internal_has_seconds_remaining();
}
inline void CreateCoopRequest::clear_seconds_remaining() {
  seconds_remaining_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double CreateCoopRequest::_internal_seconds_remaining() const {
  return seconds_remaining_;
}
inline double CreateCoopRequest::seconds_remaining() const {
  // @@protoc_insertion_point(field_get:ei.CreateCoopRequest.seconds_remaining)
  return _internal_seconds_remaining();
}
inline void CreateCoopRequest::_internal_set_seconds_remaining(double value) {
  _has_bits_[0] |= 0x00000020u;
  seconds_remaining_ = value;
}
inline void CreateCoopRequest::set_seconds_remaining(double value) {
  _internal_set_seconds_remaining(value);
  // @@protoc_insertion_point(field_set:ei.CreateCoopRequest.seconds_remaining)
}

// optional string user_id = 4;
inline bool CreateCoopRequest::_internal_has_user_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CreateCoopRequest::has_user_id() const {
  return _internal_has_user_id();
}
inline void CreateCoopRequest::clear_user_id() {
  user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CreateCoopRequest::user_id() const {
  // @@protoc_insertion_point(field_get:ei.CreateCoopRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateCoopRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.CreateCoopRequest.user_id)
}
inline std::string* CreateCoopRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:ei.CreateCoopRequest.user_id)
  return _s;
}
inline const std::string& CreateCoopRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void CreateCoopRequest::_internal_set_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateCoopRequest::_internal_mutable_user_id() {
  _has_bits_[0] |= 0x00000004u;
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateCoopRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:ei.CreateCoopRequest.user_id)
  if (!_internal_has_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CreateCoopRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.CreateCoopRequest.user_id)
}

// optional string user_name = 5;
inline bool CreateCoopRequest::_internal_has_user_name() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CreateCoopRequest::has_user_name() const {
  return _internal_has_user_name();
}
inline void CreateCoopRequest::clear_user_name() {
  user_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CreateCoopRequest::user_name() const {
  // @@protoc_insertion_point(field_get:ei.CreateCoopRequest.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateCoopRequest::set_user_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 user_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.CreateCoopRequest.user_name)
}
inline std::string* CreateCoopRequest::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:ei.CreateCoopRequest.user_name)
  return _s;
}
inline const std::string& CreateCoopRequest::_internal_user_name() const {
  return user_name_.Get();
}
inline void CreateCoopRequest::_internal_set_user_name(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  user_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateCoopRequest::_internal_mutable_user_name() {
  _has_bits_[0] |= 0x00000008u;
  return user_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateCoopRequest::release_user_name() {
  // @@protoc_insertion_point(field_release:ei.CreateCoopRequest.user_name)
  if (!_internal_has_user_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = user_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CreateCoopRequest::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  user_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.CreateCoopRequest.user_name)
}

// optional double soul_power = 8;
inline bool CreateCoopRequest::_internal_has_soul_power() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CreateCoopRequest::has_soul_power() const {
  return _internal_has_soul_power();
}
inline void CreateCoopRequest::clear_soul_power() {
  soul_power_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double CreateCoopRequest::_internal_soul_power() const {
  return soul_power_;
}
inline double CreateCoopRequest::soul_power() const {
  // @@protoc_insertion_point(field_get:ei.CreateCoopRequest.soul_power)
  return _internal_soul_power();
}
inline void CreateCoopRequest::_internal_set_soul_power(double value) {
  _has_bits_[0] |= 0x00000040u;
  soul_power_ = value;
}
inline void CreateCoopRequest::set_soul_power(double value) {
  _internal_set_soul_power(value);
  // @@protoc_insertion_point(field_set:ei.CreateCoopRequest.soul_power)
}

// optional double eop = 11;
inline bool CreateCoopRequest::_internal_has_eop() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CreateCoopRequest::has_eop() const {
  return _internal_has_eop();
}
inline void CreateCoopRequest::clear_eop() {
  eop_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline double CreateCoopRequest::_internal_eop() const {
  return eop_;
}
inline double CreateCoopRequest::eop() const {
  // @@protoc_insertion_point(field_get:ei.CreateCoopRequest.eop)
  return _internal_eop();
}
inline void CreateCoopRequest::_internal_set_eop(double value) {
  _has_bits_[0] |= 0x00000200u;
  eop_ = value;
}
inline void CreateCoopRequest::set_eop(double value) {
  _internal_set_eop(value);
  // @@protoc_insertion_point(field_set:ei.CreateCoopRequest.eop)
}

// optional uint32 league = 9;
inline bool CreateCoopRequest::_internal_has_league() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CreateCoopRequest::has_league() const {
  return _internal_has_league();
}
inline void CreateCoopRequest::clear_league() {
  league_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline uint32_t CreateCoopRequest::_internal_league() const {
  return league_;
}
inline uint32_t CreateCoopRequest::league() const {
  // @@protoc_insertion_point(field_get:ei.CreateCoopRequest.league)
  return _internal_league();
}
inline void CreateCoopRequest::_internal_set_league(uint32_t value) {
  _has_bits_[0] |= 0x00000100u;
  league_ = value;
}
inline void CreateCoopRequest::set_league(uint32_t value) {
  _internal_set_league(value);
  // @@protoc_insertion_point(field_set:ei.CreateCoopRequest.league)
}

// optional .ei.Platform platform = 6;
inline bool CreateCoopRequest::_internal_has_platform() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CreateCoopRequest::has_platform() const {
  return _internal_has_platform();
}
inline void CreateCoopRequest::clear_platform() {
  platform_ = 1;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::ei::Platform CreateCoopRequest::_internal_platform() const {
  return static_cast< ::ei::Platform >(platform_);
}
inline ::ei::Platform CreateCoopRequest::platform() const {
  // @@protoc_insertion_point(field_get:ei.CreateCoopRequest.platform)
  return _internal_platform();
}
inline void CreateCoopRequest::_internal_set_platform(::ei::Platform value) {
  assert(::ei::Platform_IsValid(value));
  _has_bits_[0] |= 0x00000400u;
  platform_ = value;
}
inline void CreateCoopRequest::set_platform(::ei::Platform value) {
  _internal_set_platform(value);
  // @@protoc_insertion_point(field_set:ei.CreateCoopRequest.platform)
}

// optional uint32 client_version = 7;
inline bool CreateCoopRequest::_internal_has_client_version() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CreateCoopRequest::has_client_version() const {
  return _internal_has_client_version();
}
inline void CreateCoopRequest::clear_client_version() {
  client_version_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline uint32_t CreateCoopRequest::_internal_client_version() const {
  return client_version_;
}
inline uint32_t CreateCoopRequest::client_version() const {
  // @@protoc_insertion_point(field_get:ei.CreateCoopRequest.client_version)
  return _internal_client_version();
}
inline void CreateCoopRequest::_internal_set_client_version(uint32_t value) {
  _has_bits_[0] |= 0x00000080u;
  client_version_ = value;
}
inline void CreateCoopRequest::set_client_version(uint32_t value) {
  _internal_set_client_version(value);
  // @@protoc_insertion_point(field_set:ei.CreateCoopRequest.client_version)
}

// -------------------------------------------------------------------

// CreateCoopResponse

// optional bool success = 1;
inline bool CreateCoopResponse::_internal_has_success() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CreateCoopResponse::has_success() const {
  return _internal_has_success();
}
inline void CreateCoopResponse::clear_success() {
  success_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool CreateCoopResponse::_internal_success() const {
  return success_;
}
inline bool CreateCoopResponse::success() const {
  // @@protoc_insertion_point(field_get:ei.CreateCoopResponse.success)
  return _internal_success();
}
inline void CreateCoopResponse::_internal_set_success(bool value) {
  _has_bits_[0] |= 0x00000002u;
  success_ = value;
}
inline void CreateCoopResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:ei.CreateCoopResponse.success)
}

// optional string message = 2;
inline bool CreateCoopResponse::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CreateCoopResponse::has_message() const {
  return _internal_has_message();
}
inline void CreateCoopResponse::clear_message() {
  message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CreateCoopResponse::message() const {
  // @@protoc_insertion_point(field_get:ei.CreateCoopResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateCoopResponse::set_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.CreateCoopResponse.message)
}
inline std::string* CreateCoopResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:ei.CreateCoopResponse.message)
  return _s;
}
inline const std::string& CreateCoopResponse::_internal_message() const {
  return message_.Get();
}
inline void CreateCoopResponse::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateCoopResponse::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateCoopResponse::release_message() {
  // @@protoc_insertion_point(field_release:ei.CreateCoopResponse.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CreateCoopResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.CreateCoopResponse.message)
}

// -------------------------------------------------------------------

// JoinCoopRequest

// optional .ei.BasicRequestInfo rinfo = 10;
inline bool JoinCoopRequest::_internal_has_rinfo() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || rinfo_ != nullptr);
  return value;
}
inline bool JoinCoopRequest::has_rinfo() const {
  return _internal_has_rinfo();
}
inline void JoinCoopRequest::clear_rinfo() {
  if (rinfo_ != nullptr) rinfo_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::ei::BasicRequestInfo& JoinCoopRequest::_internal_rinfo() const {
  const ::ei::BasicRequestInfo* p = rinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::BasicRequestInfo&>(
      ::ei::_BasicRequestInfo_default_instance_);
}
inline const ::ei::BasicRequestInfo& JoinCoopRequest::rinfo() const {
  // @@protoc_insertion_point(field_get:ei.JoinCoopRequest.rinfo)
  return _internal_rinfo();
}
inline void JoinCoopRequest::unsafe_arena_set_allocated_rinfo(
    ::ei::BasicRequestInfo* rinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rinfo_);
  }
  rinfo_ = rinfo;
  if (rinfo) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.JoinCoopRequest.rinfo)
}
inline ::ei::BasicRequestInfo* JoinCoopRequest::release_rinfo() {
  _has_bits_[0] &= ~0x00000010u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::BasicRequestInfo* JoinCoopRequest::unsafe_arena_release_rinfo() {
  // @@protoc_insertion_point(field_release:ei.JoinCoopRequest.rinfo)
  _has_bits_[0] &= ~0x00000010u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
  return temp;
}
inline ::ei::BasicRequestInfo* JoinCoopRequest::_internal_mutable_rinfo() {
  _has_bits_[0] |= 0x00000010u;
  if (rinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::BasicRequestInfo>(GetArenaForAllocation());
    rinfo_ = p;
  }
  return rinfo_;
}
inline ::ei::BasicRequestInfo* JoinCoopRequest::mutable_rinfo() {
  ::ei::BasicRequestInfo* _msg = _internal_mutable_rinfo();
  // @@protoc_insertion_point(field_mutable:ei.JoinCoopRequest.rinfo)
  return _msg;
}
inline void JoinCoopRequest::set_allocated_rinfo(::ei::BasicRequestInfo* rinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rinfo_;
  }
  if (rinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::BasicRequestInfo>::GetOwningArena(rinfo);
    if (message_arena != submessage_arena) {
      rinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  rinfo_ = rinfo;
  // @@protoc_insertion_point(field_set_allocated:ei.JoinCoopRequest.rinfo)
}

// optional string contract_identifier = 1;
inline bool JoinCoopRequest::_internal_has_contract_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool JoinCoopRequest::has_contract_identifier() const {
  return _internal_has_contract_identifier();
}
inline void JoinCoopRequest::clear_contract_identifier() {
  contract_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& JoinCoopRequest::contract_identifier() const {
  // @@protoc_insertion_point(field_get:ei.JoinCoopRequest.contract_identifier)
  return _internal_contract_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinCoopRequest::set_contract_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 contract_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.JoinCoopRequest.contract_identifier)
}
inline std::string* JoinCoopRequest::mutable_contract_identifier() {
  std::string* _s = _internal_mutable_contract_identifier();
  // @@protoc_insertion_point(field_mutable:ei.JoinCoopRequest.contract_identifier)
  return _s;
}
inline const std::string& JoinCoopRequest::_internal_contract_identifier() const {
  return contract_identifier_.Get();
}
inline void JoinCoopRequest::_internal_set_contract_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  contract_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* JoinCoopRequest::_internal_mutable_contract_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return contract_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* JoinCoopRequest::release_contract_identifier() {
  // @@protoc_insertion_point(field_release:ei.JoinCoopRequest.contract_identifier)
  if (!_internal_has_contract_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = contract_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void JoinCoopRequest::set_allocated_contract_identifier(std::string* contract_identifier) {
  if (contract_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  contract_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contract_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.JoinCoopRequest.contract_identifier)
}

// optional string coop_identifier = 2;
inline bool JoinCoopRequest::_internal_has_coop_identifier() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool JoinCoopRequest::has_coop_identifier() const {
  return _internal_has_coop_identifier();
}
inline void JoinCoopRequest::clear_coop_identifier() {
  coop_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& JoinCoopRequest::coop_identifier() const {
  // @@protoc_insertion_point(field_get:ei.JoinCoopRequest.coop_identifier)
  return _internal_coop_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinCoopRequest::set_coop_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 coop_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.JoinCoopRequest.coop_identifier)
}
inline std::string* JoinCoopRequest::mutable_coop_identifier() {
  std::string* _s = _internal_mutable_coop_identifier();
  // @@protoc_insertion_point(field_mutable:ei.JoinCoopRequest.coop_identifier)
  return _s;
}
inline const std::string& JoinCoopRequest::_internal_coop_identifier() const {
  return coop_identifier_.Get();
}
inline void JoinCoopRequest::_internal_set_coop_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  coop_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* JoinCoopRequest::_internal_mutable_coop_identifier() {
  _has_bits_[0] |= 0x00000002u;
  return coop_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* JoinCoopRequest::release_coop_identifier() {
  // @@protoc_insertion_point(field_release:ei.JoinCoopRequest.coop_identifier)
  if (!_internal_has_coop_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = coop_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coop_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coop_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void JoinCoopRequest::set_allocated_coop_identifier(std::string* coop_identifier) {
  if (coop_identifier != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  coop_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), coop_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coop_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coop_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.JoinCoopRequest.coop_identifier)
}

// optional string user_id = 3;
inline bool JoinCoopRequest::_internal_has_user_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool JoinCoopRequest::has_user_id() const {
  return _internal_has_user_id();
}
inline void JoinCoopRequest::clear_user_id() {
  user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& JoinCoopRequest::user_id() const {
  // @@protoc_insertion_point(field_get:ei.JoinCoopRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinCoopRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.JoinCoopRequest.user_id)
}
inline std::string* JoinCoopRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:ei.JoinCoopRequest.user_id)
  return _s;
}
inline const std::string& JoinCoopRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void JoinCoopRequest::_internal_set_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* JoinCoopRequest::_internal_mutable_user_id() {
  _has_bits_[0] |= 0x00000004u;
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* JoinCoopRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:ei.JoinCoopRequest.user_id)
  if (!_internal_has_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void JoinCoopRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.JoinCoopRequest.user_id)
}

// optional string user_name = 4;
inline bool JoinCoopRequest::_internal_has_user_name() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool JoinCoopRequest::has_user_name() const {
  return _internal_has_user_name();
}
inline void JoinCoopRequest::clear_user_name() {
  user_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& JoinCoopRequest::user_name() const {
  // @@protoc_insertion_point(field_get:ei.JoinCoopRequest.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinCoopRequest::set_user_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 user_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.JoinCoopRequest.user_name)
}
inline std::string* JoinCoopRequest::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:ei.JoinCoopRequest.user_name)
  return _s;
}
inline const std::string& JoinCoopRequest::_internal_user_name() const {
  return user_name_.Get();
}
inline void JoinCoopRequest::_internal_set_user_name(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  user_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* JoinCoopRequest::_internal_mutable_user_name() {
  _has_bits_[0] |= 0x00000008u;
  return user_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* JoinCoopRequest::release_user_name() {
  // @@protoc_insertion_point(field_release:ei.JoinCoopRequest.user_name)
  if (!_internal_has_user_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = user_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void JoinCoopRequest::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  user_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.JoinCoopRequest.user_name)
}

// optional double soul_power = 8;
inline bool JoinCoopRequest::_internal_has_soul_power() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool JoinCoopRequest::has_soul_power() const {
  return _internal_has_soul_power();
}
inline void JoinCoopRequest::clear_soul_power() {
  soul_power_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double JoinCoopRequest::_internal_soul_power() const {
  return soul_power_;
}
inline double JoinCoopRequest::soul_power() const {
  // @@protoc_insertion_point(field_get:ei.JoinCoopRequest.soul_power)
  return _internal_soul_power();
}
inline void JoinCoopRequest::_internal_set_soul_power(double value) {
  _has_bits_[0] |= 0x00000020u;
  soul_power_ = value;
}
inline void JoinCoopRequest::set_soul_power(double value) {
  _internal_set_soul_power(value);
  // @@protoc_insertion_point(field_set:ei.JoinCoopRequest.soul_power)
}

// optional double eop = 12;
inline bool JoinCoopRequest::_internal_has_eop() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool JoinCoopRequest::has_eop() const {
  return _internal_has_eop();
}
inline void JoinCoopRequest::clear_eop() {
  eop_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline double JoinCoopRequest::_internal_eop() const {
  return eop_;
}
inline double JoinCoopRequest::eop() const {
  // @@protoc_insertion_point(field_get:ei.JoinCoopRequest.eop)
  return _internal_eop();
}
inline void JoinCoopRequest::_internal_set_eop(double value) {
  _has_bits_[0] |= 0x00000200u;
  eop_ = value;
}
inline void JoinCoopRequest::set_eop(double value) {
  _internal_set_eop(value);
  // @@protoc_insertion_point(field_set:ei.JoinCoopRequest.eop)
}

// optional uint32 league = 9;
inline bool JoinCoopRequest::_internal_has_league() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool JoinCoopRequest::has_league() const {
  return _internal_has_league();
}
inline void JoinCoopRequest::clear_league() {
  league_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline uint32_t JoinCoopRequest::_internal_league() const {
  return league_;
}
inline uint32_t JoinCoopRequest::league() const {
  // @@protoc_insertion_point(field_get:ei.JoinCoopRequest.league)
  return _internal_league();
}
inline void JoinCoopRequest::_internal_set_league(uint32_t value) {
  _has_bits_[0] |= 0x00000080u;
  league_ = value;
}
inline void JoinCoopRequest::set_league(uint32_t value) {
  _internal_set_league(value);
  // @@protoc_insertion_point(field_set:ei.JoinCoopRequest.league)
}

// optional .ei.Platform platform = 5;
inline bool JoinCoopRequest::_internal_has_platform() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool JoinCoopRequest::has_platform() const {
  return _internal_has_platform();
}
inline void JoinCoopRequest::clear_platform() {
  platform_ = 1;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::ei::Platform JoinCoopRequest::_internal_platform() const {
  return static_cast< ::ei::Platform >(platform_);
}
inline ::ei::Platform JoinCoopRequest::platform() const {
  // @@protoc_insertion_point(field_get:ei.JoinCoopRequest.platform)
  return _internal_platform();
}
inline void JoinCoopRequest::_internal_set_platform(::ei::Platform value) {
  assert(::ei::Platform_IsValid(value));
  _has_bits_[0] |= 0x00000400u;
  platform_ = value;
}
inline void JoinCoopRequest::set_platform(::ei::Platform value) {
  _internal_set_platform(value);
  // @@protoc_insertion_point(field_set:ei.JoinCoopRequest.platform)
}

// optional double seconds_remaining = 11;
inline bool JoinCoopRequest::_internal_has_seconds_remaining() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool JoinCoopRequest::has_seconds_remaining() const {
  return _internal_has_seconds_remaining();
}
inline void JoinCoopRequest::clear_seconds_remaining() {
  seconds_remaining_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline double JoinCoopRequest::_internal_seconds_remaining() const {
  return seconds_remaining_;
}
inline double JoinCoopRequest::seconds_remaining() const {
  // @@protoc_insertion_point(field_get:ei.JoinCoopRequest.seconds_remaining)
  return _internal_seconds_remaining();
}
inline void JoinCoopRequest::_internal_set_seconds_remaining(double value) {
  _has_bits_[0] |= 0x00000100u;
  seconds_remaining_ = value;
}
inline void JoinCoopRequest::set_seconds_remaining(double value) {
  _internal_set_seconds_remaining(value);
  // @@protoc_insertion_point(field_set:ei.JoinCoopRequest.seconds_remaining)
}

// optional uint32 client_version = 7;
inline bool JoinCoopRequest::_internal_has_client_version() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool JoinCoopRequest::has_client_version() const {
  return _internal_has_client_version();
}
inline void JoinCoopRequest::clear_client_version() {
  client_version_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t JoinCoopRequest::_internal_client_version() const {
  return client_version_;
}
inline uint32_t JoinCoopRequest::client_version() const {
  // @@protoc_insertion_point(field_get:ei.JoinCoopRequest.client_version)
  return _internal_client_version();
}
inline void JoinCoopRequest::_internal_set_client_version(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  client_version_ = value;
}
inline void JoinCoopRequest::set_client_version(uint32_t value) {
  _internal_set_client_version(value);
  // @@protoc_insertion_point(field_set:ei.JoinCoopRequest.client_version)
}

// -------------------------------------------------------------------

// JoinCoopResponse

// optional bool success = 1;
inline bool JoinCoopResponse::_internal_has_success() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool JoinCoopResponse::has_success() const {
  return _internal_has_success();
}
inline void JoinCoopResponse::clear_success() {
  success_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool JoinCoopResponse::_internal_success() const {
  return success_;
}
inline bool JoinCoopResponse::success() const {
  // @@protoc_insertion_point(field_get:ei.JoinCoopResponse.success)
  return _internal_success();
}
inline void JoinCoopResponse::_internal_set_success(bool value) {
  _has_bits_[0] |= 0x00000008u;
  success_ = value;
}
inline void JoinCoopResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:ei.JoinCoopResponse.success)
}

// optional string message = 2;
inline bool JoinCoopResponse::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool JoinCoopResponse::has_message() const {
  return _internal_has_message();
}
inline void JoinCoopResponse::clear_message() {
  message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& JoinCoopResponse::message() const {
  // @@protoc_insertion_point(field_get:ei.JoinCoopResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinCoopResponse::set_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.JoinCoopResponse.message)
}
inline std::string* JoinCoopResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:ei.JoinCoopResponse.message)
  return _s;
}
inline const std::string& JoinCoopResponse::_internal_message() const {
  return message_.Get();
}
inline void JoinCoopResponse::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* JoinCoopResponse::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* JoinCoopResponse::release_message() {
  // @@protoc_insertion_point(field_release:ei.JoinCoopResponse.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void JoinCoopResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.JoinCoopResponse.message)
}

// optional bool banned = 4;
inline bool JoinCoopResponse::_internal_has_banned() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool JoinCoopResponse::has_banned() const {
  return _internal_has_banned();
}
inline void JoinCoopResponse::clear_banned() {
  banned_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool JoinCoopResponse::_internal_banned() const {
  return banned_;
}
inline bool JoinCoopResponse::banned() const {
  // @@protoc_insertion_point(field_get:ei.JoinCoopResponse.banned)
  return _internal_banned();
}
inline void JoinCoopResponse::_internal_set_banned(bool value) {
  _has_bits_[0] |= 0x00000010u;
  banned_ = value;
}
inline void JoinCoopResponse::set_banned(bool value) {
  _internal_set_banned(value);
  // @@protoc_insertion_point(field_set:ei.JoinCoopResponse.banned)
}

// optional string coop_identifier = 5;
inline bool JoinCoopResponse::_internal_has_coop_identifier() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool JoinCoopResponse::has_coop_identifier() const {
  return _internal_has_coop_identifier();
}
inline void JoinCoopResponse::clear_coop_identifier() {
  coop_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& JoinCoopResponse::coop_identifier() const {
  // @@protoc_insertion_point(field_get:ei.JoinCoopResponse.coop_identifier)
  return _internal_coop_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinCoopResponse::set_coop_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 coop_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.JoinCoopResponse.coop_identifier)
}
inline std::string* JoinCoopResponse::mutable_coop_identifier() {
  std::string* _s = _internal_mutable_coop_identifier();
  // @@protoc_insertion_point(field_mutable:ei.JoinCoopResponse.coop_identifier)
  return _s;
}
inline const std::string& JoinCoopResponse::_internal_coop_identifier() const {
  return coop_identifier_.Get();
}
inline void JoinCoopResponse::_internal_set_coop_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  coop_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* JoinCoopResponse::_internal_mutable_coop_identifier() {
  _has_bits_[0] |= 0x00000002u;
  return coop_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* JoinCoopResponse::release_coop_identifier() {
  // @@protoc_insertion_point(field_release:ei.JoinCoopResponse.coop_identifier)
  if (!_internal_has_coop_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = coop_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coop_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coop_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void JoinCoopResponse::set_allocated_coop_identifier(std::string* coop_identifier) {
  if (coop_identifier != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  coop_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), coop_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coop_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coop_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.JoinCoopResponse.coop_identifier)
}

// optional double seconds_remaining = 3;
inline bool JoinCoopResponse::_internal_has_seconds_remaining() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool JoinCoopResponse::has_seconds_remaining() const {
  return _internal_has_seconds_remaining();
}
inline void JoinCoopResponse::clear_seconds_remaining() {
  seconds_remaining_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double JoinCoopResponse::_internal_seconds_remaining() const {
  return seconds_remaining_;
}
inline double JoinCoopResponse::seconds_remaining() const {
  // @@protoc_insertion_point(field_get:ei.JoinCoopResponse.seconds_remaining)
  return _internal_seconds_remaining();
}
inline void JoinCoopResponse::_internal_set_seconds_remaining(double value) {
  _has_bits_[0] |= 0x00000004u;
  seconds_remaining_ = value;
}
inline void JoinCoopResponse::set_seconds_remaining(double value) {
  _internal_set_seconds_remaining(value);
  // @@protoc_insertion_point(field_set:ei.JoinCoopResponse.seconds_remaining)
}

// optional double match_percent = 6;
inline bool JoinCoopResponse::_internal_has_match_percent() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool JoinCoopResponse::has_match_percent() const {
  return _internal_has_match_percent();
}
inline void JoinCoopResponse::clear_match_percent() {
  match_percent_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double JoinCoopResponse::_internal_match_percent() const {
  return match_percent_;
}
inline double JoinCoopResponse::match_percent() const {
  // @@protoc_insertion_point(field_get:ei.JoinCoopResponse.match_percent)
  return _internal_match_percent();
}
inline void JoinCoopResponse::_internal_set_match_percent(double value) {
  _has_bits_[0] |= 0x00000040u;
  match_percent_ = value;
}
inline void JoinCoopResponse::set_match_percent(double value) {
  _internal_set_match_percent(value);
  // @@protoc_insertion_point(field_set:ei.JoinCoopResponse.match_percent)
}

// optional uint32 num_members = 7;
inline bool JoinCoopResponse::_internal_has_num_members() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool JoinCoopResponse::has_num_members() const {
  return _internal_has_num_members();
}
inline void JoinCoopResponse::clear_num_members() {
  num_members_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t JoinCoopResponse::_internal_num_members() const {
  return num_members_;
}
inline uint32_t JoinCoopResponse::num_members() const {
  // @@protoc_insertion_point(field_get:ei.JoinCoopResponse.num_members)
  return _internal_num_members();
}
inline void JoinCoopResponse::_internal_set_num_members(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  num_members_ = value;
}
inline void JoinCoopResponse::set_num_members(uint32_t value) {
  _internal_set_num_members(value);
  // @@protoc_insertion_point(field_set:ei.JoinCoopResponse.num_members)
}

// -------------------------------------------------------------------

// AutoJoinCoopRequest

// optional .ei.BasicRequestInfo rinfo = 9;
inline bool AutoJoinCoopRequest::_internal_has_rinfo() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || rinfo_ != nullptr);
  return value;
}
inline bool AutoJoinCoopRequest::has_rinfo() const {
  return _internal_has_rinfo();
}
inline void AutoJoinCoopRequest::clear_rinfo() {
  if (rinfo_ != nullptr) rinfo_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ei::BasicRequestInfo& AutoJoinCoopRequest::_internal_rinfo() const {
  const ::ei::BasicRequestInfo* p = rinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::BasicRequestInfo&>(
      ::ei::_BasicRequestInfo_default_instance_);
}
inline const ::ei::BasicRequestInfo& AutoJoinCoopRequest::rinfo() const {
  // @@protoc_insertion_point(field_get:ei.AutoJoinCoopRequest.rinfo)
  return _internal_rinfo();
}
inline void AutoJoinCoopRequest::unsafe_arena_set_allocated_rinfo(
    ::ei::BasicRequestInfo* rinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rinfo_);
  }
  rinfo_ = rinfo;
  if (rinfo) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.AutoJoinCoopRequest.rinfo)
}
inline ::ei::BasicRequestInfo* AutoJoinCoopRequest::release_rinfo() {
  _has_bits_[0] &= ~0x00000008u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::BasicRequestInfo* AutoJoinCoopRequest::unsafe_arena_release_rinfo() {
  // @@protoc_insertion_point(field_release:ei.AutoJoinCoopRequest.rinfo)
  _has_bits_[0] &= ~0x00000008u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
  return temp;
}
inline ::ei::BasicRequestInfo* AutoJoinCoopRequest::_internal_mutable_rinfo() {
  _has_bits_[0] |= 0x00000008u;
  if (rinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::BasicRequestInfo>(GetArenaForAllocation());
    rinfo_ = p;
  }
  return rinfo_;
}
inline ::ei::BasicRequestInfo* AutoJoinCoopRequest::mutable_rinfo() {
  ::ei::BasicRequestInfo* _msg = _internal_mutable_rinfo();
  // @@protoc_insertion_point(field_mutable:ei.AutoJoinCoopRequest.rinfo)
  return _msg;
}
inline void AutoJoinCoopRequest::set_allocated_rinfo(::ei::BasicRequestInfo* rinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rinfo_;
  }
  if (rinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::BasicRequestInfo>::GetOwningArena(rinfo);
    if (message_arena != submessage_arena) {
      rinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  rinfo_ = rinfo;
  // @@protoc_insertion_point(field_set_allocated:ei.AutoJoinCoopRequest.rinfo)
}

// optional string contract_identifier = 1;
inline bool AutoJoinCoopRequest::_internal_has_contract_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AutoJoinCoopRequest::has_contract_identifier() const {
  return _internal_has_contract_identifier();
}
inline void AutoJoinCoopRequest::clear_contract_identifier() {
  contract_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AutoJoinCoopRequest::contract_identifier() const {
  // @@protoc_insertion_point(field_get:ei.AutoJoinCoopRequest.contract_identifier)
  return _internal_contract_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutoJoinCoopRequest::set_contract_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 contract_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AutoJoinCoopRequest.contract_identifier)
}
inline std::string* AutoJoinCoopRequest::mutable_contract_identifier() {
  std::string* _s = _internal_mutable_contract_identifier();
  // @@protoc_insertion_point(field_mutable:ei.AutoJoinCoopRequest.contract_identifier)
  return _s;
}
inline const std::string& AutoJoinCoopRequest::_internal_contract_identifier() const {
  return contract_identifier_.Get();
}
inline void AutoJoinCoopRequest::_internal_set_contract_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  contract_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AutoJoinCoopRequest::_internal_mutable_contract_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return contract_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AutoJoinCoopRequest::release_contract_identifier() {
  // @@protoc_insertion_point(field_release:ei.AutoJoinCoopRequest.contract_identifier)
  if (!_internal_has_contract_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = contract_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutoJoinCoopRequest::set_allocated_contract_identifier(std::string* contract_identifier) {
  if (contract_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  contract_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contract_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AutoJoinCoopRequest.contract_identifier)
}

// optional string user_id = 2;
inline bool AutoJoinCoopRequest::_internal_has_user_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AutoJoinCoopRequest::has_user_id() const {
  return _internal_has_user_id();
}
inline void AutoJoinCoopRequest::clear_user_id() {
  user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AutoJoinCoopRequest::user_id() const {
  // @@protoc_insertion_point(field_get:ei.AutoJoinCoopRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutoJoinCoopRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AutoJoinCoopRequest.user_id)
}
inline std::string* AutoJoinCoopRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:ei.AutoJoinCoopRequest.user_id)
  return _s;
}
inline const std::string& AutoJoinCoopRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void AutoJoinCoopRequest::_internal_set_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AutoJoinCoopRequest::_internal_mutable_user_id() {
  _has_bits_[0] |= 0x00000002u;
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AutoJoinCoopRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:ei.AutoJoinCoopRequest.user_id)
  if (!_internal_has_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutoJoinCoopRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AutoJoinCoopRequest.user_id)
}

// optional string user_name = 3;
inline bool AutoJoinCoopRequest::_internal_has_user_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AutoJoinCoopRequest::has_user_name() const {
  return _internal_has_user_name();
}
inline void AutoJoinCoopRequest::clear_user_name() {
  user_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AutoJoinCoopRequest::user_name() const {
  // @@protoc_insertion_point(field_get:ei.AutoJoinCoopRequest.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutoJoinCoopRequest::set_user_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 user_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AutoJoinCoopRequest.user_name)
}
inline std::string* AutoJoinCoopRequest::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:ei.AutoJoinCoopRequest.user_name)
  return _s;
}
inline const std::string& AutoJoinCoopRequest::_internal_user_name() const {
  return user_name_.Get();
}
inline void AutoJoinCoopRequest::_internal_set_user_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  user_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AutoJoinCoopRequest::_internal_mutable_user_name() {
  _has_bits_[0] |= 0x00000004u;
  return user_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AutoJoinCoopRequest::release_user_name() {
  // @@protoc_insertion_point(field_release:ei.AutoJoinCoopRequest.user_name)
  if (!_internal_has_user_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = user_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutoJoinCoopRequest::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  user_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AutoJoinCoopRequest.user_name)
}

// optional double soul_power = 4;
inline bool AutoJoinCoopRequest::_internal_has_soul_power() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AutoJoinCoopRequest::has_soul_power() const {
  return _internal_has_soul_power();
}
inline void AutoJoinCoopRequest::clear_soul_power() {
  soul_power_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double AutoJoinCoopRequest::_internal_soul_power() const {
  return soul_power_;
}
inline double AutoJoinCoopRequest::soul_power() const {
  // @@protoc_insertion_point(field_get:ei.AutoJoinCoopRequest.soul_power)
  return _internal_soul_power();
}
inline void AutoJoinCoopRequest::_internal_set_soul_power(double value) {
  _has_bits_[0] |= 0x00000010u;
  soul_power_ = value;
}
inline void AutoJoinCoopRequest::set_soul_power(double value) {
  _internal_set_soul_power(value);
  // @@protoc_insertion_point(field_set:ei.AutoJoinCoopRequest.soul_power)
}

// optional double eop = 10;
inline bool AutoJoinCoopRequest::_internal_has_eop() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool AutoJoinCoopRequest::has_eop() const {
  return _internal_has_eop();
}
inline void AutoJoinCoopRequest::clear_eop() {
  eop_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline double AutoJoinCoopRequest::_internal_eop() const {
  return eop_;
}
inline double AutoJoinCoopRequest::eop() const {
  // @@protoc_insertion_point(field_get:ei.AutoJoinCoopRequest.eop)
  return _internal_eop();
}
inline void AutoJoinCoopRequest::_internal_set_eop(double value) {
  _has_bits_[0] |= 0x00000100u;
  eop_ = value;
}
inline void AutoJoinCoopRequest::set_eop(double value) {
  _internal_set_eop(value);
  // @@protoc_insertion_point(field_set:ei.AutoJoinCoopRequest.eop)
}

// optional uint32 league = 8;
inline bool AutoJoinCoopRequest::_internal_has_league() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool AutoJoinCoopRequest::has_league() const {
  return _internal_has_league();
}
inline void AutoJoinCoopRequest::clear_league() {
  league_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline uint32_t AutoJoinCoopRequest::_internal_league() const {
  return league_;
}
inline uint32_t AutoJoinCoopRequest::league() const {
  // @@protoc_insertion_point(field_get:ei.AutoJoinCoopRequest.league)
  return _internal_league();
}
inline void AutoJoinCoopRequest::_internal_set_league(uint32_t value) {
  _has_bits_[0] |= 0x00000080u;
  league_ = value;
}
inline void AutoJoinCoopRequest::set_league(uint32_t value) {
  _internal_set_league(value);
  // @@protoc_insertion_point(field_set:ei.AutoJoinCoopRequest.league)
}

// optional double seconds_remaining = 5;
inline bool AutoJoinCoopRequest::_internal_has_seconds_remaining() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool AutoJoinCoopRequest::has_seconds_remaining() const {
  return _internal_has_seconds_remaining();
}
inline void AutoJoinCoopRequest::clear_seconds_remaining() {
  seconds_remaining_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double AutoJoinCoopRequest::_internal_seconds_remaining() const {
  return seconds_remaining_;
}
inline double AutoJoinCoopRequest::seconds_remaining() const {
  // @@protoc_insertion_point(field_get:ei.AutoJoinCoopRequest.seconds_remaining)
  return _internal_seconds_remaining();
}
inline void AutoJoinCoopRequest::_internal_set_seconds_remaining(double value) {
  _has_bits_[0] |= 0x00000020u;
  seconds_remaining_ = value;
}
inline void AutoJoinCoopRequest::set_seconds_remaining(double value) {
  _internal_set_seconds_remaining(value);
  // @@protoc_insertion_point(field_set:ei.AutoJoinCoopRequest.seconds_remaining)
}

// optional .ei.Platform platform = 6;
inline bool AutoJoinCoopRequest::_internal_has_platform() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool AutoJoinCoopRequest::has_platform() const {
  return _internal_has_platform();
}
inline void AutoJoinCoopRequest::clear_platform() {
  platform_ = 1;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::ei::Platform AutoJoinCoopRequest::_internal_platform() const {
  return static_cast< ::ei::Platform >(platform_);
}
inline ::ei::Platform AutoJoinCoopRequest::platform() const {
  // @@protoc_insertion_point(field_get:ei.AutoJoinCoopRequest.platform)
  return _internal_platform();
}
inline void AutoJoinCoopRequest::_internal_set_platform(::ei::Platform value) {
  assert(::ei::Platform_IsValid(value));
  _has_bits_[0] |= 0x00000200u;
  platform_ = value;
}
inline void AutoJoinCoopRequest::set_platform(::ei::Platform value) {
  _internal_set_platform(value);
  // @@protoc_insertion_point(field_set:ei.AutoJoinCoopRequest.platform)
}

// optional uint32 client_version = 7;
inline bool AutoJoinCoopRequest::_internal_has_client_version() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool AutoJoinCoopRequest::has_client_version() const {
  return _internal_has_client_version();
}
inline void AutoJoinCoopRequest::clear_client_version() {
  client_version_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t AutoJoinCoopRequest::_internal_client_version() const {
  return client_version_;
}
inline uint32_t AutoJoinCoopRequest::client_version() const {
  // @@protoc_insertion_point(field_get:ei.AutoJoinCoopRequest.client_version)
  return _internal_client_version();
}
inline void AutoJoinCoopRequest::_internal_set_client_version(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  client_version_ = value;
}
inline void AutoJoinCoopRequest::set_client_version(uint32_t value) {
  _internal_set_client_version(value);
  // @@protoc_insertion_point(field_set:ei.AutoJoinCoopRequest.client_version)
}

// -------------------------------------------------------------------

// UpdateCoopPermissionsRequest

// optional .ei.BasicRequestInfo rinfo = 6;
inline bool UpdateCoopPermissionsRequest::_internal_has_rinfo() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || rinfo_ != nullptr);
  return value;
}
inline bool UpdateCoopPermissionsRequest::has_rinfo() const {
  return _internal_has_rinfo();
}
inline void UpdateCoopPermissionsRequest::clear_rinfo() {
  if (rinfo_ != nullptr) rinfo_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ei::BasicRequestInfo& UpdateCoopPermissionsRequest::_internal_rinfo() const {
  const ::ei::BasicRequestInfo* p = rinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::BasicRequestInfo&>(
      ::ei::_BasicRequestInfo_default_instance_);
}
inline const ::ei::BasicRequestInfo& UpdateCoopPermissionsRequest::rinfo() const {
  // @@protoc_insertion_point(field_get:ei.UpdateCoopPermissionsRequest.rinfo)
  return _internal_rinfo();
}
inline void UpdateCoopPermissionsRequest::unsafe_arena_set_allocated_rinfo(
    ::ei::BasicRequestInfo* rinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rinfo_);
  }
  rinfo_ = rinfo;
  if (rinfo) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.UpdateCoopPermissionsRequest.rinfo)
}
inline ::ei::BasicRequestInfo* UpdateCoopPermissionsRequest::release_rinfo() {
  _has_bits_[0] &= ~0x00000008u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::BasicRequestInfo* UpdateCoopPermissionsRequest::unsafe_arena_release_rinfo() {
  // @@protoc_insertion_point(field_release:ei.UpdateCoopPermissionsRequest.rinfo)
  _has_bits_[0] &= ~0x00000008u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
  return temp;
}
inline ::ei::BasicRequestInfo* UpdateCoopPermissionsRequest::_internal_mutable_rinfo() {
  _has_bits_[0] |= 0x00000008u;
  if (rinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::BasicRequestInfo>(GetArenaForAllocation());
    rinfo_ = p;
  }
  return rinfo_;
}
inline ::ei::BasicRequestInfo* UpdateCoopPermissionsRequest::mutable_rinfo() {
  ::ei::BasicRequestInfo* _msg = _internal_mutable_rinfo();
  // @@protoc_insertion_point(field_mutable:ei.UpdateCoopPermissionsRequest.rinfo)
  return _msg;
}
inline void UpdateCoopPermissionsRequest::set_allocated_rinfo(::ei::BasicRequestInfo* rinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rinfo_;
  }
  if (rinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::BasicRequestInfo>::GetOwningArena(rinfo);
    if (message_arena != submessage_arena) {
      rinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  rinfo_ = rinfo;
  // @@protoc_insertion_point(field_set_allocated:ei.UpdateCoopPermissionsRequest.rinfo)
}

// optional string contract_identifier = 1;
inline bool UpdateCoopPermissionsRequest::_internal_has_contract_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UpdateCoopPermissionsRequest::has_contract_identifier() const {
  return _internal_has_contract_identifier();
}
inline void UpdateCoopPermissionsRequest::clear_contract_identifier() {
  contract_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UpdateCoopPermissionsRequest::contract_identifier() const {
  // @@protoc_insertion_point(field_get:ei.UpdateCoopPermissionsRequest.contract_identifier)
  return _internal_contract_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateCoopPermissionsRequest::set_contract_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 contract_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.UpdateCoopPermissionsRequest.contract_identifier)
}
inline std::string* UpdateCoopPermissionsRequest::mutable_contract_identifier() {
  std::string* _s = _internal_mutable_contract_identifier();
  // @@protoc_insertion_point(field_mutable:ei.UpdateCoopPermissionsRequest.contract_identifier)
  return _s;
}
inline const std::string& UpdateCoopPermissionsRequest::_internal_contract_identifier() const {
  return contract_identifier_.Get();
}
inline void UpdateCoopPermissionsRequest::_internal_set_contract_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  contract_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateCoopPermissionsRequest::_internal_mutable_contract_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return contract_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateCoopPermissionsRequest::release_contract_identifier() {
  // @@protoc_insertion_point(field_release:ei.UpdateCoopPermissionsRequest.contract_identifier)
  if (!_internal_has_contract_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = contract_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UpdateCoopPermissionsRequest::set_allocated_contract_identifier(std::string* contract_identifier) {
  if (contract_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  contract_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contract_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.UpdateCoopPermissionsRequest.contract_identifier)
}

// optional string coop_identifier = 2;
inline bool UpdateCoopPermissionsRequest::_internal_has_coop_identifier() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UpdateCoopPermissionsRequest::has_coop_identifier() const {
  return _internal_has_coop_identifier();
}
inline void UpdateCoopPermissionsRequest::clear_coop_identifier() {
  coop_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UpdateCoopPermissionsRequest::coop_identifier() const {
  // @@protoc_insertion_point(field_get:ei.UpdateCoopPermissionsRequest.coop_identifier)
  return _internal_coop_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateCoopPermissionsRequest::set_coop_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 coop_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.UpdateCoopPermissionsRequest.coop_identifier)
}
inline std::string* UpdateCoopPermissionsRequest::mutable_coop_identifier() {
  std::string* _s = _internal_mutable_coop_identifier();
  // @@protoc_insertion_point(field_mutable:ei.UpdateCoopPermissionsRequest.coop_identifier)
  return _s;
}
inline const std::string& UpdateCoopPermissionsRequest::_internal_coop_identifier() const {
  return coop_identifier_.Get();
}
inline void UpdateCoopPermissionsRequest::_internal_set_coop_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  coop_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateCoopPermissionsRequest::_internal_mutable_coop_identifier() {
  _has_bits_[0] |= 0x00000002u;
  return coop_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateCoopPermissionsRequest::release_coop_identifier() {
  // @@protoc_insertion_point(field_release:ei.UpdateCoopPermissionsRequest.coop_identifier)
  if (!_internal_has_coop_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = coop_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coop_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coop_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UpdateCoopPermissionsRequest::set_allocated_coop_identifier(std::string* coop_identifier) {
  if (coop_identifier != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  coop_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), coop_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coop_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coop_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.UpdateCoopPermissionsRequest.coop_identifier)
}

// optional string requesting_user_id = 3;
inline bool UpdateCoopPermissionsRequest::_internal_has_requesting_user_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UpdateCoopPermissionsRequest::has_requesting_user_id() const {
  return _internal_has_requesting_user_id();
}
inline void UpdateCoopPermissionsRequest::clear_requesting_user_id() {
  requesting_user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& UpdateCoopPermissionsRequest::requesting_user_id() const {
  // @@protoc_insertion_point(field_get:ei.UpdateCoopPermissionsRequest.requesting_user_id)
  return _internal_requesting_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateCoopPermissionsRequest::set_requesting_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 requesting_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.UpdateCoopPermissionsRequest.requesting_user_id)
}
inline std::string* UpdateCoopPermissionsRequest::mutable_requesting_user_id() {
  std::string* _s = _internal_mutable_requesting_user_id();
  // @@protoc_insertion_point(field_mutable:ei.UpdateCoopPermissionsRequest.requesting_user_id)
  return _s;
}
inline const std::string& UpdateCoopPermissionsRequest::_internal_requesting_user_id() const {
  return requesting_user_id_.Get();
}
inline void UpdateCoopPermissionsRequest::_internal_set_requesting_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  requesting_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateCoopPermissionsRequest::_internal_mutable_requesting_user_id() {
  _has_bits_[0] |= 0x00000004u;
  return requesting_user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateCoopPermissionsRequest::release_requesting_user_id() {
  // @@protoc_insertion_point(field_release:ei.UpdateCoopPermissionsRequest.requesting_user_id)
  if (!_internal_has_requesting_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = requesting_user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (requesting_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    requesting_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UpdateCoopPermissionsRequest::set_allocated_requesting_user_id(std::string* requesting_user_id) {
  if (requesting_user_id != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  requesting_user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), requesting_user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (requesting_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    requesting_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.UpdateCoopPermissionsRequest.requesting_user_id)
}

// optional bool public = 4;
inline bool UpdateCoopPermissionsRequest::_internal_has_public_() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UpdateCoopPermissionsRequest::has_public_() const {
  return _internal_has_public_();
}
inline void UpdateCoopPermissionsRequest::clear_public_() {
  public__ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool UpdateCoopPermissionsRequest::_internal_public_() const {
  return public__;
}
inline bool UpdateCoopPermissionsRequest::public_() const {
  // @@protoc_insertion_point(field_get:ei.UpdateCoopPermissionsRequest.public)
  return _internal_public_();
}
inline void UpdateCoopPermissionsRequest::_internal_set_public_(bool value) {
  _has_bits_[0] |= 0x00000010u;
  public__ = value;
}
inline void UpdateCoopPermissionsRequest::set_public_(bool value) {
  _internal_set_public_(value);
  // @@protoc_insertion_point(field_set:ei.UpdateCoopPermissionsRequest.public)
}

// optional uint32 client_version = 5;
inline bool UpdateCoopPermissionsRequest::_internal_has_client_version() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool UpdateCoopPermissionsRequest::has_client_version() const {
  return _internal_has_client_version();
}
inline void UpdateCoopPermissionsRequest::clear_client_version() {
  client_version_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t UpdateCoopPermissionsRequest::_internal_client_version() const {
  return client_version_;
}
inline uint32_t UpdateCoopPermissionsRequest::client_version() const {
  // @@protoc_insertion_point(field_get:ei.UpdateCoopPermissionsRequest.client_version)
  return _internal_client_version();
}
inline void UpdateCoopPermissionsRequest::_internal_set_client_version(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  client_version_ = value;
}
inline void UpdateCoopPermissionsRequest::set_client_version(uint32_t value) {
  _internal_set_client_version(value);
  // @@protoc_insertion_point(field_set:ei.UpdateCoopPermissionsRequest.client_version)
}

// -------------------------------------------------------------------

// UpdateCoopPermissionsResponse

// optional bool success = 1;
inline bool UpdateCoopPermissionsResponse::_internal_has_success() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UpdateCoopPermissionsResponse::has_success() const {
  return _internal_has_success();
}
inline void UpdateCoopPermissionsResponse::clear_success() {
  success_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool UpdateCoopPermissionsResponse::_internal_success() const {
  return success_;
}
inline bool UpdateCoopPermissionsResponse::success() const {
  // @@protoc_insertion_point(field_get:ei.UpdateCoopPermissionsResponse.success)
  return _internal_success();
}
inline void UpdateCoopPermissionsResponse::_internal_set_success(bool value) {
  _has_bits_[0] |= 0x00000002u;
  success_ = value;
}
inline void UpdateCoopPermissionsResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:ei.UpdateCoopPermissionsResponse.success)
}

// optional string message = 2;
inline bool UpdateCoopPermissionsResponse::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UpdateCoopPermissionsResponse::has_message() const {
  return _internal_has_message();
}
inline void UpdateCoopPermissionsResponse::clear_message() {
  message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UpdateCoopPermissionsResponse::message() const {
  // @@protoc_insertion_point(field_get:ei.UpdateCoopPermissionsResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateCoopPermissionsResponse::set_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.UpdateCoopPermissionsResponse.message)
}
inline std::string* UpdateCoopPermissionsResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:ei.UpdateCoopPermissionsResponse.message)
  return _s;
}
inline const std::string& UpdateCoopPermissionsResponse::_internal_message() const {
  return message_.Get();
}
inline void UpdateCoopPermissionsResponse::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateCoopPermissionsResponse::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateCoopPermissionsResponse::release_message() {
  // @@protoc_insertion_point(field_release:ei.UpdateCoopPermissionsResponse.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UpdateCoopPermissionsResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.UpdateCoopPermissionsResponse.message)
}

// -------------------------------------------------------------------

// LeaveCoopRequest

// optional .ei.BasicRequestInfo rinfo = 8;
inline bool LeaveCoopRequest::_internal_has_rinfo() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || rinfo_ != nullptr);
  return value;
}
inline bool LeaveCoopRequest::has_rinfo() const {
  return _internal_has_rinfo();
}
inline void LeaveCoopRequest::clear_rinfo() {
  if (rinfo_ != nullptr) rinfo_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ei::BasicRequestInfo& LeaveCoopRequest::_internal_rinfo() const {
  const ::ei::BasicRequestInfo* p = rinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::BasicRequestInfo&>(
      ::ei::_BasicRequestInfo_default_instance_);
}
inline const ::ei::BasicRequestInfo& LeaveCoopRequest::rinfo() const {
  // @@protoc_insertion_point(field_get:ei.LeaveCoopRequest.rinfo)
  return _internal_rinfo();
}
inline void LeaveCoopRequest::unsafe_arena_set_allocated_rinfo(
    ::ei::BasicRequestInfo* rinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rinfo_);
  }
  rinfo_ = rinfo;
  if (rinfo) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.LeaveCoopRequest.rinfo)
}
inline ::ei::BasicRequestInfo* LeaveCoopRequest::release_rinfo() {
  _has_bits_[0] &= ~0x00000008u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::BasicRequestInfo* LeaveCoopRequest::unsafe_arena_release_rinfo() {
  // @@protoc_insertion_point(field_release:ei.LeaveCoopRequest.rinfo)
  _has_bits_[0] &= ~0x00000008u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
  return temp;
}
inline ::ei::BasicRequestInfo* LeaveCoopRequest::_internal_mutable_rinfo() {
  _has_bits_[0] |= 0x00000008u;
  if (rinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::BasicRequestInfo>(GetArenaForAllocation());
    rinfo_ = p;
  }
  return rinfo_;
}
inline ::ei::BasicRequestInfo* LeaveCoopRequest::mutable_rinfo() {
  ::ei::BasicRequestInfo* _msg = _internal_mutable_rinfo();
  // @@protoc_insertion_point(field_mutable:ei.LeaveCoopRequest.rinfo)
  return _msg;
}
inline void LeaveCoopRequest::set_allocated_rinfo(::ei::BasicRequestInfo* rinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rinfo_;
  }
  if (rinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::BasicRequestInfo>::GetOwningArena(rinfo);
    if (message_arena != submessage_arena) {
      rinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  rinfo_ = rinfo;
  // @@protoc_insertion_point(field_set_allocated:ei.LeaveCoopRequest.rinfo)
}

// optional string contract_identifier = 1;
inline bool LeaveCoopRequest::_internal_has_contract_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LeaveCoopRequest::has_contract_identifier() const {
  return _internal_has_contract_identifier();
}
inline void LeaveCoopRequest::clear_contract_identifier() {
  contract_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LeaveCoopRequest::contract_identifier() const {
  // @@protoc_insertion_point(field_get:ei.LeaveCoopRequest.contract_identifier)
  return _internal_contract_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LeaveCoopRequest::set_contract_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 contract_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.LeaveCoopRequest.contract_identifier)
}
inline std::string* LeaveCoopRequest::mutable_contract_identifier() {
  std::string* _s = _internal_mutable_contract_identifier();
  // @@protoc_insertion_point(field_mutable:ei.LeaveCoopRequest.contract_identifier)
  return _s;
}
inline const std::string& LeaveCoopRequest::_internal_contract_identifier() const {
  return contract_identifier_.Get();
}
inline void LeaveCoopRequest::_internal_set_contract_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  contract_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LeaveCoopRequest::_internal_mutable_contract_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return contract_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LeaveCoopRequest::release_contract_identifier() {
  // @@protoc_insertion_point(field_release:ei.LeaveCoopRequest.contract_identifier)
  if (!_internal_has_contract_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = contract_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LeaveCoopRequest::set_allocated_contract_identifier(std::string* contract_identifier) {
  if (contract_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  contract_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contract_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.LeaveCoopRequest.contract_identifier)
}

// optional string coop_identifier = 2;
inline bool LeaveCoopRequest::_internal_has_coop_identifier() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LeaveCoopRequest::has_coop_identifier() const {
  return _internal_has_coop_identifier();
}
inline void LeaveCoopRequest::clear_coop_identifier() {
  coop_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LeaveCoopRequest::coop_identifier() const {
  // @@protoc_insertion_point(field_get:ei.LeaveCoopRequest.coop_identifier)
  return _internal_coop_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LeaveCoopRequest::set_coop_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 coop_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.LeaveCoopRequest.coop_identifier)
}
inline std::string* LeaveCoopRequest::mutable_coop_identifier() {
  std::string* _s = _internal_mutable_coop_identifier();
  // @@protoc_insertion_point(field_mutable:ei.LeaveCoopRequest.coop_identifier)
  return _s;
}
inline const std::string& LeaveCoopRequest::_internal_coop_identifier() const {
  return coop_identifier_.Get();
}
inline void LeaveCoopRequest::_internal_set_coop_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  coop_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LeaveCoopRequest::_internal_mutable_coop_identifier() {
  _has_bits_[0] |= 0x00000002u;
  return coop_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LeaveCoopRequest::release_coop_identifier() {
  // @@protoc_insertion_point(field_release:ei.LeaveCoopRequest.coop_identifier)
  if (!_internal_has_coop_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = coop_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coop_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coop_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LeaveCoopRequest::set_allocated_coop_identifier(std::string* coop_identifier) {
  if (coop_identifier != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  coop_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), coop_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coop_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coop_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.LeaveCoopRequest.coop_identifier)
}

// optional string player_identifier = 3;
inline bool LeaveCoopRequest::_internal_has_player_identifier() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LeaveCoopRequest::has_player_identifier() const {
  return _internal_has_player_identifier();
}
inline void LeaveCoopRequest::clear_player_identifier() {
  player_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& LeaveCoopRequest::player_identifier() const {
  // @@protoc_insertion_point(field_get:ei.LeaveCoopRequest.player_identifier)
  return _internal_player_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LeaveCoopRequest::set_player_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 player_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.LeaveCoopRequest.player_identifier)
}
inline std::string* LeaveCoopRequest::mutable_player_identifier() {
  std::string* _s = _internal_mutable_player_identifier();
  // @@protoc_insertion_point(field_mutable:ei.LeaveCoopRequest.player_identifier)
  return _s;
}
inline const std::string& LeaveCoopRequest::_internal_player_identifier() const {
  return player_identifier_.Get();
}
inline void LeaveCoopRequest::_internal_set_player_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  player_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LeaveCoopRequest::_internal_mutable_player_identifier() {
  _has_bits_[0] |= 0x00000004u;
  return player_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LeaveCoopRequest::release_player_identifier() {
  // @@protoc_insertion_point(field_release:ei.LeaveCoopRequest.player_identifier)
  if (!_internal_has_player_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = player_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (player_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    player_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LeaveCoopRequest::set_allocated_player_identifier(std::string* player_identifier) {
  if (player_identifier != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  player_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), player_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (player_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    player_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.LeaveCoopRequest.player_identifier)
}

// optional uint32 client_version = 7;
inline bool LeaveCoopRequest::_internal_has_client_version() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LeaveCoopRequest::has_client_version() const {
  return _internal_has_client_version();
}
inline void LeaveCoopRequest::clear_client_version() {
  client_version_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t LeaveCoopRequest::_internal_client_version() const {
  return client_version_;
}
inline uint32_t LeaveCoopRequest::client_version() const {
  // @@protoc_insertion_point(field_get:ei.LeaveCoopRequest.client_version)
  return _internal_client_version();
}
inline void LeaveCoopRequest::_internal_set_client_version(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  client_version_ = value;
}
inline void LeaveCoopRequest::set_client_version(uint32_t value) {
  _internal_set_client_version(value);
  // @@protoc_insertion_point(field_set:ei.LeaveCoopRequest.client_version)
}

// -------------------------------------------------------------------

// GiftPlayerCoopRequest

// optional .ei.BasicRequestInfo rinfo = 8;
inline bool GiftPlayerCoopRequest::_internal_has_rinfo() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || rinfo_ != nullptr);
  return value;
}
inline bool GiftPlayerCoopRequest::has_rinfo() const {
  return _internal_has_rinfo();
}
inline void GiftPlayerCoopRequest::clear_rinfo() {
  if (rinfo_ != nullptr) rinfo_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::ei::BasicRequestInfo& GiftPlayerCoopRequest::_internal_rinfo() const {
  const ::ei::BasicRequestInfo* p = rinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::BasicRequestInfo&>(
      ::ei::_BasicRequestInfo_default_instance_);
}
inline const ::ei::BasicRequestInfo& GiftPlayerCoopRequest::rinfo() const {
  // @@protoc_insertion_point(field_get:ei.GiftPlayerCoopRequest.rinfo)
  return _internal_rinfo();
}
inline void GiftPlayerCoopRequest::unsafe_arena_set_allocated_rinfo(
    ::ei::BasicRequestInfo* rinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rinfo_);
  }
  rinfo_ = rinfo;
  if (rinfo) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.GiftPlayerCoopRequest.rinfo)
}
inline ::ei::BasicRequestInfo* GiftPlayerCoopRequest::release_rinfo() {
  _has_bits_[0] &= ~0x00000020u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::BasicRequestInfo* GiftPlayerCoopRequest::unsafe_arena_release_rinfo() {
  // @@protoc_insertion_point(field_release:ei.GiftPlayerCoopRequest.rinfo)
  _has_bits_[0] &= ~0x00000020u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
  return temp;
}
inline ::ei::BasicRequestInfo* GiftPlayerCoopRequest::_internal_mutable_rinfo() {
  _has_bits_[0] |= 0x00000020u;
  if (rinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::BasicRequestInfo>(GetArenaForAllocation());
    rinfo_ = p;
  }
  return rinfo_;
}
inline ::ei::BasicRequestInfo* GiftPlayerCoopRequest::mutable_rinfo() {
  ::ei::BasicRequestInfo* _msg = _internal_mutable_rinfo();
  // @@protoc_insertion_point(field_mutable:ei.GiftPlayerCoopRequest.rinfo)
  return _msg;
}
inline void GiftPlayerCoopRequest::set_allocated_rinfo(::ei::BasicRequestInfo* rinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rinfo_;
  }
  if (rinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::BasicRequestInfo>::GetOwningArena(rinfo);
    if (message_arena != submessage_arena) {
      rinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  rinfo_ = rinfo;
  // @@protoc_insertion_point(field_set_allocated:ei.GiftPlayerCoopRequest.rinfo)
}

// optional string contract_identifier = 1;
inline bool GiftPlayerCoopRequest::_internal_has_contract_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GiftPlayerCoopRequest::has_contract_identifier() const {
  return _internal_has_contract_identifier();
}
inline void GiftPlayerCoopRequest::clear_contract_identifier() {
  contract_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GiftPlayerCoopRequest::contract_identifier() const {
  // @@protoc_insertion_point(field_get:ei.GiftPlayerCoopRequest.contract_identifier)
  return _internal_contract_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GiftPlayerCoopRequest::set_contract_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 contract_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.GiftPlayerCoopRequest.contract_identifier)
}
inline std::string* GiftPlayerCoopRequest::mutable_contract_identifier() {
  std::string* _s = _internal_mutable_contract_identifier();
  // @@protoc_insertion_point(field_mutable:ei.GiftPlayerCoopRequest.contract_identifier)
  return _s;
}
inline const std::string& GiftPlayerCoopRequest::_internal_contract_identifier() const {
  return contract_identifier_.Get();
}
inline void GiftPlayerCoopRequest::_internal_set_contract_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  contract_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GiftPlayerCoopRequest::_internal_mutable_contract_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return contract_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GiftPlayerCoopRequest::release_contract_identifier() {
  // @@protoc_insertion_point(field_release:ei.GiftPlayerCoopRequest.contract_identifier)
  if (!_internal_has_contract_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = contract_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GiftPlayerCoopRequest::set_allocated_contract_identifier(std::string* contract_identifier) {
  if (contract_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  contract_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contract_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.GiftPlayerCoopRequest.contract_identifier)
}

// optional string coop_identifier = 2;
inline bool GiftPlayerCoopRequest::_internal_has_coop_identifier() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GiftPlayerCoopRequest::has_coop_identifier() const {
  return _internal_has_coop_identifier();
}
inline void GiftPlayerCoopRequest::clear_coop_identifier() {
  coop_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GiftPlayerCoopRequest::coop_identifier() const {
  // @@protoc_insertion_point(field_get:ei.GiftPlayerCoopRequest.coop_identifier)
  return _internal_coop_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GiftPlayerCoopRequest::set_coop_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 coop_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.GiftPlayerCoopRequest.coop_identifier)
}
inline std::string* GiftPlayerCoopRequest::mutable_coop_identifier() {
  std::string* _s = _internal_mutable_coop_identifier();
  // @@protoc_insertion_point(field_mutable:ei.GiftPlayerCoopRequest.coop_identifier)
  return _s;
}
inline const std::string& GiftPlayerCoopRequest::_internal_coop_identifier() const {
  return coop_identifier_.Get();
}
inline void GiftPlayerCoopRequest::_internal_set_coop_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  coop_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GiftPlayerCoopRequest::_internal_mutable_coop_identifier() {
  _has_bits_[0] |= 0x00000002u;
  return coop_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GiftPlayerCoopRequest::release_coop_identifier() {
  // @@protoc_insertion_point(field_release:ei.GiftPlayerCoopRequest.coop_identifier)
  if (!_internal_has_coop_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = coop_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coop_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coop_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GiftPlayerCoopRequest::set_allocated_coop_identifier(std::string* coop_identifier) {
  if (coop_identifier != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  coop_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), coop_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coop_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coop_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.GiftPlayerCoopRequest.coop_identifier)
}

// optional string player_identifier = 3;
inline bool GiftPlayerCoopRequest::_internal_has_player_identifier() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GiftPlayerCoopRequest::has_player_identifier() const {
  return _internal_has_player_identifier();
}
inline void GiftPlayerCoopRequest::clear_player_identifier() {
  player_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& GiftPlayerCoopRequest::player_identifier() const {
  // @@protoc_insertion_point(field_get:ei.GiftPlayerCoopRequest.player_identifier)
  return _internal_player_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GiftPlayerCoopRequest::set_player_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 player_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.GiftPlayerCoopRequest.player_identifier)
}
inline std::string* GiftPlayerCoopRequest::mutable_player_identifier() {
  std::string* _s = _internal_mutable_player_identifier();
  // @@protoc_insertion_point(field_mutable:ei.GiftPlayerCoopRequest.player_identifier)
  return _s;
}
inline const std::string& GiftPlayerCoopRequest::_internal_player_identifier() const {
  return player_identifier_.Get();
}
inline void GiftPlayerCoopRequest::_internal_set_player_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  player_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GiftPlayerCoopRequest::_internal_mutable_player_identifier() {
  _has_bits_[0] |= 0x00000004u;
  return player_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GiftPlayerCoopRequest::release_player_identifier() {
  // @@protoc_insertion_point(field_release:ei.GiftPlayerCoopRequest.player_identifier)
  if (!_internal_has_player_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = player_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (player_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    player_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GiftPlayerCoopRequest::set_allocated_player_identifier(std::string* player_identifier) {
  if (player_identifier != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  player_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), player_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (player_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    player_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.GiftPlayerCoopRequest.player_identifier)
}

// optional string requesting_user_id = 4;
inline bool GiftPlayerCoopRequest::_internal_has_requesting_user_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GiftPlayerCoopRequest::has_requesting_user_id() const {
  return _internal_has_requesting_user_id();
}
inline void GiftPlayerCoopRequest::clear_requesting_user_id() {
  requesting_user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& GiftPlayerCoopRequest::requesting_user_id() const {
  // @@protoc_insertion_point(field_get:ei.GiftPlayerCoopRequest.requesting_user_id)
  return _internal_requesting_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GiftPlayerCoopRequest::set_requesting_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 requesting_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.GiftPlayerCoopRequest.requesting_user_id)
}
inline std::string* GiftPlayerCoopRequest::mutable_requesting_user_id() {
  std::string* _s = _internal_mutable_requesting_user_id();
  // @@protoc_insertion_point(field_mutable:ei.GiftPlayerCoopRequest.requesting_user_id)
  return _s;
}
inline const std::string& GiftPlayerCoopRequest::_internal_requesting_user_id() const {
  return requesting_user_id_.Get();
}
inline void GiftPlayerCoopRequest::_internal_set_requesting_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  requesting_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GiftPlayerCoopRequest::_internal_mutable_requesting_user_id() {
  _has_bits_[0] |= 0x00000008u;
  return requesting_user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GiftPlayerCoopRequest::release_requesting_user_id() {
  // @@protoc_insertion_point(field_release:ei.GiftPlayerCoopRequest.requesting_user_id)
  if (!_internal_has_requesting_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = requesting_user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (requesting_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    requesting_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GiftPlayerCoopRequest::set_allocated_requesting_user_id(std::string* requesting_user_id) {
  if (requesting_user_id != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  requesting_user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), requesting_user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (requesting_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    requesting_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.GiftPlayerCoopRequest.requesting_user_id)
}

// optional string requesting_user_name = 6;
inline bool GiftPlayerCoopRequest::_internal_has_requesting_user_name() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GiftPlayerCoopRequest::has_requesting_user_name() const {
  return _internal_has_requesting_user_name();
}
inline void GiftPlayerCoopRequest::clear_requesting_user_name() {
  requesting_user_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& GiftPlayerCoopRequest::requesting_user_name() const {
  // @@protoc_insertion_point(field_get:ei.GiftPlayerCoopRequest.requesting_user_name)
  return _internal_requesting_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GiftPlayerCoopRequest::set_requesting_user_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 requesting_user_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.GiftPlayerCoopRequest.requesting_user_name)
}
inline std::string* GiftPlayerCoopRequest::mutable_requesting_user_name() {
  std::string* _s = _internal_mutable_requesting_user_name();
  // @@protoc_insertion_point(field_mutable:ei.GiftPlayerCoopRequest.requesting_user_name)
  return _s;
}
inline const std::string& GiftPlayerCoopRequest::_internal_requesting_user_name() const {
  return requesting_user_name_.Get();
}
inline void GiftPlayerCoopRequest::_internal_set_requesting_user_name(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  requesting_user_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GiftPlayerCoopRequest::_internal_mutable_requesting_user_name() {
  _has_bits_[0] |= 0x00000010u;
  return requesting_user_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GiftPlayerCoopRequest::release_requesting_user_name() {
  // @@protoc_insertion_point(field_release:ei.GiftPlayerCoopRequest.requesting_user_name)
  if (!_internal_has_requesting_user_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = requesting_user_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (requesting_user_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    requesting_user_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GiftPlayerCoopRequest::set_allocated_requesting_user_name(std::string* requesting_user_name) {
  if (requesting_user_name != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  requesting_user_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), requesting_user_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (requesting_user_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    requesting_user_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.GiftPlayerCoopRequest.requesting_user_name)
}

// optional uint32 amount = 5;
inline bool GiftPlayerCoopRequest::_internal_has_amount() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool GiftPlayerCoopRequest::has_amount() const {
  return _internal_has_amount();
}
inline void GiftPlayerCoopRequest::clear_amount() {
  amount_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t GiftPlayerCoopRequest::_internal_amount() const {
  return amount_;
}
inline uint32_t GiftPlayerCoopRequest::amount() const {
  // @@protoc_insertion_point(field_get:ei.GiftPlayerCoopRequest.amount)
  return _internal_amount();
}
inline void GiftPlayerCoopRequest::_internal_set_amount(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  amount_ = value;
}
inline void GiftPlayerCoopRequest::set_amount(uint32_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:ei.GiftPlayerCoopRequest.amount)
}

// optional uint32 client_version = 7;
inline bool GiftPlayerCoopRequest::_internal_has_client_version() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool GiftPlayerCoopRequest::has_client_version() const {
  return _internal_has_client_version();
}
inline void GiftPlayerCoopRequest::clear_client_version() {
  client_version_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline uint32_t GiftPlayerCoopRequest::_internal_client_version() const {
  return client_version_;
}
inline uint32_t GiftPlayerCoopRequest::client_version() const {
  // @@protoc_insertion_point(field_get:ei.GiftPlayerCoopRequest.client_version)
  return _internal_client_version();
}
inline void GiftPlayerCoopRequest::_internal_set_client_version(uint32_t value) {
  _has_bits_[0] |= 0x00000080u;
  client_version_ = value;
}
inline void GiftPlayerCoopRequest::set_client_version(uint32_t value) {
  _internal_set_client_version(value);
  // @@protoc_insertion_point(field_set:ei.GiftPlayerCoopRequest.client_version)
}

// -------------------------------------------------------------------

// SendChickenRunCoopRequest

// optional .ei.BasicRequestInfo rinfo = 8;
inline bool SendChickenRunCoopRequest::_internal_has_rinfo() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || rinfo_ != nullptr);
  return value;
}
inline bool SendChickenRunCoopRequest::has_rinfo() const {
  return _internal_has_rinfo();
}
inline void SendChickenRunCoopRequest::clear_rinfo() {
  if (rinfo_ != nullptr) rinfo_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::ei::BasicRequestInfo& SendChickenRunCoopRequest::_internal_rinfo() const {
  const ::ei::BasicRequestInfo* p = rinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::BasicRequestInfo&>(
      ::ei::_BasicRequestInfo_default_instance_);
}
inline const ::ei::BasicRequestInfo& SendChickenRunCoopRequest::rinfo() const {
  // @@protoc_insertion_point(field_get:ei.SendChickenRunCoopRequest.rinfo)
  return _internal_rinfo();
}
inline void SendChickenRunCoopRequest::unsafe_arena_set_allocated_rinfo(
    ::ei::BasicRequestInfo* rinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rinfo_);
  }
  rinfo_ = rinfo;
  if (rinfo) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.SendChickenRunCoopRequest.rinfo)
}
inline ::ei::BasicRequestInfo* SendChickenRunCoopRequest::release_rinfo() {
  _has_bits_[0] &= ~0x00000020u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::BasicRequestInfo* SendChickenRunCoopRequest::unsafe_arena_release_rinfo() {
  // @@protoc_insertion_point(field_release:ei.SendChickenRunCoopRequest.rinfo)
  _has_bits_[0] &= ~0x00000020u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
  return temp;
}
inline ::ei::BasicRequestInfo* SendChickenRunCoopRequest::_internal_mutable_rinfo() {
  _has_bits_[0] |= 0x00000020u;
  if (rinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::BasicRequestInfo>(GetArenaForAllocation());
    rinfo_ = p;
  }
  return rinfo_;
}
inline ::ei::BasicRequestInfo* SendChickenRunCoopRequest::mutable_rinfo() {
  ::ei::BasicRequestInfo* _msg = _internal_mutable_rinfo();
  // @@protoc_insertion_point(field_mutable:ei.SendChickenRunCoopRequest.rinfo)
  return _msg;
}
inline void SendChickenRunCoopRequest::set_allocated_rinfo(::ei::BasicRequestInfo* rinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rinfo_;
  }
  if (rinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::BasicRequestInfo>::GetOwningArena(rinfo);
    if (message_arena != submessage_arena) {
      rinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  rinfo_ = rinfo;
  // @@protoc_insertion_point(field_set_allocated:ei.SendChickenRunCoopRequest.rinfo)
}

// optional string contract_identifier = 1;
inline bool SendChickenRunCoopRequest::_internal_has_contract_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SendChickenRunCoopRequest::has_contract_identifier() const {
  return _internal_has_contract_identifier();
}
inline void SendChickenRunCoopRequest::clear_contract_identifier() {
  contract_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SendChickenRunCoopRequest::contract_identifier() const {
  // @@protoc_insertion_point(field_get:ei.SendChickenRunCoopRequest.contract_identifier)
  return _internal_contract_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendChickenRunCoopRequest::set_contract_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 contract_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.SendChickenRunCoopRequest.contract_identifier)
}
inline std::string* SendChickenRunCoopRequest::mutable_contract_identifier() {
  std::string* _s = _internal_mutable_contract_identifier();
  // @@protoc_insertion_point(field_mutable:ei.SendChickenRunCoopRequest.contract_identifier)
  return _s;
}
inline const std::string& SendChickenRunCoopRequest::_internal_contract_identifier() const {
  return contract_identifier_.Get();
}
inline void SendChickenRunCoopRequest::_internal_set_contract_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  contract_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SendChickenRunCoopRequest::_internal_mutable_contract_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return contract_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SendChickenRunCoopRequest::release_contract_identifier() {
  // @@protoc_insertion_point(field_release:ei.SendChickenRunCoopRequest.contract_identifier)
  if (!_internal_has_contract_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = contract_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SendChickenRunCoopRequest::set_allocated_contract_identifier(std::string* contract_identifier) {
  if (contract_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  contract_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contract_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.SendChickenRunCoopRequest.contract_identifier)
}

// optional string coop_identifier = 2;
inline bool SendChickenRunCoopRequest::_internal_has_coop_identifier() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SendChickenRunCoopRequest::has_coop_identifier() const {
  return _internal_has_coop_identifier();
}
inline void SendChickenRunCoopRequest::clear_coop_identifier() {
  coop_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SendChickenRunCoopRequest::coop_identifier() const {
  // @@protoc_insertion_point(field_get:ei.SendChickenRunCoopRequest.coop_identifier)
  return _internal_coop_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendChickenRunCoopRequest::set_coop_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 coop_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.SendChickenRunCoopRequest.coop_identifier)
}
inline std::string* SendChickenRunCoopRequest::mutable_coop_identifier() {
  std::string* _s = _internal_mutable_coop_identifier();
  // @@protoc_insertion_point(field_mutable:ei.SendChickenRunCoopRequest.coop_identifier)
  return _s;
}
inline const std::string& SendChickenRunCoopRequest::_internal_coop_identifier() const {
  return coop_identifier_.Get();
}
inline void SendChickenRunCoopRequest::_internal_set_coop_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  coop_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SendChickenRunCoopRequest::_internal_mutable_coop_identifier() {
  _has_bits_[0] |= 0x00000002u;
  return coop_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SendChickenRunCoopRequest::release_coop_identifier() {
  // @@protoc_insertion_point(field_release:ei.SendChickenRunCoopRequest.coop_identifier)
  if (!_internal_has_coop_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = coop_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coop_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coop_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SendChickenRunCoopRequest::set_allocated_coop_identifier(std::string* coop_identifier) {
  if (coop_identifier != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  coop_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), coop_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coop_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coop_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.SendChickenRunCoopRequest.coop_identifier)
}

// optional string player_identifier = 3;
inline bool SendChickenRunCoopRequest::_internal_has_player_identifier() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SendChickenRunCoopRequest::has_player_identifier() const {
  return _internal_has_player_identifier();
}
inline void SendChickenRunCoopRequest::clear_player_identifier() {
  player_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SendChickenRunCoopRequest::player_identifier() const {
  // @@protoc_insertion_point(field_get:ei.SendChickenRunCoopRequest.player_identifier)
  return _internal_player_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendChickenRunCoopRequest::set_player_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 player_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.SendChickenRunCoopRequest.player_identifier)
}
inline std::string* SendChickenRunCoopRequest::mutable_player_identifier() {
  std::string* _s = _internal_mutable_player_identifier();
  // @@protoc_insertion_point(field_mutable:ei.SendChickenRunCoopRequest.player_identifier)
  return _s;
}
inline const std::string& SendChickenRunCoopRequest::_internal_player_identifier() const {
  return player_identifier_.Get();
}
inline void SendChickenRunCoopRequest::_internal_set_player_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  player_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SendChickenRunCoopRequest::_internal_mutable_player_identifier() {
  _has_bits_[0] |= 0x00000004u;
  return player_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SendChickenRunCoopRequest::release_player_identifier() {
  // @@protoc_insertion_point(field_release:ei.SendChickenRunCoopRequest.player_identifier)
  if (!_internal_has_player_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = player_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (player_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    player_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SendChickenRunCoopRequest::set_allocated_player_identifier(std::string* player_identifier) {
  if (player_identifier != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  player_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), player_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (player_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    player_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.SendChickenRunCoopRequest.player_identifier)
}

// optional string requesting_user_id = 4;
inline bool SendChickenRunCoopRequest::_internal_has_requesting_user_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SendChickenRunCoopRequest::has_requesting_user_id() const {
  return _internal_has_requesting_user_id();
}
inline void SendChickenRunCoopRequest::clear_requesting_user_id() {
  requesting_user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& SendChickenRunCoopRequest::requesting_user_id() const {
  // @@protoc_insertion_point(field_get:ei.SendChickenRunCoopRequest.requesting_user_id)
  return _internal_requesting_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendChickenRunCoopRequest::set_requesting_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 requesting_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.SendChickenRunCoopRequest.requesting_user_id)
}
inline std::string* SendChickenRunCoopRequest::mutable_requesting_user_id() {
  std::string* _s = _internal_mutable_requesting_user_id();
  // @@protoc_insertion_point(field_mutable:ei.SendChickenRunCoopRequest.requesting_user_id)
  return _s;
}
inline const std::string& SendChickenRunCoopRequest::_internal_requesting_user_id() const {
  return requesting_user_id_.Get();
}
inline void SendChickenRunCoopRequest::_internal_set_requesting_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  requesting_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SendChickenRunCoopRequest::_internal_mutable_requesting_user_id() {
  _has_bits_[0] |= 0x00000008u;
  return requesting_user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SendChickenRunCoopRequest::release_requesting_user_id() {
  // @@protoc_insertion_point(field_release:ei.SendChickenRunCoopRequest.requesting_user_id)
  if (!_internal_has_requesting_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = requesting_user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (requesting_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    requesting_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SendChickenRunCoopRequest::set_allocated_requesting_user_id(std::string* requesting_user_id) {
  if (requesting_user_id != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  requesting_user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), requesting_user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (requesting_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    requesting_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.SendChickenRunCoopRequest.requesting_user_id)
}

// optional string requesting_user_name = 6;
inline bool SendChickenRunCoopRequest::_internal_has_requesting_user_name() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SendChickenRunCoopRequest::has_requesting_user_name() const {
  return _internal_has_requesting_user_name();
}
inline void SendChickenRunCoopRequest::clear_requesting_user_name() {
  requesting_user_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& SendChickenRunCoopRequest::requesting_user_name() const {
  // @@protoc_insertion_point(field_get:ei.SendChickenRunCoopRequest.requesting_user_name)
  return _internal_requesting_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendChickenRunCoopRequest::set_requesting_user_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 requesting_user_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.SendChickenRunCoopRequest.requesting_user_name)
}
inline std::string* SendChickenRunCoopRequest::mutable_requesting_user_name() {
  std::string* _s = _internal_mutable_requesting_user_name();
  // @@protoc_insertion_point(field_mutable:ei.SendChickenRunCoopRequest.requesting_user_name)
  return _s;
}
inline const std::string& SendChickenRunCoopRequest::_internal_requesting_user_name() const {
  return requesting_user_name_.Get();
}
inline void SendChickenRunCoopRequest::_internal_set_requesting_user_name(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  requesting_user_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SendChickenRunCoopRequest::_internal_mutable_requesting_user_name() {
  _has_bits_[0] |= 0x00000010u;
  return requesting_user_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SendChickenRunCoopRequest::release_requesting_user_name() {
  // @@protoc_insertion_point(field_release:ei.SendChickenRunCoopRequest.requesting_user_name)
  if (!_internal_has_requesting_user_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = requesting_user_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (requesting_user_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    requesting_user_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SendChickenRunCoopRequest::set_allocated_requesting_user_name(std::string* requesting_user_name) {
  if (requesting_user_name != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  requesting_user_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), requesting_user_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (requesting_user_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    requesting_user_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.SendChickenRunCoopRequest.requesting_user_name)
}

// optional uint64 farm_pop = 5;
inline bool SendChickenRunCoopRequest::_internal_has_farm_pop() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool SendChickenRunCoopRequest::has_farm_pop() const {
  return _internal_has_farm_pop();
}
inline void SendChickenRunCoopRequest::clear_farm_pop() {
  farm_pop_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000040u;
}
inline uint64_t SendChickenRunCoopRequest::_internal_farm_pop() const {
  return farm_pop_;
}
inline uint64_t SendChickenRunCoopRequest::farm_pop() const {
  // @@protoc_insertion_point(field_get:ei.SendChickenRunCoopRequest.farm_pop)
  return _internal_farm_pop();
}
inline void SendChickenRunCoopRequest::_internal_set_farm_pop(uint64_t value) {
  _has_bits_[0] |= 0x00000040u;
  farm_pop_ = value;
}
inline void SendChickenRunCoopRequest::set_farm_pop(uint64_t value) {
  _internal_set_farm_pop(value);
  // @@protoc_insertion_point(field_set:ei.SendChickenRunCoopRequest.farm_pop)
}

// optional uint32 client_version = 7;
inline bool SendChickenRunCoopRequest::_internal_has_client_version() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool SendChickenRunCoopRequest::has_client_version() const {
  return _internal_has_client_version();
}
inline void SendChickenRunCoopRequest::clear_client_version() {
  client_version_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline uint32_t SendChickenRunCoopRequest::_internal_client_version() const {
  return client_version_;
}
inline uint32_t SendChickenRunCoopRequest::client_version() const {
  // @@protoc_insertion_point(field_get:ei.SendChickenRunCoopRequest.client_version)
  return _internal_client_version();
}
inline void SendChickenRunCoopRequest::_internal_set_client_version(uint32_t value) {
  _has_bits_[0] |= 0x00000080u;
  client_version_ = value;
}
inline void SendChickenRunCoopRequest::set_client_version(uint32_t value) {
  _internal_set_client_version(value);
  // @@protoc_insertion_point(field_set:ei.SendChickenRunCoopRequest.client_version)
}

// -------------------------------------------------------------------

// KickPlayerCoopRequest

// optional .ei.BasicRequestInfo rinfo = 8;
inline bool KickPlayerCoopRequest::_internal_has_rinfo() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || rinfo_ != nullptr);
  return value;
}
inline bool KickPlayerCoopRequest::has_rinfo() const {
  return _internal_has_rinfo();
}
inline void KickPlayerCoopRequest::clear_rinfo() {
  if (rinfo_ != nullptr) rinfo_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::ei::BasicRequestInfo& KickPlayerCoopRequest::_internal_rinfo() const {
  const ::ei::BasicRequestInfo* p = rinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::BasicRequestInfo&>(
      ::ei::_BasicRequestInfo_default_instance_);
}
inline const ::ei::BasicRequestInfo& KickPlayerCoopRequest::rinfo() const {
  // @@protoc_insertion_point(field_get:ei.KickPlayerCoopRequest.rinfo)
  return _internal_rinfo();
}
inline void KickPlayerCoopRequest::unsafe_arena_set_allocated_rinfo(
    ::ei::BasicRequestInfo* rinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rinfo_);
  }
  rinfo_ = rinfo;
  if (rinfo) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.KickPlayerCoopRequest.rinfo)
}
inline ::ei::BasicRequestInfo* KickPlayerCoopRequest::release_rinfo() {
  _has_bits_[0] &= ~0x00000010u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::BasicRequestInfo* KickPlayerCoopRequest::unsafe_arena_release_rinfo() {
  // @@protoc_insertion_point(field_release:ei.KickPlayerCoopRequest.rinfo)
  _has_bits_[0] &= ~0x00000010u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
  return temp;
}
inline ::ei::BasicRequestInfo* KickPlayerCoopRequest::_internal_mutable_rinfo() {
  _has_bits_[0] |= 0x00000010u;
  if (rinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::BasicRequestInfo>(GetArenaForAllocation());
    rinfo_ = p;
  }
  return rinfo_;
}
inline ::ei::BasicRequestInfo* KickPlayerCoopRequest::mutable_rinfo() {
  ::ei::BasicRequestInfo* _msg = _internal_mutable_rinfo();
  // @@protoc_insertion_point(field_mutable:ei.KickPlayerCoopRequest.rinfo)
  return _msg;
}
inline void KickPlayerCoopRequest::set_allocated_rinfo(::ei::BasicRequestInfo* rinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rinfo_;
  }
  if (rinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::BasicRequestInfo>::GetOwningArena(rinfo);
    if (message_arena != submessage_arena) {
      rinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  rinfo_ = rinfo;
  // @@protoc_insertion_point(field_set_allocated:ei.KickPlayerCoopRequest.rinfo)
}

// optional string contract_identifier = 1;
inline bool KickPlayerCoopRequest::_internal_has_contract_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KickPlayerCoopRequest::has_contract_identifier() const {
  return _internal_has_contract_identifier();
}
inline void KickPlayerCoopRequest::clear_contract_identifier() {
  contract_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& KickPlayerCoopRequest::contract_identifier() const {
  // @@protoc_insertion_point(field_get:ei.KickPlayerCoopRequest.contract_identifier)
  return _internal_contract_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KickPlayerCoopRequest::set_contract_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 contract_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.KickPlayerCoopRequest.contract_identifier)
}
inline std::string* KickPlayerCoopRequest::mutable_contract_identifier() {
  std::string* _s = _internal_mutable_contract_identifier();
  // @@protoc_insertion_point(field_mutable:ei.KickPlayerCoopRequest.contract_identifier)
  return _s;
}
inline const std::string& KickPlayerCoopRequest::_internal_contract_identifier() const {
  return contract_identifier_.Get();
}
inline void KickPlayerCoopRequest::_internal_set_contract_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  contract_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* KickPlayerCoopRequest::_internal_mutable_contract_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return contract_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* KickPlayerCoopRequest::release_contract_identifier() {
  // @@protoc_insertion_point(field_release:ei.KickPlayerCoopRequest.contract_identifier)
  if (!_internal_has_contract_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = contract_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KickPlayerCoopRequest::set_allocated_contract_identifier(std::string* contract_identifier) {
  if (contract_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  contract_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contract_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.KickPlayerCoopRequest.contract_identifier)
}

// optional string coop_identifier = 2;
inline bool KickPlayerCoopRequest::_internal_has_coop_identifier() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KickPlayerCoopRequest::has_coop_identifier() const {
  return _internal_has_coop_identifier();
}
inline void KickPlayerCoopRequest::clear_coop_identifier() {
  coop_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& KickPlayerCoopRequest::coop_identifier() const {
  // @@protoc_insertion_point(field_get:ei.KickPlayerCoopRequest.coop_identifier)
  return _internal_coop_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KickPlayerCoopRequest::set_coop_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 coop_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.KickPlayerCoopRequest.coop_identifier)
}
inline std::string* KickPlayerCoopRequest::mutable_coop_identifier() {
  std::string* _s = _internal_mutable_coop_identifier();
  // @@protoc_insertion_point(field_mutable:ei.KickPlayerCoopRequest.coop_identifier)
  return _s;
}
inline const std::string& KickPlayerCoopRequest::_internal_coop_identifier() const {
  return coop_identifier_.Get();
}
inline void KickPlayerCoopRequest::_internal_set_coop_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  coop_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* KickPlayerCoopRequest::_internal_mutable_coop_identifier() {
  _has_bits_[0] |= 0x00000002u;
  return coop_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* KickPlayerCoopRequest::release_coop_identifier() {
  // @@protoc_insertion_point(field_release:ei.KickPlayerCoopRequest.coop_identifier)
  if (!_internal_has_coop_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = coop_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coop_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coop_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KickPlayerCoopRequest::set_allocated_coop_identifier(std::string* coop_identifier) {
  if (coop_identifier != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  coop_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), coop_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coop_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coop_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.KickPlayerCoopRequest.coop_identifier)
}

// optional string player_identifier = 3;
inline bool KickPlayerCoopRequest::_internal_has_player_identifier() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool KickPlayerCoopRequest::has_player_identifier() const {
  return _internal_has_player_identifier();
}
inline void KickPlayerCoopRequest::clear_player_identifier() {
  player_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& KickPlayerCoopRequest::player_identifier() const {
  // @@protoc_insertion_point(field_get:ei.KickPlayerCoopRequest.player_identifier)
  return _internal_player_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KickPlayerCoopRequest::set_player_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 player_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.KickPlayerCoopRequest.player_identifier)
}
inline std::string* KickPlayerCoopRequest::mutable_player_identifier() {
  std::string* _s = _internal_mutable_player_identifier();
  // @@protoc_insertion_point(field_mutable:ei.KickPlayerCoopRequest.player_identifier)
  return _s;
}
inline const std::string& KickPlayerCoopRequest::_internal_player_identifier() const {
  return player_identifier_.Get();
}
inline void KickPlayerCoopRequest::_internal_set_player_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  player_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* KickPlayerCoopRequest::_internal_mutable_player_identifier() {
  _has_bits_[0] |= 0x00000004u;
  return player_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* KickPlayerCoopRequest::release_player_identifier() {
  // @@protoc_insertion_point(field_release:ei.KickPlayerCoopRequest.player_identifier)
  if (!_internal_has_player_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = player_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (player_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    player_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KickPlayerCoopRequest::set_allocated_player_identifier(std::string* player_identifier) {
  if (player_identifier != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  player_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), player_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (player_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    player_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.KickPlayerCoopRequest.player_identifier)
}

// optional string requesting_user_id = 4;
inline bool KickPlayerCoopRequest::_internal_has_requesting_user_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool KickPlayerCoopRequest::has_requesting_user_id() const {
  return _internal_has_requesting_user_id();
}
inline void KickPlayerCoopRequest::clear_requesting_user_id() {
  requesting_user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& KickPlayerCoopRequest::requesting_user_id() const {
  // @@protoc_insertion_point(field_get:ei.KickPlayerCoopRequest.requesting_user_id)
  return _internal_requesting_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KickPlayerCoopRequest::set_requesting_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 requesting_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.KickPlayerCoopRequest.requesting_user_id)
}
inline std::string* KickPlayerCoopRequest::mutable_requesting_user_id() {
  std::string* _s = _internal_mutable_requesting_user_id();
  // @@protoc_insertion_point(field_mutable:ei.KickPlayerCoopRequest.requesting_user_id)
  return _s;
}
inline const std::string& KickPlayerCoopRequest::_internal_requesting_user_id() const {
  return requesting_user_id_.Get();
}
inline void KickPlayerCoopRequest::_internal_set_requesting_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  requesting_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* KickPlayerCoopRequest::_internal_mutable_requesting_user_id() {
  _has_bits_[0] |= 0x00000008u;
  return requesting_user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* KickPlayerCoopRequest::release_requesting_user_id() {
  // @@protoc_insertion_point(field_release:ei.KickPlayerCoopRequest.requesting_user_id)
  if (!_internal_has_requesting_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = requesting_user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (requesting_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    requesting_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KickPlayerCoopRequest::set_allocated_requesting_user_id(std::string* requesting_user_id) {
  if (requesting_user_id != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  requesting_user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), requesting_user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (requesting_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    requesting_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.KickPlayerCoopRequest.requesting_user_id)
}

// optional .ei.KickPlayerCoopRequest.Reason reason = 9;
inline bool KickPlayerCoopRequest::_internal_has_reason() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool KickPlayerCoopRequest::has_reason() const {
  return _internal_has_reason();
}
inline void KickPlayerCoopRequest::clear_reason() {
  reason_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::ei::KickPlayerCoopRequest_Reason KickPlayerCoopRequest::_internal_reason() const {
  return static_cast< ::ei::KickPlayerCoopRequest_Reason >(reason_);
}
inline ::ei::KickPlayerCoopRequest_Reason KickPlayerCoopRequest::reason() const {
  // @@protoc_insertion_point(field_get:ei.KickPlayerCoopRequest.reason)
  return _internal_reason();
}
inline void KickPlayerCoopRequest::_internal_set_reason(::ei::KickPlayerCoopRequest_Reason value) {
  assert(::ei::KickPlayerCoopRequest_Reason_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  reason_ = value;
}
inline void KickPlayerCoopRequest::set_reason(::ei::KickPlayerCoopRequest_Reason value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:ei.KickPlayerCoopRequest.reason)
}

// optional uint32 client_version = 7;
inline bool KickPlayerCoopRequest::_internal_has_client_version() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool KickPlayerCoopRequest::has_client_version() const {
  return _internal_has_client_version();
}
inline void KickPlayerCoopRequest::clear_client_version() {
  client_version_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t KickPlayerCoopRequest::_internal_client_version() const {
  return client_version_;
}
inline uint32_t KickPlayerCoopRequest::client_version() const {
  // @@protoc_insertion_point(field_get:ei.KickPlayerCoopRequest.client_version)
  return _internal_client_version();
}
inline void KickPlayerCoopRequest::_internal_set_client_version(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  client_version_ = value;
}
inline void KickPlayerCoopRequest::set_client_version(uint32_t value) {
  _internal_set_client_version(value);
  // @@protoc_insertion_point(field_set:ei.KickPlayerCoopRequest.client_version)
}

// -------------------------------------------------------------------

// ContractCoopStatusUpdateRequest

// optional .ei.BasicRequestInfo rinfo = 12;
inline bool ContractCoopStatusUpdateRequest::_internal_has_rinfo() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || rinfo_ != nullptr);
  return value;
}
inline bool ContractCoopStatusUpdateRequest::has_rinfo() const {
  return _internal_has_rinfo();
}
inline void ContractCoopStatusUpdateRequest::clear_rinfo() {
  if (rinfo_ != nullptr) rinfo_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::ei::BasicRequestInfo& ContractCoopStatusUpdateRequest::_internal_rinfo() const {
  const ::ei::BasicRequestInfo* p = rinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::BasicRequestInfo&>(
      ::ei::_BasicRequestInfo_default_instance_);
}
inline const ::ei::BasicRequestInfo& ContractCoopStatusUpdateRequest::rinfo() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusUpdateRequest.rinfo)
  return _internal_rinfo();
}
inline void ContractCoopStatusUpdateRequest::unsafe_arena_set_allocated_rinfo(
    ::ei::BasicRequestInfo* rinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rinfo_);
  }
  rinfo_ = rinfo;
  if (rinfo) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.ContractCoopStatusUpdateRequest.rinfo)
}
inline ::ei::BasicRequestInfo* ContractCoopStatusUpdateRequest::release_rinfo() {
  _has_bits_[0] &= ~0x00000010u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::BasicRequestInfo* ContractCoopStatusUpdateRequest::unsafe_arena_release_rinfo() {
  // @@protoc_insertion_point(field_release:ei.ContractCoopStatusUpdateRequest.rinfo)
  _has_bits_[0] &= ~0x00000010u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
  return temp;
}
inline ::ei::BasicRequestInfo* ContractCoopStatusUpdateRequest::_internal_mutable_rinfo() {
  _has_bits_[0] |= 0x00000010u;
  if (rinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::BasicRequestInfo>(GetArenaForAllocation());
    rinfo_ = p;
  }
  return rinfo_;
}
inline ::ei::BasicRequestInfo* ContractCoopStatusUpdateRequest::mutable_rinfo() {
  ::ei::BasicRequestInfo* _msg = _internal_mutable_rinfo();
  // @@protoc_insertion_point(field_mutable:ei.ContractCoopStatusUpdateRequest.rinfo)
  return _msg;
}
inline void ContractCoopStatusUpdateRequest::set_allocated_rinfo(::ei::BasicRequestInfo* rinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rinfo_;
  }
  if (rinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::BasicRequestInfo>::GetOwningArena(rinfo);
    if (message_arena != submessage_arena) {
      rinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  rinfo_ = rinfo;
  // @@protoc_insertion_point(field_set_allocated:ei.ContractCoopStatusUpdateRequest.rinfo)
}

// optional string user_id = 1;
inline bool ContractCoopStatusUpdateRequest::_internal_has_user_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContractCoopStatusUpdateRequest::has_user_id() const {
  return _internal_has_user_id();
}
inline void ContractCoopStatusUpdateRequest::clear_user_id() {
  user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContractCoopStatusUpdateRequest::user_id() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusUpdateRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractCoopStatusUpdateRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusUpdateRequest.user_id)
}
inline std::string* ContractCoopStatusUpdateRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:ei.ContractCoopStatusUpdateRequest.user_id)
  return _s;
}
inline const std::string& ContractCoopStatusUpdateRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void ContractCoopStatusUpdateRequest::_internal_set_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusUpdateRequest::_internal_mutable_user_id() {
  _has_bits_[0] |= 0x00000001u;
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusUpdateRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:ei.ContractCoopStatusUpdateRequest.user_id)
  if (!_internal_has_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractCoopStatusUpdateRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ContractCoopStatusUpdateRequest.user_id)
}

// optional string contract_identifier = 2;
inline bool ContractCoopStatusUpdateRequest::_internal_has_contract_identifier() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContractCoopStatusUpdateRequest::has_contract_identifier() const {
  return _internal_has_contract_identifier();
}
inline void ContractCoopStatusUpdateRequest::clear_contract_identifier() {
  contract_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ContractCoopStatusUpdateRequest::contract_identifier() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusUpdateRequest.contract_identifier)
  return _internal_contract_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractCoopStatusUpdateRequest::set_contract_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 contract_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusUpdateRequest.contract_identifier)
}
inline std::string* ContractCoopStatusUpdateRequest::mutable_contract_identifier() {
  std::string* _s = _internal_mutable_contract_identifier();
  // @@protoc_insertion_point(field_mutable:ei.ContractCoopStatusUpdateRequest.contract_identifier)
  return _s;
}
inline const std::string& ContractCoopStatusUpdateRequest::_internal_contract_identifier() const {
  return contract_identifier_.Get();
}
inline void ContractCoopStatusUpdateRequest::_internal_set_contract_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  contract_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusUpdateRequest::_internal_mutable_contract_identifier() {
  _has_bits_[0] |= 0x00000002u;
  return contract_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusUpdateRequest::release_contract_identifier() {
  // @@protoc_insertion_point(field_release:ei.ContractCoopStatusUpdateRequest.contract_identifier)
  if (!_internal_has_contract_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = contract_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractCoopStatusUpdateRequest::set_allocated_contract_identifier(std::string* contract_identifier) {
  if (contract_identifier != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  contract_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contract_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ContractCoopStatusUpdateRequest.contract_identifier)
}

// optional string coop_identifier = 3;
inline bool ContractCoopStatusUpdateRequest::_internal_has_coop_identifier() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ContractCoopStatusUpdateRequest::has_coop_identifier() const {
  return _internal_has_coop_identifier();
}
inline void ContractCoopStatusUpdateRequest::clear_coop_identifier() {
  coop_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ContractCoopStatusUpdateRequest::coop_identifier() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusUpdateRequest.coop_identifier)
  return _internal_coop_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractCoopStatusUpdateRequest::set_coop_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 coop_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusUpdateRequest.coop_identifier)
}
inline std::string* ContractCoopStatusUpdateRequest::mutable_coop_identifier() {
  std::string* _s = _internal_mutable_coop_identifier();
  // @@protoc_insertion_point(field_mutable:ei.ContractCoopStatusUpdateRequest.coop_identifier)
  return _s;
}
inline const std::string& ContractCoopStatusUpdateRequest::_internal_coop_identifier() const {
  return coop_identifier_.Get();
}
inline void ContractCoopStatusUpdateRequest::_internal_set_coop_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  coop_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusUpdateRequest::_internal_mutable_coop_identifier() {
  _has_bits_[0] |= 0x00000004u;
  return coop_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusUpdateRequest::release_coop_identifier() {
  // @@protoc_insertion_point(field_release:ei.ContractCoopStatusUpdateRequest.coop_identifier)
  if (!_internal_has_coop_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = coop_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coop_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coop_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractCoopStatusUpdateRequest::set_allocated_coop_identifier(std::string* coop_identifier) {
  if (coop_identifier != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  coop_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), coop_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coop_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coop_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ContractCoopStatusUpdateRequest.coop_identifier)
}

// optional string push_user_id = 8;
inline bool ContractCoopStatusUpdateRequest::_internal_has_push_user_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ContractCoopStatusUpdateRequest::has_push_user_id() const {
  return _internal_has_push_user_id();
}
inline void ContractCoopStatusUpdateRequest::clear_push_user_id() {
  push_user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ContractCoopStatusUpdateRequest::push_user_id() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusUpdateRequest.push_user_id)
  return _internal_push_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContractCoopStatusUpdateRequest::set_push_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 push_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusUpdateRequest.push_user_id)
}
inline std::string* ContractCoopStatusUpdateRequest::mutable_push_user_id() {
  std::string* _s = _internal_mutable_push_user_id();
  // @@protoc_insertion_point(field_mutable:ei.ContractCoopStatusUpdateRequest.push_user_id)
  return _s;
}
inline const std::string& ContractCoopStatusUpdateRequest::_internal_push_user_id() const {
  return push_user_id_.Get();
}
inline void ContractCoopStatusUpdateRequest::_internal_set_push_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  push_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusUpdateRequest::_internal_mutable_push_user_id() {
  _has_bits_[0] |= 0x00000008u;
  return push_user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ContractCoopStatusUpdateRequest::release_push_user_id() {
  // @@protoc_insertion_point(field_release:ei.ContractCoopStatusUpdateRequest.push_user_id)
  if (!_internal_has_push_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = push_user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (push_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    push_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContractCoopStatusUpdateRequest::set_allocated_push_user_id(std::string* push_user_id) {
  if (push_user_id != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  push_user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), push_user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (push_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    push_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ContractCoopStatusUpdateRequest.push_user_id)
}

// optional double amount = 4;
inline bool ContractCoopStatusUpdateRequest::_internal_has_amount() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ContractCoopStatusUpdateRequest::has_amount() const {
  return _internal_has_amount();
}
inline void ContractCoopStatusUpdateRequest::clear_amount() {
  amount_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline double ContractCoopStatusUpdateRequest::_internal_amount() const {
  return amount_;
}
inline double ContractCoopStatusUpdateRequest::amount() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusUpdateRequest.amount)
  return _internal_amount();
}
inline void ContractCoopStatusUpdateRequest::_internal_set_amount(double value) {
  _has_bits_[0] |= 0x00000080u;
  amount_ = value;
}
inline void ContractCoopStatusUpdateRequest::set_amount(double value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusUpdateRequest.amount)
}

// optional double rate = 5;
inline bool ContractCoopStatusUpdateRequest::_internal_has_rate() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ContractCoopStatusUpdateRequest::has_rate() const {
  return _internal_has_rate();
}
inline void ContractCoopStatusUpdateRequest::clear_rate() {
  rate_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline double ContractCoopStatusUpdateRequest::_internal_rate() const {
  return rate_;
}
inline double ContractCoopStatusUpdateRequest::rate() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusUpdateRequest.rate)
  return _internal_rate();
}
inline void ContractCoopStatusUpdateRequest::_internal_set_rate(double value) {
  _has_bits_[0] |= 0x00000100u;
  rate_ = value;
}
inline void ContractCoopStatusUpdateRequest::set_rate(double value) {
  _internal_set_rate(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusUpdateRequest.rate)
}

// optional uint32 time_cheats_detected = 6;
inline bool ContractCoopStatusUpdateRequest::_internal_has_time_cheats_detected() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ContractCoopStatusUpdateRequest::has_time_cheats_detected() const {
  return _internal_has_time_cheats_detected();
}
inline void ContractCoopStatusUpdateRequest::clear_time_cheats_detected() {
  time_cheats_detected_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline uint32_t ContractCoopStatusUpdateRequest::_internal_time_cheats_detected() const {
  return time_cheats_detected_;
}
inline uint32_t ContractCoopStatusUpdateRequest::time_cheats_detected() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusUpdateRequest.time_cheats_detected)
  return _internal_time_cheats_detected();
}
inline void ContractCoopStatusUpdateRequest::_internal_set_time_cheats_detected(uint32_t value) {
  _has_bits_[0] |= 0x00000400u;
  time_cheats_detected_ = value;
}
inline void ContractCoopStatusUpdateRequest::set_time_cheats_detected(uint32_t value) {
  _internal_set_time_cheats_detected(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusUpdateRequest.time_cheats_detected)
}

// optional double soul_power = 7;
inline bool ContractCoopStatusUpdateRequest::_internal_has_soul_power() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ContractCoopStatusUpdateRequest::has_soul_power() const {
  return _internal_has_soul_power();
}
inline void ContractCoopStatusUpdateRequest::clear_soul_power() {
  soul_power_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline double ContractCoopStatusUpdateRequest::_internal_soul_power() const {
  return soul_power_;
}
inline double ContractCoopStatusUpdateRequest::soul_power() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusUpdateRequest.soul_power)
  return _internal_soul_power();
}
inline void ContractCoopStatusUpdateRequest::_internal_set_soul_power(double value) {
  _has_bits_[0] |= 0x00000200u;
  soul_power_ = value;
}
inline void ContractCoopStatusUpdateRequest::set_soul_power(double value) {
  _internal_set_soul_power(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusUpdateRequest.soul_power)
}

// optional uint32 eop = 15;
inline bool ContractCoopStatusUpdateRequest::_internal_has_eop() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool ContractCoopStatusUpdateRequest::has_eop() const {
  return _internal_has_eop();
}
inline void ContractCoopStatusUpdateRequest::clear_eop() {
  eop_ = 0u;
  _has_bits_[0] &= ~0x00002000u;
}
inline uint32_t ContractCoopStatusUpdateRequest::_internal_eop() const {
  return eop_;
}
inline uint32_t ContractCoopStatusUpdateRequest::eop() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusUpdateRequest.eop)
  return _internal_eop();
}
inline void ContractCoopStatusUpdateRequest::_internal_set_eop(uint32_t value) {
  _has_bits_[0] |= 0x00002000u;
  eop_ = value;
}
inline void ContractCoopStatusUpdateRequest::set_eop(uint32_t value) {
  _internal_set_eop(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusUpdateRequest.eop)
}

// optional uint32 boost_tokens = 9;
inline bool ContractCoopStatusUpdateRequest::_internal_has_boost_tokens() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool ContractCoopStatusUpdateRequest::has_boost_tokens() const {
  return _internal_has_boost_tokens();
}
inline void ContractCoopStatusUpdateRequest::clear_boost_tokens() {
  boost_tokens_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline uint32_t ContractCoopStatusUpdateRequest::_internal_boost_tokens() const {
  return boost_tokens_;
}
inline uint32_t ContractCoopStatusUpdateRequest::boost_tokens() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusUpdateRequest.boost_tokens)
  return _internal_boost_tokens();
}
inline void ContractCoopStatusUpdateRequest::_internal_set_boost_tokens(uint32_t value) {
  _has_bits_[0] |= 0x00000800u;
  boost_tokens_ = value;
}
inline void ContractCoopStatusUpdateRequest::set_boost_tokens(uint32_t value) {
  _internal_set_boost_tokens(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusUpdateRequest.boost_tokens)
}

// optional uint32 boost_tokens_spent = 13;
inline bool ContractCoopStatusUpdateRequest::_internal_has_boost_tokens_spent() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool ContractCoopStatusUpdateRequest::has_boost_tokens_spent() const {
  return _internal_has_boost_tokens_spent();
}
inline void ContractCoopStatusUpdateRequest::clear_boost_tokens_spent() {
  boost_tokens_spent_ = 0u;
  _has_bits_[0] &= ~0x00001000u;
}
inline uint32_t ContractCoopStatusUpdateRequest::_internal_boost_tokens_spent() const {
  return boost_tokens_spent_;
}
inline uint32_t ContractCoopStatusUpdateRequest::boost_tokens_spent() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusUpdateRequest.boost_tokens_spent)
  return _internal_boost_tokens_spent();
}
inline void ContractCoopStatusUpdateRequest::_internal_set_boost_tokens_spent(uint32_t value) {
  _has_bits_[0] |= 0x00001000u;
  boost_tokens_spent_ = value;
}
inline void ContractCoopStatusUpdateRequest::set_boost_tokens_spent(uint32_t value) {
  _internal_set_boost_tokens_spent(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusUpdateRequest.boost_tokens_spent)
}

// optional .ei.FarmProductionParams production_params = 14;
inline bool ContractCoopStatusUpdateRequest::_internal_has_production_params() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || production_params_ != nullptr);
  return value;
}
inline bool ContractCoopStatusUpdateRequest::has_production_params() const {
  return _internal_has_production_params();
}
inline void ContractCoopStatusUpdateRequest::clear_production_params() {
  if (production_params_ != nullptr) production_params_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::ei::FarmProductionParams& ContractCoopStatusUpdateRequest::_internal_production_params() const {
  const ::ei::FarmProductionParams* p = production_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::FarmProductionParams&>(
      ::ei::_FarmProductionParams_default_instance_);
}
inline const ::ei::FarmProductionParams& ContractCoopStatusUpdateRequest::production_params() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusUpdateRequest.production_params)
  return _internal_production_params();
}
inline void ContractCoopStatusUpdateRequest::unsafe_arena_set_allocated_production_params(
    ::ei::FarmProductionParams* production_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(production_params_);
  }
  production_params_ = production_params;
  if (production_params) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.ContractCoopStatusUpdateRequest.production_params)
}
inline ::ei::FarmProductionParams* ContractCoopStatusUpdateRequest::release_production_params() {
  _has_bits_[0] &= ~0x00000020u;
  ::ei::FarmProductionParams* temp = production_params_;
  production_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::FarmProductionParams* ContractCoopStatusUpdateRequest::unsafe_arena_release_production_params() {
  // @@protoc_insertion_point(field_release:ei.ContractCoopStatusUpdateRequest.production_params)
  _has_bits_[0] &= ~0x00000020u;
  ::ei::FarmProductionParams* temp = production_params_;
  production_params_ = nullptr;
  return temp;
}
inline ::ei::FarmProductionParams* ContractCoopStatusUpdateRequest::_internal_mutable_production_params() {
  _has_bits_[0] |= 0x00000020u;
  if (production_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::FarmProductionParams>(GetArenaForAllocation());
    production_params_ = p;
  }
  return production_params_;
}
inline ::ei::FarmProductionParams* ContractCoopStatusUpdateRequest::mutable_production_params() {
  ::ei::FarmProductionParams* _msg = _internal_mutable_production_params();
  // @@protoc_insertion_point(field_mutable:ei.ContractCoopStatusUpdateRequest.production_params)
  return _msg;
}
inline void ContractCoopStatusUpdateRequest::set_allocated_production_params(::ei::FarmProductionParams* production_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete production_params_;
  }
  if (production_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::FarmProductionParams>::GetOwningArena(production_params);
    if (message_arena != submessage_arena) {
      production_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, production_params, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  production_params_ = production_params;
  // @@protoc_insertion_point(field_set_allocated:ei.ContractCoopStatusUpdateRequest.production_params)
}

// optional .ei.PlayerFarmInfo farm_info = 16;
inline bool ContractCoopStatusUpdateRequest::_internal_has_farm_info() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || farm_info_ != nullptr);
  return value;
}
inline bool ContractCoopStatusUpdateRequest::has_farm_info() const {
  return _internal_has_farm_info();
}
inline void ContractCoopStatusUpdateRequest::clear_farm_info() {
  if (farm_info_ != nullptr) farm_info_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::ei::PlayerFarmInfo& ContractCoopStatusUpdateRequest::_internal_farm_info() const {
  const ::ei::PlayerFarmInfo* p = farm_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::PlayerFarmInfo&>(
      ::ei::_PlayerFarmInfo_default_instance_);
}
inline const ::ei::PlayerFarmInfo& ContractCoopStatusUpdateRequest::farm_info() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusUpdateRequest.farm_info)
  return _internal_farm_info();
}
inline void ContractCoopStatusUpdateRequest::unsafe_arena_set_allocated_farm_info(
    ::ei::PlayerFarmInfo* farm_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(farm_info_);
  }
  farm_info_ = farm_info;
  if (farm_info) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.ContractCoopStatusUpdateRequest.farm_info)
}
inline ::ei::PlayerFarmInfo* ContractCoopStatusUpdateRequest::release_farm_info() {
  _has_bits_[0] &= ~0x00000040u;
  ::ei::PlayerFarmInfo* temp = farm_info_;
  farm_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::PlayerFarmInfo* ContractCoopStatusUpdateRequest::unsafe_arena_release_farm_info() {
  // @@protoc_insertion_point(field_release:ei.ContractCoopStatusUpdateRequest.farm_info)
  _has_bits_[0] &= ~0x00000040u;
  ::ei::PlayerFarmInfo* temp = farm_info_;
  farm_info_ = nullptr;
  return temp;
}
inline ::ei::PlayerFarmInfo* ContractCoopStatusUpdateRequest::_internal_mutable_farm_info() {
  _has_bits_[0] |= 0x00000040u;
  if (farm_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::PlayerFarmInfo>(GetArenaForAllocation());
    farm_info_ = p;
  }
  return farm_info_;
}
inline ::ei::PlayerFarmInfo* ContractCoopStatusUpdateRequest::mutable_farm_info() {
  ::ei::PlayerFarmInfo* _msg = _internal_mutable_farm_info();
  // @@protoc_insertion_point(field_mutable:ei.ContractCoopStatusUpdateRequest.farm_info)
  return _msg;
}
inline void ContractCoopStatusUpdateRequest::set_allocated_farm_info(::ei::PlayerFarmInfo* farm_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete farm_info_;
  }
  if (farm_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::PlayerFarmInfo>::GetOwningArena(farm_info);
    if (message_arena != submessage_arena) {
      farm_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, farm_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  farm_info_ = farm_info;
  // @@protoc_insertion_point(field_set_allocated:ei.ContractCoopStatusUpdateRequest.farm_info)
}

// optional double egg_laying_rate_buff = 10 [default = 1];
inline bool ContractCoopStatusUpdateRequest::_internal_has_egg_laying_rate_buff() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool ContractCoopStatusUpdateRequest::has_egg_laying_rate_buff() const {
  return _internal_has_egg_laying_rate_buff();
}
inline void ContractCoopStatusUpdateRequest::clear_egg_laying_rate_buff() {
  egg_laying_rate_buff_ = 1;
  _has_bits_[0] &= ~0x00004000u;
}
inline double ContractCoopStatusUpdateRequest::_internal_egg_laying_rate_buff() const {
  return egg_laying_rate_buff_;
}
inline double ContractCoopStatusUpdateRequest::egg_laying_rate_buff() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusUpdateRequest.egg_laying_rate_buff)
  return _internal_egg_laying_rate_buff();
}
inline void ContractCoopStatusUpdateRequest::_internal_set_egg_laying_rate_buff(double value) {
  _has_bits_[0] |= 0x00004000u;
  egg_laying_rate_buff_ = value;
}
inline void ContractCoopStatusUpdateRequest::set_egg_laying_rate_buff(double value) {
  _internal_set_egg_laying_rate_buff(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusUpdateRequest.egg_laying_rate_buff)
}

// optional double earnings_buff = 11 [default = 1];
inline bool ContractCoopStatusUpdateRequest::_internal_has_earnings_buff() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool ContractCoopStatusUpdateRequest::has_earnings_buff() const {
  return _internal_has_earnings_buff();
}
inline void ContractCoopStatusUpdateRequest::clear_earnings_buff() {
  earnings_buff_ = 1;
  _has_bits_[0] &= ~0x00008000u;
}
inline double ContractCoopStatusUpdateRequest::_internal_earnings_buff() const {
  return earnings_buff_;
}
inline double ContractCoopStatusUpdateRequest::earnings_buff() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusUpdateRequest.earnings_buff)
  return _internal_earnings_buff();
}
inline void ContractCoopStatusUpdateRequest::_internal_set_earnings_buff(double value) {
  _has_bits_[0] |= 0x00008000u;
  earnings_buff_ = value;
}
inline void ContractCoopStatusUpdateRequest::set_earnings_buff(double value) {
  _internal_set_earnings_buff(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusUpdateRequest.earnings_buff)
}

// -------------------------------------------------------------------

// ContractCoopStatusUpdateResponse

// optional bool finalized = 1;
inline bool ContractCoopStatusUpdateResponse::_internal_has_finalized() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContractCoopStatusUpdateResponse::has_finalized() const {
  return _internal_has_finalized();
}
inline void ContractCoopStatusUpdateResponse::clear_finalized() {
  finalized_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool ContractCoopStatusUpdateResponse::_internal_finalized() const {
  return finalized_;
}
inline bool ContractCoopStatusUpdateResponse::finalized() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusUpdateResponse.finalized)
  return _internal_finalized();
}
inline void ContractCoopStatusUpdateResponse::_internal_set_finalized(bool value) {
  _has_bits_[0] |= 0x00000001u;
  finalized_ = value;
}
inline void ContractCoopStatusUpdateResponse::set_finalized(bool value) {
  _internal_set_finalized(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusUpdateResponse.finalized)
}

// optional bool exists = 2;
inline bool ContractCoopStatusUpdateResponse::_internal_has_exists() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContractCoopStatusUpdateResponse::has_exists() const {
  return _internal_has_exists();
}
inline void ContractCoopStatusUpdateResponse::clear_exists() {
  exists_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ContractCoopStatusUpdateResponse::_internal_exists() const {
  return exists_;
}
inline bool ContractCoopStatusUpdateResponse::exists() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusUpdateResponse.exists)
  return _internal_exists();
}
inline void ContractCoopStatusUpdateResponse::_internal_set_exists(bool value) {
  _has_bits_[0] |= 0x00000002u;
  exists_ = value;
}
inline void ContractCoopStatusUpdateResponse::set_exists(bool value) {
  _internal_set_exists(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusUpdateResponse.exists)
}

// optional .ei.ContractCoopStatusResponse.MemberStatus status = 3;
inline bool ContractCoopStatusUpdateResponse::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ContractCoopStatusUpdateResponse::has_status() const {
  return _internal_has_status();
}
inline void ContractCoopStatusUpdateResponse::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::ei::ContractCoopStatusResponse_MemberStatus ContractCoopStatusUpdateResponse::_internal_status() const {
  return static_cast< ::ei::ContractCoopStatusResponse_MemberStatus >(status_);
}
inline ::ei::ContractCoopStatusResponse_MemberStatus ContractCoopStatusUpdateResponse::status() const {
  // @@protoc_insertion_point(field_get:ei.ContractCoopStatusUpdateResponse.status)
  return _internal_status();
}
inline void ContractCoopStatusUpdateResponse::_internal_set_status(::ei::ContractCoopStatusResponse_MemberStatus value) {
  assert(::ei::ContractCoopStatusResponse_MemberStatus_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  status_ = value;
}
inline void ContractCoopStatusUpdateResponse::set_status(::ei::ContractCoopStatusResponse_MemberStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:ei.ContractCoopStatusUpdateResponse.status)
}

// -------------------------------------------------------------------

// CoopBuffState

// optional double egg_laying_rate = 1 [default = 1];
inline bool CoopBuffState::_internal_has_egg_laying_rate() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CoopBuffState::has_egg_laying_rate() const {
  return _internal_has_egg_laying_rate();
}
inline void CoopBuffState::clear_egg_laying_rate() {
  egg_laying_rate_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline double CoopBuffState::_internal_egg_laying_rate() const {
  return egg_laying_rate_;
}
inline double CoopBuffState::egg_laying_rate() const {
  // @@protoc_insertion_point(field_get:ei.CoopBuffState.egg_laying_rate)
  return _internal_egg_laying_rate();
}
inline void CoopBuffState::_internal_set_egg_laying_rate(double value) {
  _has_bits_[0] |= 0x00000002u;
  egg_laying_rate_ = value;
}
inline void CoopBuffState::set_egg_laying_rate(double value) {
  _internal_set_egg_laying_rate(value);
  // @@protoc_insertion_point(field_set:ei.CoopBuffState.egg_laying_rate)
}

// optional double earnings = 2 [default = 1];
inline bool CoopBuffState::_internal_has_earnings() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CoopBuffState::has_earnings() const {
  return _internal_has_earnings();
}
inline void CoopBuffState::clear_earnings() {
  earnings_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline double CoopBuffState::_internal_earnings() const {
  return earnings_;
}
inline double CoopBuffState::earnings() const {
  // @@protoc_insertion_point(field_get:ei.CoopBuffState.earnings)
  return _internal_earnings();
}
inline void CoopBuffState::_internal_set_earnings(double value) {
  _has_bits_[0] |= 0x00000004u;
  earnings_ = value;
}
inline void CoopBuffState::set_earnings(double value) {
  _internal_set_earnings(value);
  // @@protoc_insertion_point(field_set:ei.CoopBuffState.earnings)
}

// optional double server_timestamp = 3;
inline bool CoopBuffState::_internal_has_server_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CoopBuffState::has_server_timestamp() const {
  return _internal_has_server_timestamp();
}
inline void CoopBuffState::clear_server_timestamp() {
  server_timestamp_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double CoopBuffState::_internal_server_timestamp() const {
  return server_timestamp_;
}
inline double CoopBuffState::server_timestamp() const {
  // @@protoc_insertion_point(field_get:ei.CoopBuffState.server_timestamp)
  return _internal_server_timestamp();
}
inline void CoopBuffState::_internal_set_server_timestamp(double value) {
  _has_bits_[0] |= 0x00000001u;
  server_timestamp_ = value;
}
inline void CoopBuffState::set_server_timestamp(double value) {
  _internal_set_server_timestamp(value);
  // @@protoc_insertion_point(field_set:ei.CoopBuffState.server_timestamp)
}

// -------------------------------------------------------------------

// CoopBuffHistory

// repeated .ei.CoopBuffState history = 1;
inline int CoopBuffHistory::_internal_history_size() const {
  return history_.size();
}
inline int CoopBuffHistory::history_size() const {
  return _internal_history_size();
}
inline void CoopBuffHistory::clear_history() {
  history_.Clear();
}
inline ::ei::CoopBuffState* CoopBuffHistory::mutable_history(int index) {
  // @@protoc_insertion_point(field_mutable:ei.CoopBuffHistory.history)
  return history_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::CoopBuffState >*
CoopBuffHistory::mutable_history() {
  // @@protoc_insertion_point(field_mutable_list:ei.CoopBuffHistory.history)
  return &history_;
}
inline const ::ei::CoopBuffState& CoopBuffHistory::_internal_history(int index) const {
  return history_.Get(index);
}
inline const ::ei::CoopBuffState& CoopBuffHistory::history(int index) const {
  // @@protoc_insertion_point(field_get:ei.CoopBuffHistory.history)
  return _internal_history(index);
}
inline ::ei::CoopBuffState* CoopBuffHistory::_internal_add_history() {
  return history_.Add();
}
inline ::ei::CoopBuffState* CoopBuffHistory::add_history() {
  ::ei::CoopBuffState* _add = _internal_add_history();
  // @@protoc_insertion_point(field_add:ei.CoopBuffHistory.history)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::CoopBuffState >&
CoopBuffHistory::history() const {
  // @@protoc_insertion_point(field_list:ei.CoopBuffHistory.history)
  return history_;
}

// -------------------------------------------------------------------

// CoopChickenRunEntry

// optional string user_id = 1;
inline bool CoopChickenRunEntry::_internal_has_user_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CoopChickenRunEntry::has_user_id() const {
  return _internal_has_user_id();
}
inline void CoopChickenRunEntry::clear_user_id() {
  user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CoopChickenRunEntry::user_id() const {
  // @@protoc_insertion_point(field_get:ei.CoopChickenRunEntry.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CoopChickenRunEntry::set_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.CoopChickenRunEntry.user_id)
}
inline std::string* CoopChickenRunEntry::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:ei.CoopChickenRunEntry.user_id)
  return _s;
}
inline const std::string& CoopChickenRunEntry::_internal_user_id() const {
  return user_id_.Get();
}
inline void CoopChickenRunEntry::_internal_set_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CoopChickenRunEntry::_internal_mutable_user_id() {
  _has_bits_[0] |= 0x00000001u;
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CoopChickenRunEntry::release_user_id() {
  // @@protoc_insertion_point(field_release:ei.CoopChickenRunEntry.user_id)
  if (!_internal_has_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CoopChickenRunEntry::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.CoopChickenRunEntry.user_id)
}

// optional double server_timestamp = 2;
inline bool CoopChickenRunEntry::_internal_has_server_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CoopChickenRunEntry::has_server_timestamp() const {
  return _internal_has_server_timestamp();
}
inline void CoopChickenRunEntry::clear_server_timestamp() {
  server_timestamp_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double CoopChickenRunEntry::_internal_server_timestamp() const {
  return server_timestamp_;
}
inline double CoopChickenRunEntry::server_timestamp() const {
  // @@protoc_insertion_point(field_get:ei.CoopChickenRunEntry.server_timestamp)
  return _internal_server_timestamp();
}
inline void CoopChickenRunEntry::_internal_set_server_timestamp(double value) {
  _has_bits_[0] |= 0x00000002u;
  server_timestamp_ = value;
}
inline void CoopChickenRunEntry::set_server_timestamp(double value) {
  _internal_set_server_timestamp(value);
  // @@protoc_insertion_point(field_set:ei.CoopChickenRunEntry.server_timestamp)
}

// -------------------------------------------------------------------

// CoopLastChickenRunTimes

// repeated .ei.CoopChickenRunEntry entries = 3;
inline int CoopLastChickenRunTimes::_internal_entries_size() const {
  return entries_.size();
}
inline int CoopLastChickenRunTimes::entries_size() const {
  return _internal_entries_size();
}
inline void CoopLastChickenRunTimes::clear_entries() {
  entries_.Clear();
}
inline ::ei::CoopChickenRunEntry* CoopLastChickenRunTimes::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:ei.CoopLastChickenRunTimes.entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::CoopChickenRunEntry >*
CoopLastChickenRunTimes::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:ei.CoopLastChickenRunTimes.entries)
  return &entries_;
}
inline const ::ei::CoopChickenRunEntry& CoopLastChickenRunTimes::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::ei::CoopChickenRunEntry& CoopLastChickenRunTimes::entries(int index) const {
  // @@protoc_insertion_point(field_get:ei.CoopLastChickenRunTimes.entries)
  return _internal_entries(index);
}
inline ::ei::CoopChickenRunEntry* CoopLastChickenRunTimes::_internal_add_entries() {
  return entries_.Add();
}
inline ::ei::CoopChickenRunEntry* CoopLastChickenRunTimes::add_entries() {
  ::ei::CoopChickenRunEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:ei.CoopLastChickenRunTimes.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::CoopChickenRunEntry >&
CoopLastChickenRunTimes::entries() const {
  // @@protoc_insertion_point(field_list:ei.CoopLastChickenRunTimes.entries)
  return entries_;
}

// -------------------------------------------------------------------

// UserDataInfoRequest

// optional .ei.BasicRequestInfo rinfo = 4;
inline bool UserDataInfoRequest::_internal_has_rinfo() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || rinfo_ != nullptr);
  return value;
}
inline bool UserDataInfoRequest::has_rinfo() const {
  return _internal_has_rinfo();
}
inline void UserDataInfoRequest::clear_rinfo() {
  if (rinfo_ != nullptr) rinfo_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ei::BasicRequestInfo& UserDataInfoRequest::_internal_rinfo() const {
  const ::ei::BasicRequestInfo* p = rinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::BasicRequestInfo&>(
      ::ei::_BasicRequestInfo_default_instance_);
}
inline const ::ei::BasicRequestInfo& UserDataInfoRequest::rinfo() const {
  // @@protoc_insertion_point(field_get:ei.UserDataInfoRequest.rinfo)
  return _internal_rinfo();
}
inline void UserDataInfoRequest::unsafe_arena_set_allocated_rinfo(
    ::ei::BasicRequestInfo* rinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rinfo_);
  }
  rinfo_ = rinfo;
  if (rinfo) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.UserDataInfoRequest.rinfo)
}
inline ::ei::BasicRequestInfo* UserDataInfoRequest::release_rinfo() {
  _has_bits_[0] &= ~0x00000004u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::BasicRequestInfo* UserDataInfoRequest::unsafe_arena_release_rinfo() {
  // @@protoc_insertion_point(field_release:ei.UserDataInfoRequest.rinfo)
  _has_bits_[0] &= ~0x00000004u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
  return temp;
}
inline ::ei::BasicRequestInfo* UserDataInfoRequest::_internal_mutable_rinfo() {
  _has_bits_[0] |= 0x00000004u;
  if (rinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::BasicRequestInfo>(GetArenaForAllocation());
    rinfo_ = p;
  }
  return rinfo_;
}
inline ::ei::BasicRequestInfo* UserDataInfoRequest::mutable_rinfo() {
  ::ei::BasicRequestInfo* _msg = _internal_mutable_rinfo();
  // @@protoc_insertion_point(field_mutable:ei.UserDataInfoRequest.rinfo)
  return _msg;
}
inline void UserDataInfoRequest::set_allocated_rinfo(::ei::BasicRequestInfo* rinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rinfo_;
  }
  if (rinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::BasicRequestInfo>::GetOwningArena(rinfo);
    if (message_arena != submessage_arena) {
      rinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  rinfo_ = rinfo;
  // @@protoc_insertion_point(field_set_allocated:ei.UserDataInfoRequest.rinfo)
}

// optional string user_id = 1;
inline bool UserDataInfoRequest::_internal_has_user_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserDataInfoRequest::has_user_id() const {
  return _internal_has_user_id();
}
inline void UserDataInfoRequest::clear_user_id() {
  user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserDataInfoRequest::user_id() const {
  // @@protoc_insertion_point(field_get:ei.UserDataInfoRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserDataInfoRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.UserDataInfoRequest.user_id)
}
inline std::string* UserDataInfoRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:ei.UserDataInfoRequest.user_id)
  return _s;
}
inline const std::string& UserDataInfoRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void UserDataInfoRequest::_internal_set_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserDataInfoRequest::_internal_mutable_user_id() {
  _has_bits_[0] |= 0x00000001u;
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserDataInfoRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:ei.UserDataInfoRequest.user_id)
  if (!_internal_has_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserDataInfoRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.UserDataInfoRequest.user_id)
}

// optional string device_id = 2;
inline bool UserDataInfoRequest::_internal_has_device_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserDataInfoRequest::has_device_id() const {
  return _internal_has_device_id();
}
inline void UserDataInfoRequest::clear_device_id() {
  device_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UserDataInfoRequest::device_id() const {
  // @@protoc_insertion_point(field_get:ei.UserDataInfoRequest.device_id)
  return _internal_device_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserDataInfoRequest::set_device_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 device_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.UserDataInfoRequest.device_id)
}
inline std::string* UserDataInfoRequest::mutable_device_id() {
  std::string* _s = _internal_mutable_device_id();
  // @@protoc_insertion_point(field_mutable:ei.UserDataInfoRequest.device_id)
  return _s;
}
inline const std::string& UserDataInfoRequest::_internal_device_id() const {
  return device_id_.Get();
}
inline void UserDataInfoRequest::_internal_set_device_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  device_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserDataInfoRequest::_internal_mutable_device_id() {
  _has_bits_[0] |= 0x00000002u;
  return device_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserDataInfoRequest::release_device_id() {
  // @@protoc_insertion_point(field_release:ei.UserDataInfoRequest.device_id)
  if (!_internal_has_device_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = device_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserDataInfoRequest::set_allocated_device_id(std::string* device_id) {
  if (device_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  device_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.UserDataInfoRequest.device_id)
}

// optional uint64 backup_checksum = 3;
inline bool UserDataInfoRequest::_internal_has_backup_checksum() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UserDataInfoRequest::has_backup_checksum() const {
  return _internal_has_backup_checksum();
}
inline void UserDataInfoRequest::clear_backup_checksum() {
  backup_checksum_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t UserDataInfoRequest::_internal_backup_checksum() const {
  return backup_checksum_;
}
inline uint64_t UserDataInfoRequest::backup_checksum() const {
  // @@protoc_insertion_point(field_get:ei.UserDataInfoRequest.backup_checksum)
  return _internal_backup_checksum();
}
inline void UserDataInfoRequest::_internal_set_backup_checksum(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  backup_checksum_ = value;
}
inline void UserDataInfoRequest::set_backup_checksum(uint64_t value) {
  _internal_set_backup_checksum(value);
  // @@protoc_insertion_point(field_set:ei.UserDataInfoRequest.backup_checksum)
}

// -------------------------------------------------------------------

// UserDataInfoResponse

// optional uint64 backup_checksum = 1;
inline bool UserDataInfoResponse::_internal_has_backup_checksum() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserDataInfoResponse::has_backup_checksum() const {
  return _internal_has_backup_checksum();
}
inline void UserDataInfoResponse::clear_backup_checksum() {
  backup_checksum_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t UserDataInfoResponse::_internal_backup_checksum() const {
  return backup_checksum_;
}
inline uint64_t UserDataInfoResponse::backup_checksum() const {
  // @@protoc_insertion_point(field_get:ei.UserDataInfoResponse.backup_checksum)
  return _internal_backup_checksum();
}
inline void UserDataInfoResponse::_internal_set_backup_checksum(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  backup_checksum_ = value;
}
inline void UserDataInfoResponse::set_backup_checksum(uint64_t value) {
  _internal_set_backup_checksum(value);
  // @@protoc_insertion_point(field_set:ei.UserDataInfoResponse.backup_checksum)
}

// optional double backup_total_cash = 2;
inline bool UserDataInfoResponse::_internal_has_backup_total_cash() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserDataInfoResponse::has_backup_total_cash() const {
  return _internal_has_backup_total_cash();
}
inline void UserDataInfoResponse::clear_backup_total_cash() {
  backup_total_cash_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double UserDataInfoResponse::_internal_backup_total_cash() const {
  return backup_total_cash_;
}
inline double UserDataInfoResponse::backup_total_cash() const {
  // @@protoc_insertion_point(field_get:ei.UserDataInfoResponse.backup_total_cash)
  return _internal_backup_total_cash();
}
inline void UserDataInfoResponse::_internal_set_backup_total_cash(double value) {
  _has_bits_[0] |= 0x00000002u;
  backup_total_cash_ = value;
}
inline void UserDataInfoResponse::set_backup_total_cash(double value) {
  _internal_set_backup_total_cash(value);
  // @@protoc_insertion_point(field_set:ei.UserDataInfoResponse.backup_total_cash)
}

// repeated string coop_memberships = 3;
inline int UserDataInfoResponse::_internal_coop_memberships_size() const {
  return coop_memberships_.size();
}
inline int UserDataInfoResponse::coop_memberships_size() const {
  return _internal_coop_memberships_size();
}
inline void UserDataInfoResponse::clear_coop_memberships() {
  coop_memberships_.Clear();
}
inline std::string* UserDataInfoResponse::add_coop_memberships() {
  std::string* _s = _internal_add_coop_memberships();
  // @@protoc_insertion_point(field_add_mutable:ei.UserDataInfoResponse.coop_memberships)
  return _s;
}
inline const std::string& UserDataInfoResponse::_internal_coop_memberships(int index) const {
  return coop_memberships_.Get(index);
}
inline const std::string& UserDataInfoResponse::coop_memberships(int index) const {
  // @@protoc_insertion_point(field_get:ei.UserDataInfoResponse.coop_memberships)
  return _internal_coop_memberships(index);
}
inline std::string* UserDataInfoResponse::mutable_coop_memberships(int index) {
  // @@protoc_insertion_point(field_mutable:ei.UserDataInfoResponse.coop_memberships)
  return coop_memberships_.Mutable(index);
}
inline void UserDataInfoResponse::set_coop_memberships(int index, const std::string& value) {
  coop_memberships_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ei.UserDataInfoResponse.coop_memberships)
}
inline void UserDataInfoResponse::set_coop_memberships(int index, std::string&& value) {
  coop_memberships_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ei.UserDataInfoResponse.coop_memberships)
}
inline void UserDataInfoResponse::set_coop_memberships(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  coop_memberships_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ei.UserDataInfoResponse.coop_memberships)
}
inline void UserDataInfoResponse::set_coop_memberships(int index, const char* value, size_t size) {
  coop_memberships_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ei.UserDataInfoResponse.coop_memberships)
}
inline std::string* UserDataInfoResponse::_internal_add_coop_memberships() {
  return coop_memberships_.Add();
}
inline void UserDataInfoResponse::add_coop_memberships(const std::string& value) {
  coop_memberships_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ei.UserDataInfoResponse.coop_memberships)
}
inline void UserDataInfoResponse::add_coop_memberships(std::string&& value) {
  coop_memberships_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ei.UserDataInfoResponse.coop_memberships)
}
inline void UserDataInfoResponse::add_coop_memberships(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  coop_memberships_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ei.UserDataInfoResponse.coop_memberships)
}
inline void UserDataInfoResponse::add_coop_memberships(const char* value, size_t size) {
  coop_memberships_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ei.UserDataInfoResponse.coop_memberships)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UserDataInfoResponse::coop_memberships() const {
  // @@protoc_insertion_point(field_list:ei.UserDataInfoResponse.coop_memberships)
  return coop_memberships_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UserDataInfoResponse::mutable_coop_memberships() {
  // @@protoc_insertion_point(field_mutable_list:ei.UserDataInfoResponse.coop_memberships)
  return &coop_memberships_;
}

// -------------------------------------------------------------------

// ClearAllUserDataRequest

// optional .ei.BasicRequestInfo rinfo = 4;
inline bool ClearAllUserDataRequest::_internal_has_rinfo() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || rinfo_ != nullptr);
  return value;
}
inline bool ClearAllUserDataRequest::has_rinfo() const {
  return _internal_has_rinfo();
}
inline void ClearAllUserDataRequest::clear_rinfo() {
  if (rinfo_ != nullptr) rinfo_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ei::BasicRequestInfo& ClearAllUserDataRequest::_internal_rinfo() const {
  const ::ei::BasicRequestInfo* p = rinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::BasicRequestInfo&>(
      ::ei::_BasicRequestInfo_default_instance_);
}
inline const ::ei::BasicRequestInfo& ClearAllUserDataRequest::rinfo() const {
  // @@protoc_insertion_point(field_get:ei.ClearAllUserDataRequest.rinfo)
  return _internal_rinfo();
}
inline void ClearAllUserDataRequest::unsafe_arena_set_allocated_rinfo(
    ::ei::BasicRequestInfo* rinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rinfo_);
  }
  rinfo_ = rinfo;
  if (rinfo) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.ClearAllUserDataRequest.rinfo)
}
inline ::ei::BasicRequestInfo* ClearAllUserDataRequest::release_rinfo() {
  _has_bits_[0] &= ~0x00000004u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::BasicRequestInfo* ClearAllUserDataRequest::unsafe_arena_release_rinfo() {
  // @@protoc_insertion_point(field_release:ei.ClearAllUserDataRequest.rinfo)
  _has_bits_[0] &= ~0x00000004u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
  return temp;
}
inline ::ei::BasicRequestInfo* ClearAllUserDataRequest::_internal_mutable_rinfo() {
  _has_bits_[0] |= 0x00000004u;
  if (rinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::BasicRequestInfo>(GetArenaForAllocation());
    rinfo_ = p;
  }
  return rinfo_;
}
inline ::ei::BasicRequestInfo* ClearAllUserDataRequest::mutable_rinfo() {
  ::ei::BasicRequestInfo* _msg = _internal_mutable_rinfo();
  // @@protoc_insertion_point(field_mutable:ei.ClearAllUserDataRequest.rinfo)
  return _msg;
}
inline void ClearAllUserDataRequest::set_allocated_rinfo(::ei::BasicRequestInfo* rinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rinfo_;
  }
  if (rinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::BasicRequestInfo>::GetOwningArena(rinfo);
    if (message_arena != submessage_arena) {
      rinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  rinfo_ = rinfo;
  // @@protoc_insertion_point(field_set_allocated:ei.ClearAllUserDataRequest.rinfo)
}

// optional string user_id = 1;
inline bool ClearAllUserDataRequest::_internal_has_user_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClearAllUserDataRequest::has_user_id() const {
  return _internal_has_user_id();
}
inline void ClearAllUserDataRequest::clear_user_id() {
  user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClearAllUserDataRequest::user_id() const {
  // @@protoc_insertion_point(field_get:ei.ClearAllUserDataRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClearAllUserDataRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ClearAllUserDataRequest.user_id)
}
inline std::string* ClearAllUserDataRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:ei.ClearAllUserDataRequest.user_id)
  return _s;
}
inline const std::string& ClearAllUserDataRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void ClearAllUserDataRequest::_internal_set_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ClearAllUserDataRequest::_internal_mutable_user_id() {
  _has_bits_[0] |= 0x00000001u;
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClearAllUserDataRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:ei.ClearAllUserDataRequest.user_id)
  if (!_internal_has_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClearAllUserDataRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ClearAllUserDataRequest.user_id)
}

// optional string device_id = 2;
inline bool ClearAllUserDataRequest::_internal_has_device_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ClearAllUserDataRequest::has_device_id() const {
  return _internal_has_device_id();
}
inline void ClearAllUserDataRequest::clear_device_id() {
  device_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ClearAllUserDataRequest::device_id() const {
  // @@protoc_insertion_point(field_get:ei.ClearAllUserDataRequest.device_id)
  return _internal_device_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClearAllUserDataRequest::set_device_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 device_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ClearAllUserDataRequest.device_id)
}
inline std::string* ClearAllUserDataRequest::mutable_device_id() {
  std::string* _s = _internal_mutable_device_id();
  // @@protoc_insertion_point(field_mutable:ei.ClearAllUserDataRequest.device_id)
  return _s;
}
inline const std::string& ClearAllUserDataRequest::_internal_device_id() const {
  return device_id_.Get();
}
inline void ClearAllUserDataRequest::_internal_set_device_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  device_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ClearAllUserDataRequest::_internal_mutable_device_id() {
  _has_bits_[0] |= 0x00000002u;
  return device_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClearAllUserDataRequest::release_device_id() {
  // @@protoc_insertion_point(field_release:ei.ClearAllUserDataRequest.device_id)
  if (!_internal_has_device_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = device_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClearAllUserDataRequest::set_allocated_device_id(std::string* device_id) {
  if (device_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  device_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ClearAllUserDataRequest.device_id)
}

// optional uint64 backup_checksum = 3;
inline bool ClearAllUserDataRequest::_internal_has_backup_checksum() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ClearAllUserDataRequest::has_backup_checksum() const {
  return _internal_has_backup_checksum();
}
inline void ClearAllUserDataRequest::clear_backup_checksum() {
  backup_checksum_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t ClearAllUserDataRequest::_internal_backup_checksum() const {
  return backup_checksum_;
}
inline uint64_t ClearAllUserDataRequest::backup_checksum() const {
  // @@protoc_insertion_point(field_get:ei.ClearAllUserDataRequest.backup_checksum)
  return _internal_backup_checksum();
}
inline void ClearAllUserDataRequest::_internal_set_backup_checksum(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  backup_checksum_ = value;
}
inline void ClearAllUserDataRequest::set_backup_checksum(uint64_t value) {
  _internal_set_backup_checksum(value);
  // @@protoc_insertion_point(field_set:ei.ClearAllUserDataRequest.backup_checksum)
}

// -------------------------------------------------------------------

// ServerGift

// optional string user_id = 1;
inline bool ServerGift::_internal_has_user_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ServerGift::has_user_id() const {
  return _internal_has_user_id();
}
inline void ServerGift::clear_user_id() {
  user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ServerGift::user_id() const {
  // @@protoc_insertion_point(field_get:ei.ServerGift.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerGift::set_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ServerGift.user_id)
}
inline std::string* ServerGift::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:ei.ServerGift.user_id)
  return _s;
}
inline const std::string& ServerGift::_internal_user_id() const {
  return user_id_.Get();
}
inline void ServerGift::_internal_set_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServerGift::_internal_mutable_user_id() {
  _has_bits_[0] |= 0x00000001u;
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServerGift::release_user_id() {
  // @@protoc_insertion_point(field_release:ei.ServerGift.user_id)
  if (!_internal_has_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ServerGift::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ServerGift.user_id)
}

// optional .ei.RewardType reward_type = 3;
inline bool ServerGift::_internal_has_reward_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ServerGift::has_reward_type() const {
  return _internal_has_reward_type();
}
inline void ServerGift::clear_reward_type() {
  reward_type_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::ei::RewardType ServerGift::_internal_reward_type() const {
  return static_cast< ::ei::RewardType >(reward_type_);
}
inline ::ei::RewardType ServerGift::reward_type() const {
  // @@protoc_insertion_point(field_get:ei.ServerGift.reward_type)
  return _internal_reward_type();
}
inline void ServerGift::_internal_set_reward_type(::ei::RewardType value) {
  assert(::ei::RewardType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  reward_type_ = value;
}
inline void ServerGift::set_reward_type(::ei::RewardType value) {
  _internal_set_reward_type(value);
  // @@protoc_insertion_point(field_set:ei.ServerGift.reward_type)
}

// optional string reward_sub_type = 4;
inline bool ServerGift::_internal_has_reward_sub_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ServerGift::has_reward_sub_type() const {
  return _internal_has_reward_sub_type();
}
inline void ServerGift::clear_reward_sub_type() {
  reward_sub_type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ServerGift::reward_sub_type() const {
  // @@protoc_insertion_point(field_get:ei.ServerGift.reward_sub_type)
  return _internal_reward_sub_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerGift::set_reward_sub_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 reward_sub_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ServerGift.reward_sub_type)
}
inline std::string* ServerGift::mutable_reward_sub_type() {
  std::string* _s = _internal_mutable_reward_sub_type();
  // @@protoc_insertion_point(field_mutable:ei.ServerGift.reward_sub_type)
  return _s;
}
inline const std::string& ServerGift::_internal_reward_sub_type() const {
  return reward_sub_type_.Get();
}
inline void ServerGift::_internal_set_reward_sub_type(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  reward_sub_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServerGift::_internal_mutable_reward_sub_type() {
  _has_bits_[0] |= 0x00000002u;
  return reward_sub_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServerGift::release_reward_sub_type() {
  // @@protoc_insertion_point(field_release:ei.ServerGift.reward_sub_type)
  if (!_internal_has_reward_sub_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = reward_sub_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (reward_sub_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    reward_sub_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ServerGift::set_allocated_reward_sub_type(std::string* reward_sub_type) {
  if (reward_sub_type != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  reward_sub_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reward_sub_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (reward_sub_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    reward_sub_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ServerGift.reward_sub_type)
}

// optional double reward_amount = 5;
inline bool ServerGift::_internal_has_reward_amount() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ServerGift::has_reward_amount() const {
  return _internal_has_reward_amount();
}
inline void ServerGift::clear_reward_amount() {
  reward_amount_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double ServerGift::_internal_reward_amount() const {
  return reward_amount_;
}
inline double ServerGift::reward_amount() const {
  // @@protoc_insertion_point(field_get:ei.ServerGift.reward_amount)
  return _internal_reward_amount();
}
inline void ServerGift::_internal_set_reward_amount(double value) {
  _has_bits_[0] |= 0x00000004u;
  reward_amount_ = value;
}
inline void ServerGift::set_reward_amount(double value) {
  _internal_set_reward_amount(value);
  // @@protoc_insertion_point(field_set:ei.ServerGift.reward_amount)
}

// -------------------------------------------------------------------

// LiveConfig_BoostsConfig_ItemConfig

// optional string boost_id = 1;
inline bool LiveConfig_BoostsConfig_ItemConfig::_internal_has_boost_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LiveConfig_BoostsConfig_ItemConfig::has_boost_id() const {
  return _internal_has_boost_id();
}
inline void LiveConfig_BoostsConfig_ItemConfig::clear_boost_id() {
  boost_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LiveConfig_BoostsConfig_ItemConfig::boost_id() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.BoostsConfig.ItemConfig.boost_id)
  return _internal_boost_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LiveConfig_BoostsConfig_ItemConfig::set_boost_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 boost_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.LiveConfig.BoostsConfig.ItemConfig.boost_id)
}
inline std::string* LiveConfig_BoostsConfig_ItemConfig::mutable_boost_id() {
  std::string* _s = _internal_mutable_boost_id();
  // @@protoc_insertion_point(field_mutable:ei.LiveConfig.BoostsConfig.ItemConfig.boost_id)
  return _s;
}
inline const std::string& LiveConfig_BoostsConfig_ItemConfig::_internal_boost_id() const {
  return boost_id_.Get();
}
inline void LiveConfig_BoostsConfig_ItemConfig::_internal_set_boost_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  boost_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LiveConfig_BoostsConfig_ItemConfig::_internal_mutable_boost_id() {
  _has_bits_[0] |= 0x00000001u;
  return boost_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LiveConfig_BoostsConfig_ItemConfig::release_boost_id() {
  // @@protoc_insertion_point(field_release:ei.LiveConfig.BoostsConfig.ItemConfig.boost_id)
  if (!_internal_has_boost_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = boost_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (boost_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    boost_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LiveConfig_BoostsConfig_ItemConfig::set_allocated_boost_id(std::string* boost_id) {
  if (boost_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  boost_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), boost_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (boost_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    boost_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.LiveConfig.BoostsConfig.ItemConfig.boost_id)
}

// optional uint32 price = 2;
inline bool LiveConfig_BoostsConfig_ItemConfig::_internal_has_price() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LiveConfig_BoostsConfig_ItemConfig::has_price() const {
  return _internal_has_price();
}
inline void LiveConfig_BoostsConfig_ItemConfig::clear_price() {
  price_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t LiveConfig_BoostsConfig_ItemConfig::_internal_price() const {
  return price_;
}
inline uint32_t LiveConfig_BoostsConfig_ItemConfig::price() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.BoostsConfig.ItemConfig.price)
  return _internal_price();
}
inline void LiveConfig_BoostsConfig_ItemConfig::_internal_set_price(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  price_ = value;
}
inline void LiveConfig_BoostsConfig_ItemConfig::set_price(uint32_t value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.BoostsConfig.ItemConfig.price)
}

// optional uint32 token_price = 3;
inline bool LiveConfig_BoostsConfig_ItemConfig::_internal_has_token_price() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LiveConfig_BoostsConfig_ItemConfig::has_token_price() const {
  return _internal_has_token_price();
}
inline void LiveConfig_BoostsConfig_ItemConfig::clear_token_price() {
  token_price_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t LiveConfig_BoostsConfig_ItemConfig::_internal_token_price() const {
  return token_price_;
}
inline uint32_t LiveConfig_BoostsConfig_ItemConfig::token_price() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.BoostsConfig.ItemConfig.token_price)
  return _internal_token_price();
}
inline void LiveConfig_BoostsConfig_ItemConfig::_internal_set_token_price(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  token_price_ = value;
}
inline void LiveConfig_BoostsConfig_ItemConfig::set_token_price(uint32_t value) {
  _internal_set_token_price(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.BoostsConfig.ItemConfig.token_price)
}

// optional double se_required = 4;
inline bool LiveConfig_BoostsConfig_ItemConfig::_internal_has_se_required() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LiveConfig_BoostsConfig_ItemConfig::has_se_required() const {
  return _internal_has_se_required();
}
inline void LiveConfig_BoostsConfig_ItemConfig::clear_se_required() {
  se_required_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double LiveConfig_BoostsConfig_ItemConfig::_internal_se_required() const {
  return se_required_;
}
inline double LiveConfig_BoostsConfig_ItemConfig::se_required() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.BoostsConfig.ItemConfig.se_required)
  return _internal_se_required();
}
inline void LiveConfig_BoostsConfig_ItemConfig::_internal_set_se_required(double value) {
  _has_bits_[0] |= 0x00000008u;
  se_required_ = value;
}
inline void LiveConfig_BoostsConfig_ItemConfig::set_se_required(double value) {
  _internal_set_se_required(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.BoostsConfig.ItemConfig.se_required)
}

// -------------------------------------------------------------------

// LiveConfig_BoostsConfig

// repeated .ei.LiveConfig.BoostsConfig.ItemConfig item_configs = 1;
inline int LiveConfig_BoostsConfig::_internal_item_configs_size() const {
  return item_configs_.size();
}
inline int LiveConfig_BoostsConfig::item_configs_size() const {
  return _internal_item_configs_size();
}
inline void LiveConfig_BoostsConfig::clear_item_configs() {
  item_configs_.Clear();
}
inline ::ei::LiveConfig_BoostsConfig_ItemConfig* LiveConfig_BoostsConfig::mutable_item_configs(int index) {
  // @@protoc_insertion_point(field_mutable:ei.LiveConfig.BoostsConfig.item_configs)
  return item_configs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::LiveConfig_BoostsConfig_ItemConfig >*
LiveConfig_BoostsConfig::mutable_item_configs() {
  // @@protoc_insertion_point(field_mutable_list:ei.LiveConfig.BoostsConfig.item_configs)
  return &item_configs_;
}
inline const ::ei::LiveConfig_BoostsConfig_ItemConfig& LiveConfig_BoostsConfig::_internal_item_configs(int index) const {
  return item_configs_.Get(index);
}
inline const ::ei::LiveConfig_BoostsConfig_ItemConfig& LiveConfig_BoostsConfig::item_configs(int index) const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.BoostsConfig.item_configs)
  return _internal_item_configs(index);
}
inline ::ei::LiveConfig_BoostsConfig_ItemConfig* LiveConfig_BoostsConfig::_internal_add_item_configs() {
  return item_configs_.Add();
}
inline ::ei::LiveConfig_BoostsConfig_ItemConfig* LiveConfig_BoostsConfig::add_item_configs() {
  ::ei::LiveConfig_BoostsConfig_ItemConfig* _add = _internal_add_item_configs();
  // @@protoc_insertion_point(field_add:ei.LiveConfig.BoostsConfig.item_configs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::LiveConfig_BoostsConfig_ItemConfig >&
LiveConfig_BoostsConfig::item_configs() const {
  // @@protoc_insertion_point(field_list:ei.LiveConfig.BoostsConfig.item_configs)
  return item_configs_;
}

// optional double cash_boost_cooloff_time = 2;
inline bool LiveConfig_BoostsConfig::_internal_has_cash_boost_cooloff_time() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LiveConfig_BoostsConfig::has_cash_boost_cooloff_time() const {
  return _internal_has_cash_boost_cooloff_time();
}
inline void LiveConfig_BoostsConfig::clear_cash_boost_cooloff_time() {
  cash_boost_cooloff_time_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double LiveConfig_BoostsConfig::_internal_cash_boost_cooloff_time() const {
  return cash_boost_cooloff_time_;
}
inline double LiveConfig_BoostsConfig::cash_boost_cooloff_time() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.BoostsConfig.cash_boost_cooloff_time)
  return _internal_cash_boost_cooloff_time();
}
inline void LiveConfig_BoostsConfig::_internal_set_cash_boost_cooloff_time(double value) {
  _has_bits_[0] |= 0x00000001u;
  cash_boost_cooloff_time_ = value;
}
inline void LiveConfig_BoostsConfig::set_cash_boost_cooloff_time(double value) {
  _internal_set_cash_boost_cooloff_time(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.BoostsConfig.cash_boost_cooloff_time)
}

// -------------------------------------------------------------------

// LiveConfig_GiftConfig_GiftValueConfig

// optional string gift_id = 1;
inline bool LiveConfig_GiftConfig_GiftValueConfig::_internal_has_gift_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LiveConfig_GiftConfig_GiftValueConfig::has_gift_id() const {
  return _internal_has_gift_id();
}
inline void LiveConfig_GiftConfig_GiftValueConfig::clear_gift_id() {
  gift_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LiveConfig_GiftConfig_GiftValueConfig::gift_id() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.GiftConfig.GiftValueConfig.gift_id)
  return _internal_gift_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LiveConfig_GiftConfig_GiftValueConfig::set_gift_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 gift_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.LiveConfig.GiftConfig.GiftValueConfig.gift_id)
}
inline std::string* LiveConfig_GiftConfig_GiftValueConfig::mutable_gift_id() {
  std::string* _s = _internal_mutable_gift_id();
  // @@protoc_insertion_point(field_mutable:ei.LiveConfig.GiftConfig.GiftValueConfig.gift_id)
  return _s;
}
inline const std::string& LiveConfig_GiftConfig_GiftValueConfig::_internal_gift_id() const {
  return gift_id_.Get();
}
inline void LiveConfig_GiftConfig_GiftValueConfig::_internal_set_gift_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  gift_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LiveConfig_GiftConfig_GiftValueConfig::_internal_mutable_gift_id() {
  _has_bits_[0] |= 0x00000001u;
  return gift_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LiveConfig_GiftConfig_GiftValueConfig::release_gift_id() {
  // @@protoc_insertion_point(field_release:ei.LiveConfig.GiftConfig.GiftValueConfig.gift_id)
  if (!_internal_has_gift_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = gift_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (gift_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    gift_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LiveConfig_GiftConfig_GiftValueConfig::set_allocated_gift_id(std::string* gift_id) {
  if (gift_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  gift_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gift_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (gift_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    gift_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.LiveConfig.GiftConfig.GiftValueConfig.gift_id)
}

// optional double amount = 4;
inline bool LiveConfig_GiftConfig_GiftValueConfig::_internal_has_amount() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LiveConfig_GiftConfig_GiftValueConfig::has_amount() const {
  return _internal_has_amount();
}
inline void LiveConfig_GiftConfig_GiftValueConfig::clear_amount() {
  amount_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double LiveConfig_GiftConfig_GiftValueConfig::_internal_amount() const {
  return amount_;
}
inline double LiveConfig_GiftConfig_GiftValueConfig::amount() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.GiftConfig.GiftValueConfig.amount)
  return _internal_amount();
}
inline void LiveConfig_GiftConfig_GiftValueConfig::_internal_set_amount(double value) {
  _has_bits_[0] |= 0x00000008u;
  amount_ = value;
}
inline void LiveConfig_GiftConfig_GiftValueConfig::set_amount(double value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.GiftConfig.GiftValueConfig.amount)
}

// optional double rand_min = 2;
inline bool LiveConfig_GiftConfig_GiftValueConfig::_internal_has_rand_min() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LiveConfig_GiftConfig_GiftValueConfig::has_rand_min() const {
  return _internal_has_rand_min();
}
inline void LiveConfig_GiftConfig_GiftValueConfig::clear_rand_min() {
  rand_min_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double LiveConfig_GiftConfig_GiftValueConfig::_internal_rand_min() const {
  return rand_min_;
}
inline double LiveConfig_GiftConfig_GiftValueConfig::rand_min() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.GiftConfig.GiftValueConfig.rand_min)
  return _internal_rand_min();
}
inline void LiveConfig_GiftConfig_GiftValueConfig::_internal_set_rand_min(double value) {
  _has_bits_[0] |= 0x00000002u;
  rand_min_ = value;
}
inline void LiveConfig_GiftConfig_GiftValueConfig::set_rand_min(double value) {
  _internal_set_rand_min(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.GiftConfig.GiftValueConfig.rand_min)
}

// optional double rand_max = 3;
inline bool LiveConfig_GiftConfig_GiftValueConfig::_internal_has_rand_max() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LiveConfig_GiftConfig_GiftValueConfig::has_rand_max() const {
  return _internal_has_rand_max();
}
inline void LiveConfig_GiftConfig_GiftValueConfig::clear_rand_max() {
  rand_max_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double LiveConfig_GiftConfig_GiftValueConfig::_internal_rand_max() const {
  return rand_max_;
}
inline double LiveConfig_GiftConfig_GiftValueConfig::rand_max() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.GiftConfig.GiftValueConfig.rand_max)
  return _internal_rand_max();
}
inline void LiveConfig_GiftConfig_GiftValueConfig::_internal_set_rand_max(double value) {
  _has_bits_[0] |= 0x00000004u;
  rand_max_ = value;
}
inline void LiveConfig_GiftConfig_GiftValueConfig::set_rand_max(double value) {
  _internal_set_rand_max(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.GiftConfig.GiftValueConfig.rand_max)
}

// optional double video_min = 5;
inline bool LiveConfig_GiftConfig_GiftValueConfig::_internal_has_video_min() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LiveConfig_GiftConfig_GiftValueConfig::has_video_min() const {
  return _internal_has_video_min();
}
inline void LiveConfig_GiftConfig_GiftValueConfig::clear_video_min() {
  video_min_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double LiveConfig_GiftConfig_GiftValueConfig::_internal_video_min() const {
  return video_min_;
}
inline double LiveConfig_GiftConfig_GiftValueConfig::video_min() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.GiftConfig.GiftValueConfig.video_min)
  return _internal_video_min();
}
inline void LiveConfig_GiftConfig_GiftValueConfig::_internal_set_video_min(double value) {
  _has_bits_[0] |= 0x00000010u;
  video_min_ = value;
}
inline void LiveConfig_GiftConfig_GiftValueConfig::set_video_min(double value) {
  _internal_set_video_min(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.GiftConfig.GiftValueConfig.video_min)
}

// optional double video_max = 6;
inline bool LiveConfig_GiftConfig_GiftValueConfig::_internal_has_video_max() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LiveConfig_GiftConfig_GiftValueConfig::has_video_max() const {
  return _internal_has_video_max();
}
inline void LiveConfig_GiftConfig_GiftValueConfig::clear_video_max() {
  video_max_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double LiveConfig_GiftConfig_GiftValueConfig::_internal_video_max() const {
  return video_max_;
}
inline double LiveConfig_GiftConfig_GiftValueConfig::video_max() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.GiftConfig.GiftValueConfig.video_max)
  return _internal_video_max();
}
inline void LiveConfig_GiftConfig_GiftValueConfig::_internal_set_video_max(double value) {
  _has_bits_[0] |= 0x00000020u;
  video_max_ = value;
}
inline void LiveConfig_GiftConfig_GiftValueConfig::set_video_max(double value) {
  _internal_set_video_max(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.GiftConfig.GiftValueConfig.video_max)
}

// -------------------------------------------------------------------

// LiveConfig_GiftConfig_GiftMuConfig

// optional double min_spent = 1;
inline bool LiveConfig_GiftConfig_GiftMuConfig::_internal_has_min_spent() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LiveConfig_GiftConfig_GiftMuConfig::has_min_spent() const {
  return _internal_has_min_spent();
}
inline void LiveConfig_GiftConfig_GiftMuConfig::clear_min_spent() {
  min_spent_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double LiveConfig_GiftConfig_GiftMuConfig::_internal_min_spent() const {
  return min_spent_;
}
inline double LiveConfig_GiftConfig_GiftMuConfig::min_spent() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.GiftConfig.GiftMuConfig.min_spent)
  return _internal_min_spent();
}
inline void LiveConfig_GiftConfig_GiftMuConfig::_internal_set_min_spent(double value) {
  _has_bits_[0] |= 0x00000001u;
  min_spent_ = value;
}
inline void LiveConfig_GiftConfig_GiftMuConfig::set_min_spent(double value) {
  _internal_set_min_spent(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.GiftConfig.GiftMuConfig.min_spent)
}

// optional double max_spent = 2;
inline bool LiveConfig_GiftConfig_GiftMuConfig::_internal_has_max_spent() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LiveConfig_GiftConfig_GiftMuConfig::has_max_spent() const {
  return _internal_has_max_spent();
}
inline void LiveConfig_GiftConfig_GiftMuConfig::clear_max_spent() {
  max_spent_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double LiveConfig_GiftConfig_GiftMuConfig::_internal_max_spent() const {
  return max_spent_;
}
inline double LiveConfig_GiftConfig_GiftMuConfig::max_spent() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.GiftConfig.GiftMuConfig.max_spent)
  return _internal_max_spent();
}
inline void LiveConfig_GiftConfig_GiftMuConfig::_internal_set_max_spent(double value) {
  _has_bits_[0] |= 0x00000002u;
  max_spent_ = value;
}
inline void LiveConfig_GiftConfig_GiftMuConfig::set_max_spent(double value) {
  _internal_set_max_spent(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.GiftConfig.GiftMuConfig.max_spent)
}

// optional double overall_mult = 3;
inline bool LiveConfig_GiftConfig_GiftMuConfig::_internal_has_overall_mult() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LiveConfig_GiftConfig_GiftMuConfig::has_overall_mult() const {
  return _internal_has_overall_mult();
}
inline void LiveConfig_GiftConfig_GiftMuConfig::clear_overall_mult() {
  overall_mult_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double LiveConfig_GiftConfig_GiftMuConfig::_internal_overall_mult() const {
  return overall_mult_;
}
inline double LiveConfig_GiftConfig_GiftMuConfig::overall_mult() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.GiftConfig.GiftMuConfig.overall_mult)
  return _internal_overall_mult();
}
inline void LiveConfig_GiftConfig_GiftMuConfig::_internal_set_overall_mult(double value) {
  _has_bits_[0] |= 0x00000004u;
  overall_mult_ = value;
}
inline void LiveConfig_GiftConfig_GiftMuConfig::set_overall_mult(double value) {
  _internal_set_overall_mult(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.GiftConfig.GiftMuConfig.overall_mult)
}

// -------------------------------------------------------------------

// LiveConfig_GiftConfig

// repeated .ei.LiveConfig.GiftConfig.GiftValueConfig gift_configs = 9;
inline int LiveConfig_GiftConfig::_internal_gift_configs_size() const {
  return gift_configs_.size();
}
inline int LiveConfig_GiftConfig::gift_configs_size() const {
  return _internal_gift_configs_size();
}
inline void LiveConfig_GiftConfig::clear_gift_configs() {
  gift_configs_.Clear();
}
inline ::ei::LiveConfig_GiftConfig_GiftValueConfig* LiveConfig_GiftConfig::mutable_gift_configs(int index) {
  // @@protoc_insertion_point(field_mutable:ei.LiveConfig.GiftConfig.gift_configs)
  return gift_configs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::LiveConfig_GiftConfig_GiftValueConfig >*
LiveConfig_GiftConfig::mutable_gift_configs() {
  // @@protoc_insertion_point(field_mutable_list:ei.LiveConfig.GiftConfig.gift_configs)
  return &gift_configs_;
}
inline const ::ei::LiveConfig_GiftConfig_GiftValueConfig& LiveConfig_GiftConfig::_internal_gift_configs(int index) const {
  return gift_configs_.Get(index);
}
inline const ::ei::LiveConfig_GiftConfig_GiftValueConfig& LiveConfig_GiftConfig::gift_configs(int index) const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.GiftConfig.gift_configs)
  return _internal_gift_configs(index);
}
inline ::ei::LiveConfig_GiftConfig_GiftValueConfig* LiveConfig_GiftConfig::_internal_add_gift_configs() {
  return gift_configs_.Add();
}
inline ::ei::LiveConfig_GiftConfig_GiftValueConfig* LiveConfig_GiftConfig::add_gift_configs() {
  ::ei::LiveConfig_GiftConfig_GiftValueConfig* _add = _internal_add_gift_configs();
  // @@protoc_insertion_point(field_add:ei.LiveConfig.GiftConfig.gift_configs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::LiveConfig_GiftConfig_GiftValueConfig >&
LiveConfig_GiftConfig::gift_configs() const {
  // @@protoc_insertion_point(field_list:ei.LiveConfig.GiftConfig.gift_configs)
  return gift_configs_;
}

// optional double gift_mu_min_spent = 10;
inline bool LiveConfig_GiftConfig::_internal_has_gift_mu_min_spent() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool LiveConfig_GiftConfig::has_gift_mu_min_spent() const {
  return _internal_has_gift_mu_min_spent();
}
inline void LiveConfig_GiftConfig::clear_gift_mu_min_spent() {
  gift_mu_min_spent_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline double LiveConfig_GiftConfig::_internal_gift_mu_min_spent() const {
  return gift_mu_min_spent_;
}
inline double LiveConfig_GiftConfig::gift_mu_min_spent() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.GiftConfig.gift_mu_min_spent)
  return _internal_gift_mu_min_spent();
}
inline void LiveConfig_GiftConfig::_internal_set_gift_mu_min_spent(double value) {
  _has_bits_[0] |= 0x00000400u;
  gift_mu_min_spent_ = value;
}
inline void LiveConfig_GiftConfig::set_gift_mu_min_spent(double value) {
  _internal_set_gift_mu_min_spent(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.GiftConfig.gift_mu_min_spent)
}

// optional double gift_mu_max_spent = 11;
inline bool LiveConfig_GiftConfig::_internal_has_gift_mu_max_spent() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool LiveConfig_GiftConfig::has_gift_mu_max_spent() const {
  return _internal_has_gift_mu_max_spent();
}
inline void LiveConfig_GiftConfig::clear_gift_mu_max_spent() {
  gift_mu_max_spent_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline double LiveConfig_GiftConfig::_internal_gift_mu_max_spent() const {
  return gift_mu_max_spent_;
}
inline double LiveConfig_GiftConfig::gift_mu_max_spent() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.GiftConfig.gift_mu_max_spent)
  return _internal_gift_mu_max_spent();
}
inline void LiveConfig_GiftConfig::_internal_set_gift_mu_max_spent(double value) {
  _has_bits_[0] |= 0x00000800u;
  gift_mu_max_spent_ = value;
}
inline void LiveConfig_GiftConfig::set_gift_mu_max_spent(double value) {
  _internal_set_gift_mu_max_spent(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.GiftConfig.gift_mu_max_spent)
}

// optional double gift_mu_overall_mult = 12;
inline bool LiveConfig_GiftConfig::_internal_has_gift_mu_overall_mult() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool LiveConfig_GiftConfig::has_gift_mu_overall_mult() const {
  return _internal_has_gift_mu_overall_mult();
}
inline void LiveConfig_GiftConfig::clear_gift_mu_overall_mult() {
  gift_mu_overall_mult_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline double LiveConfig_GiftConfig::_internal_gift_mu_overall_mult() const {
  return gift_mu_overall_mult_;
}
inline double LiveConfig_GiftConfig::gift_mu_overall_mult() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.GiftConfig.gift_mu_overall_mult)
  return _internal_gift_mu_overall_mult();
}
inline void LiveConfig_GiftConfig::_internal_set_gift_mu_overall_mult(double value) {
  _has_bits_[0] |= 0x00001000u;
  gift_mu_overall_mult_ = value;
}
inline void LiveConfig_GiftConfig::set_gift_mu_overall_mult(double value) {
  _internal_set_gift_mu_overall_mult(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.GiftConfig.gift_mu_overall_mult)
}

// optional .ei.LiveConfig.GiftConfig.GiftMuConfig random_gift_mu_config = 15;
inline bool LiveConfig_GiftConfig::_internal_has_random_gift_mu_config() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || random_gift_mu_config_ != nullptr);
  return value;
}
inline bool LiveConfig_GiftConfig::has_random_gift_mu_config() const {
  return _internal_has_random_gift_mu_config();
}
inline void LiveConfig_GiftConfig::clear_random_gift_mu_config() {
  if (random_gift_mu_config_ != nullptr) random_gift_mu_config_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ei::LiveConfig_GiftConfig_GiftMuConfig& LiveConfig_GiftConfig::_internal_random_gift_mu_config() const {
  const ::ei::LiveConfig_GiftConfig_GiftMuConfig* p = random_gift_mu_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::LiveConfig_GiftConfig_GiftMuConfig&>(
      ::ei::_LiveConfig_GiftConfig_GiftMuConfig_default_instance_);
}
inline const ::ei::LiveConfig_GiftConfig_GiftMuConfig& LiveConfig_GiftConfig::random_gift_mu_config() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.GiftConfig.random_gift_mu_config)
  return _internal_random_gift_mu_config();
}
inline void LiveConfig_GiftConfig::unsafe_arena_set_allocated_random_gift_mu_config(
    ::ei::LiveConfig_GiftConfig_GiftMuConfig* random_gift_mu_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(random_gift_mu_config_);
  }
  random_gift_mu_config_ = random_gift_mu_config;
  if (random_gift_mu_config) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.LiveConfig.GiftConfig.random_gift_mu_config)
}
inline ::ei::LiveConfig_GiftConfig_GiftMuConfig* LiveConfig_GiftConfig::release_random_gift_mu_config() {
  _has_bits_[0] &= ~0x00000001u;
  ::ei::LiveConfig_GiftConfig_GiftMuConfig* temp = random_gift_mu_config_;
  random_gift_mu_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::LiveConfig_GiftConfig_GiftMuConfig* LiveConfig_GiftConfig::unsafe_arena_release_random_gift_mu_config() {
  // @@protoc_insertion_point(field_release:ei.LiveConfig.GiftConfig.random_gift_mu_config)
  _has_bits_[0] &= ~0x00000001u;
  ::ei::LiveConfig_GiftConfig_GiftMuConfig* temp = random_gift_mu_config_;
  random_gift_mu_config_ = nullptr;
  return temp;
}
inline ::ei::LiveConfig_GiftConfig_GiftMuConfig* LiveConfig_GiftConfig::_internal_mutable_random_gift_mu_config() {
  _has_bits_[0] |= 0x00000001u;
  if (random_gift_mu_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::LiveConfig_GiftConfig_GiftMuConfig>(GetArenaForAllocation());
    random_gift_mu_config_ = p;
  }
  return random_gift_mu_config_;
}
inline ::ei::LiveConfig_GiftConfig_GiftMuConfig* LiveConfig_GiftConfig::mutable_random_gift_mu_config() {
  ::ei::LiveConfig_GiftConfig_GiftMuConfig* _msg = _internal_mutable_random_gift_mu_config();
  // @@protoc_insertion_point(field_mutable:ei.LiveConfig.GiftConfig.random_gift_mu_config)
  return _msg;
}
inline void LiveConfig_GiftConfig::set_allocated_random_gift_mu_config(::ei::LiveConfig_GiftConfig_GiftMuConfig* random_gift_mu_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete random_gift_mu_config_;
  }
  if (random_gift_mu_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::LiveConfig_GiftConfig_GiftMuConfig>::GetOwningArena(random_gift_mu_config);
    if (message_arena != submessage_arena) {
      random_gift_mu_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, random_gift_mu_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  random_gift_mu_config_ = random_gift_mu_config;
  // @@protoc_insertion_point(field_set_allocated:ei.LiveConfig.GiftConfig.random_gift_mu_config)
}

// optional .ei.LiveConfig.GiftConfig.GiftMuConfig video_gift_mu_config = 16;
inline bool LiveConfig_GiftConfig::_internal_has_video_gift_mu_config() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || video_gift_mu_config_ != nullptr);
  return value;
}
inline bool LiveConfig_GiftConfig::has_video_gift_mu_config() const {
  return _internal_has_video_gift_mu_config();
}
inline void LiveConfig_GiftConfig::clear_video_gift_mu_config() {
  if (video_gift_mu_config_ != nullptr) video_gift_mu_config_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ei::LiveConfig_GiftConfig_GiftMuConfig& LiveConfig_GiftConfig::_internal_video_gift_mu_config() const {
  const ::ei::LiveConfig_GiftConfig_GiftMuConfig* p = video_gift_mu_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::LiveConfig_GiftConfig_GiftMuConfig&>(
      ::ei::_LiveConfig_GiftConfig_GiftMuConfig_default_instance_);
}
inline const ::ei::LiveConfig_GiftConfig_GiftMuConfig& LiveConfig_GiftConfig::video_gift_mu_config() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.GiftConfig.video_gift_mu_config)
  return _internal_video_gift_mu_config();
}
inline void LiveConfig_GiftConfig::unsafe_arena_set_allocated_video_gift_mu_config(
    ::ei::LiveConfig_GiftConfig_GiftMuConfig* video_gift_mu_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(video_gift_mu_config_);
  }
  video_gift_mu_config_ = video_gift_mu_config;
  if (video_gift_mu_config) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.LiveConfig.GiftConfig.video_gift_mu_config)
}
inline ::ei::LiveConfig_GiftConfig_GiftMuConfig* LiveConfig_GiftConfig::release_video_gift_mu_config() {
  _has_bits_[0] &= ~0x00000002u;
  ::ei::LiveConfig_GiftConfig_GiftMuConfig* temp = video_gift_mu_config_;
  video_gift_mu_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::LiveConfig_GiftConfig_GiftMuConfig* LiveConfig_GiftConfig::unsafe_arena_release_video_gift_mu_config() {
  // @@protoc_insertion_point(field_release:ei.LiveConfig.GiftConfig.video_gift_mu_config)
  _has_bits_[0] &= ~0x00000002u;
  ::ei::LiveConfig_GiftConfig_GiftMuConfig* temp = video_gift_mu_config_;
  video_gift_mu_config_ = nullptr;
  return temp;
}
inline ::ei::LiveConfig_GiftConfig_GiftMuConfig* LiveConfig_GiftConfig::_internal_mutable_video_gift_mu_config() {
  _has_bits_[0] |= 0x00000002u;
  if (video_gift_mu_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::LiveConfig_GiftConfig_GiftMuConfig>(GetArenaForAllocation());
    video_gift_mu_config_ = p;
  }
  return video_gift_mu_config_;
}
inline ::ei::LiveConfig_GiftConfig_GiftMuConfig* LiveConfig_GiftConfig::mutable_video_gift_mu_config() {
  ::ei::LiveConfig_GiftConfig_GiftMuConfig* _msg = _internal_mutable_video_gift_mu_config();
  // @@protoc_insertion_point(field_mutable:ei.LiveConfig.GiftConfig.video_gift_mu_config)
  return _msg;
}
inline void LiveConfig_GiftConfig::set_allocated_video_gift_mu_config(::ei::LiveConfig_GiftConfig_GiftMuConfig* video_gift_mu_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete video_gift_mu_config_;
  }
  if (video_gift_mu_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::LiveConfig_GiftConfig_GiftMuConfig>::GetOwningArena(video_gift_mu_config);
    if (message_arena != submessage_arena) {
      video_gift_mu_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, video_gift_mu_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  video_gift_mu_config_ = video_gift_mu_config;
  // @@protoc_insertion_point(field_set_allocated:ei.LiveConfig.GiftConfig.video_gift_mu_config)
}

// optional double package_interval = 1;
inline bool LiveConfig_GiftConfig::_internal_has_package_interval() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LiveConfig_GiftConfig::has_package_interval() const {
  return _internal_has_package_interval();
}
inline void LiveConfig_GiftConfig::clear_package_interval() {
  package_interval_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double LiveConfig_GiftConfig::_internal_package_interval() const {
  return package_interval_;
}
inline double LiveConfig_GiftConfig::package_interval() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.GiftConfig.package_interval)
  return _internal_package_interval();
}
inline void LiveConfig_GiftConfig::_internal_set_package_interval(double value) {
  _has_bits_[0] |= 0x00000004u;
  package_interval_ = value;
}
inline void LiveConfig_GiftConfig::set_package_interval(double value) {
  _internal_set_package_interval(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.GiftConfig.package_interval)
}

// optional double video_offer_interval = 2;
inline bool LiveConfig_GiftConfig::_internal_has_video_offer_interval() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LiveConfig_GiftConfig::has_video_offer_interval() const {
  return _internal_has_video_offer_interval();
}
inline void LiveConfig_GiftConfig::clear_video_offer_interval() {
  video_offer_interval_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double LiveConfig_GiftConfig::_internal_video_offer_interval() const {
  return video_offer_interval_;
}
inline double LiveConfig_GiftConfig::video_offer_interval() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.GiftConfig.video_offer_interval)
  return _internal_video_offer_interval();
}
inline void LiveConfig_GiftConfig::_internal_set_video_offer_interval(double value) {
  _has_bits_[0] |= 0x00000008u;
  video_offer_interval_ = value;
}
inline void LiveConfig_GiftConfig::set_video_offer_interval(double value) {
  _internal_set_video_offer_interval(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.GiftConfig.video_offer_interval)
}

// optional double video_offer_interval_contract = 3;
inline bool LiveConfig_GiftConfig::_internal_has_video_offer_interval_contract() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LiveConfig_GiftConfig::has_video_offer_interval_contract() const {
  return _internal_has_video_offer_interval_contract();
}
inline void LiveConfig_GiftConfig::clear_video_offer_interval_contract() {
  video_offer_interval_contract_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double LiveConfig_GiftConfig::_internal_video_offer_interval_contract() const {
  return video_offer_interval_contract_;
}
inline double LiveConfig_GiftConfig::video_offer_interval_contract() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.GiftConfig.video_offer_interval_contract)
  return _internal_video_offer_interval_contract();
}
inline void LiveConfig_GiftConfig::_internal_set_video_offer_interval_contract(double value) {
  _has_bits_[0] |= 0x00000010u;
  video_offer_interval_contract_ = value;
}
inline void LiveConfig_GiftConfig::set_video_offer_interval_contract(double value) {
  _internal_set_video_offer_interval_contract(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.GiftConfig.video_offer_interval_contract)
}

// optional double video_offer_interval_piggy_full = 4;
inline bool LiveConfig_GiftConfig::_internal_has_video_offer_interval_piggy_full() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LiveConfig_GiftConfig::has_video_offer_interval_piggy_full() const {
  return _internal_has_video_offer_interval_piggy_full();
}
inline void LiveConfig_GiftConfig::clear_video_offer_interval_piggy_full() {
  video_offer_interval_piggy_full_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double LiveConfig_GiftConfig::_internal_video_offer_interval_piggy_full() const {
  return video_offer_interval_piggy_full_;
}
inline double LiveConfig_GiftConfig::video_offer_interval_piggy_full() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.GiftConfig.video_offer_interval_piggy_full)
  return _internal_video_offer_interval_piggy_full();
}
inline void LiveConfig_GiftConfig::_internal_set_video_offer_interval_piggy_full(double value) {
  _has_bits_[0] |= 0x00000020u;
  video_offer_interval_piggy_full_ = value;
}
inline void LiveConfig_GiftConfig::set_video_offer_interval_piggy_full(double value) {
  _internal_set_video_offer_interval_piggy_full(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.GiftConfig.video_offer_interval_piggy_full)
}

// optional double video_offer_interval_piggy_extra_full = 5;
inline bool LiveConfig_GiftConfig::_internal_has_video_offer_interval_piggy_extra_full() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool LiveConfig_GiftConfig::has_video_offer_interval_piggy_extra_full() const {
  return _internal_has_video_offer_interval_piggy_extra_full();
}
inline void LiveConfig_GiftConfig::clear_video_offer_interval_piggy_extra_full() {
  video_offer_interval_piggy_extra_full_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double LiveConfig_GiftConfig::_internal_video_offer_interval_piggy_extra_full() const {
  return video_offer_interval_piggy_extra_full_;
}
inline double LiveConfig_GiftConfig::video_offer_interval_piggy_extra_full() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.GiftConfig.video_offer_interval_piggy_extra_full)
  return _internal_video_offer_interval_piggy_extra_full();
}
inline void LiveConfig_GiftConfig::_internal_set_video_offer_interval_piggy_extra_full(double value) {
  _has_bits_[0] |= 0x00000040u;
  video_offer_interval_piggy_extra_full_ = value;
}
inline void LiveConfig_GiftConfig::set_video_offer_interval_piggy_extra_full(double value) {
  _internal_set_video_offer_interval_piggy_extra_full(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.GiftConfig.video_offer_interval_piggy_extra_full)
}

// optional bool video_reset_on_idle = 14;
inline bool LiveConfig_GiftConfig::_internal_has_video_reset_on_idle() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool LiveConfig_GiftConfig::has_video_reset_on_idle() const {
  return _internal_has_video_reset_on_idle();
}
inline void LiveConfig_GiftConfig::clear_video_reset_on_idle() {
  video_reset_on_idle_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool LiveConfig_GiftConfig::_internal_video_reset_on_idle() const {
  return video_reset_on_idle_;
}
inline bool LiveConfig_GiftConfig::video_reset_on_idle() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.GiftConfig.video_reset_on_idle)
  return _internal_video_reset_on_idle();
}
inline void LiveConfig_GiftConfig::_internal_set_video_reset_on_idle(bool value) {
  _has_bits_[0] |= 0x00002000u;
  video_reset_on_idle_ = value;
}
inline void LiveConfig_GiftConfig::set_video_reset_on_idle(bool value) {
  _internal_set_video_reset_on_idle(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.GiftConfig.video_reset_on_idle)
}

// optional double package_interval_contract = 6;
inline bool LiveConfig_GiftConfig::_internal_has_package_interval_contract() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool LiveConfig_GiftConfig::has_package_interval_contract() const {
  return _internal_has_package_interval_contract();
}
inline void LiveConfig_GiftConfig::clear_package_interval_contract() {
  package_interval_contract_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline double LiveConfig_GiftConfig::_internal_package_interval_contract() const {
  return package_interval_contract_;
}
inline double LiveConfig_GiftConfig::package_interval_contract() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.GiftConfig.package_interval_contract)
  return _internal_package_interval_contract();
}
inline void LiveConfig_GiftConfig::_internal_set_package_interval_contract(double value) {
  _has_bits_[0] |= 0x00000080u;
  package_interval_contract_ = value;
}
inline void LiveConfig_GiftConfig::set_package_interval_contract(double value) {
  _internal_set_package_interval_contract(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.GiftConfig.package_interval_contract)
}

// optional double package_interval_piggy_full = 7;
inline bool LiveConfig_GiftConfig::_internal_has_package_interval_piggy_full() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool LiveConfig_GiftConfig::has_package_interval_piggy_full() const {
  return _internal_has_package_interval_piggy_full();
}
inline void LiveConfig_GiftConfig::clear_package_interval_piggy_full() {
  package_interval_piggy_full_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline double LiveConfig_GiftConfig::_internal_package_interval_piggy_full() const {
  return package_interval_piggy_full_;
}
inline double LiveConfig_GiftConfig::package_interval_piggy_full() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.GiftConfig.package_interval_piggy_full)
  return _internal_package_interval_piggy_full();
}
inline void LiveConfig_GiftConfig::_internal_set_package_interval_piggy_full(double value) {
  _has_bits_[0] |= 0x00000100u;
  package_interval_piggy_full_ = value;
}
inline void LiveConfig_GiftConfig::set_package_interval_piggy_full(double value) {
  _internal_set_package_interval_piggy_full(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.GiftConfig.package_interval_piggy_full)
}

// optional double package_interval_piggy_extra_full = 8;
inline bool LiveConfig_GiftConfig::_internal_has_package_interval_piggy_extra_full() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool LiveConfig_GiftConfig::has_package_interval_piggy_extra_full() const {
  return _internal_has_package_interval_piggy_extra_full();
}
inline void LiveConfig_GiftConfig::clear_package_interval_piggy_extra_full() {
  package_interval_piggy_extra_full_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline double LiveConfig_GiftConfig::_internal_package_interval_piggy_extra_full() const {
  return package_interval_piggy_extra_full_;
}
inline double LiveConfig_GiftConfig::package_interval_piggy_extra_full() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.GiftConfig.package_interval_piggy_extra_full)
  return _internal_package_interval_piggy_extra_full();
}
inline void LiveConfig_GiftConfig::_internal_set_package_interval_piggy_extra_full(double value) {
  _has_bits_[0] |= 0x00000200u;
  package_interval_piggy_extra_full_ = value;
}
inline void LiveConfig_GiftConfig::set_package_interval_piggy_extra_full(double value) {
  _internal_set_package_interval_piggy_extra_full(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.GiftConfig.package_interval_piggy_extra_full)
}

// optional bool package_reset_on_idle = 13;
inline bool LiveConfig_GiftConfig::_internal_has_package_reset_on_idle() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool LiveConfig_GiftConfig::has_package_reset_on_idle() const {
  return _internal_has_package_reset_on_idle();
}
inline void LiveConfig_GiftConfig::clear_package_reset_on_idle() {
  package_reset_on_idle_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool LiveConfig_GiftConfig::_internal_package_reset_on_idle() const {
  return package_reset_on_idle_;
}
inline bool LiveConfig_GiftConfig::package_reset_on_idle() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.GiftConfig.package_reset_on_idle)
  return _internal_package_reset_on_idle();
}
inline void LiveConfig_GiftConfig::_internal_set_package_reset_on_idle(bool value) {
  _has_bits_[0] |= 0x00004000u;
  package_reset_on_idle_ = value;
}
inline void LiveConfig_GiftConfig::set_package_reset_on_idle(bool value) {
  _internal_set_package_reset_on_idle(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.GiftConfig.package_reset_on_idle)
}

// -------------------------------------------------------------------

// LiveConfig_MiscConfig

// optional bool ask_to_track = 1;
inline bool LiveConfig_MiscConfig::_internal_has_ask_to_track() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LiveConfig_MiscConfig::has_ask_to_track() const {
  return _internal_has_ask_to_track();
}
inline void LiveConfig_MiscConfig::clear_ask_to_track() {
  ask_to_track_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool LiveConfig_MiscConfig::_internal_ask_to_track() const {
  return ask_to_track_;
}
inline bool LiveConfig_MiscConfig::ask_to_track() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.MiscConfig.ask_to_track)
  return _internal_ask_to_track();
}
inline void LiveConfig_MiscConfig::_internal_set_ask_to_track(bool value) {
  _has_bits_[0] |= 0x00000004u;
  ask_to_track_ = value;
}
inline void LiveConfig_MiscConfig::set_ask_to_track(bool value) {
  _internal_set_ask_to_track(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.MiscConfig.ask_to_track)
}

// optional double ask_to_track_min_soul_eggs = 2;
inline bool LiveConfig_MiscConfig::_internal_has_ask_to_track_min_soul_eggs() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LiveConfig_MiscConfig::has_ask_to_track_min_soul_eggs() const {
  return _internal_has_ask_to_track_min_soul_eggs();
}
inline void LiveConfig_MiscConfig::clear_ask_to_track_min_soul_eggs() {
  ask_to_track_min_soul_eggs_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double LiveConfig_MiscConfig::_internal_ask_to_track_min_soul_eggs() const {
  return ask_to_track_min_soul_eggs_;
}
inline double LiveConfig_MiscConfig::ask_to_track_min_soul_eggs() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.MiscConfig.ask_to_track_min_soul_eggs)
  return _internal_ask_to_track_min_soul_eggs();
}
inline void LiveConfig_MiscConfig::_internal_set_ask_to_track_min_soul_eggs(double value) {
  _has_bits_[0] |= 0x00000002u;
  ask_to_track_min_soul_eggs_ = value;
}
inline void LiveConfig_MiscConfig::set_ask_to_track_min_soul_eggs(double value) {
  _internal_set_ask_to_track_min_soul_eggs(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.MiscConfig.ask_to_track_min_soul_eggs)
}

// optional string ask_to_track_message = 3;
inline bool LiveConfig_MiscConfig::_internal_has_ask_to_track_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LiveConfig_MiscConfig::has_ask_to_track_message() const {
  return _internal_has_ask_to_track_message();
}
inline void LiveConfig_MiscConfig::clear_ask_to_track_message() {
  ask_to_track_message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LiveConfig_MiscConfig::ask_to_track_message() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.MiscConfig.ask_to_track_message)
  return _internal_ask_to_track_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LiveConfig_MiscConfig::set_ask_to_track_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 ask_to_track_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.LiveConfig.MiscConfig.ask_to_track_message)
}
inline std::string* LiveConfig_MiscConfig::mutable_ask_to_track_message() {
  std::string* _s = _internal_mutable_ask_to_track_message();
  // @@protoc_insertion_point(field_mutable:ei.LiveConfig.MiscConfig.ask_to_track_message)
  return _s;
}
inline const std::string& LiveConfig_MiscConfig::_internal_ask_to_track_message() const {
  return ask_to_track_message_.Get();
}
inline void LiveConfig_MiscConfig::_internal_set_ask_to_track_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ask_to_track_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LiveConfig_MiscConfig::_internal_mutable_ask_to_track_message() {
  _has_bits_[0] |= 0x00000001u;
  return ask_to_track_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LiveConfig_MiscConfig::release_ask_to_track_message() {
  // @@protoc_insertion_point(field_release:ei.LiveConfig.MiscConfig.ask_to_track_message)
  if (!_internal_has_ask_to_track_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = ask_to_track_message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ask_to_track_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ask_to_track_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LiveConfig_MiscConfig::set_allocated_ask_to_track_message(std::string* ask_to_track_message) {
  if (ask_to_track_message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ask_to_track_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ask_to_track_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ask_to_track_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ask_to_track_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.LiveConfig.MiscConfig.ask_to_track_message)
}

// optional bool ask_to_track_show_pre_dialog = 4;
inline bool LiveConfig_MiscConfig::_internal_has_ask_to_track_show_pre_dialog() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LiveConfig_MiscConfig::has_ask_to_track_show_pre_dialog() const {
  return _internal_has_ask_to_track_show_pre_dialog();
}
inline void LiveConfig_MiscConfig::clear_ask_to_track_show_pre_dialog() {
  ask_to_track_show_pre_dialog_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool LiveConfig_MiscConfig::_internal_ask_to_track_show_pre_dialog() const {
  return ask_to_track_show_pre_dialog_;
}
inline bool LiveConfig_MiscConfig::ask_to_track_show_pre_dialog() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.MiscConfig.ask_to_track_show_pre_dialog)
  return _internal_ask_to_track_show_pre_dialog();
}
inline void LiveConfig_MiscConfig::_internal_set_ask_to_track_show_pre_dialog(bool value) {
  _has_bits_[0] |= 0x00000008u;
  ask_to_track_show_pre_dialog_ = value;
}
inline void LiveConfig_MiscConfig::set_ask_to_track_show_pre_dialog(bool value) {
  _internal_set_ask_to_track_show_pre_dialog(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.MiscConfig.ask_to_track_show_pre_dialog)
}

// optional bool ask_to_track_after_privacy = 5;
inline bool LiveConfig_MiscConfig::_internal_has_ask_to_track_after_privacy() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LiveConfig_MiscConfig::has_ask_to_track_after_privacy() const {
  return _internal_has_ask_to_track_after_privacy();
}
inline void LiveConfig_MiscConfig::clear_ask_to_track_after_privacy() {
  ask_to_track_after_privacy_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool LiveConfig_MiscConfig::_internal_ask_to_track_after_privacy() const {
  return ask_to_track_after_privacy_;
}
inline bool LiveConfig_MiscConfig::ask_to_track_after_privacy() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.MiscConfig.ask_to_track_after_privacy)
  return _internal_ask_to_track_after_privacy();
}
inline void LiveConfig_MiscConfig::_internal_set_ask_to_track_after_privacy(bool value) {
  _has_bits_[0] |= 0x00000010u;
  ask_to_track_after_privacy_ = value;
}
inline void LiveConfig_MiscConfig::set_ask_to_track_after_privacy(bool value) {
  _internal_set_ask_to_track_after_privacy(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.MiscConfig.ask_to_track_after_privacy)
}

// optional double chicken_run_boost_percentage = 6;
inline bool LiveConfig_MiscConfig::_internal_has_chicken_run_boost_percentage() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool LiveConfig_MiscConfig::has_chicken_run_boost_percentage() const {
  return _internal_has_chicken_run_boost_percentage();
}
inline void LiveConfig_MiscConfig::clear_chicken_run_boost_percentage() {
  chicken_run_boost_percentage_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double LiveConfig_MiscConfig::_internal_chicken_run_boost_percentage() const {
  return chicken_run_boost_percentage_;
}
inline double LiveConfig_MiscConfig::chicken_run_boost_percentage() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.MiscConfig.chicken_run_boost_percentage)
  return _internal_chicken_run_boost_percentage();
}
inline void LiveConfig_MiscConfig::_internal_set_chicken_run_boost_percentage(double value) {
  _has_bits_[0] |= 0x00000040u;
  chicken_run_boost_percentage_ = value;
}
inline void LiveConfig_MiscConfig::set_chicken_run_boost_percentage(double value) {
  _internal_set_chicken_run_boost_percentage(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.MiscConfig.chicken_run_boost_percentage)
}

// optional uint32 shells_intro_tickets = 7;
inline bool LiveConfig_MiscConfig::_internal_has_shells_intro_tickets() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LiveConfig_MiscConfig::has_shells_intro_tickets() const {
  return _internal_has_shells_intro_tickets();
}
inline void LiveConfig_MiscConfig::clear_shells_intro_tickets() {
  shells_intro_tickets_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t LiveConfig_MiscConfig::_internal_shells_intro_tickets() const {
  return shells_intro_tickets_;
}
inline uint32_t LiveConfig_MiscConfig::shells_intro_tickets() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.MiscConfig.shells_intro_tickets)
  return _internal_shells_intro_tickets();
}
inline void LiveConfig_MiscConfig::_internal_set_shells_intro_tickets(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  shells_intro_tickets_ = value;
}
inline void LiveConfig_MiscConfig::set_shells_intro_tickets(uint32_t value) {
  _internal_set_shells_intro_tickets(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.MiscConfig.shells_intro_tickets)
}

// optional uint32 shells_max_free_chicken_configs = 8;
inline bool LiveConfig_MiscConfig::_internal_has_shells_max_free_chicken_configs() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool LiveConfig_MiscConfig::has_shells_max_free_chicken_configs() const {
  return _internal_has_shells_max_free_chicken_configs();
}
inline void LiveConfig_MiscConfig::clear_shells_max_free_chicken_configs() {
  shells_max_free_chicken_configs_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline uint32_t LiveConfig_MiscConfig::_internal_shells_max_free_chicken_configs() const {
  return shells_max_free_chicken_configs_;
}
inline uint32_t LiveConfig_MiscConfig::shells_max_free_chicken_configs() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.MiscConfig.shells_max_free_chicken_configs)
  return _internal_shells_max_free_chicken_configs();
}
inline void LiveConfig_MiscConfig::_internal_set_shells_max_free_chicken_configs(uint32_t value) {
  _has_bits_[0] |= 0x00000080u;
  shells_max_free_chicken_configs_ = value;
}
inline void LiveConfig_MiscConfig::set_shells_max_free_chicken_configs(uint32_t value) {
  _internal_set_shells_max_free_chicken_configs(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.MiscConfig.shells_max_free_chicken_configs)
}

// optional uint32 shells_intro_alert_threshold = 9;
inline bool LiveConfig_MiscConfig::_internal_has_shells_intro_alert_threshold() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool LiveConfig_MiscConfig::has_shells_intro_alert_threshold() const {
  return _internal_has_shells_intro_alert_threshold();
}
inline void LiveConfig_MiscConfig::clear_shells_intro_alert_threshold() {
  shells_intro_alert_threshold_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline uint32_t LiveConfig_MiscConfig::_internal_shells_intro_alert_threshold() const {
  return shells_intro_alert_threshold_;
}
inline uint32_t LiveConfig_MiscConfig::shells_intro_alert_threshold() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.MiscConfig.shells_intro_alert_threshold)
  return _internal_shells_intro_alert_threshold();
}
inline void LiveConfig_MiscConfig::_internal_set_shells_intro_alert_threshold(uint32_t value) {
  _has_bits_[0] |= 0x00000100u;
  shells_intro_alert_threshold_ = value;
}
inline void LiveConfig_MiscConfig::set_shells_intro_alert_threshold(uint32_t value) {
  _internal_set_shells_intro_alert_threshold(value);
  // @@protoc_insertion_point(field_set:ei.LiveConfig.MiscConfig.shells_intro_alert_threshold)
}

// -------------------------------------------------------------------

// LiveConfig

// optional string config_id = 1;
inline bool LiveConfig::_internal_has_config_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LiveConfig::has_config_id() const {
  return _internal_has_config_id();
}
inline void LiveConfig::clear_config_id() {
  config_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LiveConfig::config_id() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.config_id)
  return _internal_config_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LiveConfig::set_config_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 config_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.LiveConfig.config_id)
}
inline std::string* LiveConfig::mutable_config_id() {
  std::string* _s = _internal_mutable_config_id();
  // @@protoc_insertion_point(field_mutable:ei.LiveConfig.config_id)
  return _s;
}
inline const std::string& LiveConfig::_internal_config_id() const {
  return config_id_.Get();
}
inline void LiveConfig::_internal_set_config_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  config_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LiveConfig::_internal_mutable_config_id() {
  _has_bits_[0] |= 0x00000001u;
  return config_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LiveConfig::release_config_id() {
  // @@protoc_insertion_point(field_release:ei.LiveConfig.config_id)
  if (!_internal_has_config_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = config_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (config_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    config_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LiveConfig::set_allocated_config_id(std::string* config_id) {
  if (config_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  config_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), config_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (config_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    config_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.LiveConfig.config_id)
}

// optional .ei.LiveConfig.BoostsConfig boosts_config = 2;
inline bool LiveConfig::_internal_has_boosts_config() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || boosts_config_ != nullptr);
  return value;
}
inline bool LiveConfig::has_boosts_config() const {
  return _internal_has_boosts_config();
}
inline void LiveConfig::clear_boosts_config() {
  if (boosts_config_ != nullptr) boosts_config_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ei::LiveConfig_BoostsConfig& LiveConfig::_internal_boosts_config() const {
  const ::ei::LiveConfig_BoostsConfig* p = boosts_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::LiveConfig_BoostsConfig&>(
      ::ei::_LiveConfig_BoostsConfig_default_instance_);
}
inline const ::ei::LiveConfig_BoostsConfig& LiveConfig::boosts_config() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.boosts_config)
  return _internal_boosts_config();
}
inline void LiveConfig::unsafe_arena_set_allocated_boosts_config(
    ::ei::LiveConfig_BoostsConfig* boosts_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(boosts_config_);
  }
  boosts_config_ = boosts_config;
  if (boosts_config) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.LiveConfig.boosts_config)
}
inline ::ei::LiveConfig_BoostsConfig* LiveConfig::release_boosts_config() {
  _has_bits_[0] &= ~0x00000002u;
  ::ei::LiveConfig_BoostsConfig* temp = boosts_config_;
  boosts_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::LiveConfig_BoostsConfig* LiveConfig::unsafe_arena_release_boosts_config() {
  // @@protoc_insertion_point(field_release:ei.LiveConfig.boosts_config)
  _has_bits_[0] &= ~0x00000002u;
  ::ei::LiveConfig_BoostsConfig* temp = boosts_config_;
  boosts_config_ = nullptr;
  return temp;
}
inline ::ei::LiveConfig_BoostsConfig* LiveConfig::_internal_mutable_boosts_config() {
  _has_bits_[0] |= 0x00000002u;
  if (boosts_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::LiveConfig_BoostsConfig>(GetArenaForAllocation());
    boosts_config_ = p;
  }
  return boosts_config_;
}
inline ::ei::LiveConfig_BoostsConfig* LiveConfig::mutable_boosts_config() {
  ::ei::LiveConfig_BoostsConfig* _msg = _internal_mutable_boosts_config();
  // @@protoc_insertion_point(field_mutable:ei.LiveConfig.boosts_config)
  return _msg;
}
inline void LiveConfig::set_allocated_boosts_config(::ei::LiveConfig_BoostsConfig* boosts_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete boosts_config_;
  }
  if (boosts_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::LiveConfig_BoostsConfig>::GetOwningArena(boosts_config);
    if (message_arena != submessage_arena) {
      boosts_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, boosts_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  boosts_config_ = boosts_config;
  // @@protoc_insertion_point(field_set_allocated:ei.LiveConfig.boosts_config)
}

// optional .ei.LiveConfig.GiftConfig gift_config = 3;
inline bool LiveConfig::_internal_has_gift_config() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || gift_config_ != nullptr);
  return value;
}
inline bool LiveConfig::has_gift_config() const {
  return _internal_has_gift_config();
}
inline void LiveConfig::clear_gift_config() {
  if (gift_config_ != nullptr) gift_config_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ei::LiveConfig_GiftConfig& LiveConfig::_internal_gift_config() const {
  const ::ei::LiveConfig_GiftConfig* p = gift_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::LiveConfig_GiftConfig&>(
      ::ei::_LiveConfig_GiftConfig_default_instance_);
}
inline const ::ei::LiveConfig_GiftConfig& LiveConfig::gift_config() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.gift_config)
  return _internal_gift_config();
}
inline void LiveConfig::unsafe_arena_set_allocated_gift_config(
    ::ei::LiveConfig_GiftConfig* gift_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gift_config_);
  }
  gift_config_ = gift_config;
  if (gift_config) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.LiveConfig.gift_config)
}
inline ::ei::LiveConfig_GiftConfig* LiveConfig::release_gift_config() {
  _has_bits_[0] &= ~0x00000004u;
  ::ei::LiveConfig_GiftConfig* temp = gift_config_;
  gift_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::LiveConfig_GiftConfig* LiveConfig::unsafe_arena_release_gift_config() {
  // @@protoc_insertion_point(field_release:ei.LiveConfig.gift_config)
  _has_bits_[0] &= ~0x00000004u;
  ::ei::LiveConfig_GiftConfig* temp = gift_config_;
  gift_config_ = nullptr;
  return temp;
}
inline ::ei::LiveConfig_GiftConfig* LiveConfig::_internal_mutable_gift_config() {
  _has_bits_[0] |= 0x00000004u;
  if (gift_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::LiveConfig_GiftConfig>(GetArenaForAllocation());
    gift_config_ = p;
  }
  return gift_config_;
}
inline ::ei::LiveConfig_GiftConfig* LiveConfig::mutable_gift_config() {
  ::ei::LiveConfig_GiftConfig* _msg = _internal_mutable_gift_config();
  // @@protoc_insertion_point(field_mutable:ei.LiveConfig.gift_config)
  return _msg;
}
inline void LiveConfig::set_allocated_gift_config(::ei::LiveConfig_GiftConfig* gift_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete gift_config_;
  }
  if (gift_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::LiveConfig_GiftConfig>::GetOwningArena(gift_config);
    if (message_arena != submessage_arena) {
      gift_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gift_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  gift_config_ = gift_config;
  // @@protoc_insertion_point(field_set_allocated:ei.LiveConfig.gift_config)
}

// optional .ei.LiveConfig.MiscConfig misc_config = 4;
inline bool LiveConfig::_internal_has_misc_config() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || misc_config_ != nullptr);
  return value;
}
inline bool LiveConfig::has_misc_config() const {
  return _internal_has_misc_config();
}
inline void LiveConfig::clear_misc_config() {
  if (misc_config_ != nullptr) misc_config_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ei::LiveConfig_MiscConfig& LiveConfig::_internal_misc_config() const {
  const ::ei::LiveConfig_MiscConfig* p = misc_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::LiveConfig_MiscConfig&>(
      ::ei::_LiveConfig_MiscConfig_default_instance_);
}
inline const ::ei::LiveConfig_MiscConfig& LiveConfig::misc_config() const {
  // @@protoc_insertion_point(field_get:ei.LiveConfig.misc_config)
  return _internal_misc_config();
}
inline void LiveConfig::unsafe_arena_set_allocated_misc_config(
    ::ei::LiveConfig_MiscConfig* misc_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(misc_config_);
  }
  misc_config_ = misc_config;
  if (misc_config) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.LiveConfig.misc_config)
}
inline ::ei::LiveConfig_MiscConfig* LiveConfig::release_misc_config() {
  _has_bits_[0] &= ~0x00000008u;
  ::ei::LiveConfig_MiscConfig* temp = misc_config_;
  misc_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::LiveConfig_MiscConfig* LiveConfig::unsafe_arena_release_misc_config() {
  // @@protoc_insertion_point(field_release:ei.LiveConfig.misc_config)
  _has_bits_[0] &= ~0x00000008u;
  ::ei::LiveConfig_MiscConfig* temp = misc_config_;
  misc_config_ = nullptr;
  return temp;
}
inline ::ei::LiveConfig_MiscConfig* LiveConfig::_internal_mutable_misc_config() {
  _has_bits_[0] |= 0x00000008u;
  if (misc_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::LiveConfig_MiscConfig>(GetArenaForAllocation());
    misc_config_ = p;
  }
  return misc_config_;
}
inline ::ei::LiveConfig_MiscConfig* LiveConfig::mutable_misc_config() {
  ::ei::LiveConfig_MiscConfig* _msg = _internal_mutable_misc_config();
  // @@protoc_insertion_point(field_mutable:ei.LiveConfig.misc_config)
  return _msg;
}
inline void LiveConfig::set_allocated_misc_config(::ei::LiveConfig_MiscConfig* misc_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete misc_config_;
  }
  if (misc_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::LiveConfig_MiscConfig>::GetOwningArena(misc_config);
    if (message_arena != submessage_arena) {
      misc_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, misc_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  misc_config_ = misc_config;
  // @@protoc_insertion_point(field_set_allocated:ei.LiveConfig.misc_config)
}

// -------------------------------------------------------------------

// InGameMail

// optional string id = 1;
inline bool InGameMail::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InGameMail::has_id() const {
  return _internal_has_id();
}
inline void InGameMail::clear_id() {
  id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InGameMail::id() const {
  // @@protoc_insertion_point(field_get:ei.InGameMail.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InGameMail::set_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.InGameMail.id)
}
inline std::string* InGameMail::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ei.InGameMail.id)
  return _s;
}
inline const std::string& InGameMail::_internal_id() const {
  return id_.Get();
}
inline void InGameMail::_internal_set_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InGameMail::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InGameMail::release_id() {
  // @@protoc_insertion_point(field_release:ei.InGameMail.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InGameMail::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.InGameMail.id)
}

// optional string title = 2;
inline bool InGameMail::_internal_has_title() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InGameMail::has_title() const {
  return _internal_has_title();
}
inline void InGameMail::clear_title() {
  title_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InGameMail::title() const {
  // @@protoc_insertion_point(field_get:ei.InGameMail.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InGameMail::set_title(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.InGameMail.title)
}
inline std::string* InGameMail::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:ei.InGameMail.title)
  return _s;
}
inline const std::string& InGameMail::_internal_title() const {
  return title_.Get();
}
inline void InGameMail::_internal_set_title(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InGameMail::_internal_mutable_title() {
  _has_bits_[0] |= 0x00000002u;
  return title_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InGameMail::release_title() {
  // @@protoc_insertion_point(field_release:ei.InGameMail.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = title_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InGameMail::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  title_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), title,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.InGameMail.title)
}

// optional string date = 8;
inline bool InGameMail::_internal_has_date() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool InGameMail::has_date() const {
  return _internal_has_date();
}
inline void InGameMail::clear_date() {
  date_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& InGameMail::date() const {
  // @@protoc_insertion_point(field_get:ei.InGameMail.date)
  return _internal_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InGameMail::set_date(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 date_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.InGameMail.date)
}
inline std::string* InGameMail::mutable_date() {
  std::string* _s = _internal_mutable_date();
  // @@protoc_insertion_point(field_mutable:ei.InGameMail.date)
  return _s;
}
inline const std::string& InGameMail::_internal_date() const {
  return date_.Get();
}
inline void InGameMail::_internal_set_date(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  date_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InGameMail::_internal_mutable_date() {
  _has_bits_[0] |= 0x00000020u;
  return date_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InGameMail::release_date() {
  // @@protoc_insertion_point(field_release:ei.InGameMail.date)
  if (!_internal_has_date()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = date_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (date_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    date_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InGameMail::set_allocated_date(std::string* date) {
  if (date != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  date_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), date,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (date_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    date_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.InGameMail.date)
}

// optional string message = 3;
inline bool InGameMail::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InGameMail::has_message() const {
  return _internal_has_message();
}
inline void InGameMail::clear_message() {
  message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& InGameMail::message() const {
  // @@protoc_insertion_point(field_get:ei.InGameMail.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InGameMail::set_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.InGameMail.message)
}
inline std::string* InGameMail::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:ei.InGameMail.message)
  return _s;
}
inline const std::string& InGameMail::_internal_message() const {
  return message_.Get();
}
inline void InGameMail::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InGameMail::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000004u;
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InGameMail::release_message() {
  // @@protoc_insertion_point(field_release:ei.InGameMail.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InGameMail::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.InGameMail.message)
}

// optional string action = 4;
inline bool InGameMail::_internal_has_action() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool InGameMail::has_action() const {
  return _internal_has_action();
}
inline void InGameMail::clear_action() {
  action_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& InGameMail::action() const {
  // @@protoc_insertion_point(field_get:ei.InGameMail.action)
  return _internal_action();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InGameMail::set_action(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 action_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.InGameMail.action)
}
inline std::string* InGameMail::mutable_action() {
  std::string* _s = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:ei.InGameMail.action)
  return _s;
}
inline const std::string& InGameMail::_internal_action() const {
  return action_.Get();
}
inline void InGameMail::_internal_set_action(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  action_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InGameMail::_internal_mutable_action() {
  _has_bits_[0] |= 0x00000008u;
  return action_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InGameMail::release_action() {
  // @@protoc_insertion_point(field_release:ei.InGameMail.action)
  if (!_internal_has_action()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = action_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (action_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    action_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InGameMail::set_allocated_action(std::string* action) {
  if (action != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  action_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), action,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (action_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    action_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.InGameMail.action)
}

// optional string url = 5;
inline bool InGameMail::_internal_has_url() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool InGameMail::has_url() const {
  return _internal_has_url();
}
inline void InGameMail::clear_url() {
  url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& InGameMail::url() const {
  // @@protoc_insertion_point(field_get:ei.InGameMail.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InGameMail::set_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.InGameMail.url)
}
inline std::string* InGameMail::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:ei.InGameMail.url)
  return _s;
}
inline const std::string& InGameMail::_internal_url() const {
  return url_.Get();
}
inline void InGameMail::_internal_set_url(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InGameMail::_internal_mutable_url() {
  _has_bits_[0] |= 0x00000010u;
  return url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InGameMail::release_url() {
  // @@protoc_insertion_point(field_release:ei.InGameMail.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InGameMail::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.InGameMail.url)
}

// optional uint32 platform = 7;
inline bool InGameMail::_internal_has_platform() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool InGameMail::has_platform() const {
  return _internal_has_platform();
}
inline void InGameMail::clear_platform() {
  platform_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline uint32_t InGameMail::_internal_platform() const {
  return platform_;
}
inline uint32_t InGameMail::platform() const {
  // @@protoc_insertion_point(field_get:ei.InGameMail.platform)
  return _internal_platform();
}
inline void InGameMail::_internal_set_platform(uint32_t value) {
  _has_bits_[0] |= 0x00000080u;
  platform_ = value;
}
inline void InGameMail::set_platform(uint32_t value) {
  _internal_set_platform(value);
  // @@protoc_insertion_point(field_set:ei.InGameMail.platform)
}

// repeated string builds = 9;
inline int InGameMail::_internal_builds_size() const {
  return builds_.size();
}
inline int InGameMail::builds_size() const {
  return _internal_builds_size();
}
inline void InGameMail::clear_builds() {
  builds_.Clear();
}
inline std::string* InGameMail::add_builds() {
  std::string* _s = _internal_add_builds();
  // @@protoc_insertion_point(field_add_mutable:ei.InGameMail.builds)
  return _s;
}
inline const std::string& InGameMail::_internal_builds(int index) const {
  return builds_.Get(index);
}
inline const std::string& InGameMail::builds(int index) const {
  // @@protoc_insertion_point(field_get:ei.InGameMail.builds)
  return _internal_builds(index);
}
inline std::string* InGameMail::mutable_builds(int index) {
  // @@protoc_insertion_point(field_mutable:ei.InGameMail.builds)
  return builds_.Mutable(index);
}
inline void InGameMail::set_builds(int index, const std::string& value) {
  builds_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ei.InGameMail.builds)
}
inline void InGameMail::set_builds(int index, std::string&& value) {
  builds_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ei.InGameMail.builds)
}
inline void InGameMail::set_builds(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  builds_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ei.InGameMail.builds)
}
inline void InGameMail::set_builds(int index, const char* value, size_t size) {
  builds_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ei.InGameMail.builds)
}
inline std::string* InGameMail::_internal_add_builds() {
  return builds_.Add();
}
inline void InGameMail::add_builds(const std::string& value) {
  builds_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ei.InGameMail.builds)
}
inline void InGameMail::add_builds(std::string&& value) {
  builds_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ei.InGameMail.builds)
}
inline void InGameMail::add_builds(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  builds_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ei.InGameMail.builds)
}
inline void InGameMail::add_builds(const char* value, size_t size) {
  builds_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ei.InGameMail.builds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
InGameMail::builds() const {
  // @@protoc_insertion_point(field_list:ei.InGameMail.builds)
  return builds_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
InGameMail::mutable_builds() {
  // @@protoc_insertion_point(field_mutable_list:ei.InGameMail.builds)
  return &builds_;
}

// optional uint32 min_client_version = 10;
inline bool InGameMail::_internal_has_min_client_version() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool InGameMail::has_min_client_version() const {
  return _internal_has_min_client_version();
}
inline void InGameMail::clear_min_client_version() {
  min_client_version_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline uint32_t InGameMail::_internal_min_client_version() const {
  return min_client_version_;
}
inline uint32_t InGameMail::min_client_version() const {
  // @@protoc_insertion_point(field_get:ei.InGameMail.min_client_version)
  return _internal_min_client_version();
}
inline void InGameMail::_internal_set_min_client_version(uint32_t value) {
  _has_bits_[0] |= 0x00000100u;
  min_client_version_ = value;
}
inline void InGameMail::set_min_client_version(uint32_t value) {
  _internal_set_min_client_version(value);
  // @@protoc_insertion_point(field_set:ei.InGameMail.min_client_version)
}

// optional uint32 max_client_version = 12;
inline bool InGameMail::_internal_has_max_client_version() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool InGameMail::has_max_client_version() const {
  return _internal_has_max_client_version();
}
inline void InGameMail::clear_max_client_version() {
  max_client_version_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline uint32_t InGameMail::_internal_max_client_version() const {
  return max_client_version_;
}
inline uint32_t InGameMail::max_client_version() const {
  // @@protoc_insertion_point(field_get:ei.InGameMail.max_client_version)
  return _internal_max_client_version();
}
inline void InGameMail::_internal_set_max_client_version(uint32_t value) {
  _has_bits_[0] |= 0x00000800u;
  max_client_version_ = value;
}
inline void InGameMail::set_max_client_version(uint32_t value) {
  _internal_set_max_client_version(value);
  // @@protoc_insertion_point(field_set:ei.InGameMail.max_client_version)
}

// optional double min_soul_eggs = 11;
inline bool InGameMail::_internal_has_min_soul_eggs() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool InGameMail::has_min_soul_eggs() const {
  return _internal_has_min_soul_eggs();
}
inline void InGameMail::clear_min_soul_eggs() {
  min_soul_eggs_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline double InGameMail::_internal_min_soul_eggs() const {
  return min_soul_eggs_;
}
inline double InGameMail::min_soul_eggs() const {
  // @@protoc_insertion_point(field_get:ei.InGameMail.min_soul_eggs)
  return _internal_min_soul_eggs();
}
inline void InGameMail::_internal_set_min_soul_eggs(double value) {
  _has_bits_[0] |= 0x00000200u;
  min_soul_eggs_ = value;
}
inline void InGameMail::set_min_soul_eggs(double value) {
  _internal_set_min_soul_eggs(value);
  // @@protoc_insertion_point(field_set:ei.InGameMail.min_soul_eggs)
}

// optional double min_mystical_bonus = 13;
inline bool InGameMail::_internal_has_min_mystical_bonus() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool InGameMail::has_min_mystical_bonus() const {
  return _internal_has_min_mystical_bonus();
}
inline void InGameMail::clear_min_mystical_bonus() {
  min_mystical_bonus_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline double InGameMail::_internal_min_mystical_bonus() const {
  return min_mystical_bonus_;
}
inline double InGameMail::min_mystical_bonus() const {
  // @@protoc_insertion_point(field_get:ei.InGameMail.min_mystical_bonus)
  return _internal_min_mystical_bonus();
}
inline void InGameMail::_internal_set_min_mystical_bonus(double value) {
  _has_bits_[0] |= 0x00000400u;
  min_mystical_bonus_ = value;
}
inline void InGameMail::set_min_mystical_bonus(double value) {
  _internal_set_min_mystical_bonus(value);
  // @@protoc_insertion_point(field_set:ei.InGameMail.min_mystical_bonus)
}

// optional double gold_tip = 6;
inline bool InGameMail::_internal_has_gold_tip() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool InGameMail::has_gold_tip() const {
  return _internal_has_gold_tip();
}
inline void InGameMail::clear_gold_tip() {
  gold_tip_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double InGameMail::_internal_gold_tip() const {
  return gold_tip_;
}
inline double InGameMail::gold_tip() const {
  // @@protoc_insertion_point(field_get:ei.InGameMail.gold_tip)
  return _internal_gold_tip();
}
inline void InGameMail::_internal_set_gold_tip(double value) {
  _has_bits_[0] |= 0x00000040u;
  gold_tip_ = value;
}
inline void InGameMail::set_gold_tip(double value) {
  _internal_set_gold_tip(value);
  // @@protoc_insertion_point(field_set:ei.InGameMail.gold_tip)
}

// -------------------------------------------------------------------

// MailDB

// repeated .ei.InGameMail mail = 1;
inline int MailDB::_internal_mail_size() const {
  return mail_.size();
}
inline int MailDB::mail_size() const {
  return _internal_mail_size();
}
inline void MailDB::clear_mail() {
  mail_.Clear();
}
inline ::ei::InGameMail* MailDB::mutable_mail(int index) {
  // @@protoc_insertion_point(field_mutable:ei.MailDB.mail)
  return mail_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::InGameMail >*
MailDB::mutable_mail() {
  // @@protoc_insertion_point(field_mutable_list:ei.MailDB.mail)
  return &mail_;
}
inline const ::ei::InGameMail& MailDB::_internal_mail(int index) const {
  return mail_.Get(index);
}
inline const ::ei::InGameMail& MailDB::mail(int index) const {
  // @@protoc_insertion_point(field_get:ei.MailDB.mail)
  return _internal_mail(index);
}
inline ::ei::InGameMail* MailDB::_internal_add_mail() {
  return mail_.Add();
}
inline ::ei::InGameMail* MailDB::add_mail() {
  ::ei::InGameMail* _add = _internal_add_mail();
  // @@protoc_insertion_point(field_add:ei.MailDB.mail)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::InGameMail >&
MailDB::mail() const {
  // @@protoc_insertion_point(field_list:ei.MailDB.mail)
  return mail_;
}

// -------------------------------------------------------------------

// PeriodicalsResponse

// optional .ei.SalesInfo sales = 1;
inline bool PeriodicalsResponse::_internal_has_sales() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || sales_ != nullptr);
  return value;
}
inline bool PeriodicalsResponse::has_sales() const {
  return _internal_has_sales();
}
inline void PeriodicalsResponse::clear_sales() {
  if (sales_ != nullptr) sales_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ei::SalesInfo& PeriodicalsResponse::_internal_sales() const {
  const ::ei::SalesInfo* p = sales_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::SalesInfo&>(
      ::ei::_SalesInfo_default_instance_);
}
inline const ::ei::SalesInfo& PeriodicalsResponse::sales() const {
  // @@protoc_insertion_point(field_get:ei.PeriodicalsResponse.sales)
  return _internal_sales();
}
inline void PeriodicalsResponse::unsafe_arena_set_allocated_sales(
    ::ei::SalesInfo* sales) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sales_);
  }
  sales_ = sales;
  if (sales) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.PeriodicalsResponse.sales)
}
inline ::ei::SalesInfo* PeriodicalsResponse::release_sales() {
  _has_bits_[0] &= ~0x00000001u;
  ::ei::SalesInfo* temp = sales_;
  sales_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::SalesInfo* PeriodicalsResponse::unsafe_arena_release_sales() {
  // @@protoc_insertion_point(field_release:ei.PeriodicalsResponse.sales)
  _has_bits_[0] &= ~0x00000001u;
  ::ei::SalesInfo* temp = sales_;
  sales_ = nullptr;
  return temp;
}
inline ::ei::SalesInfo* PeriodicalsResponse::_internal_mutable_sales() {
  _has_bits_[0] |= 0x00000001u;
  if (sales_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::SalesInfo>(GetArenaForAllocation());
    sales_ = p;
  }
  return sales_;
}
inline ::ei::SalesInfo* PeriodicalsResponse::mutable_sales() {
  ::ei::SalesInfo* _msg = _internal_mutable_sales();
  // @@protoc_insertion_point(field_mutable:ei.PeriodicalsResponse.sales)
  return _msg;
}
inline void PeriodicalsResponse::set_allocated_sales(::ei::SalesInfo* sales) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sales_;
  }
  if (sales) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::SalesInfo>::GetOwningArena(sales);
    if (message_arena != submessage_arena) {
      sales = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sales, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sales_ = sales;
  // @@protoc_insertion_point(field_set_allocated:ei.PeriodicalsResponse.sales)
}

// optional .ei.EggIncCurrentEvents events = 2;
inline bool PeriodicalsResponse::_internal_has_events() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || events_ != nullptr);
  return value;
}
inline bool PeriodicalsResponse::has_events() const {
  return _internal_has_events();
}
inline void PeriodicalsResponse::clear_events() {
  if (events_ != nullptr) events_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ei::EggIncCurrentEvents& PeriodicalsResponse::_internal_events() const {
  const ::ei::EggIncCurrentEvents* p = events_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::EggIncCurrentEvents&>(
      ::ei::_EggIncCurrentEvents_default_instance_);
}
inline const ::ei::EggIncCurrentEvents& PeriodicalsResponse::events() const {
  // @@protoc_insertion_point(field_get:ei.PeriodicalsResponse.events)
  return _internal_events();
}
inline void PeriodicalsResponse::unsafe_arena_set_allocated_events(
    ::ei::EggIncCurrentEvents* events) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(events_);
  }
  events_ = events;
  if (events) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.PeriodicalsResponse.events)
}
inline ::ei::EggIncCurrentEvents* PeriodicalsResponse::release_events() {
  _has_bits_[0] &= ~0x00000002u;
  ::ei::EggIncCurrentEvents* temp = events_;
  events_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::EggIncCurrentEvents* PeriodicalsResponse::unsafe_arena_release_events() {
  // @@protoc_insertion_point(field_release:ei.PeriodicalsResponse.events)
  _has_bits_[0] &= ~0x00000002u;
  ::ei::EggIncCurrentEvents* temp = events_;
  events_ = nullptr;
  return temp;
}
inline ::ei::EggIncCurrentEvents* PeriodicalsResponse::_internal_mutable_events() {
  _has_bits_[0] |= 0x00000002u;
  if (events_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::EggIncCurrentEvents>(GetArenaForAllocation());
    events_ = p;
  }
  return events_;
}
inline ::ei::EggIncCurrentEvents* PeriodicalsResponse::mutable_events() {
  ::ei::EggIncCurrentEvents* _msg = _internal_mutable_events();
  // @@protoc_insertion_point(field_mutable:ei.PeriodicalsResponse.events)
  return _msg;
}
inline void PeriodicalsResponse::set_allocated_events(::ei::EggIncCurrentEvents* events) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete events_;
  }
  if (events) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::EggIncCurrentEvents>::GetOwningArena(events);
    if (message_arena != submessage_arena) {
      events = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, events, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  events_ = events;
  // @@protoc_insertion_point(field_set_allocated:ei.PeriodicalsResponse.events)
}

// optional .ei.ContractsResponse contracts = 3;
inline bool PeriodicalsResponse::_internal_has_contracts() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || contracts_ != nullptr);
  return value;
}
inline bool PeriodicalsResponse::has_contracts() const {
  return _internal_has_contracts();
}
inline void PeriodicalsResponse::clear_contracts() {
  if (contracts_ != nullptr) contracts_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ei::ContractsResponse& PeriodicalsResponse::_internal_contracts() const {
  const ::ei::ContractsResponse* p = contracts_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::ContractsResponse&>(
      ::ei::_ContractsResponse_default_instance_);
}
inline const ::ei::ContractsResponse& PeriodicalsResponse::contracts() const {
  // @@protoc_insertion_point(field_get:ei.PeriodicalsResponse.contracts)
  return _internal_contracts();
}
inline void PeriodicalsResponse::unsafe_arena_set_allocated_contracts(
    ::ei::ContractsResponse* contracts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(contracts_);
  }
  contracts_ = contracts;
  if (contracts) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.PeriodicalsResponse.contracts)
}
inline ::ei::ContractsResponse* PeriodicalsResponse::release_contracts() {
  _has_bits_[0] &= ~0x00000004u;
  ::ei::ContractsResponse* temp = contracts_;
  contracts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::ContractsResponse* PeriodicalsResponse::unsafe_arena_release_contracts() {
  // @@protoc_insertion_point(field_release:ei.PeriodicalsResponse.contracts)
  _has_bits_[0] &= ~0x00000004u;
  ::ei::ContractsResponse* temp = contracts_;
  contracts_ = nullptr;
  return temp;
}
inline ::ei::ContractsResponse* PeriodicalsResponse::_internal_mutable_contracts() {
  _has_bits_[0] |= 0x00000004u;
  if (contracts_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::ContractsResponse>(GetArenaForAllocation());
    contracts_ = p;
  }
  return contracts_;
}
inline ::ei::ContractsResponse* PeriodicalsResponse::mutable_contracts() {
  ::ei::ContractsResponse* _msg = _internal_mutable_contracts();
  // @@protoc_insertion_point(field_mutable:ei.PeriodicalsResponse.contracts)
  return _msg;
}
inline void PeriodicalsResponse::set_allocated_contracts(::ei::ContractsResponse* contracts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete contracts_;
  }
  if (contracts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::ContractsResponse>::GetOwningArena(contracts);
    if (message_arena != submessage_arena) {
      contracts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contracts, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  contracts_ = contracts;
  // @@protoc_insertion_point(field_set_allocated:ei.PeriodicalsResponse.contracts)
}

// repeated .ei.ServerGift gifts = 4;
inline int PeriodicalsResponse::_internal_gifts_size() const {
  return gifts_.size();
}
inline int PeriodicalsResponse::gifts_size() const {
  return _internal_gifts_size();
}
inline void PeriodicalsResponse::clear_gifts() {
  gifts_.Clear();
}
inline ::ei::ServerGift* PeriodicalsResponse::mutable_gifts(int index) {
  // @@protoc_insertion_point(field_mutable:ei.PeriodicalsResponse.gifts)
  return gifts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ServerGift >*
PeriodicalsResponse::mutable_gifts() {
  // @@protoc_insertion_point(field_mutable_list:ei.PeriodicalsResponse.gifts)
  return &gifts_;
}
inline const ::ei::ServerGift& PeriodicalsResponse::_internal_gifts(int index) const {
  return gifts_.Get(index);
}
inline const ::ei::ServerGift& PeriodicalsResponse::gifts(int index) const {
  // @@protoc_insertion_point(field_get:ei.PeriodicalsResponse.gifts)
  return _internal_gifts(index);
}
inline ::ei::ServerGift* PeriodicalsResponse::_internal_add_gifts() {
  return gifts_.Add();
}
inline ::ei::ServerGift* PeriodicalsResponse::add_gifts() {
  ::ei::ServerGift* _add = _internal_add_gifts();
  // @@protoc_insertion_point(field_add:ei.PeriodicalsResponse.gifts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ServerGift >&
PeriodicalsResponse::gifts() const {
  // @@protoc_insertion_point(field_list:ei.PeriodicalsResponse.gifts)
  return gifts_;
}

// optional .ei.LiveConfig live_config = 5;
inline bool PeriodicalsResponse::_internal_has_live_config() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || live_config_ != nullptr);
  return value;
}
inline bool PeriodicalsResponse::has_live_config() const {
  return _internal_has_live_config();
}
inline void PeriodicalsResponse::clear_live_config() {
  if (live_config_ != nullptr) live_config_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ei::LiveConfig& PeriodicalsResponse::_internal_live_config() const {
  const ::ei::LiveConfig* p = live_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::LiveConfig&>(
      ::ei::_LiveConfig_default_instance_);
}
inline const ::ei::LiveConfig& PeriodicalsResponse::live_config() const {
  // @@protoc_insertion_point(field_get:ei.PeriodicalsResponse.live_config)
  return _internal_live_config();
}
inline void PeriodicalsResponse::unsafe_arena_set_allocated_live_config(
    ::ei::LiveConfig* live_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(live_config_);
  }
  live_config_ = live_config;
  if (live_config) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.PeriodicalsResponse.live_config)
}
inline ::ei::LiveConfig* PeriodicalsResponse::release_live_config() {
  _has_bits_[0] &= ~0x00000008u;
  ::ei::LiveConfig* temp = live_config_;
  live_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::LiveConfig* PeriodicalsResponse::unsafe_arena_release_live_config() {
  // @@protoc_insertion_point(field_release:ei.PeriodicalsResponse.live_config)
  _has_bits_[0] &= ~0x00000008u;
  ::ei::LiveConfig* temp = live_config_;
  live_config_ = nullptr;
  return temp;
}
inline ::ei::LiveConfig* PeriodicalsResponse::_internal_mutable_live_config() {
  _has_bits_[0] |= 0x00000008u;
  if (live_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::LiveConfig>(GetArenaForAllocation());
    live_config_ = p;
  }
  return live_config_;
}
inline ::ei::LiveConfig* PeriodicalsResponse::mutable_live_config() {
  ::ei::LiveConfig* _msg = _internal_mutable_live_config();
  // @@protoc_insertion_point(field_mutable:ei.PeriodicalsResponse.live_config)
  return _msg;
}
inline void PeriodicalsResponse::set_allocated_live_config(::ei::LiveConfig* live_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete live_config_;
  }
  if (live_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::LiveConfig>::GetOwningArena(live_config);
    if (message_arena != submessage_arena) {
      live_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, live_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  live_config_ = live_config;
  // @@protoc_insertion_point(field_set_allocated:ei.PeriodicalsResponse.live_config)
}

// optional .ei.MailDB mail_bag = 6;
inline bool PeriodicalsResponse::_internal_has_mail_bag() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || mail_bag_ != nullptr);
  return value;
}
inline bool PeriodicalsResponse::has_mail_bag() const {
  return _internal_has_mail_bag();
}
inline void PeriodicalsResponse::clear_mail_bag() {
  if (mail_bag_ != nullptr) mail_bag_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::ei::MailDB& PeriodicalsResponse::_internal_mail_bag() const {
  const ::ei::MailDB* p = mail_bag_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::MailDB&>(
      ::ei::_MailDB_default_instance_);
}
inline const ::ei::MailDB& PeriodicalsResponse::mail_bag() const {
  // @@protoc_insertion_point(field_get:ei.PeriodicalsResponse.mail_bag)
  return _internal_mail_bag();
}
inline void PeriodicalsResponse::unsafe_arena_set_allocated_mail_bag(
    ::ei::MailDB* mail_bag) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mail_bag_);
  }
  mail_bag_ = mail_bag;
  if (mail_bag) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.PeriodicalsResponse.mail_bag)
}
inline ::ei::MailDB* PeriodicalsResponse::release_mail_bag() {
  _has_bits_[0] &= ~0x00000010u;
  ::ei::MailDB* temp = mail_bag_;
  mail_bag_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::MailDB* PeriodicalsResponse::unsafe_arena_release_mail_bag() {
  // @@protoc_insertion_point(field_release:ei.PeriodicalsResponse.mail_bag)
  _has_bits_[0] &= ~0x00000010u;
  ::ei::MailDB* temp = mail_bag_;
  mail_bag_ = nullptr;
  return temp;
}
inline ::ei::MailDB* PeriodicalsResponse::_internal_mutable_mail_bag() {
  _has_bits_[0] |= 0x00000010u;
  if (mail_bag_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::MailDB>(GetArenaForAllocation());
    mail_bag_ = p;
  }
  return mail_bag_;
}
inline ::ei::MailDB* PeriodicalsResponse::mutable_mail_bag() {
  ::ei::MailDB* _msg = _internal_mutable_mail_bag();
  // @@protoc_insertion_point(field_mutable:ei.PeriodicalsResponse.mail_bag)
  return _msg;
}
inline void PeriodicalsResponse::set_allocated_mail_bag(::ei::MailDB* mail_bag) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete mail_bag_;
  }
  if (mail_bag) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::MailDB>::GetOwningArena(mail_bag);
    if (message_arena != submessage_arena) {
      mail_bag = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mail_bag, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  mail_bag_ = mail_bag;
  // @@protoc_insertion_point(field_set_allocated:ei.PeriodicalsResponse.mail_bag)
}

// -------------------------------------------------------------------

// GetPeriodicalsRequest

// optional .ei.BasicRequestInfo rinfo = 12;
inline bool GetPeriodicalsRequest::_internal_has_rinfo() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || rinfo_ != nullptr);
  return value;
}
inline bool GetPeriodicalsRequest::has_rinfo() const {
  return _internal_has_rinfo();
}
inline void GetPeriodicalsRequest::clear_rinfo() {
  if (rinfo_ != nullptr) rinfo_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ei::BasicRequestInfo& GetPeriodicalsRequest::_internal_rinfo() const {
  const ::ei::BasicRequestInfo* p = rinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::BasicRequestInfo&>(
      ::ei::_BasicRequestInfo_default_instance_);
}
inline const ::ei::BasicRequestInfo& GetPeriodicalsRequest::rinfo() const {
  // @@protoc_insertion_point(field_get:ei.GetPeriodicalsRequest.rinfo)
  return _internal_rinfo();
}
inline void GetPeriodicalsRequest::unsafe_arena_set_allocated_rinfo(
    ::ei::BasicRequestInfo* rinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rinfo_);
  }
  rinfo_ = rinfo;
  if (rinfo) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.GetPeriodicalsRequest.rinfo)
}
inline ::ei::BasicRequestInfo* GetPeriodicalsRequest::release_rinfo() {
  _has_bits_[0] &= ~0x00000002u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::BasicRequestInfo* GetPeriodicalsRequest::unsafe_arena_release_rinfo() {
  // @@protoc_insertion_point(field_release:ei.GetPeriodicalsRequest.rinfo)
  _has_bits_[0] &= ~0x00000002u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
  return temp;
}
inline ::ei::BasicRequestInfo* GetPeriodicalsRequest::_internal_mutable_rinfo() {
  _has_bits_[0] |= 0x00000002u;
  if (rinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::BasicRequestInfo>(GetArenaForAllocation());
    rinfo_ = p;
  }
  return rinfo_;
}
inline ::ei::BasicRequestInfo* GetPeriodicalsRequest::mutable_rinfo() {
  ::ei::BasicRequestInfo* _msg = _internal_mutable_rinfo();
  // @@protoc_insertion_point(field_mutable:ei.GetPeriodicalsRequest.rinfo)
  return _msg;
}
inline void GetPeriodicalsRequest::set_allocated_rinfo(::ei::BasicRequestInfo* rinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rinfo_;
  }
  if (rinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::BasicRequestInfo>::GetOwningArena(rinfo);
    if (message_arena != submessage_arena) {
      rinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  rinfo_ = rinfo;
  // @@protoc_insertion_point(field_set_allocated:ei.GetPeriodicalsRequest.rinfo)
}

// optional string user_id = 1;
inline bool GetPeriodicalsRequest::_internal_has_user_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetPeriodicalsRequest::has_user_id() const {
  return _internal_has_user_id();
}
inline void GetPeriodicalsRequest::clear_user_id() {
  user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetPeriodicalsRequest::user_id() const {
  // @@protoc_insertion_point(field_get:ei.GetPeriodicalsRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPeriodicalsRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.GetPeriodicalsRequest.user_id)
}
inline std::string* GetPeriodicalsRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:ei.GetPeriodicalsRequest.user_id)
  return _s;
}
inline const std::string& GetPeriodicalsRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void GetPeriodicalsRequest::_internal_set_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetPeriodicalsRequest::_internal_mutable_user_id() {
  _has_bits_[0] |= 0x00000001u;
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetPeriodicalsRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:ei.GetPeriodicalsRequest.user_id)
  if (!_internal_has_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetPeriodicalsRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.GetPeriodicalsRequest.user_id)
}

// optional bool piggy_full = 2;
inline bool GetPeriodicalsRequest::_internal_has_piggy_full() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool GetPeriodicalsRequest::has_piggy_full() const {
  return _internal_has_piggy_full();
}
inline void GetPeriodicalsRequest::clear_piggy_full() {
  piggy_full_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool GetPeriodicalsRequest::_internal_piggy_full() const {
  return piggy_full_;
}
inline bool GetPeriodicalsRequest::piggy_full() const {
  // @@protoc_insertion_point(field_get:ei.GetPeriodicalsRequest.piggy_full)
  return _internal_piggy_full();
}
inline void GetPeriodicalsRequest::_internal_set_piggy_full(bool value) {
  _has_bits_[0] |= 0x00000040u;
  piggy_full_ = value;
}
inline void GetPeriodicalsRequest::set_piggy_full(bool value) {
  _internal_set_piggy_full(value);
  // @@protoc_insertion_point(field_set:ei.GetPeriodicalsRequest.piggy_full)
}

// optional bool piggy_found_full = 3;
inline bool GetPeriodicalsRequest::_internal_has_piggy_found_full() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool GetPeriodicalsRequest::has_piggy_found_full() const {
  return _internal_has_piggy_found_full();
}
inline void GetPeriodicalsRequest::clear_piggy_found_full() {
  piggy_found_full_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool GetPeriodicalsRequest::_internal_piggy_found_full() const {
  return piggy_found_full_;
}
inline bool GetPeriodicalsRequest::piggy_found_full() const {
  // @@protoc_insertion_point(field_get:ei.GetPeriodicalsRequest.piggy_found_full)
  return _internal_piggy_found_full();
}
inline void GetPeriodicalsRequest::_internal_set_piggy_found_full(bool value) {
  _has_bits_[0] |= 0x00000080u;
  piggy_found_full_ = value;
}
inline void GetPeriodicalsRequest::set_piggy_found_full(bool value) {
  _internal_set_piggy_found_full(value);
  // @@protoc_insertion_point(field_set:ei.GetPeriodicalsRequest.piggy_found_full)
}

// optional double seconds_full_realtime = 4;
inline bool GetPeriodicalsRequest::_internal_has_seconds_full_realtime() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GetPeriodicalsRequest::has_seconds_full_realtime() const {
  return _internal_has_seconds_full_realtime();
}
inline void GetPeriodicalsRequest::clear_seconds_full_realtime() {
  seconds_full_realtime_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double GetPeriodicalsRequest::_internal_seconds_full_realtime() const {
  return seconds_full_realtime_;
}
inline double GetPeriodicalsRequest::seconds_full_realtime() const {
  // @@protoc_insertion_point(field_get:ei.GetPeriodicalsRequest.seconds_full_realtime)
  return _internal_seconds_full_realtime();
}
inline void GetPeriodicalsRequest::_internal_set_seconds_full_realtime(double value) {
  _has_bits_[0] |= 0x00000004u;
  seconds_full_realtime_ = value;
}
inline void GetPeriodicalsRequest::set_seconds_full_realtime(double value) {
  _internal_set_seconds_full_realtime(value);
  // @@protoc_insertion_point(field_set:ei.GetPeriodicalsRequest.seconds_full_realtime)
}

// optional double seconds_full_gametime = 5;
inline bool GetPeriodicalsRequest::_internal_has_seconds_full_gametime() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GetPeriodicalsRequest::has_seconds_full_gametime() const {
  return _internal_has_seconds_full_gametime();
}
inline void GetPeriodicalsRequest::clear_seconds_full_gametime() {
  seconds_full_gametime_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double GetPeriodicalsRequest::_internal_seconds_full_gametime() const {
  return seconds_full_gametime_;
}
inline double GetPeriodicalsRequest::seconds_full_gametime() const {
  // @@protoc_insertion_point(field_get:ei.GetPeriodicalsRequest.seconds_full_gametime)
  return _internal_seconds_full_gametime();
}
inline void GetPeriodicalsRequest::_internal_set_seconds_full_gametime(double value) {
  _has_bits_[0] |= 0x00000008u;
  seconds_full_gametime_ = value;
}
inline void GetPeriodicalsRequest::set_seconds_full_gametime(double value) {
  _internal_set_seconds_full_gametime(value);
  // @@protoc_insertion_point(field_set:ei.GetPeriodicalsRequest.seconds_full_gametime)
}

// optional uint32 lost_increments = 7;
inline bool GetPeriodicalsRequest::_internal_has_lost_increments() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool GetPeriodicalsRequest::has_lost_increments() const {
  return _internal_has_lost_increments();
}
inline void GetPeriodicalsRequest::clear_lost_increments() {
  lost_increments_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t GetPeriodicalsRequest::_internal_lost_increments() const {
  return lost_increments_;
}
inline uint32_t GetPeriodicalsRequest::lost_increments() const {
  // @@protoc_insertion_point(field_get:ei.GetPeriodicalsRequest.lost_increments)
  return _internal_lost_increments();
}
inline void GetPeriodicalsRequest::_internal_set_lost_increments(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  lost_increments_ = value;
}
inline void GetPeriodicalsRequest::set_lost_increments(uint32_t value) {
  _internal_set_lost_increments(value);
  // @@protoc_insertion_point(field_set:ei.GetPeriodicalsRequest.lost_increments)
}

// optional double soul_eggs = 8;
inline bool GetPeriodicalsRequest::_internal_has_soul_eggs() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GetPeriodicalsRequest::has_soul_eggs() const {
  return _internal_has_soul_eggs();
}
inline void GetPeriodicalsRequest::clear_soul_eggs() {
  soul_eggs_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double GetPeriodicalsRequest::_internal_soul_eggs() const {
  return soul_eggs_;
}
inline double GetPeriodicalsRequest::soul_eggs() const {
  // @@protoc_insertion_point(field_get:ei.GetPeriodicalsRequest.soul_eggs)
  return _internal_soul_eggs();
}
inline void GetPeriodicalsRequest::_internal_set_soul_eggs(double value) {
  _has_bits_[0] |= 0x00000010u;
  soul_eggs_ = value;
}
inline void GetPeriodicalsRequest::set_soul_eggs(double value) {
  _internal_set_soul_eggs(value);
  // @@protoc_insertion_point(field_set:ei.GetPeriodicalsRequest.soul_eggs)
}

// optional double mystical_earnings_mult = 13;
inline bool GetPeriodicalsRequest::_internal_has_mystical_earnings_mult() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool GetPeriodicalsRequest::has_mystical_earnings_mult() const {
  return _internal_has_mystical_earnings_mult();
}
inline void GetPeriodicalsRequest::clear_mystical_earnings_mult() {
  mystical_earnings_mult_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline double GetPeriodicalsRequest::_internal_mystical_earnings_mult() const {
  return mystical_earnings_mult_;
}
inline double GetPeriodicalsRequest::mystical_earnings_mult() const {
  // @@protoc_insertion_point(field_get:ei.GetPeriodicalsRequest.mystical_earnings_mult)
  return _internal_mystical_earnings_mult();
}
inline void GetPeriodicalsRequest::_internal_set_mystical_earnings_mult(double value) {
  _has_bits_[0] |= 0x00001000u;
  mystical_earnings_mult_ = value;
}
inline void GetPeriodicalsRequest::set_mystical_earnings_mult(double value) {
  _internal_set_mystical_earnings_mult(value);
  // @@protoc_insertion_point(field_set:ei.GetPeriodicalsRequest.mystical_earnings_mult)
}

// optional uint32 eop = 14;
inline bool GetPeriodicalsRequest::_internal_has_eop() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool GetPeriodicalsRequest::has_eop() const {
  return _internal_has_eop();
}
inline void GetPeriodicalsRequest::clear_eop() {
  eop_ = 0u;
  _has_bits_[0] &= ~0x00002000u;
}
inline uint32_t GetPeriodicalsRequest::_internal_eop() const {
  return eop_;
}
inline uint32_t GetPeriodicalsRequest::eop() const {
  // @@protoc_insertion_point(field_get:ei.GetPeriodicalsRequest.eop)
  return _internal_eop();
}
inline void GetPeriodicalsRequest::_internal_set_eop(uint32_t value) {
  _has_bits_[0] |= 0x00002000u;
  eop_ = value;
}
inline void GetPeriodicalsRequest::set_eop(uint32_t value) {
  _internal_set_eop(value);
  // @@protoc_insertion_point(field_set:ei.GetPeriodicalsRequest.eop)
}

// optional bool contracts_unlocked = 15;
inline bool GetPeriodicalsRequest::_internal_has_contracts_unlocked() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool GetPeriodicalsRequest::has_contracts_unlocked() const {
  return _internal_has_contracts_unlocked();
}
inline void GetPeriodicalsRequest::clear_contracts_unlocked() {
  contracts_unlocked_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool GetPeriodicalsRequest::_internal_contracts_unlocked() const {
  return contracts_unlocked_;
}
inline bool GetPeriodicalsRequest::contracts_unlocked() const {
  // @@protoc_insertion_point(field_get:ei.GetPeriodicalsRequest.contracts_unlocked)
  return _internal_contracts_unlocked();
}
inline void GetPeriodicalsRequest::_internal_set_contracts_unlocked(bool value) {
  _has_bits_[0] |= 0x00000100u;
  contracts_unlocked_ = value;
}
inline void GetPeriodicalsRequest::set_contracts_unlocked(bool value) {
  _internal_set_contracts_unlocked(value);
  // @@protoc_insertion_point(field_set:ei.GetPeriodicalsRequest.contracts_unlocked)
}

// optional bool artifacts_unlocked = 16;
inline bool GetPeriodicalsRequest::_internal_has_artifacts_unlocked() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool GetPeriodicalsRequest::has_artifacts_unlocked() const {
  return _internal_has_artifacts_unlocked();
}
inline void GetPeriodicalsRequest::clear_artifacts_unlocked() {
  artifacts_unlocked_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool GetPeriodicalsRequest::_internal_artifacts_unlocked() const {
  return artifacts_unlocked_;
}
inline bool GetPeriodicalsRequest::artifacts_unlocked() const {
  // @@protoc_insertion_point(field_get:ei.GetPeriodicalsRequest.artifacts_unlocked)
  return _internal_artifacts_unlocked();
}
inline void GetPeriodicalsRequest::_internal_set_artifacts_unlocked(bool value) {
  _has_bits_[0] |= 0x00000200u;
  artifacts_unlocked_ = value;
}
inline void GetPeriodicalsRequest::set_artifacts_unlocked(bool value) {
  _internal_set_artifacts_unlocked(value);
  // @@protoc_insertion_point(field_set:ei.GetPeriodicalsRequest.artifacts_unlocked)
}

// optional uint32 current_client_version = 10;
inline bool GetPeriodicalsRequest::_internal_has_current_client_version() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool GetPeriodicalsRequest::has_current_client_version() const {
  return _internal_has_current_client_version();
}
inline void GetPeriodicalsRequest::clear_current_client_version() {
  current_client_version_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline uint32_t GetPeriodicalsRequest::_internal_current_client_version() const {
  return current_client_version_;
}
inline uint32_t GetPeriodicalsRequest::current_client_version() const {
  // @@protoc_insertion_point(field_get:ei.GetPeriodicalsRequest.current_client_version)
  return _internal_current_client_version();
}
inline void GetPeriodicalsRequest::_internal_set_current_client_version(uint32_t value) {
  _has_bits_[0] |= 0x00000400u;
  current_client_version_ = value;
}
inline void GetPeriodicalsRequest::set_current_client_version(uint32_t value) {
  _internal_set_current_client_version(value);
  // @@protoc_insertion_point(field_set:ei.GetPeriodicalsRequest.current_client_version)
}

// optional bool debug = 11;
inline bool GetPeriodicalsRequest::_internal_has_debug() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool GetPeriodicalsRequest::has_debug() const {
  return _internal_has_debug();
}
inline void GetPeriodicalsRequest::clear_debug() {
  debug_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool GetPeriodicalsRequest::_internal_debug() const {
  return debug_;
}
inline bool GetPeriodicalsRequest::debug() const {
  // @@protoc_insertion_point(field_get:ei.GetPeriodicalsRequest.debug)
  return _internal_debug();
}
inline void GetPeriodicalsRequest::_internal_set_debug(bool value) {
  _has_bits_[0] |= 0x00000800u;
  debug_ = value;
}
inline void GetPeriodicalsRequest::set_debug(bool value) {
  _internal_set_debug(value);
  // @@protoc_insertion_point(field_set:ei.GetPeriodicalsRequest.debug)
}

// -------------------------------------------------------------------

// ConfigRequest

// optional .ei.BasicRequestInfo rinfo = 1;
inline bool ConfigRequest::_internal_has_rinfo() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || rinfo_ != nullptr);
  return value;
}
inline bool ConfigRequest::has_rinfo() const {
  return _internal_has_rinfo();
}
inline void ConfigRequest::clear_rinfo() {
  if (rinfo_ != nullptr) rinfo_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ei::BasicRequestInfo& ConfigRequest::_internal_rinfo() const {
  const ::ei::BasicRequestInfo* p = rinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::BasicRequestInfo&>(
      ::ei::_BasicRequestInfo_default_instance_);
}
inline const ::ei::BasicRequestInfo& ConfigRequest::rinfo() const {
  // @@protoc_insertion_point(field_get:ei.ConfigRequest.rinfo)
  return _internal_rinfo();
}
inline void ConfigRequest::unsafe_arena_set_allocated_rinfo(
    ::ei::BasicRequestInfo* rinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rinfo_);
  }
  rinfo_ = rinfo;
  if (rinfo) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.ConfigRequest.rinfo)
}
inline ::ei::BasicRequestInfo* ConfigRequest::release_rinfo() {
  _has_bits_[0] &= ~0x00000001u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::BasicRequestInfo* ConfigRequest::unsafe_arena_release_rinfo() {
  // @@protoc_insertion_point(field_release:ei.ConfigRequest.rinfo)
  _has_bits_[0] &= ~0x00000001u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
  return temp;
}
inline ::ei::BasicRequestInfo* ConfigRequest::_internal_mutable_rinfo() {
  _has_bits_[0] |= 0x00000001u;
  if (rinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::BasicRequestInfo>(GetArenaForAllocation());
    rinfo_ = p;
  }
  return rinfo_;
}
inline ::ei::BasicRequestInfo* ConfigRequest::mutable_rinfo() {
  ::ei::BasicRequestInfo* _msg = _internal_mutable_rinfo();
  // @@protoc_insertion_point(field_mutable:ei.ConfigRequest.rinfo)
  return _msg;
}
inline void ConfigRequest::set_allocated_rinfo(::ei::BasicRequestInfo* rinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rinfo_;
  }
  if (rinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::BasicRequestInfo>::GetOwningArena(rinfo);
    if (message_arena != submessage_arena) {
      rinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  rinfo_ = rinfo;
  // @@protoc_insertion_point(field_set_allocated:ei.ConfigRequest.rinfo)
}

// optional double soul_eggs = 2;
inline bool ConfigRequest::_internal_has_soul_eggs() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConfigRequest::has_soul_eggs() const {
  return _internal_has_soul_eggs();
}
inline void ConfigRequest::clear_soul_eggs() {
  soul_eggs_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ConfigRequest::_internal_soul_eggs() const {
  return soul_eggs_;
}
inline double ConfigRequest::soul_eggs() const {
  // @@protoc_insertion_point(field_get:ei.ConfigRequest.soul_eggs)
  return _internal_soul_eggs();
}
inline void ConfigRequest::_internal_set_soul_eggs(double value) {
  _has_bits_[0] |= 0x00000002u;
  soul_eggs_ = value;
}
inline void ConfigRequest::set_soul_eggs(double value) {
  _internal_set_soul_eggs(value);
  // @@protoc_insertion_point(field_set:ei.ConfigRequest.soul_eggs)
}

// optional bool artifacts_enabled = 3;
inline bool ConfigRequest::_internal_has_artifacts_enabled() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConfigRequest::has_artifacts_enabled() const {
  return _internal_has_artifacts_enabled();
}
inline void ConfigRequest::clear_artifacts_enabled() {
  artifacts_enabled_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ConfigRequest::_internal_artifacts_enabled() const {
  return artifacts_enabled_;
}
inline bool ConfigRequest::artifacts_enabled() const {
  // @@protoc_insertion_point(field_get:ei.ConfigRequest.artifacts_enabled)
  return _internal_artifacts_enabled();
}
inline void ConfigRequest::_internal_set_artifacts_enabled(bool value) {
  _has_bits_[0] |= 0x00000004u;
  artifacts_enabled_ = value;
}
inline void ConfigRequest::set_artifacts_enabled(bool value) {
  _internal_set_artifacts_enabled(value);
  // @@protoc_insertion_point(field_set:ei.ConfigRequest.artifacts_enabled)
}

// optional bool fuel_tank_unlocked = 4;
inline bool ConfigRequest::_internal_has_fuel_tank_unlocked() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ConfigRequest::has_fuel_tank_unlocked() const {
  return _internal_has_fuel_tank_unlocked();
}
inline void ConfigRequest::clear_fuel_tank_unlocked() {
  fuel_tank_unlocked_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ConfigRequest::_internal_fuel_tank_unlocked() const {
  return fuel_tank_unlocked_;
}
inline bool ConfigRequest::fuel_tank_unlocked() const {
  // @@protoc_insertion_point(field_get:ei.ConfigRequest.fuel_tank_unlocked)
  return _internal_fuel_tank_unlocked();
}
inline void ConfigRequest::_internal_set_fuel_tank_unlocked(bool value) {
  _has_bits_[0] |= 0x00000008u;
  fuel_tank_unlocked_ = value;
}
inline void ConfigRequest::set_fuel_tank_unlocked(bool value) {
  _internal_set_fuel_tank_unlocked(value);
  // @@protoc_insertion_point(field_set:ei.ConfigRequest.fuel_tank_unlocked)
}

// -------------------------------------------------------------------

// ConfigResponse

// optional .ei.LiveConfig live_config = 1;
inline bool ConfigResponse::_internal_has_live_config() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || live_config_ != nullptr);
  return value;
}
inline bool ConfigResponse::has_live_config() const {
  return _internal_has_live_config();
}
inline void ConfigResponse::clear_live_config() {
  if (live_config_ != nullptr) live_config_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ei::LiveConfig& ConfigResponse::_internal_live_config() const {
  const ::ei::LiveConfig* p = live_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::LiveConfig&>(
      ::ei::_LiveConfig_default_instance_);
}
inline const ::ei::LiveConfig& ConfigResponse::live_config() const {
  // @@protoc_insertion_point(field_get:ei.ConfigResponse.live_config)
  return _internal_live_config();
}
inline void ConfigResponse::unsafe_arena_set_allocated_live_config(
    ::ei::LiveConfig* live_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(live_config_);
  }
  live_config_ = live_config;
  if (live_config) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.ConfigResponse.live_config)
}
inline ::ei::LiveConfig* ConfigResponse::release_live_config() {
  _has_bits_[0] &= ~0x00000001u;
  ::ei::LiveConfig* temp = live_config_;
  live_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::LiveConfig* ConfigResponse::unsafe_arena_release_live_config() {
  // @@protoc_insertion_point(field_release:ei.ConfigResponse.live_config)
  _has_bits_[0] &= ~0x00000001u;
  ::ei::LiveConfig* temp = live_config_;
  live_config_ = nullptr;
  return temp;
}
inline ::ei::LiveConfig* ConfigResponse::_internal_mutable_live_config() {
  _has_bits_[0] |= 0x00000001u;
  if (live_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::LiveConfig>(GetArenaForAllocation());
    live_config_ = p;
  }
  return live_config_;
}
inline ::ei::LiveConfig* ConfigResponse::mutable_live_config() {
  ::ei::LiveConfig* _msg = _internal_mutable_live_config();
  // @@protoc_insertion_point(field_mutable:ei.ConfigResponse.live_config)
  return _msg;
}
inline void ConfigResponse::set_allocated_live_config(::ei::LiveConfig* live_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete live_config_;
  }
  if (live_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::LiveConfig>::GetOwningArena(live_config);
    if (message_arena != submessage_arena) {
      live_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, live_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  live_config_ = live_config;
  // @@protoc_insertion_point(field_set_allocated:ei.ConfigResponse.live_config)
}

// optional .ei.MailDB mail_bag = 2;
inline bool ConfigResponse::_internal_has_mail_bag() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || mail_bag_ != nullptr);
  return value;
}
inline bool ConfigResponse::has_mail_bag() const {
  return _internal_has_mail_bag();
}
inline void ConfigResponse::clear_mail_bag() {
  if (mail_bag_ != nullptr) mail_bag_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ei::MailDB& ConfigResponse::_internal_mail_bag() const {
  const ::ei::MailDB* p = mail_bag_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::MailDB&>(
      ::ei::_MailDB_default_instance_);
}
inline const ::ei::MailDB& ConfigResponse::mail_bag() const {
  // @@protoc_insertion_point(field_get:ei.ConfigResponse.mail_bag)
  return _internal_mail_bag();
}
inline void ConfigResponse::unsafe_arena_set_allocated_mail_bag(
    ::ei::MailDB* mail_bag) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mail_bag_);
  }
  mail_bag_ = mail_bag;
  if (mail_bag) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.ConfigResponse.mail_bag)
}
inline ::ei::MailDB* ConfigResponse::release_mail_bag() {
  _has_bits_[0] &= ~0x00000002u;
  ::ei::MailDB* temp = mail_bag_;
  mail_bag_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::MailDB* ConfigResponse::unsafe_arena_release_mail_bag() {
  // @@protoc_insertion_point(field_release:ei.ConfigResponse.mail_bag)
  _has_bits_[0] &= ~0x00000002u;
  ::ei::MailDB* temp = mail_bag_;
  mail_bag_ = nullptr;
  return temp;
}
inline ::ei::MailDB* ConfigResponse::_internal_mutable_mail_bag() {
  _has_bits_[0] |= 0x00000002u;
  if (mail_bag_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::MailDB>(GetArenaForAllocation());
    mail_bag_ = p;
  }
  return mail_bag_;
}
inline ::ei::MailDB* ConfigResponse::mutable_mail_bag() {
  ::ei::MailDB* _msg = _internal_mutable_mail_bag();
  // @@protoc_insertion_point(field_mutable:ei.ConfigResponse.mail_bag)
  return _msg;
}
inline void ConfigResponse::set_allocated_mail_bag(::ei::MailDB* mail_bag) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete mail_bag_;
  }
  if (mail_bag) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::MailDB>::GetOwningArena(mail_bag);
    if (message_arena != submessage_arena) {
      mail_bag = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mail_bag, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  mail_bag_ = mail_bag;
  // @@protoc_insertion_point(field_set_allocated:ei.ConfigResponse.mail_bag)
}

// optional .ei.DLCCatalog dlc_catalog = 3;
inline bool ConfigResponse::_internal_has_dlc_catalog() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || dlc_catalog_ != nullptr);
  return value;
}
inline bool ConfigResponse::has_dlc_catalog() const {
  return _internal_has_dlc_catalog();
}
inline void ConfigResponse::clear_dlc_catalog() {
  if (dlc_catalog_ != nullptr) dlc_catalog_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ei::DLCCatalog& ConfigResponse::_internal_dlc_catalog() const {
  const ::ei::DLCCatalog* p = dlc_catalog_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::DLCCatalog&>(
      ::ei::_DLCCatalog_default_instance_);
}
inline const ::ei::DLCCatalog& ConfigResponse::dlc_catalog() const {
  // @@protoc_insertion_point(field_get:ei.ConfigResponse.dlc_catalog)
  return _internal_dlc_catalog();
}
inline void ConfigResponse::unsafe_arena_set_allocated_dlc_catalog(
    ::ei::DLCCatalog* dlc_catalog) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dlc_catalog_);
  }
  dlc_catalog_ = dlc_catalog;
  if (dlc_catalog) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.ConfigResponse.dlc_catalog)
}
inline ::ei::DLCCatalog* ConfigResponse::release_dlc_catalog() {
  _has_bits_[0] &= ~0x00000004u;
  ::ei::DLCCatalog* temp = dlc_catalog_;
  dlc_catalog_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::DLCCatalog* ConfigResponse::unsafe_arena_release_dlc_catalog() {
  // @@protoc_insertion_point(field_release:ei.ConfigResponse.dlc_catalog)
  _has_bits_[0] &= ~0x00000004u;
  ::ei::DLCCatalog* temp = dlc_catalog_;
  dlc_catalog_ = nullptr;
  return temp;
}
inline ::ei::DLCCatalog* ConfigResponse::_internal_mutable_dlc_catalog() {
  _has_bits_[0] |= 0x00000004u;
  if (dlc_catalog_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::DLCCatalog>(GetArenaForAllocation());
    dlc_catalog_ = p;
  }
  return dlc_catalog_;
}
inline ::ei::DLCCatalog* ConfigResponse::mutable_dlc_catalog() {
  ::ei::DLCCatalog* _msg = _internal_mutable_dlc_catalog();
  // @@protoc_insertion_point(field_mutable:ei.ConfigResponse.dlc_catalog)
  return _msg;
}
inline void ConfigResponse::set_allocated_dlc_catalog(::ei::DLCCatalog* dlc_catalog) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dlc_catalog_;
  }
  if (dlc_catalog) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::DLCCatalog>::GetOwningArena(dlc_catalog);
    if (message_arena != submessage_arena) {
      dlc_catalog = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dlc_catalog, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  dlc_catalog_ = dlc_catalog;
  // @@protoc_insertion_point(field_set_allocated:ei.ConfigResponse.dlc_catalog)
}

// -------------------------------------------------------------------

// AdAttributionRawData

// optional string device_ad_id = 1;
inline bool AdAttributionRawData::_internal_has_device_ad_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AdAttributionRawData::has_device_ad_id() const {
  return _internal_has_device_ad_id();
}
inline void AdAttributionRawData::clear_device_ad_id() {
  device_ad_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AdAttributionRawData::device_ad_id() const {
  // @@protoc_insertion_point(field_get:ei.AdAttributionRawData.device_ad_id)
  return _internal_device_ad_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdAttributionRawData::set_device_ad_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 device_ad_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AdAttributionRawData.device_ad_id)
}
inline std::string* AdAttributionRawData::mutable_device_ad_id() {
  std::string* _s = _internal_mutable_device_ad_id();
  // @@protoc_insertion_point(field_mutable:ei.AdAttributionRawData.device_ad_id)
  return _s;
}
inline const std::string& AdAttributionRawData::_internal_device_ad_id() const {
  return device_ad_id_.Get();
}
inline void AdAttributionRawData::_internal_set_device_ad_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  device_ad_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AdAttributionRawData::_internal_mutable_device_ad_id() {
  _has_bits_[0] |= 0x00000001u;
  return device_ad_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AdAttributionRawData::release_device_ad_id() {
  // @@protoc_insertion_point(field_release:ei.AdAttributionRawData.device_ad_id)
  if (!_internal_has_device_ad_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = device_ad_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_ad_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_ad_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdAttributionRawData::set_allocated_device_ad_id(std::string* device_ad_id) {
  if (device_ad_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  device_ad_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_ad_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_ad_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_ad_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AdAttributionRawData.device_ad_id)
}

// optional string user_id = 4;
inline bool AdAttributionRawData::_internal_has_user_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AdAttributionRawData::has_user_id() const {
  return _internal_has_user_id();
}
inline void AdAttributionRawData::clear_user_id() {
  user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& AdAttributionRawData::user_id() const {
  // @@protoc_insertion_point(field_get:ei.AdAttributionRawData.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdAttributionRawData::set_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AdAttributionRawData.user_id)
}
inline std::string* AdAttributionRawData::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:ei.AdAttributionRawData.user_id)
  return _s;
}
inline const std::string& AdAttributionRawData::_internal_user_id() const {
  return user_id_.Get();
}
inline void AdAttributionRawData::_internal_set_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AdAttributionRawData::_internal_mutable_user_id() {
  _has_bits_[0] |= 0x00000008u;
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AdAttributionRawData::release_user_id() {
  // @@protoc_insertion_point(field_release:ei.AdAttributionRawData.user_id)
  if (!_internal_has_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdAttributionRawData::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AdAttributionRawData.user_id)
}

// optional string ad_network = 2;
inline bool AdAttributionRawData::_internal_has_ad_network() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AdAttributionRawData::has_ad_network() const {
  return _internal_has_ad_network();
}
inline void AdAttributionRawData::clear_ad_network() {
  ad_network_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AdAttributionRawData::ad_network() const {
  // @@protoc_insertion_point(field_get:ei.AdAttributionRawData.ad_network)
  return _internal_ad_network();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdAttributionRawData::set_ad_network(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 ad_network_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AdAttributionRawData.ad_network)
}
inline std::string* AdAttributionRawData::mutable_ad_network() {
  std::string* _s = _internal_mutable_ad_network();
  // @@protoc_insertion_point(field_mutable:ei.AdAttributionRawData.ad_network)
  return _s;
}
inline const std::string& AdAttributionRawData::_internal_ad_network() const {
  return ad_network_.Get();
}
inline void AdAttributionRawData::_internal_set_ad_network(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  ad_network_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AdAttributionRawData::_internal_mutable_ad_network() {
  _has_bits_[0] |= 0x00000002u;
  return ad_network_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AdAttributionRawData::release_ad_network() {
  // @@protoc_insertion_point(field_release:ei.AdAttributionRawData.ad_network)
  if (!_internal_has_ad_network()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = ad_network_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ad_network_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ad_network_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdAttributionRawData::set_allocated_ad_network(std::string* ad_network) {
  if (ad_network != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ad_network_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ad_network,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ad_network_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ad_network_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AdAttributionRawData.ad_network)
}

// optional string json_data = 3;
inline bool AdAttributionRawData::_internal_has_json_data() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AdAttributionRawData::has_json_data() const {
  return _internal_has_json_data();
}
inline void AdAttributionRawData::clear_json_data() {
  json_data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AdAttributionRawData::json_data() const {
  // @@protoc_insertion_point(field_get:ei.AdAttributionRawData.json_data)
  return _internal_json_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdAttributionRawData::set_json_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 json_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AdAttributionRawData.json_data)
}
inline std::string* AdAttributionRawData::mutable_json_data() {
  std::string* _s = _internal_mutable_json_data();
  // @@protoc_insertion_point(field_mutable:ei.AdAttributionRawData.json_data)
  return _s;
}
inline const std::string& AdAttributionRawData::_internal_json_data() const {
  return json_data_.Get();
}
inline void AdAttributionRawData::_internal_set_json_data(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  json_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AdAttributionRawData::_internal_mutable_json_data() {
  _has_bits_[0] |= 0x00000004u;
  return json_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AdAttributionRawData::release_json_data() {
  // @@protoc_insertion_point(field_release:ei.AdAttributionRawData.json_data)
  if (!_internal_has_json_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = json_data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (json_data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    json_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdAttributionRawData::set_allocated_json_data(std::string* json_data) {
  if (json_data != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  json_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), json_data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (json_data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    json_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AdAttributionRawData.json_data)
}

// -------------------------------------------------------------------

// AdAttributionRow

// optional string user_id = 1;
inline bool AdAttributionRow::_internal_has_user_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AdAttributionRow::has_user_id() const {
  return _internal_has_user_id();
}
inline void AdAttributionRow::clear_user_id() {
  user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AdAttributionRow::user_id() const {
  // @@protoc_insertion_point(field_get:ei.AdAttributionRow.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdAttributionRow::set_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AdAttributionRow.user_id)
}
inline std::string* AdAttributionRow::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:ei.AdAttributionRow.user_id)
  return _s;
}
inline const std::string& AdAttributionRow::_internal_user_id() const {
  return user_id_.Get();
}
inline void AdAttributionRow::_internal_set_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AdAttributionRow::_internal_mutable_user_id() {
  _has_bits_[0] |= 0x00000001u;
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AdAttributionRow::release_user_id() {
  // @@protoc_insertion_point(field_release:ei.AdAttributionRow.user_id)
  if (!_internal_has_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdAttributionRow::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AdAttributionRow.user_id)
}

// optional string ad_id = 2;
inline bool AdAttributionRow::_internal_has_ad_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AdAttributionRow::has_ad_id() const {
  return _internal_has_ad_id();
}
inline void AdAttributionRow::clear_ad_id() {
  ad_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AdAttributionRow::ad_id() const {
  // @@protoc_insertion_point(field_get:ei.AdAttributionRow.ad_id)
  return _internal_ad_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdAttributionRow::set_ad_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 ad_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AdAttributionRow.ad_id)
}
inline std::string* AdAttributionRow::mutable_ad_id() {
  std::string* _s = _internal_mutable_ad_id();
  // @@protoc_insertion_point(field_mutable:ei.AdAttributionRow.ad_id)
  return _s;
}
inline const std::string& AdAttributionRow::_internal_ad_id() const {
  return ad_id_.Get();
}
inline void AdAttributionRow::_internal_set_ad_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  ad_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AdAttributionRow::_internal_mutable_ad_id() {
  _has_bits_[0] |= 0x00000002u;
  return ad_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AdAttributionRow::release_ad_id() {
  // @@protoc_insertion_point(field_release:ei.AdAttributionRow.ad_id)
  if (!_internal_has_ad_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = ad_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ad_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ad_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdAttributionRow::set_allocated_ad_id(std::string* ad_id) {
  if (ad_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ad_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ad_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ad_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ad_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AdAttributionRow.ad_id)
}

// optional string ad_network = 3;
inline bool AdAttributionRow::_internal_has_ad_network() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AdAttributionRow::has_ad_network() const {
  return _internal_has_ad_network();
}
inline void AdAttributionRow::clear_ad_network() {
  ad_network_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AdAttributionRow::ad_network() const {
  // @@protoc_insertion_point(field_get:ei.AdAttributionRow.ad_network)
  return _internal_ad_network();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdAttributionRow::set_ad_network(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 ad_network_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AdAttributionRow.ad_network)
}
inline std::string* AdAttributionRow::mutable_ad_network() {
  std::string* _s = _internal_mutable_ad_network();
  // @@protoc_insertion_point(field_mutable:ei.AdAttributionRow.ad_network)
  return _s;
}
inline const std::string& AdAttributionRow::_internal_ad_network() const {
  return ad_network_.Get();
}
inline void AdAttributionRow::_internal_set_ad_network(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  ad_network_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AdAttributionRow::_internal_mutable_ad_network() {
  _has_bits_[0] |= 0x00000004u;
  return ad_network_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AdAttributionRow::release_ad_network() {
  // @@protoc_insertion_point(field_release:ei.AdAttributionRow.ad_network)
  if (!_internal_has_ad_network()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = ad_network_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ad_network_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ad_network_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdAttributionRow::set_allocated_ad_network(std::string* ad_network) {
  if (ad_network != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  ad_network_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ad_network,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ad_network_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ad_network_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AdAttributionRow.ad_network)
}

// optional string campaign = 4;
inline bool AdAttributionRow::_internal_has_campaign() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AdAttributionRow::has_campaign() const {
  return _internal_has_campaign();
}
inline void AdAttributionRow::clear_campaign() {
  campaign_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& AdAttributionRow::campaign() const {
  // @@protoc_insertion_point(field_get:ei.AdAttributionRow.campaign)
  return _internal_campaign();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdAttributionRow::set_campaign(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 campaign_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AdAttributionRow.campaign)
}
inline std::string* AdAttributionRow::mutable_campaign() {
  std::string* _s = _internal_mutable_campaign();
  // @@protoc_insertion_point(field_mutable:ei.AdAttributionRow.campaign)
  return _s;
}
inline const std::string& AdAttributionRow::_internal_campaign() const {
  return campaign_.Get();
}
inline void AdAttributionRow::_internal_set_campaign(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  campaign_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AdAttributionRow::_internal_mutable_campaign() {
  _has_bits_[0] |= 0x00000008u;
  return campaign_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AdAttributionRow::release_campaign() {
  // @@protoc_insertion_point(field_release:ei.AdAttributionRow.campaign)
  if (!_internal_has_campaign()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = campaign_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (campaign_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    campaign_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdAttributionRow::set_allocated_campaign(std::string* campaign) {
  if (campaign != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  campaign_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), campaign,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (campaign_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    campaign_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AdAttributionRow.campaign)
}

// optional string keyword = 5;
inline bool AdAttributionRow::_internal_has_keyword() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AdAttributionRow::has_keyword() const {
  return _internal_has_keyword();
}
inline void AdAttributionRow::clear_keyword() {
  keyword_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& AdAttributionRow::keyword() const {
  // @@protoc_insertion_point(field_get:ei.AdAttributionRow.keyword)
  return _internal_keyword();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdAttributionRow::set_keyword(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 keyword_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AdAttributionRow.keyword)
}
inline std::string* AdAttributionRow::mutable_keyword() {
  std::string* _s = _internal_mutable_keyword();
  // @@protoc_insertion_point(field_mutable:ei.AdAttributionRow.keyword)
  return _s;
}
inline const std::string& AdAttributionRow::_internal_keyword() const {
  return keyword_.Get();
}
inline void AdAttributionRow::_internal_set_keyword(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  keyword_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AdAttributionRow::_internal_mutable_keyword() {
  _has_bits_[0] |= 0x00000010u;
  return keyword_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AdAttributionRow::release_keyword() {
  // @@protoc_insertion_point(field_release:ei.AdAttributionRow.keyword)
  if (!_internal_has_keyword()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = keyword_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (keyword_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    keyword_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdAttributionRow::set_allocated_keyword(std::string* keyword) {
  if (keyword != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  keyword_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), keyword,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (keyword_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    keyword_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AdAttributionRow.keyword)
}

// optional string extra = 6;
inline bool AdAttributionRow::_internal_has_extra() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool AdAttributionRow::has_extra() const {
  return _internal_has_extra();
}
inline void AdAttributionRow::clear_extra() {
  extra_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& AdAttributionRow::extra() const {
  // @@protoc_insertion_point(field_get:ei.AdAttributionRow.extra)
  return _internal_extra();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdAttributionRow::set_extra(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 extra_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AdAttributionRow.extra)
}
inline std::string* AdAttributionRow::mutable_extra() {
  std::string* _s = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:ei.AdAttributionRow.extra)
  return _s;
}
inline const std::string& AdAttributionRow::_internal_extra() const {
  return extra_.Get();
}
inline void AdAttributionRow::_internal_set_extra(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  extra_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AdAttributionRow::_internal_mutable_extra() {
  _has_bits_[0] |= 0x00000020u;
  return extra_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AdAttributionRow::release_extra() {
  // @@protoc_insertion_point(field_release:ei.AdAttributionRow.extra)
  if (!_internal_has_extra()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = extra_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (extra_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    extra_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdAttributionRow::set_allocated_extra(std::string* extra) {
  if (extra != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  extra_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), extra,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (extra_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    extra_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AdAttributionRow.extra)
}

// optional float click_date = 7;
inline bool AdAttributionRow::_internal_has_click_date() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool AdAttributionRow::has_click_date() const {
  return _internal_has_click_date();
}
inline void AdAttributionRow::clear_click_date() {
  click_date_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float AdAttributionRow::_internal_click_date() const {
  return click_date_;
}
inline float AdAttributionRow::click_date() const {
  // @@protoc_insertion_point(field_get:ei.AdAttributionRow.click_date)
  return _internal_click_date();
}
inline void AdAttributionRow::_internal_set_click_date(float value) {
  _has_bits_[0] |= 0x00000040u;
  click_date_ = value;
}
inline void AdAttributionRow::set_click_date(float value) {
  _internal_set_click_date(value);
  // @@protoc_insertion_point(field_set:ei.AdAttributionRow.click_date)
}

// optional float download_date = 8;
inline bool AdAttributionRow::_internal_has_download_date() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool AdAttributionRow::has_download_date() const {
  return _internal_has_download_date();
}
inline void AdAttributionRow::clear_download_date() {
  download_date_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float AdAttributionRow::_internal_download_date() const {
  return download_date_;
}
inline float AdAttributionRow::download_date() const {
  // @@protoc_insertion_point(field_get:ei.AdAttributionRow.download_date)
  return _internal_download_date();
}
inline void AdAttributionRow::_internal_set_download_date(float value) {
  _has_bits_[0] |= 0x00000080u;
  download_date_ = value;
}
inline void AdAttributionRow::set_download_date(float value) {
  _internal_set_download_date(value);
  // @@protoc_insertion_point(field_set:ei.AdAttributionRow.download_date)
}

// optional float approx_time = 9;
inline bool AdAttributionRow::_internal_has_approx_time() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool AdAttributionRow::has_approx_time() const {
  return _internal_has_approx_time();
}
inline void AdAttributionRow::clear_approx_time() {
  approx_time_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float AdAttributionRow::_internal_approx_time() const {
  return approx_time_;
}
inline float AdAttributionRow::approx_time() const {
  // @@protoc_insertion_point(field_get:ei.AdAttributionRow.approx_time)
  return _internal_approx_time();
}
inline void AdAttributionRow::_internal_set_approx_time(float value) {
  _has_bits_[0] |= 0x00000100u;
  approx_time_ = value;
}
inline void AdAttributionRow::set_approx_time(float value) {
  _internal_set_approx_time(value);
  // @@protoc_insertion_point(field_set:ei.AdAttributionRow.approx_time)
}

// -------------------------------------------------------------------

// AdAttributionInfo

// optional string device_ad_id = 1;
inline bool AdAttributionInfo::_internal_has_device_ad_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AdAttributionInfo::has_device_ad_id() const {
  return _internal_has_device_ad_id();
}
inline void AdAttributionInfo::clear_device_ad_id() {
  device_ad_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AdAttributionInfo::device_ad_id() const {
  // @@protoc_insertion_point(field_get:ei.AdAttributionInfo.device_ad_id)
  return _internal_device_ad_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdAttributionInfo::set_device_ad_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 device_ad_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AdAttributionInfo.device_ad_id)
}
inline std::string* AdAttributionInfo::mutable_device_ad_id() {
  std::string* _s = _internal_mutable_device_ad_id();
  // @@protoc_insertion_point(field_mutable:ei.AdAttributionInfo.device_ad_id)
  return _s;
}
inline const std::string& AdAttributionInfo::_internal_device_ad_id() const {
  return device_ad_id_.Get();
}
inline void AdAttributionInfo::_internal_set_device_ad_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  device_ad_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::_internal_mutable_device_ad_id() {
  _has_bits_[0] |= 0x00000001u;
  return device_ad_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::release_device_ad_id() {
  // @@protoc_insertion_point(field_release:ei.AdAttributionInfo.device_ad_id)
  if (!_internal_has_device_ad_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = device_ad_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_ad_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_ad_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdAttributionInfo::set_allocated_device_ad_id(std::string* device_ad_id) {
  if (device_ad_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  device_ad_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_ad_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_ad_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_ad_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AdAttributionInfo.device_ad_id)
}

// optional string network_name = 2;
inline bool AdAttributionInfo::_internal_has_network_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AdAttributionInfo::has_network_name() const {
  return _internal_has_network_name();
}
inline void AdAttributionInfo::clear_network_name() {
  network_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AdAttributionInfo::network_name() const {
  // @@protoc_insertion_point(field_get:ei.AdAttributionInfo.network_name)
  return _internal_network_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdAttributionInfo::set_network_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 network_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AdAttributionInfo.network_name)
}
inline std::string* AdAttributionInfo::mutable_network_name() {
  std::string* _s = _internal_mutable_network_name();
  // @@protoc_insertion_point(field_mutable:ei.AdAttributionInfo.network_name)
  return _s;
}
inline const std::string& AdAttributionInfo::_internal_network_name() const {
  return network_name_.Get();
}
inline void AdAttributionInfo::_internal_set_network_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  network_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::_internal_mutable_network_name() {
  _has_bits_[0] |= 0x00000002u;
  return network_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::release_network_name() {
  // @@protoc_insertion_point(field_release:ei.AdAttributionInfo.network_name)
  if (!_internal_has_network_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = network_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (network_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    network_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdAttributionInfo::set_allocated_network_name(std::string* network_name) {
  if (network_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  network_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), network_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (network_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    network_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AdAttributionInfo.network_name)
}

// optional bool attribution = 3;
inline bool AdAttributionInfo::_internal_has_attribution() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool AdAttributionInfo::has_attribution() const {
  return _internal_has_attribution();
}
inline void AdAttributionInfo::clear_attribution() {
  attribution_ = false;
  _has_bits_[0] &= ~0x00020000u;
}
inline bool AdAttributionInfo::_internal_attribution() const {
  return attribution_;
}
inline bool AdAttributionInfo::attribution() const {
  // @@protoc_insertion_point(field_get:ei.AdAttributionInfo.attribution)
  return _internal_attribution();
}
inline void AdAttributionInfo::_internal_set_attribution(bool value) {
  _has_bits_[0] |= 0x00020000u;
  attribution_ = value;
}
inline void AdAttributionInfo::set_attribution(bool value) {
  _internal_set_attribution(value);
  // @@protoc_insertion_point(field_set:ei.AdAttributionInfo.attribution)
}

// optional string org_name = 4;
inline bool AdAttributionInfo::_internal_has_org_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AdAttributionInfo::has_org_name() const {
  return _internal_has_org_name();
}
inline void AdAttributionInfo::clear_org_name() {
  org_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AdAttributionInfo::org_name() const {
  // @@protoc_insertion_point(field_get:ei.AdAttributionInfo.org_name)
  return _internal_org_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdAttributionInfo::set_org_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 org_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AdAttributionInfo.org_name)
}
inline std::string* AdAttributionInfo::mutable_org_name() {
  std::string* _s = _internal_mutable_org_name();
  // @@protoc_insertion_point(field_mutable:ei.AdAttributionInfo.org_name)
  return _s;
}
inline const std::string& AdAttributionInfo::_internal_org_name() const {
  return org_name_.Get();
}
inline void AdAttributionInfo::_internal_set_org_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  org_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::_internal_mutable_org_name() {
  _has_bits_[0] |= 0x00000004u;
  return org_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::release_org_name() {
  // @@protoc_insertion_point(field_release:ei.AdAttributionInfo.org_name)
  if (!_internal_has_org_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = org_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    org_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdAttributionInfo::set_allocated_org_name(std::string* org_name) {
  if (org_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  org_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), org_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    org_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AdAttributionInfo.org_name)
}

// optional string org_id = 5;
inline bool AdAttributionInfo::_internal_has_org_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AdAttributionInfo::has_org_id() const {
  return _internal_has_org_id();
}
inline void AdAttributionInfo::clear_org_id() {
  org_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& AdAttributionInfo::org_id() const {
  // @@protoc_insertion_point(field_get:ei.AdAttributionInfo.org_id)
  return _internal_org_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdAttributionInfo::set_org_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 org_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AdAttributionInfo.org_id)
}
inline std::string* AdAttributionInfo::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:ei.AdAttributionInfo.org_id)
  return _s;
}
inline const std::string& AdAttributionInfo::_internal_org_id() const {
  return org_id_.Get();
}
inline void AdAttributionInfo::_internal_set_org_id(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  org_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::_internal_mutable_org_id() {
  _has_bits_[0] |= 0x00000008u;
  return org_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::release_org_id() {
  // @@protoc_insertion_point(field_release:ei.AdAttributionInfo.org_id)
  if (!_internal_has_org_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = org_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    org_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdAttributionInfo::set_allocated_org_id(std::string* org_id) {
  if (org_id != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  org_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), org_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (org_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    org_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AdAttributionInfo.org_id)
}

// optional string campaign_name = 6;
inline bool AdAttributionInfo::_internal_has_campaign_name() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AdAttributionInfo::has_campaign_name() const {
  return _internal_has_campaign_name();
}
inline void AdAttributionInfo::clear_campaign_name() {
  campaign_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& AdAttributionInfo::campaign_name() const {
  // @@protoc_insertion_point(field_get:ei.AdAttributionInfo.campaign_name)
  return _internal_campaign_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdAttributionInfo::set_campaign_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 campaign_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AdAttributionInfo.campaign_name)
}
inline std::string* AdAttributionInfo::mutable_campaign_name() {
  std::string* _s = _internal_mutable_campaign_name();
  // @@protoc_insertion_point(field_mutable:ei.AdAttributionInfo.campaign_name)
  return _s;
}
inline const std::string& AdAttributionInfo::_internal_campaign_name() const {
  return campaign_name_.Get();
}
inline void AdAttributionInfo::_internal_set_campaign_name(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  campaign_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::_internal_mutable_campaign_name() {
  _has_bits_[0] |= 0x00000010u;
  return campaign_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::release_campaign_name() {
  // @@protoc_insertion_point(field_release:ei.AdAttributionInfo.campaign_name)
  if (!_internal_has_campaign_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = campaign_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (campaign_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    campaign_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdAttributionInfo::set_allocated_campaign_name(std::string* campaign_name) {
  if (campaign_name != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  campaign_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), campaign_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (campaign_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    campaign_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AdAttributionInfo.campaign_name)
}

// optional string campaign_id = 7;
inline bool AdAttributionInfo::_internal_has_campaign_id() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool AdAttributionInfo::has_campaign_id() const {
  return _internal_has_campaign_id();
}
inline void AdAttributionInfo::clear_campaign_id() {
  campaign_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& AdAttributionInfo::campaign_id() const {
  // @@protoc_insertion_point(field_get:ei.AdAttributionInfo.campaign_id)
  return _internal_campaign_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdAttributionInfo::set_campaign_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 campaign_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AdAttributionInfo.campaign_id)
}
inline std::string* AdAttributionInfo::mutable_campaign_id() {
  std::string* _s = _internal_mutable_campaign_id();
  // @@protoc_insertion_point(field_mutable:ei.AdAttributionInfo.campaign_id)
  return _s;
}
inline const std::string& AdAttributionInfo::_internal_campaign_id() const {
  return campaign_id_.Get();
}
inline void AdAttributionInfo::_internal_set_campaign_id(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  campaign_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::_internal_mutable_campaign_id() {
  _has_bits_[0] |= 0x00000020u;
  return campaign_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::release_campaign_id() {
  // @@protoc_insertion_point(field_release:ei.AdAttributionInfo.campaign_id)
  if (!_internal_has_campaign_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = campaign_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (campaign_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    campaign_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdAttributionInfo::set_allocated_campaign_id(std::string* campaign_id) {
  if (campaign_id != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  campaign_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), campaign_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (campaign_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    campaign_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AdAttributionInfo.campaign_id)
}

// optional string click_date = 8;
inline bool AdAttributionInfo::_internal_has_click_date() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool AdAttributionInfo::has_click_date() const {
  return _internal_has_click_date();
}
inline void AdAttributionInfo::clear_click_date() {
  click_date_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& AdAttributionInfo::click_date() const {
  // @@protoc_insertion_point(field_get:ei.AdAttributionInfo.click_date)
  return _internal_click_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdAttributionInfo::set_click_date(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 click_date_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AdAttributionInfo.click_date)
}
inline std::string* AdAttributionInfo::mutable_click_date() {
  std::string* _s = _internal_mutable_click_date();
  // @@protoc_insertion_point(field_mutable:ei.AdAttributionInfo.click_date)
  return _s;
}
inline const std::string& AdAttributionInfo::_internal_click_date() const {
  return click_date_.Get();
}
inline void AdAttributionInfo::_internal_set_click_date(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  click_date_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::_internal_mutable_click_date() {
  _has_bits_[0] |= 0x00000040u;
  return click_date_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::release_click_date() {
  // @@protoc_insertion_point(field_release:ei.AdAttributionInfo.click_date)
  if (!_internal_has_click_date()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = click_date_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (click_date_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    click_date_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdAttributionInfo::set_allocated_click_date(std::string* click_date) {
  if (click_date != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  click_date_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), click_date,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (click_date_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    click_date_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AdAttributionInfo.click_date)
}

// optional string conversion_date = 9;
inline bool AdAttributionInfo::_internal_has_conversion_date() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool AdAttributionInfo::has_conversion_date() const {
  return _internal_has_conversion_date();
}
inline void AdAttributionInfo::clear_conversion_date() {
  conversion_date_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& AdAttributionInfo::conversion_date() const {
  // @@protoc_insertion_point(field_get:ei.AdAttributionInfo.conversion_date)
  return _internal_conversion_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdAttributionInfo::set_conversion_date(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 conversion_date_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AdAttributionInfo.conversion_date)
}
inline std::string* AdAttributionInfo::mutable_conversion_date() {
  std::string* _s = _internal_mutable_conversion_date();
  // @@protoc_insertion_point(field_mutable:ei.AdAttributionInfo.conversion_date)
  return _s;
}
inline const std::string& AdAttributionInfo::_internal_conversion_date() const {
  return conversion_date_.Get();
}
inline void AdAttributionInfo::_internal_set_conversion_date(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  conversion_date_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::_internal_mutable_conversion_date() {
  _has_bits_[0] |= 0x00000080u;
  return conversion_date_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::release_conversion_date() {
  // @@protoc_insertion_point(field_release:ei.AdAttributionInfo.conversion_date)
  if (!_internal_has_conversion_date()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  auto* p = conversion_date_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (conversion_date_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    conversion_date_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdAttributionInfo::set_allocated_conversion_date(std::string* conversion_date) {
  if (conversion_date != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  conversion_date_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), conversion_date,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (conversion_date_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    conversion_date_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AdAttributionInfo.conversion_date)
}

// optional string conversion_type = 10;
inline bool AdAttributionInfo::_internal_has_conversion_type() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool AdAttributionInfo::has_conversion_type() const {
  return _internal_has_conversion_type();
}
inline void AdAttributionInfo::clear_conversion_type() {
  conversion_type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& AdAttributionInfo::conversion_type() const {
  // @@protoc_insertion_point(field_get:ei.AdAttributionInfo.conversion_type)
  return _internal_conversion_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdAttributionInfo::set_conversion_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000100u;
 conversion_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AdAttributionInfo.conversion_type)
}
inline std::string* AdAttributionInfo::mutable_conversion_type() {
  std::string* _s = _internal_mutable_conversion_type();
  // @@protoc_insertion_point(field_mutable:ei.AdAttributionInfo.conversion_type)
  return _s;
}
inline const std::string& AdAttributionInfo::_internal_conversion_type() const {
  return conversion_type_.Get();
}
inline void AdAttributionInfo::_internal_set_conversion_type(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  conversion_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::_internal_mutable_conversion_type() {
  _has_bits_[0] |= 0x00000100u;
  return conversion_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::release_conversion_type() {
  // @@protoc_insertion_point(field_release:ei.AdAttributionInfo.conversion_type)
  if (!_internal_has_conversion_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  auto* p = conversion_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (conversion_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    conversion_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdAttributionInfo::set_allocated_conversion_type(std::string* conversion_type) {
  if (conversion_type != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  conversion_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), conversion_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (conversion_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    conversion_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AdAttributionInfo.conversion_type)
}

// optional string geo = 11;
inline bool AdAttributionInfo::_internal_has_geo() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool AdAttributionInfo::has_geo() const {
  return _internal_has_geo();
}
inline void AdAttributionInfo::clear_geo() {
  geo_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000200u;
}
inline const std::string& AdAttributionInfo::geo() const {
  // @@protoc_insertion_point(field_get:ei.AdAttributionInfo.geo)
  return _internal_geo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdAttributionInfo::set_geo(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000200u;
 geo_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AdAttributionInfo.geo)
}
inline std::string* AdAttributionInfo::mutable_geo() {
  std::string* _s = _internal_mutable_geo();
  // @@protoc_insertion_point(field_mutable:ei.AdAttributionInfo.geo)
  return _s;
}
inline const std::string& AdAttributionInfo::_internal_geo() const {
  return geo_.Get();
}
inline void AdAttributionInfo::_internal_set_geo(const std::string& value) {
  _has_bits_[0] |= 0x00000200u;
  geo_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::_internal_mutable_geo() {
  _has_bits_[0] |= 0x00000200u;
  return geo_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::release_geo() {
  // @@protoc_insertion_point(field_release:ei.AdAttributionInfo.geo)
  if (!_internal_has_geo()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000200u;
  auto* p = geo_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (geo_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    geo_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdAttributionInfo::set_allocated_geo(std::string* geo) {
  if (geo != nullptr) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  geo_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), geo,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (geo_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    geo_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AdAttributionInfo.geo)
}

// optional string adgroup_name = 12;
inline bool AdAttributionInfo::_internal_has_adgroup_name() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool AdAttributionInfo::has_adgroup_name() const {
  return _internal_has_adgroup_name();
}
inline void AdAttributionInfo::clear_adgroup_name() {
  adgroup_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000400u;
}
inline const std::string& AdAttributionInfo::adgroup_name() const {
  // @@protoc_insertion_point(field_get:ei.AdAttributionInfo.adgroup_name)
  return _internal_adgroup_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdAttributionInfo::set_adgroup_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000400u;
 adgroup_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AdAttributionInfo.adgroup_name)
}
inline std::string* AdAttributionInfo::mutable_adgroup_name() {
  std::string* _s = _internal_mutable_adgroup_name();
  // @@protoc_insertion_point(field_mutable:ei.AdAttributionInfo.adgroup_name)
  return _s;
}
inline const std::string& AdAttributionInfo::_internal_adgroup_name() const {
  return adgroup_name_.Get();
}
inline void AdAttributionInfo::_internal_set_adgroup_name(const std::string& value) {
  _has_bits_[0] |= 0x00000400u;
  adgroup_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::_internal_mutable_adgroup_name() {
  _has_bits_[0] |= 0x00000400u;
  return adgroup_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::release_adgroup_name() {
  // @@protoc_insertion_point(field_release:ei.AdAttributionInfo.adgroup_name)
  if (!_internal_has_adgroup_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000400u;
  auto* p = adgroup_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (adgroup_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    adgroup_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdAttributionInfo::set_allocated_adgroup_name(std::string* adgroup_name) {
  if (adgroup_name != nullptr) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  adgroup_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), adgroup_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (adgroup_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    adgroup_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AdAttributionInfo.adgroup_name)
}

// optional string adgroup_id = 13;
inline bool AdAttributionInfo::_internal_has_adgroup_id() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool AdAttributionInfo::has_adgroup_id() const {
  return _internal_has_adgroup_id();
}
inline void AdAttributionInfo::clear_adgroup_id() {
  adgroup_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000800u;
}
inline const std::string& AdAttributionInfo::adgroup_id() const {
  // @@protoc_insertion_point(field_get:ei.AdAttributionInfo.adgroup_id)
  return _internal_adgroup_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdAttributionInfo::set_adgroup_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000800u;
 adgroup_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AdAttributionInfo.adgroup_id)
}
inline std::string* AdAttributionInfo::mutable_adgroup_id() {
  std::string* _s = _internal_mutable_adgroup_id();
  // @@protoc_insertion_point(field_mutable:ei.AdAttributionInfo.adgroup_id)
  return _s;
}
inline const std::string& AdAttributionInfo::_internal_adgroup_id() const {
  return adgroup_id_.Get();
}
inline void AdAttributionInfo::_internal_set_adgroup_id(const std::string& value) {
  _has_bits_[0] |= 0x00000800u;
  adgroup_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::_internal_mutable_adgroup_id() {
  _has_bits_[0] |= 0x00000800u;
  return adgroup_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::release_adgroup_id() {
  // @@protoc_insertion_point(field_release:ei.AdAttributionInfo.adgroup_id)
  if (!_internal_has_adgroup_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000800u;
  auto* p = adgroup_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (adgroup_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    adgroup_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdAttributionInfo::set_allocated_adgroup_id(std::string* adgroup_id) {
  if (adgroup_id != nullptr) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  adgroup_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), adgroup_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (adgroup_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    adgroup_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AdAttributionInfo.adgroup_id)
}

// optional string keyword = 14;
inline bool AdAttributionInfo::_internal_has_keyword() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool AdAttributionInfo::has_keyword() const {
  return _internal_has_keyword();
}
inline void AdAttributionInfo::clear_keyword() {
  keyword_.ClearToEmpty();
  _has_bits_[0] &= ~0x00001000u;
}
inline const std::string& AdAttributionInfo::keyword() const {
  // @@protoc_insertion_point(field_get:ei.AdAttributionInfo.keyword)
  return _internal_keyword();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdAttributionInfo::set_keyword(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00001000u;
 keyword_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AdAttributionInfo.keyword)
}
inline std::string* AdAttributionInfo::mutable_keyword() {
  std::string* _s = _internal_mutable_keyword();
  // @@protoc_insertion_point(field_mutable:ei.AdAttributionInfo.keyword)
  return _s;
}
inline const std::string& AdAttributionInfo::_internal_keyword() const {
  return keyword_.Get();
}
inline void AdAttributionInfo::_internal_set_keyword(const std::string& value) {
  _has_bits_[0] |= 0x00001000u;
  keyword_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::_internal_mutable_keyword() {
  _has_bits_[0] |= 0x00001000u;
  return keyword_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::release_keyword() {
  // @@protoc_insertion_point(field_release:ei.AdAttributionInfo.keyword)
  if (!_internal_has_keyword()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00001000u;
  auto* p = keyword_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (keyword_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    keyword_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdAttributionInfo::set_allocated_keyword(std::string* keyword) {
  if (keyword != nullptr) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  keyword_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), keyword,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (keyword_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    keyword_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AdAttributionInfo.keyword)
}

// optional string keyword_id = 15;
inline bool AdAttributionInfo::_internal_has_keyword_id() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool AdAttributionInfo::has_keyword_id() const {
  return _internal_has_keyword_id();
}
inline void AdAttributionInfo::clear_keyword_id() {
  keyword_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00002000u;
}
inline const std::string& AdAttributionInfo::keyword_id() const {
  // @@protoc_insertion_point(field_get:ei.AdAttributionInfo.keyword_id)
  return _internal_keyword_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdAttributionInfo::set_keyword_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00002000u;
 keyword_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AdAttributionInfo.keyword_id)
}
inline std::string* AdAttributionInfo::mutable_keyword_id() {
  std::string* _s = _internal_mutable_keyword_id();
  // @@protoc_insertion_point(field_mutable:ei.AdAttributionInfo.keyword_id)
  return _s;
}
inline const std::string& AdAttributionInfo::_internal_keyword_id() const {
  return keyword_id_.Get();
}
inline void AdAttributionInfo::_internal_set_keyword_id(const std::string& value) {
  _has_bits_[0] |= 0x00002000u;
  keyword_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::_internal_mutable_keyword_id() {
  _has_bits_[0] |= 0x00002000u;
  return keyword_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::release_keyword_id() {
  // @@protoc_insertion_point(field_release:ei.AdAttributionInfo.keyword_id)
  if (!_internal_has_keyword_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00002000u;
  auto* p = keyword_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (keyword_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    keyword_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdAttributionInfo::set_allocated_keyword_id(std::string* keyword_id) {
  if (keyword_id != nullptr) {
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  keyword_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), keyword_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (keyword_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    keyword_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AdAttributionInfo.keyword_id)
}

// optional string keyword_extra = 16;
inline bool AdAttributionInfo::_internal_has_keyword_extra() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool AdAttributionInfo::has_keyword_extra() const {
  return _internal_has_keyword_extra();
}
inline void AdAttributionInfo::clear_keyword_extra() {
  keyword_extra_.ClearToEmpty();
  _has_bits_[0] &= ~0x00004000u;
}
inline const std::string& AdAttributionInfo::keyword_extra() const {
  // @@protoc_insertion_point(field_get:ei.AdAttributionInfo.keyword_extra)
  return _internal_keyword_extra();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdAttributionInfo::set_keyword_extra(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00004000u;
 keyword_extra_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AdAttributionInfo.keyword_extra)
}
inline std::string* AdAttributionInfo::mutable_keyword_extra() {
  std::string* _s = _internal_mutable_keyword_extra();
  // @@protoc_insertion_point(field_mutable:ei.AdAttributionInfo.keyword_extra)
  return _s;
}
inline const std::string& AdAttributionInfo::_internal_keyword_extra() const {
  return keyword_extra_.Get();
}
inline void AdAttributionInfo::_internal_set_keyword_extra(const std::string& value) {
  _has_bits_[0] |= 0x00004000u;
  keyword_extra_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::_internal_mutable_keyword_extra() {
  _has_bits_[0] |= 0x00004000u;
  return keyword_extra_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::release_keyword_extra() {
  // @@protoc_insertion_point(field_release:ei.AdAttributionInfo.keyword_extra)
  if (!_internal_has_keyword_extra()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00004000u;
  auto* p = keyword_extra_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (keyword_extra_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    keyword_extra_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdAttributionInfo::set_allocated_keyword_extra(std::string* keyword_extra) {
  if (keyword_extra != nullptr) {
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  keyword_extra_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), keyword_extra,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (keyword_extra_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    keyword_extra_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AdAttributionInfo.keyword_extra)
}

// optional string creativeset_name = 17;
inline bool AdAttributionInfo::_internal_has_creativeset_name() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool AdAttributionInfo::has_creativeset_name() const {
  return _internal_has_creativeset_name();
}
inline void AdAttributionInfo::clear_creativeset_name() {
  creativeset_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00008000u;
}
inline const std::string& AdAttributionInfo::creativeset_name() const {
  // @@protoc_insertion_point(field_get:ei.AdAttributionInfo.creativeset_name)
  return _internal_creativeset_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdAttributionInfo::set_creativeset_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00008000u;
 creativeset_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AdAttributionInfo.creativeset_name)
}
inline std::string* AdAttributionInfo::mutable_creativeset_name() {
  std::string* _s = _internal_mutable_creativeset_name();
  // @@protoc_insertion_point(field_mutable:ei.AdAttributionInfo.creativeset_name)
  return _s;
}
inline const std::string& AdAttributionInfo::_internal_creativeset_name() const {
  return creativeset_name_.Get();
}
inline void AdAttributionInfo::_internal_set_creativeset_name(const std::string& value) {
  _has_bits_[0] |= 0x00008000u;
  creativeset_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::_internal_mutable_creativeset_name() {
  _has_bits_[0] |= 0x00008000u;
  return creativeset_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::release_creativeset_name() {
  // @@protoc_insertion_point(field_release:ei.AdAttributionInfo.creativeset_name)
  if (!_internal_has_creativeset_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00008000u;
  auto* p = creativeset_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (creativeset_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    creativeset_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdAttributionInfo::set_allocated_creativeset_name(std::string* creativeset_name) {
  if (creativeset_name != nullptr) {
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  creativeset_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), creativeset_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (creativeset_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    creativeset_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AdAttributionInfo.creativeset_name)
}

// optional string creativeset_id = 18;
inline bool AdAttributionInfo::_internal_has_creativeset_id() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool AdAttributionInfo::has_creativeset_id() const {
  return _internal_has_creativeset_id();
}
inline void AdAttributionInfo::clear_creativeset_id() {
  creativeset_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00010000u;
}
inline const std::string& AdAttributionInfo::creativeset_id() const {
  // @@protoc_insertion_point(field_get:ei.AdAttributionInfo.creativeset_id)
  return _internal_creativeset_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdAttributionInfo::set_creativeset_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00010000u;
 creativeset_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AdAttributionInfo.creativeset_id)
}
inline std::string* AdAttributionInfo::mutable_creativeset_id() {
  std::string* _s = _internal_mutable_creativeset_id();
  // @@protoc_insertion_point(field_mutable:ei.AdAttributionInfo.creativeset_id)
  return _s;
}
inline const std::string& AdAttributionInfo::_internal_creativeset_id() const {
  return creativeset_id_.Get();
}
inline void AdAttributionInfo::_internal_set_creativeset_id(const std::string& value) {
  _has_bits_[0] |= 0x00010000u;
  creativeset_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::_internal_mutable_creativeset_id() {
  _has_bits_[0] |= 0x00010000u;
  return creativeset_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AdAttributionInfo::release_creativeset_id() {
  // @@protoc_insertion_point(field_release:ei.AdAttributionInfo.creativeset_id)
  if (!_internal_has_creativeset_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00010000u;
  auto* p = creativeset_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (creativeset_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    creativeset_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdAttributionInfo::set_allocated_creativeset_id(std::string* creativeset_id) {
  if (creativeset_id != nullptr) {
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  creativeset_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), creativeset_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (creativeset_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    creativeset_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AdAttributionInfo.creativeset_id)
}

// -------------------------------------------------------------------

// ArtifactsClientInfo_LaunchCount

// optional .ei.MissionInfo.Spaceship ship = 1;
inline bool ArtifactsClientInfo_LaunchCount::_internal_has_ship() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ArtifactsClientInfo_LaunchCount::has_ship() const {
  return _internal_has_ship();
}
inline void ArtifactsClientInfo_LaunchCount::clear_ship() {
  ship_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::ei::MissionInfo_Spaceship ArtifactsClientInfo_LaunchCount::_internal_ship() const {
  return static_cast< ::ei::MissionInfo_Spaceship >(ship_);
}
inline ::ei::MissionInfo_Spaceship ArtifactsClientInfo_LaunchCount::ship() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsClientInfo.LaunchCount.ship)
  return _internal_ship();
}
inline void ArtifactsClientInfo_LaunchCount::_internal_set_ship(::ei::MissionInfo_Spaceship value) {
  assert(::ei::MissionInfo_Spaceship_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  ship_ = value;
}
inline void ArtifactsClientInfo_LaunchCount::set_ship(::ei::MissionInfo_Spaceship value) {
  _internal_set_ship(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactsClientInfo.LaunchCount.ship)
}

// optional uint32 num_launches = 2;
inline bool ArtifactsClientInfo_LaunchCount::_internal_has_num_launches() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ArtifactsClientInfo_LaunchCount::has_num_launches() const {
  return _internal_has_num_launches();
}
inline void ArtifactsClientInfo_LaunchCount::clear_num_launches() {
  num_launches_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ArtifactsClientInfo_LaunchCount::_internal_num_launches() const {
  return num_launches_;
}
inline uint32_t ArtifactsClientInfo_LaunchCount::num_launches() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsClientInfo.LaunchCount.num_launches)
  return _internal_num_launches();
}
inline void ArtifactsClientInfo_LaunchCount::_internal_set_num_launches(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  num_launches_ = value;
}
inline void ArtifactsClientInfo_LaunchCount::set_num_launches(uint32_t value) {
  _internal_set_num_launches(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactsClientInfo.LaunchCount.num_launches)
}

// optional double launch_points = 3;
inline bool ArtifactsClientInfo_LaunchCount::_internal_has_launch_points() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ArtifactsClientInfo_LaunchCount::has_launch_points() const {
  return _internal_has_launch_points();
}
inline void ArtifactsClientInfo_LaunchCount::clear_launch_points() {
  launch_points_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double ArtifactsClientInfo_LaunchCount::_internal_launch_points() const {
  return launch_points_;
}
inline double ArtifactsClientInfo_LaunchCount::launch_points() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsClientInfo.LaunchCount.launch_points)
  return _internal_launch_points();
}
inline void ArtifactsClientInfo_LaunchCount::_internal_set_launch_points(double value) {
  _has_bits_[0] |= 0x00000004u;
  launch_points_ = value;
}
inline void ArtifactsClientInfo_LaunchCount::set_launch_points(double value) {
  _internal_set_launch_points(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactsClientInfo.LaunchCount.launch_points)
}

// -------------------------------------------------------------------

// ArtifactsClientInfo

// optional double mission_capacity_mult = 1;
inline bool ArtifactsClientInfo::_internal_has_mission_capacity_mult() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ArtifactsClientInfo::has_mission_capacity_mult() const {
  return _internal_has_mission_capacity_mult();
}
inline void ArtifactsClientInfo::clear_mission_capacity_mult() {
  mission_capacity_mult_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double ArtifactsClientInfo::_internal_mission_capacity_mult() const {
  return mission_capacity_mult_;
}
inline double ArtifactsClientInfo::mission_capacity_mult() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsClientInfo.mission_capacity_mult)
  return _internal_mission_capacity_mult();
}
inline void ArtifactsClientInfo::_internal_set_mission_capacity_mult(double value) {
  _has_bits_[0] |= 0x00000001u;
  mission_capacity_mult_ = value;
}
inline void ArtifactsClientInfo::set_mission_capacity_mult(double value) {
  _internal_set_mission_capacity_mult(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactsClientInfo.mission_capacity_mult)
}

// optional double mission_duration_mult = 2;
inline bool ArtifactsClientInfo::_internal_has_mission_duration_mult() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ArtifactsClientInfo::has_mission_duration_mult() const {
  return _internal_has_mission_duration_mult();
}
inline void ArtifactsClientInfo::clear_mission_duration_mult() {
  mission_duration_mult_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ArtifactsClientInfo::_internal_mission_duration_mult() const {
  return mission_duration_mult_;
}
inline double ArtifactsClientInfo::mission_duration_mult() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsClientInfo.mission_duration_mult)
  return _internal_mission_duration_mult();
}
inline void ArtifactsClientInfo::_internal_set_mission_duration_mult(double value) {
  _has_bits_[0] |= 0x00000002u;
  mission_duration_mult_ = value;
}
inline void ArtifactsClientInfo::set_mission_duration_mult(double value) {
  _internal_set_mission_duration_mult(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactsClientInfo.mission_duration_mult)
}

// optional double mission_ftl_duration_mult = 4;
inline bool ArtifactsClientInfo::_internal_has_mission_ftl_duration_mult() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ArtifactsClientInfo::has_mission_ftl_duration_mult() const {
  return _internal_has_mission_ftl_duration_mult();
}
inline void ArtifactsClientInfo::clear_mission_ftl_duration_mult() {
  mission_ftl_duration_mult_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double ArtifactsClientInfo::_internal_mission_ftl_duration_mult() const {
  return mission_ftl_duration_mult_;
}
inline double ArtifactsClientInfo::mission_ftl_duration_mult() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsClientInfo.mission_ftl_duration_mult)
  return _internal_mission_ftl_duration_mult();
}
inline void ArtifactsClientInfo::_internal_set_mission_ftl_duration_mult(double value) {
  _has_bits_[0] |= 0x00000004u;
  mission_ftl_duration_mult_ = value;
}
inline void ArtifactsClientInfo::set_mission_ftl_duration_mult(double value) {
  _internal_set_mission_ftl_duration_mult(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactsClientInfo.mission_ftl_duration_mult)
}

// repeated .ei.ArtifactsClientInfo.LaunchCount launch_counts = 3;
inline int ArtifactsClientInfo::_internal_launch_counts_size() const {
  return launch_counts_.size();
}
inline int ArtifactsClientInfo::launch_counts_size() const {
  return _internal_launch_counts_size();
}
inline void ArtifactsClientInfo::clear_launch_counts() {
  launch_counts_.Clear();
}
inline ::ei::ArtifactsClientInfo_LaunchCount* ArtifactsClientInfo::mutable_launch_counts(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ArtifactsClientInfo.launch_counts)
  return launch_counts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsClientInfo_LaunchCount >*
ArtifactsClientInfo::mutable_launch_counts() {
  // @@protoc_insertion_point(field_mutable_list:ei.ArtifactsClientInfo.launch_counts)
  return &launch_counts_;
}
inline const ::ei::ArtifactsClientInfo_LaunchCount& ArtifactsClientInfo::_internal_launch_counts(int index) const {
  return launch_counts_.Get(index);
}
inline const ::ei::ArtifactsClientInfo_LaunchCount& ArtifactsClientInfo::launch_counts(int index) const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsClientInfo.launch_counts)
  return _internal_launch_counts(index);
}
inline ::ei::ArtifactsClientInfo_LaunchCount* ArtifactsClientInfo::_internal_add_launch_counts() {
  return launch_counts_.Add();
}
inline ::ei::ArtifactsClientInfo_LaunchCount* ArtifactsClientInfo::add_launch_counts() {
  ::ei::ArtifactsClientInfo_LaunchCount* _add = _internal_add_launch_counts();
  // @@protoc_insertion_point(field_add:ei.ArtifactsClientInfo.launch_counts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsClientInfo_LaunchCount >&
ArtifactsClientInfo::launch_counts() const {
  // @@protoc_insertion_point(field_list:ei.ArtifactsClientInfo.launch_counts)
  return launch_counts_;
}

// -------------------------------------------------------------------

// MissionInfo_Fuel

// optional .ei.Egg egg = 1;
inline bool MissionInfo_Fuel::_internal_has_egg() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MissionInfo_Fuel::has_egg() const {
  return _internal_has_egg();
}
inline void MissionInfo_Fuel::clear_egg() {
  egg_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::ei::Egg MissionInfo_Fuel::_internal_egg() const {
  return static_cast< ::ei::Egg >(egg_);
}
inline ::ei::Egg MissionInfo_Fuel::egg() const {
  // @@protoc_insertion_point(field_get:ei.MissionInfo.Fuel.egg)
  return _internal_egg();
}
inline void MissionInfo_Fuel::_internal_set_egg(::ei::Egg value) {
  assert(::ei::Egg_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  egg_ = value;
}
inline void MissionInfo_Fuel::set_egg(::ei::Egg value) {
  _internal_set_egg(value);
  // @@protoc_insertion_point(field_set:ei.MissionInfo.Fuel.egg)
}

// optional double amount = 2;
inline bool MissionInfo_Fuel::_internal_has_amount() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MissionInfo_Fuel::has_amount() const {
  return _internal_has_amount();
}
inline void MissionInfo_Fuel::clear_amount() {
  amount_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double MissionInfo_Fuel::_internal_amount() const {
  return amount_;
}
inline double MissionInfo_Fuel::amount() const {
  // @@protoc_insertion_point(field_get:ei.MissionInfo.Fuel.amount)
  return _internal_amount();
}
inline void MissionInfo_Fuel::_internal_set_amount(double value) {
  _has_bits_[0] |= 0x00000001u;
  amount_ = value;
}
inline void MissionInfo_Fuel::set_amount(double value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:ei.MissionInfo.Fuel.amount)
}

// -------------------------------------------------------------------

// MissionInfo

// optional .ei.MissionInfo.Spaceship ship = 1;
inline bool MissionInfo::_internal_has_ship() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MissionInfo::has_ship() const {
  return _internal_has_ship();
}
inline void MissionInfo::clear_ship() {
  ship_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::ei::MissionInfo_Spaceship MissionInfo::_internal_ship() const {
  return static_cast< ::ei::MissionInfo_Spaceship >(ship_);
}
inline ::ei::MissionInfo_Spaceship MissionInfo::ship() const {
  // @@protoc_insertion_point(field_get:ei.MissionInfo.ship)
  return _internal_ship();
}
inline void MissionInfo::_internal_set_ship(::ei::MissionInfo_Spaceship value) {
  assert(::ei::MissionInfo_Spaceship_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  ship_ = value;
}
inline void MissionInfo::set_ship(::ei::MissionInfo_Spaceship value) {
  _internal_set_ship(value);
  // @@protoc_insertion_point(field_set:ei.MissionInfo.ship)
}

// optional .ei.MissionInfo.Status status = 2;
inline bool MissionInfo::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MissionInfo::has_status() const {
  return _internal_has_status();
}
inline void MissionInfo::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::ei::MissionInfo_Status MissionInfo::_internal_status() const {
  return static_cast< ::ei::MissionInfo_Status >(status_);
}
inline ::ei::MissionInfo_Status MissionInfo::status() const {
  // @@protoc_insertion_point(field_get:ei.MissionInfo.status)
  return _internal_status();
}
inline void MissionInfo::_internal_set_status(::ei::MissionInfo_Status value) {
  assert(::ei::MissionInfo_Status_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  status_ = value;
}
inline void MissionInfo::set_status(::ei::MissionInfo_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:ei.MissionInfo.status)
}

// optional .ei.MissionInfo.DurationType duration_type = 3;
inline bool MissionInfo::_internal_has_duration_type() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool MissionInfo::has_duration_type() const {
  return _internal_has_duration_type();
}
inline void MissionInfo::clear_duration_type() {
  duration_type_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::ei::MissionInfo_DurationType MissionInfo::_internal_duration_type() const {
  return static_cast< ::ei::MissionInfo_DurationType >(duration_type_);
}
inline ::ei::MissionInfo_DurationType MissionInfo::duration_type() const {
  // @@protoc_insertion_point(field_get:ei.MissionInfo.duration_type)
  return _internal_duration_type();
}
inline void MissionInfo::_internal_set_duration_type(::ei::MissionInfo_DurationType value) {
  assert(::ei::MissionInfo_DurationType_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  duration_type_ = value;
}
inline void MissionInfo::set_duration_type(::ei::MissionInfo_DurationType value) {
  _internal_set_duration_type(value);
  // @@protoc_insertion_point(field_set:ei.MissionInfo.duration_type)
}

// repeated .ei.MissionInfo.Fuel fuel = 4;
inline int MissionInfo::_internal_fuel_size() const {
  return fuel_.size();
}
inline int MissionInfo::fuel_size() const {
  return _internal_fuel_size();
}
inline void MissionInfo::clear_fuel() {
  fuel_.Clear();
}
inline ::ei::MissionInfo_Fuel* MissionInfo::mutable_fuel(int index) {
  // @@protoc_insertion_point(field_mutable:ei.MissionInfo.fuel)
  return fuel_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::MissionInfo_Fuel >*
MissionInfo::mutable_fuel() {
  // @@protoc_insertion_point(field_mutable_list:ei.MissionInfo.fuel)
  return &fuel_;
}
inline const ::ei::MissionInfo_Fuel& MissionInfo::_internal_fuel(int index) const {
  return fuel_.Get(index);
}
inline const ::ei::MissionInfo_Fuel& MissionInfo::fuel(int index) const {
  // @@protoc_insertion_point(field_get:ei.MissionInfo.fuel)
  return _internal_fuel(index);
}
inline ::ei::MissionInfo_Fuel* MissionInfo::_internal_add_fuel() {
  return fuel_.Add();
}
inline ::ei::MissionInfo_Fuel* MissionInfo::add_fuel() {
  ::ei::MissionInfo_Fuel* _add = _internal_add_fuel();
  // @@protoc_insertion_point(field_add:ei.MissionInfo.fuel)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::MissionInfo_Fuel >&
MissionInfo::fuel() const {
  // @@protoc_insertion_point(field_list:ei.MissionInfo.fuel)
  return fuel_;
}

// optional uint32 level = 12;
inline bool MissionInfo::_internal_has_level() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool MissionInfo::has_level() const {
  return _internal_has_level();
}
inline void MissionInfo::clear_level() {
  level_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline uint32_t MissionInfo::_internal_level() const {
  return level_;
}
inline uint32_t MissionInfo::level() const {
  // @@protoc_insertion_point(field_get:ei.MissionInfo.level)
  return _internal_level();
}
inline void MissionInfo::_internal_set_level(uint32_t value) {
  _has_bits_[0] |= 0x00000400u;
  level_ = value;
}
inline void MissionInfo::set_level(uint32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:ei.MissionInfo.level)
}

// optional double duration_seconds = 5;
inline bool MissionInfo::_internal_has_duration_seconds() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MissionInfo::has_duration_seconds() const {
  return _internal_has_duration_seconds();
}
inline void MissionInfo::clear_duration_seconds() {
  duration_seconds_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double MissionInfo::_internal_duration_seconds() const {
  return duration_seconds_;
}
inline double MissionInfo::duration_seconds() const {
  // @@protoc_insertion_point(field_get:ei.MissionInfo.duration_seconds)
  return _internal_duration_seconds();
}
inline void MissionInfo::_internal_set_duration_seconds(double value) {
  _has_bits_[0] |= 0x00000010u;
  duration_seconds_ = value;
}
inline void MissionInfo::set_duration_seconds(double value) {
  _internal_set_duration_seconds(value);
  // @@protoc_insertion_point(field_set:ei.MissionInfo.duration_seconds)
}

// optional uint32 capacity = 9;
inline bool MissionInfo::_internal_has_capacity() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool MissionInfo::has_capacity() const {
  return _internal_has_capacity();
}
inline void MissionInfo::clear_capacity() {
  capacity_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline uint32_t MissionInfo::_internal_capacity() const {
  return capacity_;
}
inline uint32_t MissionInfo::capacity() const {
  // @@protoc_insertion_point(field_get:ei.MissionInfo.capacity)
  return _internal_capacity();
}
inline void MissionInfo::_internal_set_capacity(uint32_t value) {
  _has_bits_[0] |= 0x00000080u;
  capacity_ = value;
}
inline void MissionInfo::set_capacity(uint32_t value) {
  _internal_set_capacity(value);
  // @@protoc_insertion_point(field_set:ei.MissionInfo.capacity)
}

// optional double quality_bump = 11;
inline bool MissionInfo::_internal_has_quality_bump() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool MissionInfo::has_quality_bump() const {
  return _internal_has_quality_bump();
}
inline void MissionInfo::clear_quality_bump() {
  quality_bump_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline double MissionInfo::_internal_quality_bump() const {
  return quality_bump_;
}
inline double MissionInfo::quality_bump() const {
  // @@protoc_insertion_point(field_get:ei.MissionInfo.quality_bump)
  return _internal_quality_bump();
}
inline void MissionInfo::_internal_set_quality_bump(double value) {
  _has_bits_[0] |= 0x00000200u;
  quality_bump_ = value;
}
inline void MissionInfo::set_quality_bump(double value) {
  _internal_set_quality_bump(value);
  // @@protoc_insertion_point(field_set:ei.MissionInfo.quality_bump)
}

// optional double seconds_remaining = 6;
inline bool MissionInfo::_internal_has_seconds_remaining() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MissionInfo::has_seconds_remaining() const {
  return _internal_has_seconds_remaining();
}
inline void MissionInfo::clear_seconds_remaining() {
  seconds_remaining_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double MissionInfo::_internal_seconds_remaining() const {
  return seconds_remaining_;
}
inline double MissionInfo::seconds_remaining() const {
  // @@protoc_insertion_point(field_get:ei.MissionInfo.seconds_remaining)
  return _internal_seconds_remaining();
}
inline void MissionInfo::_internal_set_seconds_remaining(double value) {
  _has_bits_[0] |= 0x00000020u;
  seconds_remaining_ = value;
}
inline void MissionInfo::set_seconds_remaining(double value) {
  _internal_set_seconds_remaining(value);
  // @@protoc_insertion_point(field_set:ei.MissionInfo.seconds_remaining)
}

// optional double start_time_derived = 8;
inline bool MissionInfo::_internal_has_start_time_derived() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool MissionInfo::has_start_time_derived() const {
  return _internal_has_start_time_derived();
}
inline void MissionInfo::clear_start_time_derived() {
  start_time_derived_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline double MissionInfo::_internal_start_time_derived() const {
  return start_time_derived_;
}
inline double MissionInfo::start_time_derived() const {
  // @@protoc_insertion_point(field_get:ei.MissionInfo.start_time_derived)
  return _internal_start_time_derived();
}
inline void MissionInfo::_internal_set_start_time_derived(double value) {
  _has_bits_[0] |= 0x00000100u;
  start_time_derived_ = value;
}
inline void MissionInfo::set_start_time_derived(double value) {
  _internal_set_start_time_derived(value);
  // @@protoc_insertion_point(field_set:ei.MissionInfo.start_time_derived)
}

// optional string mission_log = 10;
inline bool MissionInfo::_internal_has_mission_log() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MissionInfo::has_mission_log() const {
  return _internal_has_mission_log();
}
inline void MissionInfo::clear_mission_log() {
  mission_log_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MissionInfo::mission_log() const {
  // @@protoc_insertion_point(field_get:ei.MissionInfo.mission_log)
  return _internal_mission_log();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MissionInfo::set_mission_log(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 mission_log_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.MissionInfo.mission_log)
}
inline std::string* MissionInfo::mutable_mission_log() {
  std::string* _s = _internal_mutable_mission_log();
  // @@protoc_insertion_point(field_mutable:ei.MissionInfo.mission_log)
  return _s;
}
inline const std::string& MissionInfo::_internal_mission_log() const {
  return mission_log_.Get();
}
inline void MissionInfo::_internal_set_mission_log(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  mission_log_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MissionInfo::_internal_mutable_mission_log() {
  _has_bits_[0] |= 0x00000002u;
  return mission_log_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MissionInfo::release_mission_log() {
  // @@protoc_insertion_point(field_release:ei.MissionInfo.mission_log)
  if (!_internal_has_mission_log()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = mission_log_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mission_log_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    mission_log_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MissionInfo::set_allocated_mission_log(std::string* mission_log) {
  if (mission_log != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  mission_log_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mission_log,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mission_log_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    mission_log_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.MissionInfo.mission_log)
}

// optional string identifier = 7;
inline bool MissionInfo::_internal_has_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MissionInfo::has_identifier() const {
  return _internal_has_identifier();
}
inline void MissionInfo::clear_identifier() {
  identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MissionInfo::identifier() const {
  // @@protoc_insertion_point(field_get:ei.MissionInfo.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MissionInfo::set_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.MissionInfo.identifier)
}
inline std::string* MissionInfo::mutable_identifier() {
  std::string* _s = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:ei.MissionInfo.identifier)
  return _s;
}
inline const std::string& MissionInfo::_internal_identifier() const {
  return identifier_.Get();
}
inline void MissionInfo::_internal_set_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MissionInfo::_internal_mutable_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MissionInfo::release_identifier() {
  // @@protoc_insertion_point(field_release:ei.MissionInfo.identifier)
  if (!_internal_has_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MissionInfo::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.MissionInfo.identifier)
}

// -------------------------------------------------------------------

// ArtifactSpec

// optional .ei.ArtifactSpec.Name name = 1;
inline bool ArtifactSpec::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ArtifactSpec::has_name() const {
  return _internal_has_name();
}
inline void ArtifactSpec::clear_name() {
  name_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::ei::ArtifactSpec_Name ArtifactSpec::_internal_name() const {
  return static_cast< ::ei::ArtifactSpec_Name >(name_);
}
inline ::ei::ArtifactSpec_Name ArtifactSpec::name() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactSpec.name)
  return _internal_name();
}
inline void ArtifactSpec::_internal_set_name(::ei::ArtifactSpec_Name value) {
  assert(::ei::ArtifactSpec_Name_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  name_ = value;
}
inline void ArtifactSpec::set_name(::ei::ArtifactSpec_Name value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactSpec.name)
}

// optional .ei.ArtifactSpec.Level level = 2;
inline bool ArtifactSpec::_internal_has_level() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ArtifactSpec::has_level() const {
  return _internal_has_level();
}
inline void ArtifactSpec::clear_level() {
  level_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::ei::ArtifactSpec_Level ArtifactSpec::_internal_level() const {
  return static_cast< ::ei::ArtifactSpec_Level >(level_);
}
inline ::ei::ArtifactSpec_Level ArtifactSpec::level() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactSpec.level)
  return _internal_level();
}
inline void ArtifactSpec::_internal_set_level(::ei::ArtifactSpec_Level value) {
  assert(::ei::ArtifactSpec_Level_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  level_ = value;
}
inline void ArtifactSpec::set_level(::ei::ArtifactSpec_Level value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactSpec.level)
}

// optional .ei.ArtifactSpec.Rarity rarity = 3;
inline bool ArtifactSpec::_internal_has_rarity() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ArtifactSpec::has_rarity() const {
  return _internal_has_rarity();
}
inline void ArtifactSpec::clear_rarity() {
  rarity_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::ei::ArtifactSpec_Rarity ArtifactSpec::_internal_rarity() const {
  return static_cast< ::ei::ArtifactSpec_Rarity >(rarity_);
}
inline ::ei::ArtifactSpec_Rarity ArtifactSpec::rarity() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactSpec.rarity)
  return _internal_rarity();
}
inline void ArtifactSpec::_internal_set_rarity(::ei::ArtifactSpec_Rarity value) {
  assert(::ei::ArtifactSpec_Rarity_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  rarity_ = value;
}
inline void ArtifactSpec::set_rarity(::ei::ArtifactSpec_Rarity value) {
  _internal_set_rarity(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactSpec.rarity)
}

// optional .ei.Egg egg = 4;
inline bool ArtifactSpec::_internal_has_egg() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ArtifactSpec::has_egg() const {
  return _internal_has_egg();
}
inline void ArtifactSpec::clear_egg() {
  egg_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::ei::Egg ArtifactSpec::_internal_egg() const {
  return static_cast< ::ei::Egg >(egg_);
}
inline ::ei::Egg ArtifactSpec::egg() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactSpec.egg)
  return _internal_egg();
}
inline void ArtifactSpec::_internal_set_egg(::ei::Egg value) {
  assert(::ei::Egg_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  egg_ = value;
}
inline void ArtifactSpec::set_egg(::ei::Egg value) {
  _internal_set_egg(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactSpec.egg)
}

// -------------------------------------------------------------------

// CompleteArtifact

// optional .ei.ArtifactSpec spec = 1;
inline bool CompleteArtifact::_internal_has_spec() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || spec_ != nullptr);
  return value;
}
inline bool CompleteArtifact::has_spec() const {
  return _internal_has_spec();
}
inline void CompleteArtifact::clear_spec() {
  if (spec_ != nullptr) spec_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ei::ArtifactSpec& CompleteArtifact::_internal_spec() const {
  const ::ei::ArtifactSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::ArtifactSpec&>(
      ::ei::_ArtifactSpec_default_instance_);
}
inline const ::ei::ArtifactSpec& CompleteArtifact::spec() const {
  // @@protoc_insertion_point(field_get:ei.CompleteArtifact.spec)
  return _internal_spec();
}
inline void CompleteArtifact::unsafe_arena_set_allocated_spec(
    ::ei::ArtifactSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.CompleteArtifact.spec)
}
inline ::ei::ArtifactSpec* CompleteArtifact::release_spec() {
  _has_bits_[0] &= ~0x00000001u;
  ::ei::ArtifactSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::ArtifactSpec* CompleteArtifact::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:ei.CompleteArtifact.spec)
  _has_bits_[0] &= ~0x00000001u;
  ::ei::ArtifactSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::ei::ArtifactSpec* CompleteArtifact::_internal_mutable_spec() {
  _has_bits_[0] |= 0x00000001u;
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::ArtifactSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::ei::ArtifactSpec* CompleteArtifact::mutable_spec() {
  ::ei::ArtifactSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:ei.CompleteArtifact.spec)
  return _msg;
}
inline void CompleteArtifact::set_allocated_spec(::ei::ArtifactSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::ArtifactSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:ei.CompleteArtifact.spec)
}

// repeated .ei.ArtifactSpec stones = 2;
inline int CompleteArtifact::_internal_stones_size() const {
  return stones_.size();
}
inline int CompleteArtifact::stones_size() const {
  return _internal_stones_size();
}
inline void CompleteArtifact::clear_stones() {
  stones_.Clear();
}
inline ::ei::ArtifactSpec* CompleteArtifact::mutable_stones(int index) {
  // @@protoc_insertion_point(field_mutable:ei.CompleteArtifact.stones)
  return stones_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactSpec >*
CompleteArtifact::mutable_stones() {
  // @@protoc_insertion_point(field_mutable_list:ei.CompleteArtifact.stones)
  return &stones_;
}
inline const ::ei::ArtifactSpec& CompleteArtifact::_internal_stones(int index) const {
  return stones_.Get(index);
}
inline const ::ei::ArtifactSpec& CompleteArtifact::stones(int index) const {
  // @@protoc_insertion_point(field_get:ei.CompleteArtifact.stones)
  return _internal_stones(index);
}
inline ::ei::ArtifactSpec* CompleteArtifact::_internal_add_stones() {
  return stones_.Add();
}
inline ::ei::ArtifactSpec* CompleteArtifact::add_stones() {
  ::ei::ArtifactSpec* _add = _internal_add_stones();
  // @@protoc_insertion_point(field_add:ei.CompleteArtifact.stones)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactSpec >&
CompleteArtifact::stones() const {
  // @@protoc_insertion_point(field_list:ei.CompleteArtifact.stones)
  return stones_;
}

// -------------------------------------------------------------------

// ArtifactInventoryItem

// optional uint64 item_id = 1;
inline bool ArtifactInventoryItem::_internal_has_item_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ArtifactInventoryItem::has_item_id() const {
  return _internal_has_item_id();
}
inline void ArtifactInventoryItem::clear_item_id() {
  item_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t ArtifactInventoryItem::_internal_item_id() const {
  return item_id_;
}
inline uint64_t ArtifactInventoryItem::item_id() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactInventoryItem.item_id)
  return _internal_item_id();
}
inline void ArtifactInventoryItem::_internal_set_item_id(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  item_id_ = value;
}
inline void ArtifactInventoryItem::set_item_id(uint64_t value) {
  _internal_set_item_id(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactInventoryItem.item_id)
}

// optional .ei.CompleteArtifact artifact = 2;
inline bool ArtifactInventoryItem::_internal_has_artifact() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || artifact_ != nullptr);
  return value;
}
inline bool ArtifactInventoryItem::has_artifact() const {
  return _internal_has_artifact();
}
inline void ArtifactInventoryItem::clear_artifact() {
  if (artifact_ != nullptr) artifact_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ei::CompleteArtifact& ArtifactInventoryItem::_internal_artifact() const {
  const ::ei::CompleteArtifact* p = artifact_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::CompleteArtifact&>(
      ::ei::_CompleteArtifact_default_instance_);
}
inline const ::ei::CompleteArtifact& ArtifactInventoryItem::artifact() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactInventoryItem.artifact)
  return _internal_artifact();
}
inline void ArtifactInventoryItem::unsafe_arena_set_allocated_artifact(
    ::ei::CompleteArtifact* artifact) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(artifact_);
  }
  artifact_ = artifact;
  if (artifact) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.ArtifactInventoryItem.artifact)
}
inline ::ei::CompleteArtifact* ArtifactInventoryItem::release_artifact() {
  _has_bits_[0] &= ~0x00000002u;
  ::ei::CompleteArtifact* temp = artifact_;
  artifact_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::CompleteArtifact* ArtifactInventoryItem::unsafe_arena_release_artifact() {
  // @@protoc_insertion_point(field_release:ei.ArtifactInventoryItem.artifact)
  _has_bits_[0] &= ~0x00000002u;
  ::ei::CompleteArtifact* temp = artifact_;
  artifact_ = nullptr;
  return temp;
}
inline ::ei::CompleteArtifact* ArtifactInventoryItem::_internal_mutable_artifact() {
  _has_bits_[0] |= 0x00000002u;
  if (artifact_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::CompleteArtifact>(GetArenaForAllocation());
    artifact_ = p;
  }
  return artifact_;
}
inline ::ei::CompleteArtifact* ArtifactInventoryItem::mutable_artifact() {
  ::ei::CompleteArtifact* _msg = _internal_mutable_artifact();
  // @@protoc_insertion_point(field_mutable:ei.ArtifactInventoryItem.artifact)
  return _msg;
}
inline void ArtifactInventoryItem::set_allocated_artifact(::ei::CompleteArtifact* artifact) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete artifact_;
  }
  if (artifact) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::CompleteArtifact>::GetOwningArena(artifact);
    if (message_arena != submessage_arena) {
      artifact = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, artifact, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  artifact_ = artifact;
  // @@protoc_insertion_point(field_set_allocated:ei.ArtifactInventoryItem.artifact)
}

// optional double quantity = 3;
inline bool ArtifactInventoryItem::_internal_has_quantity() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ArtifactInventoryItem::has_quantity() const {
  return _internal_has_quantity();
}
inline void ArtifactInventoryItem::clear_quantity() {
  quantity_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double ArtifactInventoryItem::_internal_quantity() const {
  return quantity_;
}
inline double ArtifactInventoryItem::quantity() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactInventoryItem.quantity)
  return _internal_quantity();
}
inline void ArtifactInventoryItem::_internal_set_quantity(double value) {
  _has_bits_[0] |= 0x00000008u;
  quantity_ = value;
}
inline void ArtifactInventoryItem::set_quantity(double value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactInventoryItem.quantity)
}

// optional string server_id = 4;
inline bool ArtifactInventoryItem::_internal_has_server_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ArtifactInventoryItem::has_server_id() const {
  return _internal_has_server_id();
}
inline void ArtifactInventoryItem::clear_server_id() {
  server_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ArtifactInventoryItem::server_id() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactInventoryItem.server_id)
  return _internal_server_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ArtifactInventoryItem::set_server_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 server_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ArtifactInventoryItem.server_id)
}
inline std::string* ArtifactInventoryItem::mutable_server_id() {
  std::string* _s = _internal_mutable_server_id();
  // @@protoc_insertion_point(field_mutable:ei.ArtifactInventoryItem.server_id)
  return _s;
}
inline const std::string& ArtifactInventoryItem::_internal_server_id() const {
  return server_id_.Get();
}
inline void ArtifactInventoryItem::_internal_set_server_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  server_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ArtifactInventoryItem::_internal_mutable_server_id() {
  _has_bits_[0] |= 0x00000001u;
  return server_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ArtifactInventoryItem::release_server_id() {
  // @@protoc_insertion_point(field_release:ei.ArtifactInventoryItem.server_id)
  if (!_internal_has_server_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = server_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (server_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    server_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ArtifactInventoryItem::set_allocated_server_id(std::string* server_id) {
  if (server_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  server_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), server_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (server_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    server_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ArtifactInventoryItem.server_id)
}

// -------------------------------------------------------------------

// InventorySlot

// optional bool occupied = 1;
inline bool InventorySlot::_internal_has_occupied() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InventorySlot::has_occupied() const {
  return _internal_has_occupied();
}
inline void InventorySlot::clear_occupied() {
  occupied_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool InventorySlot::_internal_occupied() const {
  return occupied_;
}
inline bool InventorySlot::occupied() const {
  // @@protoc_insertion_point(field_get:ei.InventorySlot.occupied)
  return _internal_occupied();
}
inline void InventorySlot::_internal_set_occupied(bool value) {
  _has_bits_[0] |= 0x00000001u;
  occupied_ = value;
}
inline void InventorySlot::set_occupied(bool value) {
  _internal_set_occupied(value);
  // @@protoc_insertion_point(field_set:ei.InventorySlot.occupied)
}

// optional uint32 item_id = 2;
inline bool InventorySlot::_internal_has_item_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InventorySlot::has_item_id() const {
  return _internal_has_item_id();
}
inline void InventorySlot::clear_item_id() {
  item_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t InventorySlot::_internal_item_id() const {
  return item_id_;
}
inline uint32_t InventorySlot::item_id() const {
  // @@protoc_insertion_point(field_get:ei.InventorySlot.item_id)
  return _internal_item_id();
}
inline void InventorySlot::_internal_set_item_id(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  item_id_ = value;
}
inline void InventorySlot::set_item_id(uint32_t value) {
  _internal_set_item_id(value);
  // @@protoc_insertion_point(field_set:ei.InventorySlot.item_id)
}

// -------------------------------------------------------------------

// ArtifactsConfigurationRequest

// optional .ei.BasicRequestInfo rinfo = 2;
inline bool ArtifactsConfigurationRequest::_internal_has_rinfo() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || rinfo_ != nullptr);
  return value;
}
inline bool ArtifactsConfigurationRequest::has_rinfo() const {
  return _internal_has_rinfo();
}
inline void ArtifactsConfigurationRequest::clear_rinfo() {
  if (rinfo_ != nullptr) rinfo_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ei::BasicRequestInfo& ArtifactsConfigurationRequest::_internal_rinfo() const {
  const ::ei::BasicRequestInfo* p = rinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::BasicRequestInfo&>(
      ::ei::_BasicRequestInfo_default_instance_);
}
inline const ::ei::BasicRequestInfo& ArtifactsConfigurationRequest::rinfo() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsConfigurationRequest.rinfo)
  return _internal_rinfo();
}
inline void ArtifactsConfigurationRequest::unsafe_arena_set_allocated_rinfo(
    ::ei::BasicRequestInfo* rinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rinfo_);
  }
  rinfo_ = rinfo;
  if (rinfo) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.ArtifactsConfigurationRequest.rinfo)
}
inline ::ei::BasicRequestInfo* ArtifactsConfigurationRequest::release_rinfo() {
  _has_bits_[0] &= ~0x00000001u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::BasicRequestInfo* ArtifactsConfigurationRequest::unsafe_arena_release_rinfo() {
  // @@protoc_insertion_point(field_release:ei.ArtifactsConfigurationRequest.rinfo)
  _has_bits_[0] &= ~0x00000001u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
  return temp;
}
inline ::ei::BasicRequestInfo* ArtifactsConfigurationRequest::_internal_mutable_rinfo() {
  _has_bits_[0] |= 0x00000001u;
  if (rinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::BasicRequestInfo>(GetArenaForAllocation());
    rinfo_ = p;
  }
  return rinfo_;
}
inline ::ei::BasicRequestInfo* ArtifactsConfigurationRequest::mutable_rinfo() {
  ::ei::BasicRequestInfo* _msg = _internal_mutable_rinfo();
  // @@protoc_insertion_point(field_mutable:ei.ArtifactsConfigurationRequest.rinfo)
  return _msg;
}
inline void ArtifactsConfigurationRequest::set_allocated_rinfo(::ei::BasicRequestInfo* rinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rinfo_;
  }
  if (rinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::BasicRequestInfo>::GetOwningArena(rinfo);
    if (message_arena != submessage_arena) {
      rinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  rinfo_ = rinfo;
  // @@protoc_insertion_point(field_set_allocated:ei.ArtifactsConfigurationRequest.rinfo)
}

// optional uint32 client_version = 1;
inline bool ArtifactsConfigurationRequest::_internal_has_client_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ArtifactsConfigurationRequest::has_client_version() const {
  return _internal_has_client_version();
}
inline void ArtifactsConfigurationRequest::clear_client_version() {
  client_version_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ArtifactsConfigurationRequest::_internal_client_version() const {
  return client_version_;
}
inline uint32_t ArtifactsConfigurationRequest::client_version() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsConfigurationRequest.client_version)
  return _internal_client_version();
}
inline void ArtifactsConfigurationRequest::_internal_set_client_version(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  client_version_ = value;
}
inline void ArtifactsConfigurationRequest::set_client_version(uint32_t value) {
  _internal_set_client_version(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactsConfigurationRequest.client_version)
}

// -------------------------------------------------------------------

// ArtifactsConfigurationResponse_MissionParameters_Duration

// optional .ei.MissionInfo.DurationType duration_type = 1;
inline bool ArtifactsConfigurationResponse_MissionParameters_Duration::_internal_has_duration_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ArtifactsConfigurationResponse_MissionParameters_Duration::has_duration_type() const {
  return _internal_has_duration_type();
}
inline void ArtifactsConfigurationResponse_MissionParameters_Duration::clear_duration_type() {
  duration_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::ei::MissionInfo_DurationType ArtifactsConfigurationResponse_MissionParameters_Duration::_internal_duration_type() const {
  return static_cast< ::ei::MissionInfo_DurationType >(duration_type_);
}
inline ::ei::MissionInfo_DurationType ArtifactsConfigurationResponse_MissionParameters_Duration::duration_type() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsConfigurationResponse.MissionParameters.Duration.duration_type)
  return _internal_duration_type();
}
inline void ArtifactsConfigurationResponse_MissionParameters_Duration::_internal_set_duration_type(::ei::MissionInfo_DurationType value) {
  assert(::ei::MissionInfo_DurationType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  duration_type_ = value;
}
inline void ArtifactsConfigurationResponse_MissionParameters_Duration::set_duration_type(::ei::MissionInfo_DurationType value) {
  _internal_set_duration_type(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactsConfigurationResponse.MissionParameters.Duration.duration_type)
}

// optional double seconds = 2;
inline bool ArtifactsConfigurationResponse_MissionParameters_Duration::_internal_has_seconds() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ArtifactsConfigurationResponse_MissionParameters_Duration::has_seconds() const {
  return _internal_has_seconds();
}
inline void ArtifactsConfigurationResponse_MissionParameters_Duration::clear_seconds() {
  seconds_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double ArtifactsConfigurationResponse_MissionParameters_Duration::_internal_seconds() const {
  return seconds_;
}
inline double ArtifactsConfigurationResponse_MissionParameters_Duration::seconds() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsConfigurationResponse.MissionParameters.Duration.seconds)
  return _internal_seconds();
}
inline void ArtifactsConfigurationResponse_MissionParameters_Duration::_internal_set_seconds(double value) {
  _has_bits_[0] |= 0x00000001u;
  seconds_ = value;
}
inline void ArtifactsConfigurationResponse_MissionParameters_Duration::set_seconds(double value) {
  _internal_set_seconds(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactsConfigurationResponse.MissionParameters.Duration.seconds)
}

// optional float quality = 3;
inline bool ArtifactsConfigurationResponse_MissionParameters_Duration::_internal_has_quality() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ArtifactsConfigurationResponse_MissionParameters_Duration::has_quality() const {
  return _internal_has_quality();
}
inline void ArtifactsConfigurationResponse_MissionParameters_Duration::clear_quality() {
  quality_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float ArtifactsConfigurationResponse_MissionParameters_Duration::_internal_quality() const {
  return quality_;
}
inline float ArtifactsConfigurationResponse_MissionParameters_Duration::quality() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsConfigurationResponse.MissionParameters.Duration.quality)
  return _internal_quality();
}
inline void ArtifactsConfigurationResponse_MissionParameters_Duration::_internal_set_quality(float value) {
  _has_bits_[0] |= 0x00000004u;
  quality_ = value;
}
inline void ArtifactsConfigurationResponse_MissionParameters_Duration::set_quality(float value) {
  _internal_set_quality(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactsConfigurationResponse.MissionParameters.Duration.quality)
}

// optional float min_quality = 4;
inline bool ArtifactsConfigurationResponse_MissionParameters_Duration::_internal_has_min_quality() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ArtifactsConfigurationResponse_MissionParameters_Duration::has_min_quality() const {
  return _internal_has_min_quality();
}
inline void ArtifactsConfigurationResponse_MissionParameters_Duration::clear_min_quality() {
  min_quality_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float ArtifactsConfigurationResponse_MissionParameters_Duration::_internal_min_quality() const {
  return min_quality_;
}
inline float ArtifactsConfigurationResponse_MissionParameters_Duration::min_quality() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsConfigurationResponse.MissionParameters.Duration.min_quality)
  return _internal_min_quality();
}
inline void ArtifactsConfigurationResponse_MissionParameters_Duration::_internal_set_min_quality(float value) {
  _has_bits_[0] |= 0x00000008u;
  min_quality_ = value;
}
inline void ArtifactsConfigurationResponse_MissionParameters_Duration::set_min_quality(float value) {
  _internal_set_min_quality(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactsConfigurationResponse.MissionParameters.Duration.min_quality)
}

// optional float max_quality = 5;
inline bool ArtifactsConfigurationResponse_MissionParameters_Duration::_internal_has_max_quality() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ArtifactsConfigurationResponse_MissionParameters_Duration::has_max_quality() const {
  return _internal_has_max_quality();
}
inline void ArtifactsConfigurationResponse_MissionParameters_Duration::clear_max_quality() {
  max_quality_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float ArtifactsConfigurationResponse_MissionParameters_Duration::_internal_max_quality() const {
  return max_quality_;
}
inline float ArtifactsConfigurationResponse_MissionParameters_Duration::max_quality() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsConfigurationResponse.MissionParameters.Duration.max_quality)
  return _internal_max_quality();
}
inline void ArtifactsConfigurationResponse_MissionParameters_Duration::_internal_set_max_quality(float value) {
  _has_bits_[0] |= 0x00000010u;
  max_quality_ = value;
}
inline void ArtifactsConfigurationResponse_MissionParameters_Duration::set_max_quality(float value) {
  _internal_set_max_quality(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactsConfigurationResponse.MissionParameters.Duration.max_quality)
}

// optional uint32 capacity = 6;
inline bool ArtifactsConfigurationResponse_MissionParameters_Duration::_internal_has_capacity() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ArtifactsConfigurationResponse_MissionParameters_Duration::has_capacity() const {
  return _internal_has_capacity();
}
inline void ArtifactsConfigurationResponse_MissionParameters_Duration::clear_capacity() {
  capacity_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t ArtifactsConfigurationResponse_MissionParameters_Duration::_internal_capacity() const {
  return capacity_;
}
inline uint32_t ArtifactsConfigurationResponse_MissionParameters_Duration::capacity() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsConfigurationResponse.MissionParameters.Duration.capacity)
  return _internal_capacity();
}
inline void ArtifactsConfigurationResponse_MissionParameters_Duration::_internal_set_capacity(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  capacity_ = value;
}
inline void ArtifactsConfigurationResponse_MissionParameters_Duration::set_capacity(uint32_t value) {
  _internal_set_capacity(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactsConfigurationResponse.MissionParameters.Duration.capacity)
}

// optional uint32 level_capacity_bump = 7;
inline bool ArtifactsConfigurationResponse_MissionParameters_Duration::_internal_has_level_capacity_bump() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ArtifactsConfigurationResponse_MissionParameters_Duration::has_level_capacity_bump() const {
  return _internal_has_level_capacity_bump();
}
inline void ArtifactsConfigurationResponse_MissionParameters_Duration::clear_level_capacity_bump() {
  level_capacity_bump_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t ArtifactsConfigurationResponse_MissionParameters_Duration::_internal_level_capacity_bump() const {
  return level_capacity_bump_;
}
inline uint32_t ArtifactsConfigurationResponse_MissionParameters_Duration::level_capacity_bump() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsConfigurationResponse.MissionParameters.Duration.level_capacity_bump)
  return _internal_level_capacity_bump();
}
inline void ArtifactsConfigurationResponse_MissionParameters_Duration::_internal_set_level_capacity_bump(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  level_capacity_bump_ = value;
}
inline void ArtifactsConfigurationResponse_MissionParameters_Duration::set_level_capacity_bump(uint32_t value) {
  _internal_set_level_capacity_bump(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactsConfigurationResponse.MissionParameters.Duration.level_capacity_bump)
}

// optional float level_quality_bump = 8;
inline bool ArtifactsConfigurationResponse_MissionParameters_Duration::_internal_has_level_quality_bump() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ArtifactsConfigurationResponse_MissionParameters_Duration::has_level_quality_bump() const {
  return _internal_has_level_quality_bump();
}
inline void ArtifactsConfigurationResponse_MissionParameters_Duration::clear_level_quality_bump() {
  level_quality_bump_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float ArtifactsConfigurationResponse_MissionParameters_Duration::_internal_level_quality_bump() const {
  return level_quality_bump_;
}
inline float ArtifactsConfigurationResponse_MissionParameters_Duration::level_quality_bump() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsConfigurationResponse.MissionParameters.Duration.level_quality_bump)
  return _internal_level_quality_bump();
}
inline void ArtifactsConfigurationResponse_MissionParameters_Duration::_internal_set_level_quality_bump(float value) {
  _has_bits_[0] |= 0x00000080u;
  level_quality_bump_ = value;
}
inline void ArtifactsConfigurationResponse_MissionParameters_Duration::set_level_quality_bump(float value) {
  _internal_set_level_quality_bump(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactsConfigurationResponse.MissionParameters.Duration.level_quality_bump)
}

// -------------------------------------------------------------------

// ArtifactsConfigurationResponse_MissionParameters

// optional .ei.MissionInfo.Spaceship ship = 1;
inline bool ArtifactsConfigurationResponse_MissionParameters::_internal_has_ship() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ArtifactsConfigurationResponse_MissionParameters::has_ship() const {
  return _internal_has_ship();
}
inline void ArtifactsConfigurationResponse_MissionParameters::clear_ship() {
  ship_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::ei::MissionInfo_Spaceship ArtifactsConfigurationResponse_MissionParameters::_internal_ship() const {
  return static_cast< ::ei::MissionInfo_Spaceship >(ship_);
}
inline ::ei::MissionInfo_Spaceship ArtifactsConfigurationResponse_MissionParameters::ship() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsConfigurationResponse.MissionParameters.ship)
  return _internal_ship();
}
inline void ArtifactsConfigurationResponse_MissionParameters::_internal_set_ship(::ei::MissionInfo_Spaceship value) {
  assert(::ei::MissionInfo_Spaceship_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  ship_ = value;
}
inline void ArtifactsConfigurationResponse_MissionParameters::set_ship(::ei::MissionInfo_Spaceship value) {
  _internal_set_ship(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactsConfigurationResponse.MissionParameters.ship)
}

// repeated .ei.ArtifactsConfigurationResponse.MissionParameters.Duration durations = 3;
inline int ArtifactsConfigurationResponse_MissionParameters::_internal_durations_size() const {
  return durations_.size();
}
inline int ArtifactsConfigurationResponse_MissionParameters::durations_size() const {
  return _internal_durations_size();
}
inline void ArtifactsConfigurationResponse_MissionParameters::clear_durations() {
  durations_.Clear();
}
inline ::ei::ArtifactsConfigurationResponse_MissionParameters_Duration* ArtifactsConfigurationResponse_MissionParameters::mutable_durations(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ArtifactsConfigurationResponse.MissionParameters.durations)
  return durations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsConfigurationResponse_MissionParameters_Duration >*
ArtifactsConfigurationResponse_MissionParameters::mutable_durations() {
  // @@protoc_insertion_point(field_mutable_list:ei.ArtifactsConfigurationResponse.MissionParameters.durations)
  return &durations_;
}
inline const ::ei::ArtifactsConfigurationResponse_MissionParameters_Duration& ArtifactsConfigurationResponse_MissionParameters::_internal_durations(int index) const {
  return durations_.Get(index);
}
inline const ::ei::ArtifactsConfigurationResponse_MissionParameters_Duration& ArtifactsConfigurationResponse_MissionParameters::durations(int index) const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsConfigurationResponse.MissionParameters.durations)
  return _internal_durations(index);
}
inline ::ei::ArtifactsConfigurationResponse_MissionParameters_Duration* ArtifactsConfigurationResponse_MissionParameters::_internal_add_durations() {
  return durations_.Add();
}
inline ::ei::ArtifactsConfigurationResponse_MissionParameters_Duration* ArtifactsConfigurationResponse_MissionParameters::add_durations() {
  ::ei::ArtifactsConfigurationResponse_MissionParameters_Duration* _add = _internal_add_durations();
  // @@protoc_insertion_point(field_add:ei.ArtifactsConfigurationResponse.MissionParameters.durations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsConfigurationResponse_MissionParameters_Duration >&
ArtifactsConfigurationResponse_MissionParameters::durations() const {
  // @@protoc_insertion_point(field_list:ei.ArtifactsConfigurationResponse.MissionParameters.durations)
  return durations_;
}

// repeated uint32 level_mission_requirements = 4;
inline int ArtifactsConfigurationResponse_MissionParameters::_internal_level_mission_requirements_size() const {
  return level_mission_requirements_.size();
}
inline int ArtifactsConfigurationResponse_MissionParameters::level_mission_requirements_size() const {
  return _internal_level_mission_requirements_size();
}
inline void ArtifactsConfigurationResponse_MissionParameters::clear_level_mission_requirements() {
  level_mission_requirements_.Clear();
}
inline uint32_t ArtifactsConfigurationResponse_MissionParameters::_internal_level_mission_requirements(int index) const {
  return level_mission_requirements_.Get(index);
}
inline uint32_t ArtifactsConfigurationResponse_MissionParameters::level_mission_requirements(int index) const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsConfigurationResponse.MissionParameters.level_mission_requirements)
  return _internal_level_mission_requirements(index);
}
inline void ArtifactsConfigurationResponse_MissionParameters::set_level_mission_requirements(int index, uint32_t value) {
  level_mission_requirements_.Set(index, value);
  // @@protoc_insertion_point(field_set:ei.ArtifactsConfigurationResponse.MissionParameters.level_mission_requirements)
}
inline void ArtifactsConfigurationResponse_MissionParameters::_internal_add_level_mission_requirements(uint32_t value) {
  level_mission_requirements_.Add(value);
}
inline void ArtifactsConfigurationResponse_MissionParameters::add_level_mission_requirements(uint32_t value) {
  _internal_add_level_mission_requirements(value);
  // @@protoc_insertion_point(field_add:ei.ArtifactsConfigurationResponse.MissionParameters.level_mission_requirements)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
ArtifactsConfigurationResponse_MissionParameters::_internal_level_mission_requirements() const {
  return level_mission_requirements_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
ArtifactsConfigurationResponse_MissionParameters::level_mission_requirements() const {
  // @@protoc_insertion_point(field_list:ei.ArtifactsConfigurationResponse.MissionParameters.level_mission_requirements)
  return _internal_level_mission_requirements();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
ArtifactsConfigurationResponse_MissionParameters::_internal_mutable_level_mission_requirements() {
  return &level_mission_requirements_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
ArtifactsConfigurationResponse_MissionParameters::mutable_level_mission_requirements() {
  // @@protoc_insertion_point(field_mutable_list:ei.ArtifactsConfigurationResponse.MissionParameters.level_mission_requirements)
  return _internal_mutable_level_mission_requirements();
}

// optional uint32 capacity_DEPRECATED = 2;
inline bool ArtifactsConfigurationResponse_MissionParameters::_internal_has_capacity_deprecated() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ArtifactsConfigurationResponse_MissionParameters::has_capacity_deprecated() const {
  return _internal_has_capacity_deprecated();
}
inline void ArtifactsConfigurationResponse_MissionParameters::clear_capacity_deprecated() {
  capacity_deprecated_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ArtifactsConfigurationResponse_MissionParameters::_internal_capacity_deprecated() const {
  return capacity_deprecated_;
}
inline uint32_t ArtifactsConfigurationResponse_MissionParameters::capacity_deprecated() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsConfigurationResponse.MissionParameters.capacity_DEPRECATED)
  return _internal_capacity_deprecated();
}
inline void ArtifactsConfigurationResponse_MissionParameters::_internal_set_capacity_deprecated(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  capacity_deprecated_ = value;
}
inline void ArtifactsConfigurationResponse_MissionParameters::set_capacity_deprecated(uint32_t value) {
  _internal_set_capacity_deprecated(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactsConfigurationResponse.MissionParameters.capacity_DEPRECATED)
}

// -------------------------------------------------------------------

// ArtifactsConfigurationResponse_ArtifactParameters

// optional .ei.ArtifactSpec spec = 1;
inline bool ArtifactsConfigurationResponse_ArtifactParameters::_internal_has_spec() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || spec_ != nullptr);
  return value;
}
inline bool ArtifactsConfigurationResponse_ArtifactParameters::has_spec() const {
  return _internal_has_spec();
}
inline void ArtifactsConfigurationResponse_ArtifactParameters::clear_spec() {
  if (spec_ != nullptr) spec_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ei::ArtifactSpec& ArtifactsConfigurationResponse_ArtifactParameters::_internal_spec() const {
  const ::ei::ArtifactSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::ArtifactSpec&>(
      ::ei::_ArtifactSpec_default_instance_);
}
inline const ::ei::ArtifactSpec& ArtifactsConfigurationResponse_ArtifactParameters::spec() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsConfigurationResponse.ArtifactParameters.spec)
  return _internal_spec();
}
inline void ArtifactsConfigurationResponse_ArtifactParameters::unsafe_arena_set_allocated_spec(
    ::ei::ArtifactSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.ArtifactsConfigurationResponse.ArtifactParameters.spec)
}
inline ::ei::ArtifactSpec* ArtifactsConfigurationResponse_ArtifactParameters::release_spec() {
  _has_bits_[0] &= ~0x00000001u;
  ::ei::ArtifactSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::ArtifactSpec* ArtifactsConfigurationResponse_ArtifactParameters::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:ei.ArtifactsConfigurationResponse.ArtifactParameters.spec)
  _has_bits_[0] &= ~0x00000001u;
  ::ei::ArtifactSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::ei::ArtifactSpec* ArtifactsConfigurationResponse_ArtifactParameters::_internal_mutable_spec() {
  _has_bits_[0] |= 0x00000001u;
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::ArtifactSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::ei::ArtifactSpec* ArtifactsConfigurationResponse_ArtifactParameters::mutable_spec() {
  ::ei::ArtifactSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:ei.ArtifactsConfigurationResponse.ArtifactParameters.spec)
  return _msg;
}
inline void ArtifactsConfigurationResponse_ArtifactParameters::set_allocated_spec(::ei::ArtifactSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::ArtifactSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:ei.ArtifactsConfigurationResponse.ArtifactParameters.spec)
}

// optional double base_quality = 2;
inline bool ArtifactsConfigurationResponse_ArtifactParameters::_internal_has_base_quality() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ArtifactsConfigurationResponse_ArtifactParameters::has_base_quality() const {
  return _internal_has_base_quality();
}
inline void ArtifactsConfigurationResponse_ArtifactParameters::clear_base_quality() {
  base_quality_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ArtifactsConfigurationResponse_ArtifactParameters::_internal_base_quality() const {
  return base_quality_;
}
inline double ArtifactsConfigurationResponse_ArtifactParameters::base_quality() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsConfigurationResponse.ArtifactParameters.base_quality)
  return _internal_base_quality();
}
inline void ArtifactsConfigurationResponse_ArtifactParameters::_internal_set_base_quality(double value) {
  _has_bits_[0] |= 0x00000002u;
  base_quality_ = value;
}
inline void ArtifactsConfigurationResponse_ArtifactParameters::set_base_quality(double value) {
  _internal_set_base_quality(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactsConfigurationResponse.ArtifactParameters.base_quality)
}

// optional double odds_multiplier = 4;
inline bool ArtifactsConfigurationResponse_ArtifactParameters::_internal_has_odds_multiplier() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ArtifactsConfigurationResponse_ArtifactParameters::has_odds_multiplier() const {
  return _internal_has_odds_multiplier();
}
inline void ArtifactsConfigurationResponse_ArtifactParameters::clear_odds_multiplier() {
  odds_multiplier_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double ArtifactsConfigurationResponse_ArtifactParameters::_internal_odds_multiplier() const {
  return odds_multiplier_;
}
inline double ArtifactsConfigurationResponse_ArtifactParameters::odds_multiplier() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsConfigurationResponse.ArtifactParameters.odds_multiplier)
  return _internal_odds_multiplier();
}
inline void ArtifactsConfigurationResponse_ArtifactParameters::_internal_set_odds_multiplier(double value) {
  _has_bits_[0] |= 0x00000008u;
  odds_multiplier_ = value;
}
inline void ArtifactsConfigurationResponse_ArtifactParameters::set_odds_multiplier(double value) {
  _internal_set_odds_multiplier(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactsConfigurationResponse.ArtifactParameters.odds_multiplier)
}

// optional double value = 3;
inline bool ArtifactsConfigurationResponse_ArtifactParameters::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ArtifactsConfigurationResponse_ArtifactParameters::has_value() const {
  return _internal_has_value();
}
inline void ArtifactsConfigurationResponse_ArtifactParameters::clear_value() {
  value_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double ArtifactsConfigurationResponse_ArtifactParameters::_internal_value() const {
  return value_;
}
inline double ArtifactsConfigurationResponse_ArtifactParameters::value() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsConfigurationResponse.ArtifactParameters.value)
  return _internal_value();
}
inline void ArtifactsConfigurationResponse_ArtifactParameters::_internal_set_value(double value) {
  _has_bits_[0] |= 0x00000004u;
  value_ = value;
}
inline void ArtifactsConfigurationResponse_ArtifactParameters::set_value(double value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactsConfigurationResponse.ArtifactParameters.value)
}

// optional double crafting_price = 5;
inline bool ArtifactsConfigurationResponse_ArtifactParameters::_internal_has_crafting_price() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ArtifactsConfigurationResponse_ArtifactParameters::has_crafting_price() const {
  return _internal_has_crafting_price();
}
inline void ArtifactsConfigurationResponse_ArtifactParameters::clear_crafting_price() {
  crafting_price_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double ArtifactsConfigurationResponse_ArtifactParameters::_internal_crafting_price() const {
  return crafting_price_;
}
inline double ArtifactsConfigurationResponse_ArtifactParameters::crafting_price() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsConfigurationResponse.ArtifactParameters.crafting_price)
  return _internal_crafting_price();
}
inline void ArtifactsConfigurationResponse_ArtifactParameters::_internal_set_crafting_price(double value) {
  _has_bits_[0] |= 0x00000010u;
  crafting_price_ = value;
}
inline void ArtifactsConfigurationResponse_ArtifactParameters::set_crafting_price(double value) {
  _internal_set_crafting_price(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactsConfigurationResponse.ArtifactParameters.crafting_price)
}

// optional double crafting_price_low = 6;
inline bool ArtifactsConfigurationResponse_ArtifactParameters::_internal_has_crafting_price_low() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ArtifactsConfigurationResponse_ArtifactParameters::has_crafting_price_low() const {
  return _internal_has_crafting_price_low();
}
inline void ArtifactsConfigurationResponse_ArtifactParameters::clear_crafting_price_low() {
  crafting_price_low_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double ArtifactsConfigurationResponse_ArtifactParameters::_internal_crafting_price_low() const {
  return crafting_price_low_;
}
inline double ArtifactsConfigurationResponse_ArtifactParameters::crafting_price_low() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsConfigurationResponse.ArtifactParameters.crafting_price_low)
  return _internal_crafting_price_low();
}
inline void ArtifactsConfigurationResponse_ArtifactParameters::_internal_set_crafting_price_low(double value) {
  _has_bits_[0] |= 0x00000020u;
  crafting_price_low_ = value;
}
inline void ArtifactsConfigurationResponse_ArtifactParameters::set_crafting_price_low(double value) {
  _internal_set_crafting_price_low(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactsConfigurationResponse.ArtifactParameters.crafting_price_low)
}

// optional uint32 crafting_price_domain = 7;
inline bool ArtifactsConfigurationResponse_ArtifactParameters::_internal_has_crafting_price_domain() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ArtifactsConfigurationResponse_ArtifactParameters::has_crafting_price_domain() const {
  return _internal_has_crafting_price_domain();
}
inline void ArtifactsConfigurationResponse_ArtifactParameters::clear_crafting_price_domain() {
  crafting_price_domain_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline uint32_t ArtifactsConfigurationResponse_ArtifactParameters::_internal_crafting_price_domain() const {
  return crafting_price_domain_;
}
inline uint32_t ArtifactsConfigurationResponse_ArtifactParameters::crafting_price_domain() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsConfigurationResponse.ArtifactParameters.crafting_price_domain)
  return _internal_crafting_price_domain();
}
inline void ArtifactsConfigurationResponse_ArtifactParameters::_internal_set_crafting_price_domain(uint32_t value) {
  _has_bits_[0] |= 0x00000080u;
  crafting_price_domain_ = value;
}
inline void ArtifactsConfigurationResponse_ArtifactParameters::set_crafting_price_domain(uint32_t value) {
  _internal_set_crafting_price_domain(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactsConfigurationResponse.ArtifactParameters.crafting_price_domain)
}

// optional double crafting_price_curve = 8;
inline bool ArtifactsConfigurationResponse_ArtifactParameters::_internal_has_crafting_price_curve() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ArtifactsConfigurationResponse_ArtifactParameters::has_crafting_price_curve() const {
  return _internal_has_crafting_price_curve();
}
inline void ArtifactsConfigurationResponse_ArtifactParameters::clear_crafting_price_curve() {
  crafting_price_curve_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double ArtifactsConfigurationResponse_ArtifactParameters::_internal_crafting_price_curve() const {
  return crafting_price_curve_;
}
inline double ArtifactsConfigurationResponse_ArtifactParameters::crafting_price_curve() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsConfigurationResponse.ArtifactParameters.crafting_price_curve)
  return _internal_crafting_price_curve();
}
inline void ArtifactsConfigurationResponse_ArtifactParameters::_internal_set_crafting_price_curve(double value) {
  _has_bits_[0] |= 0x00000040u;
  crafting_price_curve_ = value;
}
inline void ArtifactsConfigurationResponse_ArtifactParameters::set_crafting_price_curve(double value) {
  _internal_set_crafting_price_curve(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactsConfigurationResponse.ArtifactParameters.crafting_price_curve)
}

// -------------------------------------------------------------------

// ArtifactsConfigurationResponse

// repeated .ei.ArtifactsConfigurationResponse.MissionParameters mission_parameters = 1;
inline int ArtifactsConfigurationResponse::_internal_mission_parameters_size() const {
  return mission_parameters_.size();
}
inline int ArtifactsConfigurationResponse::mission_parameters_size() const {
  return _internal_mission_parameters_size();
}
inline void ArtifactsConfigurationResponse::clear_mission_parameters() {
  mission_parameters_.Clear();
}
inline ::ei::ArtifactsConfigurationResponse_MissionParameters* ArtifactsConfigurationResponse::mutable_mission_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ArtifactsConfigurationResponse.mission_parameters)
  return mission_parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsConfigurationResponse_MissionParameters >*
ArtifactsConfigurationResponse::mutable_mission_parameters() {
  // @@protoc_insertion_point(field_mutable_list:ei.ArtifactsConfigurationResponse.mission_parameters)
  return &mission_parameters_;
}
inline const ::ei::ArtifactsConfigurationResponse_MissionParameters& ArtifactsConfigurationResponse::_internal_mission_parameters(int index) const {
  return mission_parameters_.Get(index);
}
inline const ::ei::ArtifactsConfigurationResponse_MissionParameters& ArtifactsConfigurationResponse::mission_parameters(int index) const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsConfigurationResponse.mission_parameters)
  return _internal_mission_parameters(index);
}
inline ::ei::ArtifactsConfigurationResponse_MissionParameters* ArtifactsConfigurationResponse::_internal_add_mission_parameters() {
  return mission_parameters_.Add();
}
inline ::ei::ArtifactsConfigurationResponse_MissionParameters* ArtifactsConfigurationResponse::add_mission_parameters() {
  ::ei::ArtifactsConfigurationResponse_MissionParameters* _add = _internal_add_mission_parameters();
  // @@protoc_insertion_point(field_add:ei.ArtifactsConfigurationResponse.mission_parameters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsConfigurationResponse_MissionParameters >&
ArtifactsConfigurationResponse::mission_parameters() const {
  // @@protoc_insertion_point(field_list:ei.ArtifactsConfigurationResponse.mission_parameters)
  return mission_parameters_;
}

// repeated .ei.ArtifactsConfigurationResponse.ArtifactParameters artifact_parameters = 2;
inline int ArtifactsConfigurationResponse::_internal_artifact_parameters_size() const {
  return artifact_parameters_.size();
}
inline int ArtifactsConfigurationResponse::artifact_parameters_size() const {
  return _internal_artifact_parameters_size();
}
inline void ArtifactsConfigurationResponse::clear_artifact_parameters() {
  artifact_parameters_.Clear();
}
inline ::ei::ArtifactsConfigurationResponse_ArtifactParameters* ArtifactsConfigurationResponse::mutable_artifact_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ArtifactsConfigurationResponse.artifact_parameters)
  return artifact_parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsConfigurationResponse_ArtifactParameters >*
ArtifactsConfigurationResponse::mutable_artifact_parameters() {
  // @@protoc_insertion_point(field_mutable_list:ei.ArtifactsConfigurationResponse.artifact_parameters)
  return &artifact_parameters_;
}
inline const ::ei::ArtifactsConfigurationResponse_ArtifactParameters& ArtifactsConfigurationResponse::_internal_artifact_parameters(int index) const {
  return artifact_parameters_.Get(index);
}
inline const ::ei::ArtifactsConfigurationResponse_ArtifactParameters& ArtifactsConfigurationResponse::artifact_parameters(int index) const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsConfigurationResponse.artifact_parameters)
  return _internal_artifact_parameters(index);
}
inline ::ei::ArtifactsConfigurationResponse_ArtifactParameters* ArtifactsConfigurationResponse::_internal_add_artifact_parameters() {
  return artifact_parameters_.Add();
}
inline ::ei::ArtifactsConfigurationResponse_ArtifactParameters* ArtifactsConfigurationResponse::add_artifact_parameters() {
  ::ei::ArtifactsConfigurationResponse_ArtifactParameters* _add = _internal_add_artifact_parameters();
  // @@protoc_insertion_point(field_add:ei.ArtifactsConfigurationResponse.artifact_parameters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsConfigurationResponse_ArtifactParameters >&
ArtifactsConfigurationResponse::artifact_parameters() const {
  // @@protoc_insertion_point(field_list:ei.ArtifactsConfigurationResponse.artifact_parameters)
  return artifact_parameters_;
}

// -------------------------------------------------------------------

// MissionRequest

// optional .ei.BasicRequestInfo rinfo = 4;
inline bool MissionRequest::_internal_has_rinfo() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || rinfo_ != nullptr);
  return value;
}
inline bool MissionRequest::has_rinfo() const {
  return _internal_has_rinfo();
}
inline void MissionRequest::clear_rinfo() {
  if (rinfo_ != nullptr) rinfo_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ei::BasicRequestInfo& MissionRequest::_internal_rinfo() const {
  const ::ei::BasicRequestInfo* p = rinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::BasicRequestInfo&>(
      ::ei::_BasicRequestInfo_default_instance_);
}
inline const ::ei::BasicRequestInfo& MissionRequest::rinfo() const {
  // @@protoc_insertion_point(field_get:ei.MissionRequest.rinfo)
  return _internal_rinfo();
}
inline void MissionRequest::unsafe_arena_set_allocated_rinfo(
    ::ei::BasicRequestInfo* rinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rinfo_);
  }
  rinfo_ = rinfo;
  if (rinfo) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.MissionRequest.rinfo)
}
inline ::ei::BasicRequestInfo* MissionRequest::release_rinfo() {
  _has_bits_[0] &= ~0x00000004u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::BasicRequestInfo* MissionRequest::unsafe_arena_release_rinfo() {
  // @@protoc_insertion_point(field_release:ei.MissionRequest.rinfo)
  _has_bits_[0] &= ~0x00000004u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
  return temp;
}
inline ::ei::BasicRequestInfo* MissionRequest::_internal_mutable_rinfo() {
  _has_bits_[0] |= 0x00000004u;
  if (rinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::BasicRequestInfo>(GetArenaForAllocation());
    rinfo_ = p;
  }
  return rinfo_;
}
inline ::ei::BasicRequestInfo* MissionRequest::mutable_rinfo() {
  ::ei::BasicRequestInfo* _msg = _internal_mutable_rinfo();
  // @@protoc_insertion_point(field_mutable:ei.MissionRequest.rinfo)
  return _msg;
}
inline void MissionRequest::set_allocated_rinfo(::ei::BasicRequestInfo* rinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rinfo_;
  }
  if (rinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::BasicRequestInfo>::GetOwningArena(rinfo);
    if (message_arena != submessage_arena) {
      rinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  rinfo_ = rinfo;
  // @@protoc_insertion_point(field_set_allocated:ei.MissionRequest.rinfo)
}

// optional uint32 client_version = 1;
inline bool MissionRequest::_internal_has_client_version() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MissionRequest::has_client_version() const {
  return _internal_has_client_version();
}
inline void MissionRequest::clear_client_version() {
  client_version_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t MissionRequest::_internal_client_version() const {
  return client_version_;
}
inline uint32_t MissionRequest::client_version() const {
  // @@protoc_insertion_point(field_get:ei.MissionRequest.client_version)
  return _internal_client_version();
}
inline void MissionRequest::_internal_set_client_version(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  client_version_ = value;
}
inline void MissionRequest::set_client_version(uint32_t value) {
  _internal_set_client_version(value);
  // @@protoc_insertion_point(field_set:ei.MissionRequest.client_version)
}

// optional string ei_user_id = 3;
inline bool MissionRequest::_internal_has_ei_user_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MissionRequest::has_ei_user_id() const {
  return _internal_has_ei_user_id();
}
inline void MissionRequest::clear_ei_user_id() {
  ei_user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MissionRequest::ei_user_id() const {
  // @@protoc_insertion_point(field_get:ei.MissionRequest.ei_user_id)
  return _internal_ei_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MissionRequest::set_ei_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 ei_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.MissionRequest.ei_user_id)
}
inline std::string* MissionRequest::mutable_ei_user_id() {
  std::string* _s = _internal_mutable_ei_user_id();
  // @@protoc_insertion_point(field_mutable:ei.MissionRequest.ei_user_id)
  return _s;
}
inline const std::string& MissionRequest::_internal_ei_user_id() const {
  return ei_user_id_.Get();
}
inline void MissionRequest::_internal_set_ei_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ei_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MissionRequest::_internal_mutable_ei_user_id() {
  _has_bits_[0] |= 0x00000001u;
  return ei_user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MissionRequest::release_ei_user_id() {
  // @@protoc_insertion_point(field_release:ei.MissionRequest.ei_user_id)
  if (!_internal_has_ei_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = ei_user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ei_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ei_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MissionRequest::set_allocated_ei_user_id(std::string* ei_user_id) {
  if (ei_user_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ei_user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ei_user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ei_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ei_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.MissionRequest.ei_user_id)
}

// optional .ei.MissionInfo info = 2;
inline bool MissionRequest::_internal_has_info() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || info_ != nullptr);
  return value;
}
inline bool MissionRequest::has_info() const {
  return _internal_has_info();
}
inline void MissionRequest::clear_info() {
  if (info_ != nullptr) info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ei::MissionInfo& MissionRequest::_internal_info() const {
  const ::ei::MissionInfo* p = info_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::MissionInfo&>(
      ::ei::_MissionInfo_default_instance_);
}
inline const ::ei::MissionInfo& MissionRequest::info() const {
  // @@protoc_insertion_point(field_get:ei.MissionRequest.info)
  return _internal_info();
}
inline void MissionRequest::unsafe_arena_set_allocated_info(
    ::ei::MissionInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  info_ = info;
  if (info) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.MissionRequest.info)
}
inline ::ei::MissionInfo* MissionRequest::release_info() {
  _has_bits_[0] &= ~0x00000002u;
  ::ei::MissionInfo* temp = info_;
  info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::MissionInfo* MissionRequest::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:ei.MissionRequest.info)
  _has_bits_[0] &= ~0x00000002u;
  ::ei::MissionInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::ei::MissionInfo* MissionRequest::_internal_mutable_info() {
  _has_bits_[0] |= 0x00000002u;
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::MissionInfo>(GetArenaForAllocation());
    info_ = p;
  }
  return info_;
}
inline ::ei::MissionInfo* MissionRequest::mutable_info() {
  ::ei::MissionInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:ei.MissionRequest.info)
  return _msg;
}
inline void MissionRequest::set_allocated_info(::ei::MissionInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::MissionInfo>::GetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:ei.MissionRequest.info)
}

// optional .ei.ArtifactsClientInfo client_info = 5;
inline bool MissionRequest::_internal_has_client_info() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || client_info_ != nullptr);
  return value;
}
inline bool MissionRequest::has_client_info() const {
  return _internal_has_client_info();
}
inline void MissionRequest::clear_client_info() {
  if (client_info_ != nullptr) client_info_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ei::ArtifactsClientInfo& MissionRequest::_internal_client_info() const {
  const ::ei::ArtifactsClientInfo* p = client_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::ArtifactsClientInfo&>(
      ::ei::_ArtifactsClientInfo_default_instance_);
}
inline const ::ei::ArtifactsClientInfo& MissionRequest::client_info() const {
  // @@protoc_insertion_point(field_get:ei.MissionRequest.client_info)
  return _internal_client_info();
}
inline void MissionRequest::unsafe_arena_set_allocated_client_info(
    ::ei::ArtifactsClientInfo* client_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_info_);
  }
  client_info_ = client_info;
  if (client_info) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.MissionRequest.client_info)
}
inline ::ei::ArtifactsClientInfo* MissionRequest::release_client_info() {
  _has_bits_[0] &= ~0x00000008u;
  ::ei::ArtifactsClientInfo* temp = client_info_;
  client_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::ArtifactsClientInfo* MissionRequest::unsafe_arena_release_client_info() {
  // @@protoc_insertion_point(field_release:ei.MissionRequest.client_info)
  _has_bits_[0] &= ~0x00000008u;
  ::ei::ArtifactsClientInfo* temp = client_info_;
  client_info_ = nullptr;
  return temp;
}
inline ::ei::ArtifactsClientInfo* MissionRequest::_internal_mutable_client_info() {
  _has_bits_[0] |= 0x00000008u;
  if (client_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::ArtifactsClientInfo>(GetArenaForAllocation());
    client_info_ = p;
  }
  return client_info_;
}
inline ::ei::ArtifactsClientInfo* MissionRequest::mutable_client_info() {
  ::ei::ArtifactsClientInfo* _msg = _internal_mutable_client_info();
  // @@protoc_insertion_point(field_mutable:ei.MissionRequest.client_info)
  return _msg;
}
inline void MissionRequest::set_allocated_client_info(::ei::ArtifactsClientInfo* client_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_info_;
  }
  if (client_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::ArtifactsClientInfo>::GetOwningArena(client_info);
    if (message_arena != submessage_arena) {
      client_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  client_info_ = client_info;
  // @@protoc_insertion_point(field_set_allocated:ei.MissionRequest.client_info)
}

// -------------------------------------------------------------------

// MissionResponse

// optional bool success = 1;
inline bool MissionResponse::_internal_has_success() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MissionResponse::has_success() const {
  return _internal_has_success();
}
inline void MissionResponse::clear_success() {
  success_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool MissionResponse::_internal_success() const {
  return success_;
}
inline bool MissionResponse::success() const {
  // @@protoc_insertion_point(field_get:ei.MissionResponse.success)
  return _internal_success();
}
inline void MissionResponse::_internal_set_success(bool value) {
  _has_bits_[0] |= 0x00000002u;
  success_ = value;
}
inline void MissionResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:ei.MissionResponse.success)
}

// optional .ei.MissionInfo info = 2;
inline bool MissionResponse::_internal_has_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || info_ != nullptr);
  return value;
}
inline bool MissionResponse::has_info() const {
  return _internal_has_info();
}
inline void MissionResponse::clear_info() {
  if (info_ != nullptr) info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ei::MissionInfo& MissionResponse::_internal_info() const {
  const ::ei::MissionInfo* p = info_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::MissionInfo&>(
      ::ei::_MissionInfo_default_instance_);
}
inline const ::ei::MissionInfo& MissionResponse::info() const {
  // @@protoc_insertion_point(field_get:ei.MissionResponse.info)
  return _internal_info();
}
inline void MissionResponse::unsafe_arena_set_allocated_info(
    ::ei::MissionInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  info_ = info;
  if (info) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.MissionResponse.info)
}
inline ::ei::MissionInfo* MissionResponse::release_info() {
  _has_bits_[0] &= ~0x00000001u;
  ::ei::MissionInfo* temp = info_;
  info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::MissionInfo* MissionResponse::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:ei.MissionResponse.info)
  _has_bits_[0] &= ~0x00000001u;
  ::ei::MissionInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::ei::MissionInfo* MissionResponse::_internal_mutable_info() {
  _has_bits_[0] |= 0x00000001u;
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::MissionInfo>(GetArenaForAllocation());
    info_ = p;
  }
  return info_;
}
inline ::ei::MissionInfo* MissionResponse::mutable_info() {
  ::ei::MissionInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:ei.MissionResponse.info)
  return _msg;
}
inline void MissionResponse::set_allocated_info(::ei::MissionInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::MissionInfo>::GetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:ei.MissionResponse.info)
}

// -------------------------------------------------------------------

// CompleteMissionResponse_SecureArtifactSpec

// optional .ei.ArtifactSpec spec = 1;
inline bool CompleteMissionResponse_SecureArtifactSpec::_internal_has_spec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || spec_ != nullptr);
  return value;
}
inline bool CompleteMissionResponse_SecureArtifactSpec::has_spec() const {
  return _internal_has_spec();
}
inline void CompleteMissionResponse_SecureArtifactSpec::clear_spec() {
  if (spec_ != nullptr) spec_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ei::ArtifactSpec& CompleteMissionResponse_SecureArtifactSpec::_internal_spec() const {
  const ::ei::ArtifactSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::ArtifactSpec&>(
      ::ei::_ArtifactSpec_default_instance_);
}
inline const ::ei::ArtifactSpec& CompleteMissionResponse_SecureArtifactSpec::spec() const {
  // @@protoc_insertion_point(field_get:ei.CompleteMissionResponse.SecureArtifactSpec.spec)
  return _internal_spec();
}
inline void CompleteMissionResponse_SecureArtifactSpec::unsafe_arena_set_allocated_spec(
    ::ei::ArtifactSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.CompleteMissionResponse.SecureArtifactSpec.spec)
}
inline ::ei::ArtifactSpec* CompleteMissionResponse_SecureArtifactSpec::release_spec() {
  _has_bits_[0] &= ~0x00000002u;
  ::ei::ArtifactSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::ArtifactSpec* CompleteMissionResponse_SecureArtifactSpec::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:ei.CompleteMissionResponse.SecureArtifactSpec.spec)
  _has_bits_[0] &= ~0x00000002u;
  ::ei::ArtifactSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::ei::ArtifactSpec* CompleteMissionResponse_SecureArtifactSpec::_internal_mutable_spec() {
  _has_bits_[0] |= 0x00000002u;
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::ArtifactSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::ei::ArtifactSpec* CompleteMissionResponse_SecureArtifactSpec::mutable_spec() {
  ::ei::ArtifactSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:ei.CompleteMissionResponse.SecureArtifactSpec.spec)
  return _msg;
}
inline void CompleteMissionResponse_SecureArtifactSpec::set_allocated_spec(::ei::ArtifactSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::ArtifactSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:ei.CompleteMissionResponse.SecureArtifactSpec.spec)
}

// optional string server_id = 2;
inline bool CompleteMissionResponse_SecureArtifactSpec::_internal_has_server_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CompleteMissionResponse_SecureArtifactSpec::has_server_id() const {
  return _internal_has_server_id();
}
inline void CompleteMissionResponse_SecureArtifactSpec::clear_server_id() {
  server_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CompleteMissionResponse_SecureArtifactSpec::server_id() const {
  // @@protoc_insertion_point(field_get:ei.CompleteMissionResponse.SecureArtifactSpec.server_id)
  return _internal_server_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompleteMissionResponse_SecureArtifactSpec::set_server_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 server_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.CompleteMissionResponse.SecureArtifactSpec.server_id)
}
inline std::string* CompleteMissionResponse_SecureArtifactSpec::mutable_server_id() {
  std::string* _s = _internal_mutable_server_id();
  // @@protoc_insertion_point(field_mutable:ei.CompleteMissionResponse.SecureArtifactSpec.server_id)
  return _s;
}
inline const std::string& CompleteMissionResponse_SecureArtifactSpec::_internal_server_id() const {
  return server_id_.Get();
}
inline void CompleteMissionResponse_SecureArtifactSpec::_internal_set_server_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  server_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CompleteMissionResponse_SecureArtifactSpec::_internal_mutable_server_id() {
  _has_bits_[0] |= 0x00000001u;
  return server_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CompleteMissionResponse_SecureArtifactSpec::release_server_id() {
  // @@protoc_insertion_point(field_release:ei.CompleteMissionResponse.SecureArtifactSpec.server_id)
  if (!_internal_has_server_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = server_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (server_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    server_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CompleteMissionResponse_SecureArtifactSpec::set_allocated_server_id(std::string* server_id) {
  if (server_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  server_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), server_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (server_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    server_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.CompleteMissionResponse.SecureArtifactSpec.server_id)
}

// -------------------------------------------------------------------

// CompleteMissionResponse

// optional bool success = 1;
inline bool CompleteMissionResponse::_internal_has_success() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CompleteMissionResponse::has_success() const {
  return _internal_has_success();
}
inline void CompleteMissionResponse::clear_success() {
  success_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool CompleteMissionResponse::_internal_success() const {
  return success_;
}
inline bool CompleteMissionResponse::success() const {
  // @@protoc_insertion_point(field_get:ei.CompleteMissionResponse.success)
  return _internal_success();
}
inline void CompleteMissionResponse::_internal_set_success(bool value) {
  _has_bits_[0] |= 0x00000004u;
  success_ = value;
}
inline void CompleteMissionResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:ei.CompleteMissionResponse.success)
}

// optional .ei.MissionInfo info = 2;
inline bool CompleteMissionResponse::_internal_has_info() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || info_ != nullptr);
  return value;
}
inline bool CompleteMissionResponse::has_info() const {
  return _internal_has_info();
}
inline void CompleteMissionResponse::clear_info() {
  if (info_ != nullptr) info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ei::MissionInfo& CompleteMissionResponse::_internal_info() const {
  const ::ei::MissionInfo* p = info_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::MissionInfo&>(
      ::ei::_MissionInfo_default_instance_);
}
inline const ::ei::MissionInfo& CompleteMissionResponse::info() const {
  // @@protoc_insertion_point(field_get:ei.CompleteMissionResponse.info)
  return _internal_info();
}
inline void CompleteMissionResponse::unsafe_arena_set_allocated_info(
    ::ei::MissionInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  info_ = info;
  if (info) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.CompleteMissionResponse.info)
}
inline ::ei::MissionInfo* CompleteMissionResponse::release_info() {
  _has_bits_[0] &= ~0x00000002u;
  ::ei::MissionInfo* temp = info_;
  info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::MissionInfo* CompleteMissionResponse::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:ei.CompleteMissionResponse.info)
  _has_bits_[0] &= ~0x00000002u;
  ::ei::MissionInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::ei::MissionInfo* CompleteMissionResponse::_internal_mutable_info() {
  _has_bits_[0] |= 0x00000002u;
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::MissionInfo>(GetArenaForAllocation());
    info_ = p;
  }
  return info_;
}
inline ::ei::MissionInfo* CompleteMissionResponse::mutable_info() {
  ::ei::MissionInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:ei.CompleteMissionResponse.info)
  return _msg;
}
inline void CompleteMissionResponse::set_allocated_info(::ei::MissionInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::MissionInfo>::GetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:ei.CompleteMissionResponse.info)
}

// repeated .ei.CompleteMissionResponse.SecureArtifactSpec artifacts = 3;
inline int CompleteMissionResponse::_internal_artifacts_size() const {
  return artifacts_.size();
}
inline int CompleteMissionResponse::artifacts_size() const {
  return _internal_artifacts_size();
}
inline void CompleteMissionResponse::clear_artifacts() {
  artifacts_.Clear();
}
inline ::ei::CompleteMissionResponse_SecureArtifactSpec* CompleteMissionResponse::mutable_artifacts(int index) {
  // @@protoc_insertion_point(field_mutable:ei.CompleteMissionResponse.artifacts)
  return artifacts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::CompleteMissionResponse_SecureArtifactSpec >*
CompleteMissionResponse::mutable_artifacts() {
  // @@protoc_insertion_point(field_mutable_list:ei.CompleteMissionResponse.artifacts)
  return &artifacts_;
}
inline const ::ei::CompleteMissionResponse_SecureArtifactSpec& CompleteMissionResponse::_internal_artifacts(int index) const {
  return artifacts_.Get(index);
}
inline const ::ei::CompleteMissionResponse_SecureArtifactSpec& CompleteMissionResponse::artifacts(int index) const {
  // @@protoc_insertion_point(field_get:ei.CompleteMissionResponse.artifacts)
  return _internal_artifacts(index);
}
inline ::ei::CompleteMissionResponse_SecureArtifactSpec* CompleteMissionResponse::_internal_add_artifacts() {
  return artifacts_.Add();
}
inline ::ei::CompleteMissionResponse_SecureArtifactSpec* CompleteMissionResponse::add_artifacts() {
  ::ei::CompleteMissionResponse_SecureArtifactSpec* _add = _internal_add_artifacts();
  // @@protoc_insertion_point(field_add:ei.CompleteMissionResponse.artifacts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::CompleteMissionResponse_SecureArtifactSpec >&
CompleteMissionResponse::artifacts() const {
  // @@protoc_insertion_point(field_list:ei.CompleteMissionResponse.artifacts)
  return artifacts_;
}

// repeated .ei.Reward other_rewards = 4;
inline int CompleteMissionResponse::_internal_other_rewards_size() const {
  return other_rewards_.size();
}
inline int CompleteMissionResponse::other_rewards_size() const {
  return _internal_other_rewards_size();
}
inline void CompleteMissionResponse::clear_other_rewards() {
  other_rewards_.Clear();
}
inline ::ei::Reward* CompleteMissionResponse::mutable_other_rewards(int index) {
  // @@protoc_insertion_point(field_mutable:ei.CompleteMissionResponse.other_rewards)
  return other_rewards_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Reward >*
CompleteMissionResponse::mutable_other_rewards() {
  // @@protoc_insertion_point(field_mutable_list:ei.CompleteMissionResponse.other_rewards)
  return &other_rewards_;
}
inline const ::ei::Reward& CompleteMissionResponse::_internal_other_rewards(int index) const {
  return other_rewards_.Get(index);
}
inline const ::ei::Reward& CompleteMissionResponse::other_rewards(int index) const {
  // @@protoc_insertion_point(field_get:ei.CompleteMissionResponse.other_rewards)
  return _internal_other_rewards(index);
}
inline ::ei::Reward* CompleteMissionResponse::_internal_add_other_rewards() {
  return other_rewards_.Add();
}
inline ::ei::Reward* CompleteMissionResponse::add_other_rewards() {
  ::ei::Reward* _add = _internal_add_other_rewards();
  // @@protoc_insertion_point(field_add:ei.CompleteMissionResponse.other_rewards)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Reward >&
CompleteMissionResponse::other_rewards() const {
  // @@protoc_insertion_point(field_list:ei.CompleteMissionResponse.other_rewards)
  return other_rewards_;
}

// optional string ei_user_id = 5;
inline bool CompleteMissionResponse::_internal_has_ei_user_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CompleteMissionResponse::has_ei_user_id() const {
  return _internal_has_ei_user_id();
}
inline void CompleteMissionResponse::clear_ei_user_id() {
  ei_user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CompleteMissionResponse::ei_user_id() const {
  // @@protoc_insertion_point(field_get:ei.CompleteMissionResponse.ei_user_id)
  return _internal_ei_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompleteMissionResponse::set_ei_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 ei_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.CompleteMissionResponse.ei_user_id)
}
inline std::string* CompleteMissionResponse::mutable_ei_user_id() {
  std::string* _s = _internal_mutable_ei_user_id();
  // @@protoc_insertion_point(field_mutable:ei.CompleteMissionResponse.ei_user_id)
  return _s;
}
inline const std::string& CompleteMissionResponse::_internal_ei_user_id() const {
  return ei_user_id_.Get();
}
inline void CompleteMissionResponse::_internal_set_ei_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ei_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CompleteMissionResponse::_internal_mutable_ei_user_id() {
  _has_bits_[0] |= 0x00000001u;
  return ei_user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CompleteMissionResponse::release_ei_user_id() {
  // @@protoc_insertion_point(field_release:ei.CompleteMissionResponse.ei_user_id)
  if (!_internal_has_ei_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = ei_user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ei_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ei_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CompleteMissionResponse::set_allocated_ei_user_id(std::string* ei_user_id) {
  if (ei_user_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ei_user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ei_user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ei_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ei_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.CompleteMissionResponse.ei_user_id)
}

// -------------------------------------------------------------------

// CollectContractArtifactRewardsRequest

// optional .ei.BasicRequestInfo rinfo = 1;
inline bool CollectContractArtifactRewardsRequest::_internal_has_rinfo() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || rinfo_ != nullptr);
  return value;
}
inline bool CollectContractArtifactRewardsRequest::has_rinfo() const {
  return _internal_has_rinfo();
}
inline void CollectContractArtifactRewardsRequest::clear_rinfo() {
  if (rinfo_ != nullptr) rinfo_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ei::BasicRequestInfo& CollectContractArtifactRewardsRequest::_internal_rinfo() const {
  const ::ei::BasicRequestInfo* p = rinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::BasicRequestInfo&>(
      ::ei::_BasicRequestInfo_default_instance_);
}
inline const ::ei::BasicRequestInfo& CollectContractArtifactRewardsRequest::rinfo() const {
  // @@protoc_insertion_point(field_get:ei.CollectContractArtifactRewardsRequest.rinfo)
  return _internal_rinfo();
}
inline void CollectContractArtifactRewardsRequest::unsafe_arena_set_allocated_rinfo(
    ::ei::BasicRequestInfo* rinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rinfo_);
  }
  rinfo_ = rinfo;
  if (rinfo) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.CollectContractArtifactRewardsRequest.rinfo)
}
inline ::ei::BasicRequestInfo* CollectContractArtifactRewardsRequest::release_rinfo() {
  _has_bits_[0] &= ~0x00000002u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::BasicRequestInfo* CollectContractArtifactRewardsRequest::unsafe_arena_release_rinfo() {
  // @@protoc_insertion_point(field_release:ei.CollectContractArtifactRewardsRequest.rinfo)
  _has_bits_[0] &= ~0x00000002u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
  return temp;
}
inline ::ei::BasicRequestInfo* CollectContractArtifactRewardsRequest::_internal_mutable_rinfo() {
  _has_bits_[0] |= 0x00000002u;
  if (rinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::BasicRequestInfo>(GetArenaForAllocation());
    rinfo_ = p;
  }
  return rinfo_;
}
inline ::ei::BasicRequestInfo* CollectContractArtifactRewardsRequest::mutable_rinfo() {
  ::ei::BasicRequestInfo* _msg = _internal_mutable_rinfo();
  // @@protoc_insertion_point(field_mutable:ei.CollectContractArtifactRewardsRequest.rinfo)
  return _msg;
}
inline void CollectContractArtifactRewardsRequest::set_allocated_rinfo(::ei::BasicRequestInfo* rinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rinfo_;
  }
  if (rinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::BasicRequestInfo>::GetOwningArena(rinfo);
    if (message_arena != submessage_arena) {
      rinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  rinfo_ = rinfo;
  // @@protoc_insertion_point(field_set_allocated:ei.CollectContractArtifactRewardsRequest.rinfo)
}

// optional string contract_identifier = 2;
inline bool CollectContractArtifactRewardsRequest::_internal_has_contract_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CollectContractArtifactRewardsRequest::has_contract_identifier() const {
  return _internal_has_contract_identifier();
}
inline void CollectContractArtifactRewardsRequest::clear_contract_identifier() {
  contract_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CollectContractArtifactRewardsRequest::contract_identifier() const {
  // @@protoc_insertion_point(field_get:ei.CollectContractArtifactRewardsRequest.contract_identifier)
  return _internal_contract_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CollectContractArtifactRewardsRequest::set_contract_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 contract_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.CollectContractArtifactRewardsRequest.contract_identifier)
}
inline std::string* CollectContractArtifactRewardsRequest::mutable_contract_identifier() {
  std::string* _s = _internal_mutable_contract_identifier();
  // @@protoc_insertion_point(field_mutable:ei.CollectContractArtifactRewardsRequest.contract_identifier)
  return _s;
}
inline const std::string& CollectContractArtifactRewardsRequest::_internal_contract_identifier() const {
  return contract_identifier_.Get();
}
inline void CollectContractArtifactRewardsRequest::_internal_set_contract_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  contract_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CollectContractArtifactRewardsRequest::_internal_mutable_contract_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return contract_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CollectContractArtifactRewardsRequest::release_contract_identifier() {
  // @@protoc_insertion_point(field_release:ei.CollectContractArtifactRewardsRequest.contract_identifier)
  if (!_internal_has_contract_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = contract_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CollectContractArtifactRewardsRequest::set_allocated_contract_identifier(std::string* contract_identifier) {
  if (contract_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  contract_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contract_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.CollectContractArtifactRewardsRequest.contract_identifier)
}

// optional uint32 league = 5;
inline bool CollectContractArtifactRewardsRequest::_internal_has_league() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CollectContractArtifactRewardsRequest::has_league() const {
  return _internal_has_league();
}
inline void CollectContractArtifactRewardsRequest::clear_league() {
  league_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CollectContractArtifactRewardsRequest::_internal_league() const {
  return league_;
}
inline uint32_t CollectContractArtifactRewardsRequest::league() const {
  // @@protoc_insertion_point(field_get:ei.CollectContractArtifactRewardsRequest.league)
  return _internal_league();
}
inline void CollectContractArtifactRewardsRequest::_internal_set_league(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  league_ = value;
}
inline void CollectContractArtifactRewardsRequest::set_league(uint32_t value) {
  _internal_set_league(value);
  // @@protoc_insertion_point(field_set:ei.CollectContractArtifactRewardsRequest.league)
}

// optional uint32 goal_index = 3;
inline bool CollectContractArtifactRewardsRequest::_internal_has_goal_index() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CollectContractArtifactRewardsRequest::has_goal_index() const {
  return _internal_has_goal_index();
}
inline void CollectContractArtifactRewardsRequest::clear_goal_index() {
  goal_index_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CollectContractArtifactRewardsRequest::_internal_goal_index() const {
  return goal_index_;
}
inline uint32_t CollectContractArtifactRewardsRequest::goal_index() const {
  // @@protoc_insertion_point(field_get:ei.CollectContractArtifactRewardsRequest.goal_index)
  return _internal_goal_index();
}
inline void CollectContractArtifactRewardsRequest::_internal_set_goal_index(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  goal_index_ = value;
}
inline void CollectContractArtifactRewardsRequest::set_goal_index(uint32_t value) {
  _internal_set_goal_index(value);
  // @@protoc_insertion_point(field_set:ei.CollectContractArtifactRewardsRequest.goal_index)
}

// optional .ei.MissionInfo.Spaceship best_ship = 4;
inline bool CollectContractArtifactRewardsRequest::_internal_has_best_ship() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CollectContractArtifactRewardsRequest::has_best_ship() const {
  return _internal_has_best_ship();
}
inline void CollectContractArtifactRewardsRequest::clear_best_ship() {
  best_ship_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::ei::MissionInfo_Spaceship CollectContractArtifactRewardsRequest::_internal_best_ship() const {
  return static_cast< ::ei::MissionInfo_Spaceship >(best_ship_);
}
inline ::ei::MissionInfo_Spaceship CollectContractArtifactRewardsRequest::best_ship() const {
  // @@protoc_insertion_point(field_get:ei.CollectContractArtifactRewardsRequest.best_ship)
  return _internal_best_ship();
}
inline void CollectContractArtifactRewardsRequest::_internal_set_best_ship(::ei::MissionInfo_Spaceship value) {
  assert(::ei::MissionInfo_Spaceship_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  best_ship_ = value;
}
inline void CollectContractArtifactRewardsRequest::set_best_ship(::ei::MissionInfo_Spaceship value) {
  _internal_set_best_ship(value);
  // @@protoc_insertion_point(field_set:ei.CollectContractArtifactRewardsRequest.best_ship)
}

// -------------------------------------------------------------------

// CraftArtifactRequest

// optional .ei.BasicRequestInfo rinfo = 5;
inline bool CraftArtifactRequest::_internal_has_rinfo() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || rinfo_ != nullptr);
  return value;
}
inline bool CraftArtifactRequest::has_rinfo() const {
  return _internal_has_rinfo();
}
inline void CraftArtifactRequest::clear_rinfo() {
  if (rinfo_ != nullptr) rinfo_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ei::BasicRequestInfo& CraftArtifactRequest::_internal_rinfo() const {
  const ::ei::BasicRequestInfo* p = rinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::BasicRequestInfo&>(
      ::ei::_BasicRequestInfo_default_instance_);
}
inline const ::ei::BasicRequestInfo& CraftArtifactRequest::rinfo() const {
  // @@protoc_insertion_point(field_get:ei.CraftArtifactRequest.rinfo)
  return _internal_rinfo();
}
inline void CraftArtifactRequest::unsafe_arena_set_allocated_rinfo(
    ::ei::BasicRequestInfo* rinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rinfo_);
  }
  rinfo_ = rinfo;
  if (rinfo) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.CraftArtifactRequest.rinfo)
}
inline ::ei::BasicRequestInfo* CraftArtifactRequest::release_rinfo() {
  _has_bits_[0] &= ~0x00000004u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::BasicRequestInfo* CraftArtifactRequest::unsafe_arena_release_rinfo() {
  // @@protoc_insertion_point(field_release:ei.CraftArtifactRequest.rinfo)
  _has_bits_[0] &= ~0x00000004u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
  return temp;
}
inline ::ei::BasicRequestInfo* CraftArtifactRequest::_internal_mutable_rinfo() {
  _has_bits_[0] |= 0x00000004u;
  if (rinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::BasicRequestInfo>(GetArenaForAllocation());
    rinfo_ = p;
  }
  return rinfo_;
}
inline ::ei::BasicRequestInfo* CraftArtifactRequest::mutable_rinfo() {
  ::ei::BasicRequestInfo* _msg = _internal_mutable_rinfo();
  // @@protoc_insertion_point(field_mutable:ei.CraftArtifactRequest.rinfo)
  return _msg;
}
inline void CraftArtifactRequest::set_allocated_rinfo(::ei::BasicRequestInfo* rinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rinfo_;
  }
  if (rinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::BasicRequestInfo>::GetOwningArena(rinfo);
    if (message_arena != submessage_arena) {
      rinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  rinfo_ = rinfo;
  // @@protoc_insertion_point(field_set_allocated:ei.CraftArtifactRequest.rinfo)
}

// optional string ei_user_id = 1;
inline bool CraftArtifactRequest::_internal_has_ei_user_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CraftArtifactRequest::has_ei_user_id() const {
  return _internal_has_ei_user_id();
}
inline void CraftArtifactRequest::clear_ei_user_id() {
  ei_user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CraftArtifactRequest::ei_user_id() const {
  // @@protoc_insertion_point(field_get:ei.CraftArtifactRequest.ei_user_id)
  return _internal_ei_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CraftArtifactRequest::set_ei_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 ei_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.CraftArtifactRequest.ei_user_id)
}
inline std::string* CraftArtifactRequest::mutable_ei_user_id() {
  std::string* _s = _internal_mutable_ei_user_id();
  // @@protoc_insertion_point(field_mutable:ei.CraftArtifactRequest.ei_user_id)
  return _s;
}
inline const std::string& CraftArtifactRequest::_internal_ei_user_id() const {
  return ei_user_id_.Get();
}
inline void CraftArtifactRequest::_internal_set_ei_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ei_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CraftArtifactRequest::_internal_mutable_ei_user_id() {
  _has_bits_[0] |= 0x00000001u;
  return ei_user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CraftArtifactRequest::release_ei_user_id() {
  // @@protoc_insertion_point(field_release:ei.CraftArtifactRequest.ei_user_id)
  if (!_internal_has_ei_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = ei_user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ei_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ei_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CraftArtifactRequest::set_allocated_ei_user_id(std::string* ei_user_id) {
  if (ei_user_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ei_user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ei_user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ei_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ei_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.CraftArtifactRequest.ei_user_id)
}

// optional .ei.ArtifactSpec spec = 2;
inline bool CraftArtifactRequest::_internal_has_spec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || spec_ != nullptr);
  return value;
}
inline bool CraftArtifactRequest::has_spec() const {
  return _internal_has_spec();
}
inline void CraftArtifactRequest::clear_spec() {
  if (spec_ != nullptr) spec_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ei::ArtifactSpec& CraftArtifactRequest::_internal_spec() const {
  const ::ei::ArtifactSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::ArtifactSpec&>(
      ::ei::_ArtifactSpec_default_instance_);
}
inline const ::ei::ArtifactSpec& CraftArtifactRequest::spec() const {
  // @@protoc_insertion_point(field_get:ei.CraftArtifactRequest.spec)
  return _internal_spec();
}
inline void CraftArtifactRequest::unsafe_arena_set_allocated_spec(
    ::ei::ArtifactSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.CraftArtifactRequest.spec)
}
inline ::ei::ArtifactSpec* CraftArtifactRequest::release_spec() {
  _has_bits_[0] &= ~0x00000002u;
  ::ei::ArtifactSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::ArtifactSpec* CraftArtifactRequest::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:ei.CraftArtifactRequest.spec)
  _has_bits_[0] &= ~0x00000002u;
  ::ei::ArtifactSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::ei::ArtifactSpec* CraftArtifactRequest::_internal_mutable_spec() {
  _has_bits_[0] |= 0x00000002u;
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::ArtifactSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::ei::ArtifactSpec* CraftArtifactRequest::mutable_spec() {
  ::ei::ArtifactSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:ei.CraftArtifactRequest.spec)
  return _msg;
}
inline void CraftArtifactRequest::set_allocated_spec(::ei::ArtifactSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::ArtifactSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:ei.CraftArtifactRequest.spec)
}

// optional uint64 item_id = 3;
inline bool CraftArtifactRequest::_internal_has_item_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CraftArtifactRequest::has_item_id() const {
  return _internal_has_item_id();
}
inline void CraftArtifactRequest::clear_item_id() {
  item_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t CraftArtifactRequest::_internal_item_id() const {
  return item_id_;
}
inline uint64_t CraftArtifactRequest::item_id() const {
  // @@protoc_insertion_point(field_get:ei.CraftArtifactRequest.item_id)
  return _internal_item_id();
}
inline void CraftArtifactRequest::_internal_set_item_id(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  item_id_ = value;
}
inline void CraftArtifactRequest::set_item_id(uint64_t value) {
  _internal_set_item_id(value);
  // @@protoc_insertion_point(field_set:ei.CraftArtifactRequest.item_id)
}

// optional double gold_price_paid = 6;
inline bool CraftArtifactRequest::_internal_has_gold_price_paid() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CraftArtifactRequest::has_gold_price_paid() const {
  return _internal_has_gold_price_paid();
}
inline void CraftArtifactRequest::clear_gold_price_paid() {
  gold_price_paid_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double CraftArtifactRequest::_internal_gold_price_paid() const {
  return gold_price_paid_;
}
inline double CraftArtifactRequest::gold_price_paid() const {
  // @@protoc_insertion_point(field_get:ei.CraftArtifactRequest.gold_price_paid)
  return _internal_gold_price_paid();
}
inline void CraftArtifactRequest::_internal_set_gold_price_paid(double value) {
  _has_bits_[0] |= 0x00000010u;
  gold_price_paid_ = value;
}
inline void CraftArtifactRequest::set_gold_price_paid(double value) {
  _internal_set_gold_price_paid(value);
  // @@protoc_insertion_point(field_set:ei.CraftArtifactRequest.gold_price_paid)
}

// optional uint32 crafting_count = 7;
inline bool CraftArtifactRequest::_internal_has_crafting_count() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CraftArtifactRequest::has_crafting_count() const {
  return _internal_has_crafting_count();
}
inline void CraftArtifactRequest::clear_crafting_count() {
  crafting_count_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t CraftArtifactRequest::_internal_crafting_count() const {
  return crafting_count_;
}
inline uint32_t CraftArtifactRequest::crafting_count() const {
  // @@protoc_insertion_point(field_get:ei.CraftArtifactRequest.crafting_count)
  return _internal_crafting_count();
}
inline void CraftArtifactRequest::_internal_set_crafting_count(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  crafting_count_ = value;
}
inline void CraftArtifactRequest::set_crafting_count(uint32_t value) {
  _internal_set_crafting_count(value);
  // @@protoc_insertion_point(field_set:ei.CraftArtifactRequest.crafting_count)
}

// repeated .ei.ArtifactInventoryItem ingredients = 4;
inline int CraftArtifactRequest::_internal_ingredients_size() const {
  return ingredients_.size();
}
inline int CraftArtifactRequest::ingredients_size() const {
  return _internal_ingredients_size();
}
inline void CraftArtifactRequest::clear_ingredients() {
  ingredients_.Clear();
}
inline ::ei::ArtifactInventoryItem* CraftArtifactRequest::mutable_ingredients(int index) {
  // @@protoc_insertion_point(field_mutable:ei.CraftArtifactRequest.ingredients)
  return ingredients_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactInventoryItem >*
CraftArtifactRequest::mutable_ingredients() {
  // @@protoc_insertion_point(field_mutable_list:ei.CraftArtifactRequest.ingredients)
  return &ingredients_;
}
inline const ::ei::ArtifactInventoryItem& CraftArtifactRequest::_internal_ingredients(int index) const {
  return ingredients_.Get(index);
}
inline const ::ei::ArtifactInventoryItem& CraftArtifactRequest::ingredients(int index) const {
  // @@protoc_insertion_point(field_get:ei.CraftArtifactRequest.ingredients)
  return _internal_ingredients(index);
}
inline ::ei::ArtifactInventoryItem* CraftArtifactRequest::_internal_add_ingredients() {
  return ingredients_.Add();
}
inline ::ei::ArtifactInventoryItem* CraftArtifactRequest::add_ingredients() {
  ::ei::ArtifactInventoryItem* _add = _internal_add_ingredients();
  // @@protoc_insertion_point(field_add:ei.CraftArtifactRequest.ingredients)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactInventoryItem >&
CraftArtifactRequest::ingredients() const {
  // @@protoc_insertion_point(field_list:ei.CraftArtifactRequest.ingredients)
  return ingredients_;
}

// -------------------------------------------------------------------

// CraftArtifactResponse

// optional uint64 item_id = 1;
inline bool CraftArtifactResponse::_internal_has_item_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CraftArtifactResponse::has_item_id() const {
  return _internal_has_item_id();
}
inline void CraftArtifactResponse::clear_item_id() {
  item_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t CraftArtifactResponse::_internal_item_id() const {
  return item_id_;
}
inline uint64_t CraftArtifactResponse::item_id() const {
  // @@protoc_insertion_point(field_get:ei.CraftArtifactResponse.item_id)
  return _internal_item_id();
}
inline void CraftArtifactResponse::_internal_set_item_id(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  item_id_ = value;
}
inline void CraftArtifactResponse::set_item_id(uint64_t value) {
  _internal_set_item_id(value);
  // @@protoc_insertion_point(field_set:ei.CraftArtifactResponse.item_id)
}

// optional string ei_user_id = 5;
inline bool CraftArtifactResponse::_internal_has_ei_user_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CraftArtifactResponse::has_ei_user_id() const {
  return _internal_has_ei_user_id();
}
inline void CraftArtifactResponse::clear_ei_user_id() {
  ei_user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CraftArtifactResponse::ei_user_id() const {
  // @@protoc_insertion_point(field_get:ei.CraftArtifactResponse.ei_user_id)
  return _internal_ei_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CraftArtifactResponse::set_ei_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 ei_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.CraftArtifactResponse.ei_user_id)
}
inline std::string* CraftArtifactResponse::mutable_ei_user_id() {
  std::string* _s = _internal_mutable_ei_user_id();
  // @@protoc_insertion_point(field_mutable:ei.CraftArtifactResponse.ei_user_id)
  return _s;
}
inline const std::string& CraftArtifactResponse::_internal_ei_user_id() const {
  return ei_user_id_.Get();
}
inline void CraftArtifactResponse::_internal_set_ei_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  ei_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CraftArtifactResponse::_internal_mutable_ei_user_id() {
  _has_bits_[0] |= 0x00000002u;
  return ei_user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CraftArtifactResponse::release_ei_user_id() {
  // @@protoc_insertion_point(field_release:ei.CraftArtifactResponse.ei_user_id)
  if (!_internal_has_ei_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = ei_user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ei_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ei_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CraftArtifactResponse::set_allocated_ei_user_id(std::string* ei_user_id) {
  if (ei_user_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ei_user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ei_user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ei_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ei_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.CraftArtifactResponse.ei_user_id)
}

// optional .ei.ArtifactSpec.Rarity rarity_achieved = 2 [default = COMMON];
inline bool CraftArtifactResponse::_internal_has_rarity_achieved() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CraftArtifactResponse::has_rarity_achieved() const {
  return _internal_has_rarity_achieved();
}
inline void CraftArtifactResponse::clear_rarity_achieved() {
  rarity_achieved_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::ei::ArtifactSpec_Rarity CraftArtifactResponse::_internal_rarity_achieved() const {
  return static_cast< ::ei::ArtifactSpec_Rarity >(rarity_achieved_);
}
inline ::ei::ArtifactSpec_Rarity CraftArtifactResponse::rarity_achieved() const {
  // @@protoc_insertion_point(field_get:ei.CraftArtifactResponse.rarity_achieved)
  return _internal_rarity_achieved();
}
inline void CraftArtifactResponse::_internal_set_rarity_achieved(::ei::ArtifactSpec_Rarity value) {
  assert(::ei::ArtifactSpec_Rarity_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  rarity_achieved_ = value;
}
inline void CraftArtifactResponse::set_rarity_achieved(::ei::ArtifactSpec_Rarity value) {
  _internal_set_rarity_achieved(value);
  // @@protoc_insertion_point(field_set:ei.CraftArtifactResponse.rarity_achieved)
}

// optional string server_id = 3;
inline bool CraftArtifactResponse::_internal_has_server_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CraftArtifactResponse::has_server_id() const {
  return _internal_has_server_id();
}
inline void CraftArtifactResponse::clear_server_id() {
  server_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CraftArtifactResponse::server_id() const {
  // @@protoc_insertion_point(field_get:ei.CraftArtifactResponse.server_id)
  return _internal_server_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CraftArtifactResponse::set_server_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 server_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.CraftArtifactResponse.server_id)
}
inline std::string* CraftArtifactResponse::mutable_server_id() {
  std::string* _s = _internal_mutable_server_id();
  // @@protoc_insertion_point(field_mutable:ei.CraftArtifactResponse.server_id)
  return _s;
}
inline const std::string& CraftArtifactResponse::_internal_server_id() const {
  return server_id_.Get();
}
inline void CraftArtifactResponse::_internal_set_server_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  server_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CraftArtifactResponse::_internal_mutable_server_id() {
  _has_bits_[0] |= 0x00000001u;
  return server_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CraftArtifactResponse::release_server_id() {
  // @@protoc_insertion_point(field_release:ei.CraftArtifactResponse.server_id)
  if (!_internal_has_server_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = server_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (server_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    server_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CraftArtifactResponse::set_allocated_server_id(std::string* server_id) {
  if (server_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  server_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), server_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (server_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    server_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.CraftArtifactResponse.server_id)
}

// -------------------------------------------------------------------

// ConsumeArtifactRequest

// optional .ei.BasicRequestInfo rinfo = 4;
inline bool ConsumeArtifactRequest::_internal_has_rinfo() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || rinfo_ != nullptr);
  return value;
}
inline bool ConsumeArtifactRequest::has_rinfo() const {
  return _internal_has_rinfo();
}
inline void ConsumeArtifactRequest::clear_rinfo() {
  if (rinfo_ != nullptr) rinfo_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ei::BasicRequestInfo& ConsumeArtifactRequest::_internal_rinfo() const {
  const ::ei::BasicRequestInfo* p = rinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::BasicRequestInfo&>(
      ::ei::_BasicRequestInfo_default_instance_);
}
inline const ::ei::BasicRequestInfo& ConsumeArtifactRequest::rinfo() const {
  // @@protoc_insertion_point(field_get:ei.ConsumeArtifactRequest.rinfo)
  return _internal_rinfo();
}
inline void ConsumeArtifactRequest::unsafe_arena_set_allocated_rinfo(
    ::ei::BasicRequestInfo* rinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rinfo_);
  }
  rinfo_ = rinfo;
  if (rinfo) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.ConsumeArtifactRequest.rinfo)
}
inline ::ei::BasicRequestInfo* ConsumeArtifactRequest::release_rinfo() {
  _has_bits_[0] &= ~0x00000008u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::BasicRequestInfo* ConsumeArtifactRequest::unsafe_arena_release_rinfo() {
  // @@protoc_insertion_point(field_release:ei.ConsumeArtifactRequest.rinfo)
  _has_bits_[0] &= ~0x00000008u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
  return temp;
}
inline ::ei::BasicRequestInfo* ConsumeArtifactRequest::_internal_mutable_rinfo() {
  _has_bits_[0] |= 0x00000008u;
  if (rinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::BasicRequestInfo>(GetArenaForAllocation());
    rinfo_ = p;
  }
  return rinfo_;
}
inline ::ei::BasicRequestInfo* ConsumeArtifactRequest::mutable_rinfo() {
  ::ei::BasicRequestInfo* _msg = _internal_mutable_rinfo();
  // @@protoc_insertion_point(field_mutable:ei.ConsumeArtifactRequest.rinfo)
  return _msg;
}
inline void ConsumeArtifactRequest::set_allocated_rinfo(::ei::BasicRequestInfo* rinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rinfo_;
  }
  if (rinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::BasicRequestInfo>::GetOwningArena(rinfo);
    if (message_arena != submessage_arena) {
      rinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  rinfo_ = rinfo;
  // @@protoc_insertion_point(field_set_allocated:ei.ConsumeArtifactRequest.rinfo)
}

// optional string ei_user_id = 3;
inline bool ConsumeArtifactRequest::_internal_has_ei_user_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConsumeArtifactRequest::has_ei_user_id() const {
  return _internal_has_ei_user_id();
}
inline void ConsumeArtifactRequest::clear_ei_user_id() {
  ei_user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConsumeArtifactRequest::ei_user_id() const {
  // @@protoc_insertion_point(field_get:ei.ConsumeArtifactRequest.ei_user_id)
  return _internal_ei_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConsumeArtifactRequest::set_ei_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 ei_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ConsumeArtifactRequest.ei_user_id)
}
inline std::string* ConsumeArtifactRequest::mutable_ei_user_id() {
  std::string* _s = _internal_mutable_ei_user_id();
  // @@protoc_insertion_point(field_mutable:ei.ConsumeArtifactRequest.ei_user_id)
  return _s;
}
inline const std::string& ConsumeArtifactRequest::_internal_ei_user_id() const {
  return ei_user_id_.Get();
}
inline void ConsumeArtifactRequest::_internal_set_ei_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ei_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConsumeArtifactRequest::_internal_mutable_ei_user_id() {
  _has_bits_[0] |= 0x00000001u;
  return ei_user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConsumeArtifactRequest::release_ei_user_id() {
  // @@protoc_insertion_point(field_release:ei.ConsumeArtifactRequest.ei_user_id)
  if (!_internal_has_ei_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = ei_user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ei_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ei_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConsumeArtifactRequest::set_allocated_ei_user_id(std::string* ei_user_id) {
  if (ei_user_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ei_user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ei_user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ei_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ei_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ConsumeArtifactRequest.ei_user_id)
}

// optional .ei.ArtifactSpec spec = 1;
inline bool ConsumeArtifactRequest::_internal_has_spec() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || spec_ != nullptr);
  return value;
}
inline bool ConsumeArtifactRequest::has_spec() const {
  return _internal_has_spec();
}
inline void ConsumeArtifactRequest::clear_spec() {
  if (spec_ != nullptr) spec_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ei::ArtifactSpec& ConsumeArtifactRequest::_internal_spec() const {
  const ::ei::ArtifactSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::ArtifactSpec&>(
      ::ei::_ArtifactSpec_default_instance_);
}
inline const ::ei::ArtifactSpec& ConsumeArtifactRequest::spec() const {
  // @@protoc_insertion_point(field_get:ei.ConsumeArtifactRequest.spec)
  return _internal_spec();
}
inline void ConsumeArtifactRequest::unsafe_arena_set_allocated_spec(
    ::ei::ArtifactSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.ConsumeArtifactRequest.spec)
}
inline ::ei::ArtifactSpec* ConsumeArtifactRequest::release_spec() {
  _has_bits_[0] &= ~0x00000004u;
  ::ei::ArtifactSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::ArtifactSpec* ConsumeArtifactRequest::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:ei.ConsumeArtifactRequest.spec)
  _has_bits_[0] &= ~0x00000004u;
  ::ei::ArtifactSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::ei::ArtifactSpec* ConsumeArtifactRequest::_internal_mutable_spec() {
  _has_bits_[0] |= 0x00000004u;
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::ArtifactSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::ei::ArtifactSpec* ConsumeArtifactRequest::mutable_spec() {
  ::ei::ArtifactSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:ei.ConsumeArtifactRequest.spec)
  return _msg;
}
inline void ConsumeArtifactRequest::set_allocated_spec(::ei::ArtifactSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::ArtifactSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:ei.ConsumeArtifactRequest.spec)
}

// optional string artifact_server_id = 5;
inline bool ConsumeArtifactRequest::_internal_has_artifact_server_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConsumeArtifactRequest::has_artifact_server_id() const {
  return _internal_has_artifact_server_id();
}
inline void ConsumeArtifactRequest::clear_artifact_server_id() {
  artifact_server_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ConsumeArtifactRequest::artifact_server_id() const {
  // @@protoc_insertion_point(field_get:ei.ConsumeArtifactRequest.artifact_server_id)
  return _internal_artifact_server_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConsumeArtifactRequest::set_artifact_server_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 artifact_server_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ConsumeArtifactRequest.artifact_server_id)
}
inline std::string* ConsumeArtifactRequest::mutable_artifact_server_id() {
  std::string* _s = _internal_mutable_artifact_server_id();
  // @@protoc_insertion_point(field_mutable:ei.ConsumeArtifactRequest.artifact_server_id)
  return _s;
}
inline const std::string& ConsumeArtifactRequest::_internal_artifact_server_id() const {
  return artifact_server_id_.Get();
}
inline void ConsumeArtifactRequest::_internal_set_artifact_server_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  artifact_server_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConsumeArtifactRequest::_internal_mutable_artifact_server_id() {
  _has_bits_[0] |= 0x00000002u;
  return artifact_server_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConsumeArtifactRequest::release_artifact_server_id() {
  // @@protoc_insertion_point(field_release:ei.ConsumeArtifactRequest.artifact_server_id)
  if (!_internal_has_artifact_server_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = artifact_server_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (artifact_server_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    artifact_server_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConsumeArtifactRequest::set_allocated_artifact_server_id(std::string* artifact_server_id) {
  if (artifact_server_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  artifact_server_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), artifact_server_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (artifact_server_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    artifact_server_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ConsumeArtifactRequest.artifact_server_id)
}

// optional uint64 original_item_id = 2;
inline bool ConsumeArtifactRequest::_internal_has_original_item_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ConsumeArtifactRequest::has_original_item_id() const {
  return _internal_has_original_item_id();
}
inline void ConsumeArtifactRequest::clear_original_item_id() {
  original_item_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000010u;
}
inline uint64_t ConsumeArtifactRequest::_internal_original_item_id() const {
  return original_item_id_;
}
inline uint64_t ConsumeArtifactRequest::original_item_id() const {
  // @@protoc_insertion_point(field_get:ei.ConsumeArtifactRequest.original_item_id)
  return _internal_original_item_id();
}
inline void ConsumeArtifactRequest::_internal_set_original_item_id(uint64_t value) {
  _has_bits_[0] |= 0x00000010u;
  original_item_id_ = value;
}
inline void ConsumeArtifactRequest::set_original_item_id(uint64_t value) {
  _internal_set_original_item_id(value);
  // @@protoc_insertion_point(field_set:ei.ConsumeArtifactRequest.original_item_id)
}

// optional uint32 quantity = 6;
inline bool ConsumeArtifactRequest::_internal_has_quantity() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ConsumeArtifactRequest::has_quantity() const {
  return _internal_has_quantity();
}
inline void ConsumeArtifactRequest::clear_quantity() {
  quantity_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t ConsumeArtifactRequest::_internal_quantity() const {
  return quantity_;
}
inline uint32_t ConsumeArtifactRequest::quantity() const {
  // @@protoc_insertion_point(field_get:ei.ConsumeArtifactRequest.quantity)
  return _internal_quantity();
}
inline void ConsumeArtifactRequest::_internal_set_quantity(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  quantity_ = value;
}
inline void ConsumeArtifactRequest::set_quantity(uint32_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:ei.ConsumeArtifactRequest.quantity)
}

// -------------------------------------------------------------------

// ConsumeArtifactResponse

// optional bool success = 1;
inline bool ConsumeArtifactResponse::_internal_has_success() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConsumeArtifactResponse::has_success() const {
  return _internal_has_success();
}
inline void ConsumeArtifactResponse::clear_success() {
  success_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ConsumeArtifactResponse::_internal_success() const {
  return success_;
}
inline bool ConsumeArtifactResponse::success() const {
  // @@protoc_insertion_point(field_get:ei.ConsumeArtifactResponse.success)
  return _internal_success();
}
inline void ConsumeArtifactResponse::_internal_set_success(bool value) {
  _has_bits_[0] |= 0x00000004u;
  success_ = value;
}
inline void ConsumeArtifactResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:ei.ConsumeArtifactResponse.success)
}

// optional uint64 original_item_id = 2;
inline bool ConsumeArtifactResponse::_internal_has_original_item_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConsumeArtifactResponse::has_original_item_id() const {
  return _internal_has_original_item_id();
}
inline void ConsumeArtifactResponse::clear_original_item_id() {
  original_item_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t ConsumeArtifactResponse::_internal_original_item_id() const {
  return original_item_id_;
}
inline uint64_t ConsumeArtifactResponse::original_item_id() const {
  // @@protoc_insertion_point(field_get:ei.ConsumeArtifactResponse.original_item_id)
  return _internal_original_item_id();
}
inline void ConsumeArtifactResponse::_internal_set_original_item_id(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  original_item_id_ = value;
}
inline void ConsumeArtifactResponse::set_original_item_id(uint64_t value) {
  _internal_set_original_item_id(value);
  // @@protoc_insertion_point(field_set:ei.ConsumeArtifactResponse.original_item_id)
}

// repeated .ei.ArtifactSpec byproducts = 3;
inline int ConsumeArtifactResponse::_internal_byproducts_size() const {
  return byproducts_.size();
}
inline int ConsumeArtifactResponse::byproducts_size() const {
  return _internal_byproducts_size();
}
inline void ConsumeArtifactResponse::clear_byproducts() {
  byproducts_.Clear();
}
inline ::ei::ArtifactSpec* ConsumeArtifactResponse::mutable_byproducts(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ConsumeArtifactResponse.byproducts)
  return byproducts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactSpec >*
ConsumeArtifactResponse::mutable_byproducts() {
  // @@protoc_insertion_point(field_mutable_list:ei.ConsumeArtifactResponse.byproducts)
  return &byproducts_;
}
inline const ::ei::ArtifactSpec& ConsumeArtifactResponse::_internal_byproducts(int index) const {
  return byproducts_.Get(index);
}
inline const ::ei::ArtifactSpec& ConsumeArtifactResponse::byproducts(int index) const {
  // @@protoc_insertion_point(field_get:ei.ConsumeArtifactResponse.byproducts)
  return _internal_byproducts(index);
}
inline ::ei::ArtifactSpec* ConsumeArtifactResponse::_internal_add_byproducts() {
  return byproducts_.Add();
}
inline ::ei::ArtifactSpec* ConsumeArtifactResponse::add_byproducts() {
  ::ei::ArtifactSpec* _add = _internal_add_byproducts();
  // @@protoc_insertion_point(field_add:ei.ConsumeArtifactResponse.byproducts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactSpec >&
ConsumeArtifactResponse::byproducts() const {
  // @@protoc_insertion_point(field_list:ei.ConsumeArtifactResponse.byproducts)
  return byproducts_;
}

// repeated .ei.Reward other_rewards = 4;
inline int ConsumeArtifactResponse::_internal_other_rewards_size() const {
  return other_rewards_.size();
}
inline int ConsumeArtifactResponse::other_rewards_size() const {
  return _internal_other_rewards_size();
}
inline void ConsumeArtifactResponse::clear_other_rewards() {
  other_rewards_.Clear();
}
inline ::ei::Reward* ConsumeArtifactResponse::mutable_other_rewards(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ConsumeArtifactResponse.other_rewards)
  return other_rewards_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Reward >*
ConsumeArtifactResponse::mutable_other_rewards() {
  // @@protoc_insertion_point(field_mutable_list:ei.ConsumeArtifactResponse.other_rewards)
  return &other_rewards_;
}
inline const ::ei::Reward& ConsumeArtifactResponse::_internal_other_rewards(int index) const {
  return other_rewards_.Get(index);
}
inline const ::ei::Reward& ConsumeArtifactResponse::other_rewards(int index) const {
  // @@protoc_insertion_point(field_get:ei.ConsumeArtifactResponse.other_rewards)
  return _internal_other_rewards(index);
}
inline ::ei::Reward* ConsumeArtifactResponse::_internal_add_other_rewards() {
  return other_rewards_.Add();
}
inline ::ei::Reward* ConsumeArtifactResponse::add_other_rewards() {
  ::ei::Reward* _add = _internal_add_other_rewards();
  // @@protoc_insertion_point(field_add:ei.ConsumeArtifactResponse.other_rewards)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::Reward >&
ConsumeArtifactResponse::other_rewards() const {
  // @@protoc_insertion_point(field_list:ei.ConsumeArtifactResponse.other_rewards)
  return other_rewards_;
}

// optional string ei_user_id = 5;
inline bool ConsumeArtifactResponse::_internal_has_ei_user_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConsumeArtifactResponse::has_ei_user_id() const {
  return _internal_has_ei_user_id();
}
inline void ConsumeArtifactResponse::clear_ei_user_id() {
  ei_user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConsumeArtifactResponse::ei_user_id() const {
  // @@protoc_insertion_point(field_get:ei.ConsumeArtifactResponse.ei_user_id)
  return _internal_ei_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConsumeArtifactResponse::set_ei_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 ei_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ConsumeArtifactResponse.ei_user_id)
}
inline std::string* ConsumeArtifactResponse::mutable_ei_user_id() {
  std::string* _s = _internal_mutable_ei_user_id();
  // @@protoc_insertion_point(field_mutable:ei.ConsumeArtifactResponse.ei_user_id)
  return _s;
}
inline const std::string& ConsumeArtifactResponse::_internal_ei_user_id() const {
  return ei_user_id_.Get();
}
inline void ConsumeArtifactResponse::_internal_set_ei_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ei_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConsumeArtifactResponse::_internal_mutable_ei_user_id() {
  _has_bits_[0] |= 0x00000001u;
  return ei_user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConsumeArtifactResponse::release_ei_user_id() {
  // @@protoc_insertion_point(field_release:ei.ConsumeArtifactResponse.ei_user_id)
  if (!_internal_has_ei_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = ei_user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ei_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ei_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConsumeArtifactResponse::set_allocated_ei_user_id(std::string* ei_user_id) {
  if (ei_user_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ei_user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ei_user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ei_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ei_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ConsumeArtifactResponse.ei_user_id)
}

// -------------------------------------------------------------------

// AuthenticateArtifactResponse

// optional bool success = 1;
inline bool AuthenticateArtifactResponse::_internal_has_success() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AuthenticateArtifactResponse::has_success() const {
  return _internal_has_success();
}
inline void AuthenticateArtifactResponse::clear_success() {
  success_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool AuthenticateArtifactResponse::_internal_success() const {
  return success_;
}
inline bool AuthenticateArtifactResponse::success() const {
  // @@protoc_insertion_point(field_get:ei.AuthenticateArtifactResponse.success)
  return _internal_success();
}
inline void AuthenticateArtifactResponse::_internal_set_success(bool value) {
  _has_bits_[0] |= 0x00000004u;
  success_ = value;
}
inline void AuthenticateArtifactResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:ei.AuthenticateArtifactResponse.success)
}

// optional uint64 original_item_id = 2;
inline bool AuthenticateArtifactResponse::_internal_has_original_item_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AuthenticateArtifactResponse::has_original_item_id() const {
  return _internal_has_original_item_id();
}
inline void AuthenticateArtifactResponse::clear_original_item_id() {
  original_item_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t AuthenticateArtifactResponse::_internal_original_item_id() const {
  return original_item_id_;
}
inline uint64_t AuthenticateArtifactResponse::original_item_id() const {
  // @@protoc_insertion_point(field_get:ei.AuthenticateArtifactResponse.original_item_id)
  return _internal_original_item_id();
}
inline void AuthenticateArtifactResponse::_internal_set_original_item_id(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  original_item_id_ = value;
}
inline void AuthenticateArtifactResponse::set_original_item_id(uint64_t value) {
  _internal_set_original_item_id(value);
  // @@protoc_insertion_point(field_set:ei.AuthenticateArtifactResponse.original_item_id)
}

// optional bool demote = 3;
inline bool AuthenticateArtifactResponse::_internal_has_demote() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AuthenticateArtifactResponse::has_demote() const {
  return _internal_has_demote();
}
inline void AuthenticateArtifactResponse::clear_demote() {
  demote_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool AuthenticateArtifactResponse::_internal_demote() const {
  return demote_;
}
inline bool AuthenticateArtifactResponse::demote() const {
  // @@protoc_insertion_point(field_get:ei.AuthenticateArtifactResponse.demote)
  return _internal_demote();
}
inline void AuthenticateArtifactResponse::_internal_set_demote(bool value) {
  _has_bits_[0] |= 0x00000008u;
  demote_ = value;
}
inline void AuthenticateArtifactResponse::set_demote(bool value) {
  _internal_set_demote(value);
  // @@protoc_insertion_point(field_set:ei.AuthenticateArtifactResponse.demote)
}

// optional bool delete = 4;
inline bool AuthenticateArtifactResponse::_internal_has_delete_() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AuthenticateArtifactResponse::has_delete_() const {
  return _internal_has_delete_();
}
inline void AuthenticateArtifactResponse::clear_delete_() {
  delete__ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool AuthenticateArtifactResponse::_internal_delete_() const {
  return delete__;
}
inline bool AuthenticateArtifactResponse::delete_() const {
  // @@protoc_insertion_point(field_get:ei.AuthenticateArtifactResponse.delete)
  return _internal_delete_();
}
inline void AuthenticateArtifactResponse::_internal_set_delete_(bool value) {
  _has_bits_[0] |= 0x00000010u;
  delete__ = value;
}
inline void AuthenticateArtifactResponse::set_delete_(bool value) {
  _internal_set_delete_(value);
  // @@protoc_insertion_point(field_set:ei.AuthenticateArtifactResponse.delete)
}

// optional string ei_user_id = 5;
inline bool AuthenticateArtifactResponse::_internal_has_ei_user_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AuthenticateArtifactResponse::has_ei_user_id() const {
  return _internal_has_ei_user_id();
}
inline void AuthenticateArtifactResponse::clear_ei_user_id() {
  ei_user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AuthenticateArtifactResponse::ei_user_id() const {
  // @@protoc_insertion_point(field_get:ei.AuthenticateArtifactResponse.ei_user_id)
  return _internal_ei_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticateArtifactResponse::set_ei_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 ei_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AuthenticateArtifactResponse.ei_user_id)
}
inline std::string* AuthenticateArtifactResponse::mutable_ei_user_id() {
  std::string* _s = _internal_mutable_ei_user_id();
  // @@protoc_insertion_point(field_mutable:ei.AuthenticateArtifactResponse.ei_user_id)
  return _s;
}
inline const std::string& AuthenticateArtifactResponse::_internal_ei_user_id() const {
  return ei_user_id_.Get();
}
inline void AuthenticateArtifactResponse::_internal_set_ei_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ei_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AuthenticateArtifactResponse::_internal_mutable_ei_user_id() {
  _has_bits_[0] |= 0x00000001u;
  return ei_user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AuthenticateArtifactResponse::release_ei_user_id() {
  // @@protoc_insertion_point(field_release:ei.AuthenticateArtifactResponse.ei_user_id)
  if (!_internal_has_ei_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = ei_user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ei_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ei_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AuthenticateArtifactResponse::set_allocated_ei_user_id(std::string* ei_user_id) {
  if (ei_user_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ei_user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ei_user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ei_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ei_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AuthenticateArtifactResponse.ei_user_id)
}

// -------------------------------------------------------------------

// SetArtifactRequest

// optional .ei.BasicRequestInfo rinfo = 1;
inline bool SetArtifactRequest::_internal_has_rinfo() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || rinfo_ != nullptr);
  return value;
}
inline bool SetArtifactRequest::has_rinfo() const {
  return _internal_has_rinfo();
}
inline void SetArtifactRequest::clear_rinfo() {
  if (rinfo_ != nullptr) rinfo_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ei::BasicRequestInfo& SetArtifactRequest::_internal_rinfo() const {
  const ::ei::BasicRequestInfo* p = rinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::BasicRequestInfo&>(
      ::ei::_BasicRequestInfo_default_instance_);
}
inline const ::ei::BasicRequestInfo& SetArtifactRequest::rinfo() const {
  // @@protoc_insertion_point(field_get:ei.SetArtifactRequest.rinfo)
  return _internal_rinfo();
}
inline void SetArtifactRequest::unsafe_arena_set_allocated_rinfo(
    ::ei::BasicRequestInfo* rinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rinfo_);
  }
  rinfo_ = rinfo;
  if (rinfo) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.SetArtifactRequest.rinfo)
}
inline ::ei::BasicRequestInfo* SetArtifactRequest::release_rinfo() {
  _has_bits_[0] &= ~0x00000001u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::BasicRequestInfo* SetArtifactRequest::unsafe_arena_release_rinfo() {
  // @@protoc_insertion_point(field_release:ei.SetArtifactRequest.rinfo)
  _has_bits_[0] &= ~0x00000001u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
  return temp;
}
inline ::ei::BasicRequestInfo* SetArtifactRequest::_internal_mutable_rinfo() {
  _has_bits_[0] |= 0x00000001u;
  if (rinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::BasicRequestInfo>(GetArenaForAllocation());
    rinfo_ = p;
  }
  return rinfo_;
}
inline ::ei::BasicRequestInfo* SetArtifactRequest::mutable_rinfo() {
  ::ei::BasicRequestInfo* _msg = _internal_mutable_rinfo();
  // @@protoc_insertion_point(field_mutable:ei.SetArtifactRequest.rinfo)
  return _msg;
}
inline void SetArtifactRequest::set_allocated_rinfo(::ei::BasicRequestInfo* rinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rinfo_;
  }
  if (rinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::BasicRequestInfo>::GetOwningArena(rinfo);
    if (message_arena != submessage_arena) {
      rinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  rinfo_ = rinfo;
  // @@protoc_insertion_point(field_set_allocated:ei.SetArtifactRequest.rinfo)
}

// optional .ei.ArtifactInventoryItem artifact = 2;
inline bool SetArtifactRequest::_internal_has_artifact() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || artifact_ != nullptr);
  return value;
}
inline bool SetArtifactRequest::has_artifact() const {
  return _internal_has_artifact();
}
inline void SetArtifactRequest::clear_artifact() {
  if (artifact_ != nullptr) artifact_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ei::ArtifactInventoryItem& SetArtifactRequest::_internal_artifact() const {
  const ::ei::ArtifactInventoryItem* p = artifact_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::ArtifactInventoryItem&>(
      ::ei::_ArtifactInventoryItem_default_instance_);
}
inline const ::ei::ArtifactInventoryItem& SetArtifactRequest::artifact() const {
  // @@protoc_insertion_point(field_get:ei.SetArtifactRequest.artifact)
  return _internal_artifact();
}
inline void SetArtifactRequest::unsafe_arena_set_allocated_artifact(
    ::ei::ArtifactInventoryItem* artifact) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(artifact_);
  }
  artifact_ = artifact;
  if (artifact) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.SetArtifactRequest.artifact)
}
inline ::ei::ArtifactInventoryItem* SetArtifactRequest::release_artifact() {
  _has_bits_[0] &= ~0x00000002u;
  ::ei::ArtifactInventoryItem* temp = artifact_;
  artifact_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::ArtifactInventoryItem* SetArtifactRequest::unsafe_arena_release_artifact() {
  // @@protoc_insertion_point(field_release:ei.SetArtifactRequest.artifact)
  _has_bits_[0] &= ~0x00000002u;
  ::ei::ArtifactInventoryItem* temp = artifact_;
  artifact_ = nullptr;
  return temp;
}
inline ::ei::ArtifactInventoryItem* SetArtifactRequest::_internal_mutable_artifact() {
  _has_bits_[0] |= 0x00000002u;
  if (artifact_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::ArtifactInventoryItem>(GetArenaForAllocation());
    artifact_ = p;
  }
  return artifact_;
}
inline ::ei::ArtifactInventoryItem* SetArtifactRequest::mutable_artifact() {
  ::ei::ArtifactInventoryItem* _msg = _internal_mutable_artifact();
  // @@protoc_insertion_point(field_mutable:ei.SetArtifactRequest.artifact)
  return _msg;
}
inline void SetArtifactRequest::set_allocated_artifact(::ei::ArtifactInventoryItem* artifact) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete artifact_;
  }
  if (artifact) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::ArtifactInventoryItem>::GetOwningArena(artifact);
    if (message_arena != submessage_arena) {
      artifact = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, artifact, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  artifact_ = artifact;
  // @@protoc_insertion_point(field_set_allocated:ei.SetArtifactRequest.artifact)
}

// repeated .ei.ArtifactSpec stones = 3;
inline int SetArtifactRequest::_internal_stones_size() const {
  return stones_.size();
}
inline int SetArtifactRequest::stones_size() const {
  return _internal_stones_size();
}
inline void SetArtifactRequest::clear_stones() {
  stones_.Clear();
}
inline ::ei::ArtifactSpec* SetArtifactRequest::mutable_stones(int index) {
  // @@protoc_insertion_point(field_mutable:ei.SetArtifactRequest.stones)
  return stones_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactSpec >*
SetArtifactRequest::mutable_stones() {
  // @@protoc_insertion_point(field_mutable_list:ei.SetArtifactRequest.stones)
  return &stones_;
}
inline const ::ei::ArtifactSpec& SetArtifactRequest::_internal_stones(int index) const {
  return stones_.Get(index);
}
inline const ::ei::ArtifactSpec& SetArtifactRequest::stones(int index) const {
  // @@protoc_insertion_point(field_get:ei.SetArtifactRequest.stones)
  return _internal_stones(index);
}
inline ::ei::ArtifactSpec* SetArtifactRequest::_internal_add_stones() {
  return stones_.Add();
}
inline ::ei::ArtifactSpec* SetArtifactRequest::add_stones() {
  ::ei::ArtifactSpec* _add = _internal_add_stones();
  // @@protoc_insertion_point(field_add:ei.SetArtifactRequest.stones)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactSpec >&
SetArtifactRequest::stones() const {
  // @@protoc_insertion_point(field_list:ei.SetArtifactRequest.stones)
  return stones_;
}

// optional double gold_price_paid = 4;
inline bool SetArtifactRequest::_internal_has_gold_price_paid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SetArtifactRequest::has_gold_price_paid() const {
  return _internal_has_gold_price_paid();
}
inline void SetArtifactRequest::clear_gold_price_paid() {
  gold_price_paid_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double SetArtifactRequest::_internal_gold_price_paid() const {
  return gold_price_paid_;
}
inline double SetArtifactRequest::gold_price_paid() const {
  // @@protoc_insertion_point(field_get:ei.SetArtifactRequest.gold_price_paid)
  return _internal_gold_price_paid();
}
inline void SetArtifactRequest::_internal_set_gold_price_paid(double value) {
  _has_bits_[0] |= 0x00000004u;
  gold_price_paid_ = value;
}
inline void SetArtifactRequest::set_gold_price_paid(double value) {
  _internal_set_gold_price_paid(value);
  // @@protoc_insertion_point(field_set:ei.SetArtifactRequest.gold_price_paid)
}

// -------------------------------------------------------------------

// SetArtifactResponse

// optional bool success = 1;
inline bool SetArtifactResponse::_internal_has_success() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SetArtifactResponse::has_success() const {
  return _internal_has_success();
}
inline void SetArtifactResponse::clear_success() {
  success_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool SetArtifactResponse::_internal_success() const {
  return success_;
}
inline bool SetArtifactResponse::success() const {
  // @@protoc_insertion_point(field_get:ei.SetArtifactResponse.success)
  return _internal_success();
}
inline void SetArtifactResponse::_internal_set_success(bool value) {
  _has_bits_[0] |= 0x00000004u;
  success_ = value;
}
inline void SetArtifactResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:ei.SetArtifactResponse.success)
}

// optional uint64 original_item_id = 2;
inline bool SetArtifactResponse::_internal_has_original_item_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SetArtifactResponse::has_original_item_id() const {
  return _internal_has_original_item_id();
}
inline void SetArtifactResponse::clear_original_item_id() {
  original_item_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t SetArtifactResponse::_internal_original_item_id() const {
  return original_item_id_;
}
inline uint64_t SetArtifactResponse::original_item_id() const {
  // @@protoc_insertion_point(field_get:ei.SetArtifactResponse.original_item_id)
  return _internal_original_item_id();
}
inline void SetArtifactResponse::_internal_set_original_item_id(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  original_item_id_ = value;
}
inline void SetArtifactResponse::set_original_item_id(uint64_t value) {
  _internal_set_original_item_id(value);
  // @@protoc_insertion_point(field_set:ei.SetArtifactResponse.original_item_id)
}

// optional string ei_user_id = 5;
inline bool SetArtifactResponse::_internal_has_ei_user_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetArtifactResponse::has_ei_user_id() const {
  return _internal_has_ei_user_id();
}
inline void SetArtifactResponse::clear_ei_user_id() {
  ei_user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SetArtifactResponse::ei_user_id() const {
  // @@protoc_insertion_point(field_get:ei.SetArtifactResponse.ei_user_id)
  return _internal_ei_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetArtifactResponse::set_ei_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 ei_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.SetArtifactResponse.ei_user_id)
}
inline std::string* SetArtifactResponse::mutable_ei_user_id() {
  std::string* _s = _internal_mutable_ei_user_id();
  // @@protoc_insertion_point(field_mutable:ei.SetArtifactResponse.ei_user_id)
  return _s;
}
inline const std::string& SetArtifactResponse::_internal_ei_user_id() const {
  return ei_user_id_.Get();
}
inline void SetArtifactResponse::_internal_set_ei_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ei_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SetArtifactResponse::_internal_mutable_ei_user_id() {
  _has_bits_[0] |= 0x00000001u;
  return ei_user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SetArtifactResponse::release_ei_user_id() {
  // @@protoc_insertion_point(field_release:ei.SetArtifactResponse.ei_user_id)
  if (!_internal_has_ei_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = ei_user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ei_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ei_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SetArtifactResponse::set_allocated_ei_user_id(std::string* ei_user_id) {
  if (ei_user_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ei_user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ei_user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ei_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ei_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.SetArtifactResponse.ei_user_id)
}

// -------------------------------------------------------------------

// ArtifactsDB_ActiveArtifactSlot

// optional bool occupied = 1;
inline bool ArtifactsDB_ActiveArtifactSlot::_internal_has_occupied() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ArtifactsDB_ActiveArtifactSlot::has_occupied() const {
  return _internal_has_occupied();
}
inline void ArtifactsDB_ActiveArtifactSlot::clear_occupied() {
  occupied_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ArtifactsDB_ActiveArtifactSlot::_internal_occupied() const {
  return occupied_;
}
inline bool ArtifactsDB_ActiveArtifactSlot::occupied() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsDB.ActiveArtifactSlot.occupied)
  return _internal_occupied();
}
inline void ArtifactsDB_ActiveArtifactSlot::_internal_set_occupied(bool value) {
  _has_bits_[0] |= 0x00000002u;
  occupied_ = value;
}
inline void ArtifactsDB_ActiveArtifactSlot::set_occupied(bool value) {
  _internal_set_occupied(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactsDB.ActiveArtifactSlot.occupied)
}

// optional uint64 item_id = 2;
inline bool ArtifactsDB_ActiveArtifactSlot::_internal_has_item_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ArtifactsDB_ActiveArtifactSlot::has_item_id() const {
  return _internal_has_item_id();
}
inline void ArtifactsDB_ActiveArtifactSlot::clear_item_id() {
  item_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t ArtifactsDB_ActiveArtifactSlot::_internal_item_id() const {
  return item_id_;
}
inline uint64_t ArtifactsDB_ActiveArtifactSlot::item_id() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsDB.ActiveArtifactSlot.item_id)
  return _internal_item_id();
}
inline void ArtifactsDB_ActiveArtifactSlot::_internal_set_item_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  item_id_ = value;
}
inline void ArtifactsDB_ActiveArtifactSlot::set_item_id(uint64_t value) {
  _internal_set_item_id(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactsDB.ActiveArtifactSlot.item_id)
}

// -------------------------------------------------------------------

// ArtifactsDB_ActiveArtifactSet

// repeated .ei.ArtifactsDB.ActiveArtifactSlot slots = 1;
inline int ArtifactsDB_ActiveArtifactSet::_internal_slots_size() const {
  return slots_.size();
}
inline int ArtifactsDB_ActiveArtifactSet::slots_size() const {
  return _internal_slots_size();
}
inline void ArtifactsDB_ActiveArtifactSet::clear_slots() {
  slots_.Clear();
}
inline ::ei::ArtifactsDB_ActiveArtifactSlot* ArtifactsDB_ActiveArtifactSet::mutable_slots(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ArtifactsDB.ActiveArtifactSet.slots)
  return slots_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsDB_ActiveArtifactSlot >*
ArtifactsDB_ActiveArtifactSet::mutable_slots() {
  // @@protoc_insertion_point(field_mutable_list:ei.ArtifactsDB.ActiveArtifactSet.slots)
  return &slots_;
}
inline const ::ei::ArtifactsDB_ActiveArtifactSlot& ArtifactsDB_ActiveArtifactSet::_internal_slots(int index) const {
  return slots_.Get(index);
}
inline const ::ei::ArtifactsDB_ActiveArtifactSlot& ArtifactsDB_ActiveArtifactSet::slots(int index) const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsDB.ActiveArtifactSet.slots)
  return _internal_slots(index);
}
inline ::ei::ArtifactsDB_ActiveArtifactSlot* ArtifactsDB_ActiveArtifactSet::_internal_add_slots() {
  return slots_.Add();
}
inline ::ei::ArtifactsDB_ActiveArtifactSlot* ArtifactsDB_ActiveArtifactSet::add_slots() {
  ::ei::ArtifactsDB_ActiveArtifactSlot* _add = _internal_add_slots();
  // @@protoc_insertion_point(field_add:ei.ArtifactsDB.ActiveArtifactSet.slots)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsDB_ActiveArtifactSlot >&
ArtifactsDB_ActiveArtifactSet::slots() const {
  // @@protoc_insertion_point(field_list:ei.ArtifactsDB.ActiveArtifactSet.slots)
  return slots_;
}

// -------------------------------------------------------------------

// ArtifactsDB_CraftableArtifact

// optional .ei.ArtifactSpec spec = 1;
inline bool ArtifactsDB_CraftableArtifact::_internal_has_spec() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || spec_ != nullptr);
  return value;
}
inline bool ArtifactsDB_CraftableArtifact::has_spec() const {
  return _internal_has_spec();
}
inline void ArtifactsDB_CraftableArtifact::clear_spec() {
  if (spec_ != nullptr) spec_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ei::ArtifactSpec& ArtifactsDB_CraftableArtifact::_internal_spec() const {
  const ::ei::ArtifactSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::ArtifactSpec&>(
      ::ei::_ArtifactSpec_default_instance_);
}
inline const ::ei::ArtifactSpec& ArtifactsDB_CraftableArtifact::spec() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsDB.CraftableArtifact.spec)
  return _internal_spec();
}
inline void ArtifactsDB_CraftableArtifact::unsafe_arena_set_allocated_spec(
    ::ei::ArtifactSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.ArtifactsDB.CraftableArtifact.spec)
}
inline ::ei::ArtifactSpec* ArtifactsDB_CraftableArtifact::release_spec() {
  _has_bits_[0] &= ~0x00000001u;
  ::ei::ArtifactSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::ArtifactSpec* ArtifactsDB_CraftableArtifact::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:ei.ArtifactsDB.CraftableArtifact.spec)
  _has_bits_[0] &= ~0x00000001u;
  ::ei::ArtifactSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::ei::ArtifactSpec* ArtifactsDB_CraftableArtifact::_internal_mutable_spec() {
  _has_bits_[0] |= 0x00000001u;
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::ArtifactSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::ei::ArtifactSpec* ArtifactsDB_CraftableArtifact::mutable_spec() {
  ::ei::ArtifactSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:ei.ArtifactsDB.CraftableArtifact.spec)
  return _msg;
}
inline void ArtifactsDB_CraftableArtifact::set_allocated_spec(::ei::ArtifactSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::ArtifactSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:ei.ArtifactsDB.CraftableArtifact.spec)
}

// optional bool seen = 2;
inline bool ArtifactsDB_CraftableArtifact::_internal_has_seen() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ArtifactsDB_CraftableArtifact::has_seen() const {
  return _internal_has_seen();
}
inline void ArtifactsDB_CraftableArtifact::clear_seen() {
  seen_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ArtifactsDB_CraftableArtifact::_internal_seen() const {
  return seen_;
}
inline bool ArtifactsDB_CraftableArtifact::seen() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsDB.CraftableArtifact.seen)
  return _internal_seen();
}
inline void ArtifactsDB_CraftableArtifact::_internal_set_seen(bool value) {
  _has_bits_[0] |= 0x00000002u;
  seen_ = value;
}
inline void ArtifactsDB_CraftableArtifact::set_seen(bool value) {
  _internal_set_seen(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactsDB.CraftableArtifact.seen)
}

// optional uint32 count = 3;
inline bool ArtifactsDB_CraftableArtifact::_internal_has_count() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ArtifactsDB_CraftableArtifact::has_count() const {
  return _internal_has_count();
}
inline void ArtifactsDB_CraftableArtifact::clear_count() {
  count_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ArtifactsDB_CraftableArtifact::_internal_count() const {
  return count_;
}
inline uint32_t ArtifactsDB_CraftableArtifact::count() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsDB.CraftableArtifact.count)
  return _internal_count();
}
inline void ArtifactsDB_CraftableArtifact::_internal_set_count(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  count_ = value;
}
inline void ArtifactsDB_CraftableArtifact::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactsDB.CraftableArtifact.count)
}

// -------------------------------------------------------------------

// ArtifactsDB

// repeated .ei.ArtifactInventoryItem inventory_items = 1;
inline int ArtifactsDB::_internal_inventory_items_size() const {
  return inventory_items_.size();
}
inline int ArtifactsDB::inventory_items_size() const {
  return _internal_inventory_items_size();
}
inline void ArtifactsDB::clear_inventory_items() {
  inventory_items_.Clear();
}
inline ::ei::ArtifactInventoryItem* ArtifactsDB::mutable_inventory_items(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ArtifactsDB.inventory_items)
  return inventory_items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactInventoryItem >*
ArtifactsDB::mutable_inventory_items() {
  // @@protoc_insertion_point(field_mutable_list:ei.ArtifactsDB.inventory_items)
  return &inventory_items_;
}
inline const ::ei::ArtifactInventoryItem& ArtifactsDB::_internal_inventory_items(int index) const {
  return inventory_items_.Get(index);
}
inline const ::ei::ArtifactInventoryItem& ArtifactsDB::inventory_items(int index) const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsDB.inventory_items)
  return _internal_inventory_items(index);
}
inline ::ei::ArtifactInventoryItem* ArtifactsDB::_internal_add_inventory_items() {
  return inventory_items_.Add();
}
inline ::ei::ArtifactInventoryItem* ArtifactsDB::add_inventory_items() {
  ::ei::ArtifactInventoryItem* _add = _internal_add_inventory_items();
  // @@protoc_insertion_point(field_add:ei.ArtifactsDB.inventory_items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactInventoryItem >&
ArtifactsDB::inventory_items() const {
  // @@protoc_insertion_point(field_list:ei.ArtifactsDB.inventory_items)
  return inventory_items_;
}

// optional uint64 item_sequence = 2;
inline bool ArtifactsDB::_internal_has_item_sequence() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ArtifactsDB::has_item_sequence() const {
  return _internal_has_item_sequence();
}
inline void ArtifactsDB::clear_item_sequence() {
  item_sequence_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t ArtifactsDB::_internal_item_sequence() const {
  return item_sequence_;
}
inline uint64_t ArtifactsDB::item_sequence() const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsDB.item_sequence)
  return _internal_item_sequence();
}
inline void ArtifactsDB::_internal_set_item_sequence(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  item_sequence_ = value;
}
inline void ArtifactsDB::set_item_sequence(uint64_t value) {
  _internal_set_item_sequence(value);
  // @@protoc_insertion_point(field_set:ei.ArtifactsDB.item_sequence)
}

// repeated .ei.InventorySlot inventory_slots = 3;
inline int ArtifactsDB::_internal_inventory_slots_size() const {
  return inventory_slots_.size();
}
inline int ArtifactsDB::inventory_slots_size() const {
  return _internal_inventory_slots_size();
}
inline void ArtifactsDB::clear_inventory_slots() {
  inventory_slots_.Clear();
}
inline ::ei::InventorySlot* ArtifactsDB::mutable_inventory_slots(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ArtifactsDB.inventory_slots)
  return inventory_slots_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::InventorySlot >*
ArtifactsDB::mutable_inventory_slots() {
  // @@protoc_insertion_point(field_mutable_list:ei.ArtifactsDB.inventory_slots)
  return &inventory_slots_;
}
inline const ::ei::InventorySlot& ArtifactsDB::_internal_inventory_slots(int index) const {
  return inventory_slots_.Get(index);
}
inline const ::ei::InventorySlot& ArtifactsDB::inventory_slots(int index) const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsDB.inventory_slots)
  return _internal_inventory_slots(index);
}
inline ::ei::InventorySlot* ArtifactsDB::_internal_add_inventory_slots() {
  return inventory_slots_.Add();
}
inline ::ei::InventorySlot* ArtifactsDB::add_inventory_slots() {
  ::ei::InventorySlot* _add = _internal_add_inventory_slots();
  // @@protoc_insertion_point(field_add:ei.ArtifactsDB.inventory_slots)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::InventorySlot >&
ArtifactsDB::inventory_slots() const {
  // @@protoc_insertion_point(field_list:ei.ArtifactsDB.inventory_slots)
  return inventory_slots_;
}

// repeated .ei.ArtifactsDB.ActiveArtifactSlot active_artifacts = 7;
inline int ArtifactsDB::_internal_active_artifacts_size() const {
  return active_artifacts_.size();
}
inline int ArtifactsDB::active_artifacts_size() const {
  return _internal_active_artifacts_size();
}
inline void ArtifactsDB::clear_active_artifacts() {
  active_artifacts_.Clear();
}
inline ::ei::ArtifactsDB_ActiveArtifactSlot* ArtifactsDB::mutable_active_artifacts(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ArtifactsDB.active_artifacts)
  return active_artifacts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsDB_ActiveArtifactSlot >*
ArtifactsDB::mutable_active_artifacts() {
  // @@protoc_insertion_point(field_mutable_list:ei.ArtifactsDB.active_artifacts)
  return &active_artifacts_;
}
inline const ::ei::ArtifactsDB_ActiveArtifactSlot& ArtifactsDB::_internal_active_artifacts(int index) const {
  return active_artifacts_.Get(index);
}
inline const ::ei::ArtifactsDB_ActiveArtifactSlot& ArtifactsDB::active_artifacts(int index) const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsDB.active_artifacts)
  return _internal_active_artifacts(index);
}
inline ::ei::ArtifactsDB_ActiveArtifactSlot* ArtifactsDB::_internal_add_active_artifacts() {
  return active_artifacts_.Add();
}
inline ::ei::ArtifactsDB_ActiveArtifactSlot* ArtifactsDB::add_active_artifacts() {
  ::ei::ArtifactsDB_ActiveArtifactSlot* _add = _internal_add_active_artifacts();
  // @@protoc_insertion_point(field_add:ei.ArtifactsDB.active_artifacts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsDB_ActiveArtifactSlot >&
ArtifactsDB::active_artifacts() const {
  // @@protoc_insertion_point(field_list:ei.ArtifactsDB.active_artifacts)
  return active_artifacts_;
}

// repeated .ei.ArtifactsDB.ActiveArtifactSet active_artifact_sets = 11;
inline int ArtifactsDB::_internal_active_artifact_sets_size() const {
  return active_artifact_sets_.size();
}
inline int ArtifactsDB::active_artifact_sets_size() const {
  return _internal_active_artifact_sets_size();
}
inline void ArtifactsDB::clear_active_artifact_sets() {
  active_artifact_sets_.Clear();
}
inline ::ei::ArtifactsDB_ActiveArtifactSet* ArtifactsDB::mutable_active_artifact_sets(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ArtifactsDB.active_artifact_sets)
  return active_artifact_sets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsDB_ActiveArtifactSet >*
ArtifactsDB::mutable_active_artifact_sets() {
  // @@protoc_insertion_point(field_mutable_list:ei.ArtifactsDB.active_artifact_sets)
  return &active_artifact_sets_;
}
inline const ::ei::ArtifactsDB_ActiveArtifactSet& ArtifactsDB::_internal_active_artifact_sets(int index) const {
  return active_artifact_sets_.Get(index);
}
inline const ::ei::ArtifactsDB_ActiveArtifactSet& ArtifactsDB::active_artifact_sets(int index) const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsDB.active_artifact_sets)
  return _internal_active_artifact_sets(index);
}
inline ::ei::ArtifactsDB_ActiveArtifactSet* ArtifactsDB::_internal_add_active_artifact_sets() {
  return active_artifact_sets_.Add();
}
inline ::ei::ArtifactsDB_ActiveArtifactSet* ArtifactsDB::add_active_artifact_sets() {
  ::ei::ArtifactsDB_ActiveArtifactSet* _add = _internal_add_active_artifact_sets();
  // @@protoc_insertion_point(field_add:ei.ArtifactsDB.active_artifact_sets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsDB_ActiveArtifactSet >&
ArtifactsDB::active_artifact_sets() const {
  // @@protoc_insertion_point(field_list:ei.ArtifactsDB.active_artifact_sets)
  return active_artifact_sets_;
}

// repeated .ei.ArtifactSpec discovered_artifacts = 8;
inline int ArtifactsDB::_internal_discovered_artifacts_size() const {
  return discovered_artifacts_.size();
}
inline int ArtifactsDB::discovered_artifacts_size() const {
  return _internal_discovered_artifacts_size();
}
inline void ArtifactsDB::clear_discovered_artifacts() {
  discovered_artifacts_.Clear();
}
inline ::ei::ArtifactSpec* ArtifactsDB::mutable_discovered_artifacts(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ArtifactsDB.discovered_artifacts)
  return discovered_artifacts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactSpec >*
ArtifactsDB::mutable_discovered_artifacts() {
  // @@protoc_insertion_point(field_mutable_list:ei.ArtifactsDB.discovered_artifacts)
  return &discovered_artifacts_;
}
inline const ::ei::ArtifactSpec& ArtifactsDB::_internal_discovered_artifacts(int index) const {
  return discovered_artifacts_.Get(index);
}
inline const ::ei::ArtifactSpec& ArtifactsDB::discovered_artifacts(int index) const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsDB.discovered_artifacts)
  return _internal_discovered_artifacts(index);
}
inline ::ei::ArtifactSpec* ArtifactsDB::_internal_add_discovered_artifacts() {
  return discovered_artifacts_.Add();
}
inline ::ei::ArtifactSpec* ArtifactsDB::add_discovered_artifacts() {
  ::ei::ArtifactSpec* _add = _internal_add_discovered_artifacts();
  // @@protoc_insertion_point(field_add:ei.ArtifactsDB.discovered_artifacts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactSpec >&
ArtifactsDB::discovered_artifacts() const {
  // @@protoc_insertion_point(field_list:ei.ArtifactsDB.discovered_artifacts)
  return discovered_artifacts_;
}

// repeated .ei.ArtifactsDB.CraftableArtifact craftable_artifacts = 9;
inline int ArtifactsDB::_internal_craftable_artifacts_size() const {
  return craftable_artifacts_.size();
}
inline int ArtifactsDB::craftable_artifacts_size() const {
  return _internal_craftable_artifacts_size();
}
inline void ArtifactsDB::clear_craftable_artifacts() {
  craftable_artifacts_.Clear();
}
inline ::ei::ArtifactsDB_CraftableArtifact* ArtifactsDB::mutable_craftable_artifacts(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ArtifactsDB.craftable_artifacts)
  return craftable_artifacts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsDB_CraftableArtifact >*
ArtifactsDB::mutable_craftable_artifacts() {
  // @@protoc_insertion_point(field_mutable_list:ei.ArtifactsDB.craftable_artifacts)
  return &craftable_artifacts_;
}
inline const ::ei::ArtifactsDB_CraftableArtifact& ArtifactsDB::_internal_craftable_artifacts(int index) const {
  return craftable_artifacts_.Get(index);
}
inline const ::ei::ArtifactsDB_CraftableArtifact& ArtifactsDB::craftable_artifacts(int index) const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsDB.craftable_artifacts)
  return _internal_craftable_artifacts(index);
}
inline ::ei::ArtifactsDB_CraftableArtifact* ArtifactsDB::_internal_add_craftable_artifacts() {
  return craftable_artifacts_.Add();
}
inline ::ei::ArtifactsDB_CraftableArtifact* ArtifactsDB::add_craftable_artifacts() {
  ::ei::ArtifactsDB_CraftableArtifact* _add = _internal_add_craftable_artifacts();
  // @@protoc_insertion_point(field_add:ei.ArtifactsDB.craftable_artifacts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsDB_CraftableArtifact >&
ArtifactsDB::craftable_artifacts() const {
  // @@protoc_insertion_point(field_list:ei.ArtifactsDB.craftable_artifacts)
  return craftable_artifacts_;
}

// repeated .ei.ArtifactsDB.CraftableArtifact crafting_counts = 10;
inline int ArtifactsDB::_internal_crafting_counts_size() const {
  return crafting_counts_.size();
}
inline int ArtifactsDB::crafting_counts_size() const {
  return _internal_crafting_counts_size();
}
inline void ArtifactsDB::clear_crafting_counts() {
  crafting_counts_.Clear();
}
inline ::ei::ArtifactsDB_CraftableArtifact* ArtifactsDB::mutable_crafting_counts(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ArtifactsDB.crafting_counts)
  return crafting_counts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsDB_CraftableArtifact >*
ArtifactsDB::mutable_crafting_counts() {
  // @@protoc_insertion_point(field_mutable_list:ei.ArtifactsDB.crafting_counts)
  return &crafting_counts_;
}
inline const ::ei::ArtifactsDB_CraftableArtifact& ArtifactsDB::_internal_crafting_counts(int index) const {
  return crafting_counts_.Get(index);
}
inline const ::ei::ArtifactsDB_CraftableArtifact& ArtifactsDB::crafting_counts(int index) const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsDB.crafting_counts)
  return _internal_crafting_counts(index);
}
inline ::ei::ArtifactsDB_CraftableArtifact* ArtifactsDB::_internal_add_crafting_counts() {
  return crafting_counts_.Add();
}
inline ::ei::ArtifactsDB_CraftableArtifact* ArtifactsDB::add_crafting_counts() {
  ::ei::ArtifactsDB_CraftableArtifact* _add = _internal_add_crafting_counts();
  // @@protoc_insertion_point(field_add:ei.ArtifactsDB.crafting_counts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ArtifactsDB_CraftableArtifact >&
ArtifactsDB::crafting_counts() const {
  // @@protoc_insertion_point(field_list:ei.ArtifactsDB.crafting_counts)
  return crafting_counts_;
}

// repeated .ei.MissionInfo mission_infos = 4;
inline int ArtifactsDB::_internal_mission_infos_size() const {
  return mission_infos_.size();
}
inline int ArtifactsDB::mission_infos_size() const {
  return _internal_mission_infos_size();
}
inline void ArtifactsDB::clear_mission_infos() {
  mission_infos_.Clear();
}
inline ::ei::MissionInfo* ArtifactsDB::mutable_mission_infos(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ArtifactsDB.mission_infos)
  return mission_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::MissionInfo >*
ArtifactsDB::mutable_mission_infos() {
  // @@protoc_insertion_point(field_mutable_list:ei.ArtifactsDB.mission_infos)
  return &mission_infos_;
}
inline const ::ei::MissionInfo& ArtifactsDB::_internal_mission_infos(int index) const {
  return mission_infos_.Get(index);
}
inline const ::ei::MissionInfo& ArtifactsDB::mission_infos(int index) const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsDB.mission_infos)
  return _internal_mission_infos(index);
}
inline ::ei::MissionInfo* ArtifactsDB::_internal_add_mission_infos() {
  return mission_infos_.Add();
}
inline ::ei::MissionInfo* ArtifactsDB::add_mission_infos() {
  ::ei::MissionInfo* _add = _internal_add_mission_infos();
  // @@protoc_insertion_point(field_add:ei.ArtifactsDB.mission_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::MissionInfo >&
ArtifactsDB::mission_infos() const {
  // @@protoc_insertion_point(field_list:ei.ArtifactsDB.mission_infos)
  return mission_infos_;
}

// repeated .ei.MissionInfo mission_archive = 5;
inline int ArtifactsDB::_internal_mission_archive_size() const {
  return mission_archive_.size();
}
inline int ArtifactsDB::mission_archive_size() const {
  return _internal_mission_archive_size();
}
inline void ArtifactsDB::clear_mission_archive() {
  mission_archive_.Clear();
}
inline ::ei::MissionInfo* ArtifactsDB::mutable_mission_archive(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ArtifactsDB.mission_archive)
  return mission_archive_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::MissionInfo >*
ArtifactsDB::mutable_mission_archive() {
  // @@protoc_insertion_point(field_mutable_list:ei.ArtifactsDB.mission_archive)
  return &mission_archive_;
}
inline const ::ei::MissionInfo& ArtifactsDB::_internal_mission_archive(int index) const {
  return mission_archive_.Get(index);
}
inline const ::ei::MissionInfo& ArtifactsDB::mission_archive(int index) const {
  // @@protoc_insertion_point(field_get:ei.ArtifactsDB.mission_archive)
  return _internal_mission_archive(index);
}
inline ::ei::MissionInfo* ArtifactsDB::_internal_add_mission_archive() {
  return mission_archive_.Add();
}
inline ::ei::MissionInfo* ArtifactsDB::add_mission_archive() {
  ::ei::MissionInfo* _add = _internal_add_mission_archive();
  // @@protoc_insertion_point(field_add:ei.ArtifactsDB.mission_archive)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::MissionInfo >&
ArtifactsDB::mission_archive() const {
  // @@protoc_insertion_point(field_list:ei.ArtifactsDB.mission_archive)
  return mission_archive_;
}

// -------------------------------------------------------------------

// AuthenticatedMessage

// optional bytes message = 1;
inline bool AuthenticatedMessage::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AuthenticatedMessage::has_message() const {
  return _internal_has_message();
}
inline void AuthenticatedMessage::clear_message() {
  message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AuthenticatedMessage::message() const {
  // @@protoc_insertion_point(field_get:ei.AuthenticatedMessage.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticatedMessage::set_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 message_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AuthenticatedMessage.message)
}
inline std::string* AuthenticatedMessage::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:ei.AuthenticatedMessage.message)
  return _s;
}
inline const std::string& AuthenticatedMessage::_internal_message() const {
  return message_.Get();
}
inline void AuthenticatedMessage::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AuthenticatedMessage::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AuthenticatedMessage::release_message() {
  // @@protoc_insertion_point(field_release:ei.AuthenticatedMessage.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AuthenticatedMessage::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AuthenticatedMessage.message)
}

// optional uint32 version = 3;
inline bool AuthenticatedMessage::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AuthenticatedMessage::has_version() const {
  return _internal_has_version();
}
inline void AuthenticatedMessage::clear_version() {
  version_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t AuthenticatedMessage::_internal_version() const {
  return version_;
}
inline uint32_t AuthenticatedMessage::version() const {
  // @@protoc_insertion_point(field_get:ei.AuthenticatedMessage.version)
  return _internal_version();
}
inline void AuthenticatedMessage::_internal_set_version(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  version_ = value;
}
inline void AuthenticatedMessage::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:ei.AuthenticatedMessage.version)
}

// optional string code = 2;
inline bool AuthenticatedMessage::_internal_has_code() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AuthenticatedMessage::has_code() const {
  return _internal_has_code();
}
inline void AuthenticatedMessage::clear_code() {
  code_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AuthenticatedMessage::code() const {
  // @@protoc_insertion_point(field_get:ei.AuthenticatedMessage.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticatedMessage::set_code(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AuthenticatedMessage.code)
}
inline std::string* AuthenticatedMessage::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:ei.AuthenticatedMessage.code)
  return _s;
}
inline const std::string& AuthenticatedMessage::_internal_code() const {
  return code_.Get();
}
inline void AuthenticatedMessage::_internal_set_code(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AuthenticatedMessage::_internal_mutable_code() {
  _has_bits_[0] |= 0x00000002u;
  return code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AuthenticatedMessage::release_code() {
  // @@protoc_insertion_point(field_release:ei.AuthenticatedMessage.code)
  if (!_internal_has_code()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = code_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (code_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AuthenticatedMessage::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (code_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AuthenticatedMessage.code)
}

// -------------------------------------------------------------------

// LogCompleteMissionPayload

// optional .ei.MissionRequest req = 1;
inline bool LogCompleteMissionPayload::_internal_has_req() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || req_ != nullptr);
  return value;
}
inline bool LogCompleteMissionPayload::has_req() const {
  return _internal_has_req();
}
inline void LogCompleteMissionPayload::clear_req() {
  if (req_ != nullptr) req_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ei::MissionRequest& LogCompleteMissionPayload::_internal_req() const {
  const ::ei::MissionRequest* p = req_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::MissionRequest&>(
      ::ei::_MissionRequest_default_instance_);
}
inline const ::ei::MissionRequest& LogCompleteMissionPayload::req() const {
  // @@protoc_insertion_point(field_get:ei.LogCompleteMissionPayload.req)
  return _internal_req();
}
inline void LogCompleteMissionPayload::unsafe_arena_set_allocated_req(
    ::ei::MissionRequest* req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(req_);
  }
  req_ = req;
  if (req) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.LogCompleteMissionPayload.req)
}
inline ::ei::MissionRequest* LogCompleteMissionPayload::release_req() {
  _has_bits_[0] &= ~0x00000001u;
  ::ei::MissionRequest* temp = req_;
  req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::MissionRequest* LogCompleteMissionPayload::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_release:ei.LogCompleteMissionPayload.req)
  _has_bits_[0] &= ~0x00000001u;
  ::ei::MissionRequest* temp = req_;
  req_ = nullptr;
  return temp;
}
inline ::ei::MissionRequest* LogCompleteMissionPayload::_internal_mutable_req() {
  _has_bits_[0] |= 0x00000001u;
  if (req_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::MissionRequest>(GetArenaForAllocation());
    req_ = p;
  }
  return req_;
}
inline ::ei::MissionRequest* LogCompleteMissionPayload::mutable_req() {
  ::ei::MissionRequest* _msg = _internal_mutable_req();
  // @@protoc_insertion_point(field_mutable:ei.LogCompleteMissionPayload.req)
  return _msg;
}
inline void LogCompleteMissionPayload::set_allocated_req(::ei::MissionRequest* req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete req_;
  }
  if (req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::MissionRequest>::GetOwningArena(req);
    if (message_arena != submessage_arena) {
      req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:ei.LogCompleteMissionPayload.req)
}

// optional .ei.CompleteMissionResponse res = 2;
inline bool LogCompleteMissionPayload::_internal_has_res() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || res_ != nullptr);
  return value;
}
inline bool LogCompleteMissionPayload::has_res() const {
  return _internal_has_res();
}
inline void LogCompleteMissionPayload::clear_res() {
  if (res_ != nullptr) res_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ei::CompleteMissionResponse& LogCompleteMissionPayload::_internal_res() const {
  const ::ei::CompleteMissionResponse* p = res_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::CompleteMissionResponse&>(
      ::ei::_CompleteMissionResponse_default_instance_);
}
inline const ::ei::CompleteMissionResponse& LogCompleteMissionPayload::res() const {
  // @@protoc_insertion_point(field_get:ei.LogCompleteMissionPayload.res)
  return _internal_res();
}
inline void LogCompleteMissionPayload::unsafe_arena_set_allocated_res(
    ::ei::CompleteMissionResponse* res) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(res_);
  }
  res_ = res;
  if (res) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.LogCompleteMissionPayload.res)
}
inline ::ei::CompleteMissionResponse* LogCompleteMissionPayload::release_res() {
  _has_bits_[0] &= ~0x00000002u;
  ::ei::CompleteMissionResponse* temp = res_;
  res_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::CompleteMissionResponse* LogCompleteMissionPayload::unsafe_arena_release_res() {
  // @@protoc_insertion_point(field_release:ei.LogCompleteMissionPayload.res)
  _has_bits_[0] &= ~0x00000002u;
  ::ei::CompleteMissionResponse* temp = res_;
  res_ = nullptr;
  return temp;
}
inline ::ei::CompleteMissionResponse* LogCompleteMissionPayload::_internal_mutable_res() {
  _has_bits_[0] |= 0x00000002u;
  if (res_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::CompleteMissionResponse>(GetArenaForAllocation());
    res_ = p;
  }
  return res_;
}
inline ::ei::CompleteMissionResponse* LogCompleteMissionPayload::mutable_res() {
  ::ei::CompleteMissionResponse* _msg = _internal_mutable_res();
  // @@protoc_insertion_point(field_mutable:ei.LogCompleteMissionPayload.res)
  return _msg;
}
inline void LogCompleteMissionPayload::set_allocated_res(::ei::CompleteMissionResponse* res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete res_;
  }
  if (res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::CompleteMissionResponse>::GetOwningArena(res);
    if (message_arena != submessage_arena) {
      res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, res, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  res_ = res;
  // @@protoc_insertion_point(field_set_allocated:ei.LogCompleteMissionPayload.res)
}

// -------------------------------------------------------------------

// LogCraftArtifactPayload

// optional .ei.CraftArtifactRequest req = 1;
inline bool LogCraftArtifactPayload::_internal_has_req() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || req_ != nullptr);
  return value;
}
inline bool LogCraftArtifactPayload::has_req() const {
  return _internal_has_req();
}
inline void LogCraftArtifactPayload::clear_req() {
  if (req_ != nullptr) req_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ei::CraftArtifactRequest& LogCraftArtifactPayload::_internal_req() const {
  const ::ei::CraftArtifactRequest* p = req_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::CraftArtifactRequest&>(
      ::ei::_CraftArtifactRequest_default_instance_);
}
inline const ::ei::CraftArtifactRequest& LogCraftArtifactPayload::req() const {
  // @@protoc_insertion_point(field_get:ei.LogCraftArtifactPayload.req)
  return _internal_req();
}
inline void LogCraftArtifactPayload::unsafe_arena_set_allocated_req(
    ::ei::CraftArtifactRequest* req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(req_);
  }
  req_ = req;
  if (req) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.LogCraftArtifactPayload.req)
}
inline ::ei::CraftArtifactRequest* LogCraftArtifactPayload::release_req() {
  _has_bits_[0] &= ~0x00000001u;
  ::ei::CraftArtifactRequest* temp = req_;
  req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::CraftArtifactRequest* LogCraftArtifactPayload::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_release:ei.LogCraftArtifactPayload.req)
  _has_bits_[0] &= ~0x00000001u;
  ::ei::CraftArtifactRequest* temp = req_;
  req_ = nullptr;
  return temp;
}
inline ::ei::CraftArtifactRequest* LogCraftArtifactPayload::_internal_mutable_req() {
  _has_bits_[0] |= 0x00000001u;
  if (req_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::CraftArtifactRequest>(GetArenaForAllocation());
    req_ = p;
  }
  return req_;
}
inline ::ei::CraftArtifactRequest* LogCraftArtifactPayload::mutable_req() {
  ::ei::CraftArtifactRequest* _msg = _internal_mutable_req();
  // @@protoc_insertion_point(field_mutable:ei.LogCraftArtifactPayload.req)
  return _msg;
}
inline void LogCraftArtifactPayload::set_allocated_req(::ei::CraftArtifactRequest* req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete req_;
  }
  if (req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::CraftArtifactRequest>::GetOwningArena(req);
    if (message_arena != submessage_arena) {
      req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:ei.LogCraftArtifactPayload.req)
}

// optional .ei.CraftArtifactResponse res = 2;
inline bool LogCraftArtifactPayload::_internal_has_res() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || res_ != nullptr);
  return value;
}
inline bool LogCraftArtifactPayload::has_res() const {
  return _internal_has_res();
}
inline void LogCraftArtifactPayload::clear_res() {
  if (res_ != nullptr) res_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ei::CraftArtifactResponse& LogCraftArtifactPayload::_internal_res() const {
  const ::ei::CraftArtifactResponse* p = res_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::CraftArtifactResponse&>(
      ::ei::_CraftArtifactResponse_default_instance_);
}
inline const ::ei::CraftArtifactResponse& LogCraftArtifactPayload::res() const {
  // @@protoc_insertion_point(field_get:ei.LogCraftArtifactPayload.res)
  return _internal_res();
}
inline void LogCraftArtifactPayload::unsafe_arena_set_allocated_res(
    ::ei::CraftArtifactResponse* res) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(res_);
  }
  res_ = res;
  if (res) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.LogCraftArtifactPayload.res)
}
inline ::ei::CraftArtifactResponse* LogCraftArtifactPayload::release_res() {
  _has_bits_[0] &= ~0x00000002u;
  ::ei::CraftArtifactResponse* temp = res_;
  res_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::CraftArtifactResponse* LogCraftArtifactPayload::unsafe_arena_release_res() {
  // @@protoc_insertion_point(field_release:ei.LogCraftArtifactPayload.res)
  _has_bits_[0] &= ~0x00000002u;
  ::ei::CraftArtifactResponse* temp = res_;
  res_ = nullptr;
  return temp;
}
inline ::ei::CraftArtifactResponse* LogCraftArtifactPayload::_internal_mutable_res() {
  _has_bits_[0] |= 0x00000002u;
  if (res_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::CraftArtifactResponse>(GetArenaForAllocation());
    res_ = p;
  }
  return res_;
}
inline ::ei::CraftArtifactResponse* LogCraftArtifactPayload::mutable_res() {
  ::ei::CraftArtifactResponse* _msg = _internal_mutable_res();
  // @@protoc_insertion_point(field_mutable:ei.LogCraftArtifactPayload.res)
  return _msg;
}
inline void LogCraftArtifactPayload::set_allocated_res(::ei::CraftArtifactResponse* res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete res_;
  }
  if (res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::CraftArtifactResponse>::GetOwningArena(res);
    if (message_arena != submessage_arena) {
      res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, res, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  res_ = res;
  // @@protoc_insertion_point(field_set_allocated:ei.LogCraftArtifactPayload.res)
}

// -------------------------------------------------------------------

// LogConsumeArtifactPayload

// optional .ei.ConsumeArtifactRequest req = 1;
inline bool LogConsumeArtifactPayload::_internal_has_req() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || req_ != nullptr);
  return value;
}
inline bool LogConsumeArtifactPayload::has_req() const {
  return _internal_has_req();
}
inline void LogConsumeArtifactPayload::clear_req() {
  if (req_ != nullptr) req_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ei::ConsumeArtifactRequest& LogConsumeArtifactPayload::_internal_req() const {
  const ::ei::ConsumeArtifactRequest* p = req_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::ConsumeArtifactRequest&>(
      ::ei::_ConsumeArtifactRequest_default_instance_);
}
inline const ::ei::ConsumeArtifactRequest& LogConsumeArtifactPayload::req() const {
  // @@protoc_insertion_point(field_get:ei.LogConsumeArtifactPayload.req)
  return _internal_req();
}
inline void LogConsumeArtifactPayload::unsafe_arena_set_allocated_req(
    ::ei::ConsumeArtifactRequest* req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(req_);
  }
  req_ = req;
  if (req) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.LogConsumeArtifactPayload.req)
}
inline ::ei::ConsumeArtifactRequest* LogConsumeArtifactPayload::release_req() {
  _has_bits_[0] &= ~0x00000001u;
  ::ei::ConsumeArtifactRequest* temp = req_;
  req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::ConsumeArtifactRequest* LogConsumeArtifactPayload::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_release:ei.LogConsumeArtifactPayload.req)
  _has_bits_[0] &= ~0x00000001u;
  ::ei::ConsumeArtifactRequest* temp = req_;
  req_ = nullptr;
  return temp;
}
inline ::ei::ConsumeArtifactRequest* LogConsumeArtifactPayload::_internal_mutable_req() {
  _has_bits_[0] |= 0x00000001u;
  if (req_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::ConsumeArtifactRequest>(GetArenaForAllocation());
    req_ = p;
  }
  return req_;
}
inline ::ei::ConsumeArtifactRequest* LogConsumeArtifactPayload::mutable_req() {
  ::ei::ConsumeArtifactRequest* _msg = _internal_mutable_req();
  // @@protoc_insertion_point(field_mutable:ei.LogConsumeArtifactPayload.req)
  return _msg;
}
inline void LogConsumeArtifactPayload::set_allocated_req(::ei::ConsumeArtifactRequest* req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete req_;
  }
  if (req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::ConsumeArtifactRequest>::GetOwningArena(req);
    if (message_arena != submessage_arena) {
      req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:ei.LogConsumeArtifactPayload.req)
}

// optional .ei.ConsumeArtifactResponse res = 2;
inline bool LogConsumeArtifactPayload::_internal_has_res() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || res_ != nullptr);
  return value;
}
inline bool LogConsumeArtifactPayload::has_res() const {
  return _internal_has_res();
}
inline void LogConsumeArtifactPayload::clear_res() {
  if (res_ != nullptr) res_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ei::ConsumeArtifactResponse& LogConsumeArtifactPayload::_internal_res() const {
  const ::ei::ConsumeArtifactResponse* p = res_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::ConsumeArtifactResponse&>(
      ::ei::_ConsumeArtifactResponse_default_instance_);
}
inline const ::ei::ConsumeArtifactResponse& LogConsumeArtifactPayload::res() const {
  // @@protoc_insertion_point(field_get:ei.LogConsumeArtifactPayload.res)
  return _internal_res();
}
inline void LogConsumeArtifactPayload::unsafe_arena_set_allocated_res(
    ::ei::ConsumeArtifactResponse* res) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(res_);
  }
  res_ = res;
  if (res) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.LogConsumeArtifactPayload.res)
}
inline ::ei::ConsumeArtifactResponse* LogConsumeArtifactPayload::release_res() {
  _has_bits_[0] &= ~0x00000002u;
  ::ei::ConsumeArtifactResponse* temp = res_;
  res_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::ConsumeArtifactResponse* LogConsumeArtifactPayload::unsafe_arena_release_res() {
  // @@protoc_insertion_point(field_release:ei.LogConsumeArtifactPayload.res)
  _has_bits_[0] &= ~0x00000002u;
  ::ei::ConsumeArtifactResponse* temp = res_;
  res_ = nullptr;
  return temp;
}
inline ::ei::ConsumeArtifactResponse* LogConsumeArtifactPayload::_internal_mutable_res() {
  _has_bits_[0] |= 0x00000002u;
  if (res_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::ConsumeArtifactResponse>(GetArenaForAllocation());
    res_ = p;
  }
  return res_;
}
inline ::ei::ConsumeArtifactResponse* LogConsumeArtifactPayload::mutable_res() {
  ::ei::ConsumeArtifactResponse* _msg = _internal_mutable_res();
  // @@protoc_insertion_point(field_mutable:ei.LogConsumeArtifactPayload.res)
  return _msg;
}
inline void LogConsumeArtifactPayload::set_allocated_res(::ei::ConsumeArtifactResponse* res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete res_;
  }
  if (res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::ConsumeArtifactResponse>::GetOwningArena(res);
    if (message_arena != submessage_arena) {
      res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, res, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  res_ = res;
  // @@protoc_insertion_point(field_set_allocated:ei.LogConsumeArtifactPayload.res)
}

// -------------------------------------------------------------------

// LogSetArtifactPayload

// optional .ei.SetArtifactRequest req = 1;
inline bool LogSetArtifactPayload::_internal_has_req() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || req_ != nullptr);
  return value;
}
inline bool LogSetArtifactPayload::has_req() const {
  return _internal_has_req();
}
inline void LogSetArtifactPayload::clear_req() {
  if (req_ != nullptr) req_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ei::SetArtifactRequest& LogSetArtifactPayload::_internal_req() const {
  const ::ei::SetArtifactRequest* p = req_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::SetArtifactRequest&>(
      ::ei::_SetArtifactRequest_default_instance_);
}
inline const ::ei::SetArtifactRequest& LogSetArtifactPayload::req() const {
  // @@protoc_insertion_point(field_get:ei.LogSetArtifactPayload.req)
  return _internal_req();
}
inline void LogSetArtifactPayload::unsafe_arena_set_allocated_req(
    ::ei::SetArtifactRequest* req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(req_);
  }
  req_ = req;
  if (req) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.LogSetArtifactPayload.req)
}
inline ::ei::SetArtifactRequest* LogSetArtifactPayload::release_req() {
  _has_bits_[0] &= ~0x00000001u;
  ::ei::SetArtifactRequest* temp = req_;
  req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::SetArtifactRequest* LogSetArtifactPayload::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_release:ei.LogSetArtifactPayload.req)
  _has_bits_[0] &= ~0x00000001u;
  ::ei::SetArtifactRequest* temp = req_;
  req_ = nullptr;
  return temp;
}
inline ::ei::SetArtifactRequest* LogSetArtifactPayload::_internal_mutable_req() {
  _has_bits_[0] |= 0x00000001u;
  if (req_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::SetArtifactRequest>(GetArenaForAllocation());
    req_ = p;
  }
  return req_;
}
inline ::ei::SetArtifactRequest* LogSetArtifactPayload::mutable_req() {
  ::ei::SetArtifactRequest* _msg = _internal_mutable_req();
  // @@protoc_insertion_point(field_mutable:ei.LogSetArtifactPayload.req)
  return _msg;
}
inline void LogSetArtifactPayload::set_allocated_req(::ei::SetArtifactRequest* req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete req_;
  }
  if (req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::SetArtifactRequest>::GetOwningArena(req);
    if (message_arena != submessage_arena) {
      req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:ei.LogSetArtifactPayload.req)
}

// optional .ei.SetArtifactResponse res = 2;
inline bool LogSetArtifactPayload::_internal_has_res() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || res_ != nullptr);
  return value;
}
inline bool LogSetArtifactPayload::has_res() const {
  return _internal_has_res();
}
inline void LogSetArtifactPayload::clear_res() {
  if (res_ != nullptr) res_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ei::SetArtifactResponse& LogSetArtifactPayload::_internal_res() const {
  const ::ei::SetArtifactResponse* p = res_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::SetArtifactResponse&>(
      ::ei::_SetArtifactResponse_default_instance_);
}
inline const ::ei::SetArtifactResponse& LogSetArtifactPayload::res() const {
  // @@protoc_insertion_point(field_get:ei.LogSetArtifactPayload.res)
  return _internal_res();
}
inline void LogSetArtifactPayload::unsafe_arena_set_allocated_res(
    ::ei::SetArtifactResponse* res) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(res_);
  }
  res_ = res;
  if (res) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.LogSetArtifactPayload.res)
}
inline ::ei::SetArtifactResponse* LogSetArtifactPayload::release_res() {
  _has_bits_[0] &= ~0x00000002u;
  ::ei::SetArtifactResponse* temp = res_;
  res_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::SetArtifactResponse* LogSetArtifactPayload::unsafe_arena_release_res() {
  // @@protoc_insertion_point(field_release:ei.LogSetArtifactPayload.res)
  _has_bits_[0] &= ~0x00000002u;
  ::ei::SetArtifactResponse* temp = res_;
  res_ = nullptr;
  return temp;
}
inline ::ei::SetArtifactResponse* LogSetArtifactPayload::_internal_mutable_res() {
  _has_bits_[0] |= 0x00000002u;
  if (res_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::SetArtifactResponse>(GetArenaForAllocation());
    res_ = p;
  }
  return res_;
}
inline ::ei::SetArtifactResponse* LogSetArtifactPayload::mutable_res() {
  ::ei::SetArtifactResponse* _msg = _internal_mutable_res();
  // @@protoc_insertion_point(field_mutable:ei.LogSetArtifactPayload.res)
  return _msg;
}
inline void LogSetArtifactPayload::set_allocated_res(::ei::SetArtifactResponse* res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete res_;
  }
  if (res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::SetArtifactResponse>::GetOwningArena(res);
    if (message_arena != submessage_arena) {
      res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, res, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  res_ = res;
  // @@protoc_insertion_point(field_set_allocated:ei.LogSetArtifactPayload.res)
}

// -------------------------------------------------------------------

// AccountTransferPayload

// optional string from_id = 1;
inline bool AccountTransferPayload::_internal_has_from_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AccountTransferPayload::has_from_id() const {
  return _internal_has_from_id();
}
inline void AccountTransferPayload::clear_from_id() {
  from_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AccountTransferPayload::from_id() const {
  // @@protoc_insertion_point(field_get:ei.AccountTransferPayload.from_id)
  return _internal_from_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountTransferPayload::set_from_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 from_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AccountTransferPayload.from_id)
}
inline std::string* AccountTransferPayload::mutable_from_id() {
  std::string* _s = _internal_mutable_from_id();
  // @@protoc_insertion_point(field_mutable:ei.AccountTransferPayload.from_id)
  return _s;
}
inline const std::string& AccountTransferPayload::_internal_from_id() const {
  return from_id_.Get();
}
inline void AccountTransferPayload::_internal_set_from_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  from_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccountTransferPayload::_internal_mutable_from_id() {
  _has_bits_[0] |= 0x00000001u;
  return from_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccountTransferPayload::release_from_id() {
  // @@protoc_insertion_point(field_release:ei.AccountTransferPayload.from_id)
  if (!_internal_has_from_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = from_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    from_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AccountTransferPayload::set_allocated_from_id(std::string* from_id) {
  if (from_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  from_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    from_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AccountTransferPayload.from_id)
}

// optional string to_ei_user_id = 2;
inline bool AccountTransferPayload::_internal_has_to_ei_user_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AccountTransferPayload::has_to_ei_user_id() const {
  return _internal_has_to_ei_user_id();
}
inline void AccountTransferPayload::clear_to_ei_user_id() {
  to_ei_user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AccountTransferPayload::to_ei_user_id() const {
  // @@protoc_insertion_point(field_get:ei.AccountTransferPayload.to_ei_user_id)
  return _internal_to_ei_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountTransferPayload::set_to_ei_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 to_ei_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.AccountTransferPayload.to_ei_user_id)
}
inline std::string* AccountTransferPayload::mutable_to_ei_user_id() {
  std::string* _s = _internal_mutable_to_ei_user_id();
  // @@protoc_insertion_point(field_mutable:ei.AccountTransferPayload.to_ei_user_id)
  return _s;
}
inline const std::string& AccountTransferPayload::_internal_to_ei_user_id() const {
  return to_ei_user_id_.Get();
}
inline void AccountTransferPayload::_internal_set_to_ei_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  to_ei_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccountTransferPayload::_internal_mutable_to_ei_user_id() {
  _has_bits_[0] |= 0x00000002u;
  return to_ei_user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccountTransferPayload::release_to_ei_user_id() {
  // @@protoc_insertion_point(field_release:ei.AccountTransferPayload.to_ei_user_id)
  if (!_internal_has_to_ei_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = to_ei_user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (to_ei_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    to_ei_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AccountTransferPayload::set_allocated_to_ei_user_id(std::string* to_ei_user_id) {
  if (to_ei_user_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  to_ei_user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), to_ei_user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (to_ei_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    to_ei_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.AccountTransferPayload.to_ei_user_id)
}

// -------------------------------------------------------------------

// SaveBackupResponse

// optional bool success = 1;
inline bool SaveBackupResponse::_internal_has_success() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SaveBackupResponse::has_success() const {
  return _internal_has_success();
}
inline void SaveBackupResponse::clear_success() {
  success_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool SaveBackupResponse::_internal_success() const {
  return success_;
}
inline bool SaveBackupResponse::success() const {
  // @@protoc_insertion_point(field_get:ei.SaveBackupResponse.success)
  return _internal_success();
}
inline void SaveBackupResponse::_internal_set_success(bool value) {
  _has_bits_[0] |= 0x00000004u;
  success_ = value;
}
inline void SaveBackupResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:ei.SaveBackupResponse.success)
}

// optional uint32 error_code = 2;
inline bool SaveBackupResponse::_internal_has_error_code() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SaveBackupResponse::has_error_code() const {
  return _internal_has_error_code();
}
inline void SaveBackupResponse::clear_error_code() {
  error_code_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t SaveBackupResponse::_internal_error_code() const {
  return error_code_;
}
inline uint32_t SaveBackupResponse::error_code() const {
  // @@protoc_insertion_point(field_get:ei.SaveBackupResponse.error_code)
  return _internal_error_code();
}
inline void SaveBackupResponse::_internal_set_error_code(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  error_code_ = value;
}
inline void SaveBackupResponse::set_error_code(uint32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:ei.SaveBackupResponse.error_code)
}

// optional string message = 3;
inline bool SaveBackupResponse::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SaveBackupResponse::has_message() const {
  return _internal_has_message();
}
inline void SaveBackupResponse::clear_message() {
  message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SaveBackupResponse::message() const {
  // @@protoc_insertion_point(field_get:ei.SaveBackupResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SaveBackupResponse::set_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.SaveBackupResponse.message)
}
inline std::string* SaveBackupResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:ei.SaveBackupResponse.message)
  return _s;
}
inline const std::string& SaveBackupResponse::_internal_message() const {
  return message_.Get();
}
inline void SaveBackupResponse::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SaveBackupResponse::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SaveBackupResponse::release_message() {
  // @@protoc_insertion_point(field_release:ei.SaveBackupResponse.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SaveBackupResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.SaveBackupResponse.message)
}

// optional .ei.Backup existing_backup = 4;
inline bool SaveBackupResponse::_internal_has_existing_backup() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || existing_backup_ != nullptr);
  return value;
}
inline bool SaveBackupResponse::has_existing_backup() const {
  return _internal_has_existing_backup();
}
inline void SaveBackupResponse::clear_existing_backup() {
  if (existing_backup_ != nullptr) existing_backup_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ei::Backup& SaveBackupResponse::_internal_existing_backup() const {
  const ::ei::Backup* p = existing_backup_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::Backup&>(
      ::ei::_Backup_default_instance_);
}
inline const ::ei::Backup& SaveBackupResponse::existing_backup() const {
  // @@protoc_insertion_point(field_get:ei.SaveBackupResponse.existing_backup)
  return _internal_existing_backup();
}
inline void SaveBackupResponse::unsafe_arena_set_allocated_existing_backup(
    ::ei::Backup* existing_backup) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(existing_backup_);
  }
  existing_backup_ = existing_backup;
  if (existing_backup) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.SaveBackupResponse.existing_backup)
}
inline ::ei::Backup* SaveBackupResponse::release_existing_backup() {
  _has_bits_[0] &= ~0x00000002u;
  ::ei::Backup* temp = existing_backup_;
  existing_backup_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::Backup* SaveBackupResponse::unsafe_arena_release_existing_backup() {
  // @@protoc_insertion_point(field_release:ei.SaveBackupResponse.existing_backup)
  _has_bits_[0] &= ~0x00000002u;
  ::ei::Backup* temp = existing_backup_;
  existing_backup_ = nullptr;
  return temp;
}
inline ::ei::Backup* SaveBackupResponse::_internal_mutable_existing_backup() {
  _has_bits_[0] |= 0x00000002u;
  if (existing_backup_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::Backup>(GetArenaForAllocation());
    existing_backup_ = p;
  }
  return existing_backup_;
}
inline ::ei::Backup* SaveBackupResponse::mutable_existing_backup() {
  ::ei::Backup* _msg = _internal_mutable_existing_backup();
  // @@protoc_insertion_point(field_mutable:ei.SaveBackupResponse.existing_backup)
  return _msg;
}
inline void SaveBackupResponse::set_allocated_existing_backup(::ei::Backup* existing_backup) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete existing_backup_;
  }
  if (existing_backup) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::Backup>::GetOwningArena(existing_backup);
    if (message_arena != submessage_arena) {
      existing_backup = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, existing_backup, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  existing_backup_ = existing_backup;
  // @@protoc_insertion_point(field_set_allocated:ei.SaveBackupResponse.existing_backup)
}

// -------------------------------------------------------------------

// CleanAccountRequest

// optional string ei_user_id_to_keep = 1;
inline bool CleanAccountRequest::_internal_has_ei_user_id_to_keep() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CleanAccountRequest::has_ei_user_id_to_keep() const {
  return _internal_has_ei_user_id_to_keep();
}
inline void CleanAccountRequest::clear_ei_user_id_to_keep() {
  ei_user_id_to_keep_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CleanAccountRequest::ei_user_id_to_keep() const {
  // @@protoc_insertion_point(field_get:ei.CleanAccountRequest.ei_user_id_to_keep)
  return _internal_ei_user_id_to_keep();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CleanAccountRequest::set_ei_user_id_to_keep(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 ei_user_id_to_keep_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.CleanAccountRequest.ei_user_id_to_keep)
}
inline std::string* CleanAccountRequest::mutable_ei_user_id_to_keep() {
  std::string* _s = _internal_mutable_ei_user_id_to_keep();
  // @@protoc_insertion_point(field_mutable:ei.CleanAccountRequest.ei_user_id_to_keep)
  return _s;
}
inline const std::string& CleanAccountRequest::_internal_ei_user_id_to_keep() const {
  return ei_user_id_to_keep_.Get();
}
inline void CleanAccountRequest::_internal_set_ei_user_id_to_keep(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ei_user_id_to_keep_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CleanAccountRequest::_internal_mutable_ei_user_id_to_keep() {
  _has_bits_[0] |= 0x00000001u;
  return ei_user_id_to_keep_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CleanAccountRequest::release_ei_user_id_to_keep() {
  // @@protoc_insertion_point(field_release:ei.CleanAccountRequest.ei_user_id_to_keep)
  if (!_internal_has_ei_user_id_to_keep()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = ei_user_id_to_keep_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ei_user_id_to_keep_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ei_user_id_to_keep_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CleanAccountRequest::set_allocated_ei_user_id_to_keep(std::string* ei_user_id_to_keep) {
  if (ei_user_id_to_keep != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ei_user_id_to_keep_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ei_user_id_to_keep,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ei_user_id_to_keep_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ei_user_id_to_keep_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.CleanAccountRequest.ei_user_id_to_keep)
}

// optional string game_services_id = 2;
inline bool CleanAccountRequest::_internal_has_game_services_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CleanAccountRequest::has_game_services_id() const {
  return _internal_has_game_services_id();
}
inline void CleanAccountRequest::clear_game_services_id() {
  game_services_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CleanAccountRequest::game_services_id() const {
  // @@protoc_insertion_point(field_get:ei.CleanAccountRequest.game_services_id)
  return _internal_game_services_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CleanAccountRequest::set_game_services_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 game_services_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.CleanAccountRequest.game_services_id)
}
inline std::string* CleanAccountRequest::mutable_game_services_id() {
  std::string* _s = _internal_mutable_game_services_id();
  // @@protoc_insertion_point(field_mutable:ei.CleanAccountRequest.game_services_id)
  return _s;
}
inline const std::string& CleanAccountRequest::_internal_game_services_id() const {
  return game_services_id_.Get();
}
inline void CleanAccountRequest::_internal_set_game_services_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  game_services_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CleanAccountRequest::_internal_mutable_game_services_id() {
  _has_bits_[0] |= 0x00000002u;
  return game_services_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CleanAccountRequest::release_game_services_id() {
  // @@protoc_insertion_point(field_release:ei.CleanAccountRequest.game_services_id)
  if (!_internal_has_game_services_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = game_services_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (game_services_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    game_services_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CleanAccountRequest::set_allocated_game_services_id(std::string* game_services_id) {
  if (game_services_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  game_services_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), game_services_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (game_services_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    game_services_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.CleanAccountRequest.game_services_id)
}

// -------------------------------------------------------------------

// ReturnEDTPayload

// optional string ei_user_id = 1;
inline bool ReturnEDTPayload::_internal_has_ei_user_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReturnEDTPayload::has_ei_user_id() const {
  return _internal_has_ei_user_id();
}
inline void ReturnEDTPayload::clear_ei_user_id() {
  ei_user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReturnEDTPayload::ei_user_id() const {
  // @@protoc_insertion_point(field_get:ei.ReturnEDTPayload.ei_user_id)
  return _internal_ei_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReturnEDTPayload::set_ei_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 ei_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ReturnEDTPayload.ei_user_id)
}
inline std::string* ReturnEDTPayload::mutable_ei_user_id() {
  std::string* _s = _internal_mutable_ei_user_id();
  // @@protoc_insertion_point(field_mutable:ei.ReturnEDTPayload.ei_user_id)
  return _s;
}
inline const std::string& ReturnEDTPayload::_internal_ei_user_id() const {
  return ei_user_id_.Get();
}
inline void ReturnEDTPayload::_internal_set_ei_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ei_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReturnEDTPayload::_internal_mutable_ei_user_id() {
  _has_bits_[0] |= 0x00000001u;
  return ei_user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReturnEDTPayload::release_ei_user_id() {
  // @@protoc_insertion_point(field_release:ei.ReturnEDTPayload.ei_user_id)
  if (!_internal_has_ei_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = ei_user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ei_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ei_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ReturnEDTPayload::set_allocated_ei_user_id(std::string* ei_user_id) {
  if (ei_user_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ei_user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ei_user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ei_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ei_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ReturnEDTPayload.ei_user_id)
}

// -------------------------------------------------------------------

// DLCItem

// optional string name = 1;
inline bool DLCItem::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DLCItem::has_name() const {
  return _internal_has_name();
}
inline void DLCItem::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DLCItem::name() const {
  // @@protoc_insertion_point(field_get:ei.DLCItem.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DLCItem::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.DLCItem.name)
}
inline std::string* DLCItem::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ei.DLCItem.name)
  return _s;
}
inline const std::string& DLCItem::_internal_name() const {
  return name_.Get();
}
inline void DLCItem::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DLCItem::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DLCItem::release_name() {
  // @@protoc_insertion_point(field_release:ei.DLCItem.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DLCItem::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.DLCItem.name)
}

// optional string directory = 2;
inline bool DLCItem::_internal_has_directory() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DLCItem::has_directory() const {
  return _internal_has_directory();
}
inline void DLCItem::clear_directory() {
  directory_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DLCItem::directory() const {
  // @@protoc_insertion_point(field_get:ei.DLCItem.directory)
  return _internal_directory();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DLCItem::set_directory(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 directory_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.DLCItem.directory)
}
inline std::string* DLCItem::mutable_directory() {
  std::string* _s = _internal_mutable_directory();
  // @@protoc_insertion_point(field_mutable:ei.DLCItem.directory)
  return _s;
}
inline const std::string& DLCItem::_internal_directory() const {
  return directory_.Get();
}
inline void DLCItem::_internal_set_directory(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  directory_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DLCItem::_internal_mutable_directory() {
  _has_bits_[0] |= 0x00000002u;
  return directory_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DLCItem::release_directory() {
  // @@protoc_insertion_point(field_release:ei.DLCItem.directory)
  if (!_internal_has_directory()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = directory_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (directory_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    directory_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DLCItem::set_allocated_directory(std::string* directory) {
  if (directory != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  directory_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), directory,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (directory_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    directory_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.DLCItem.directory)
}

// optional string ext = 3;
inline bool DLCItem::_internal_has_ext() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DLCItem::has_ext() const {
  return _internal_has_ext();
}
inline void DLCItem::clear_ext() {
  ext_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DLCItem::ext() const {
  // @@protoc_insertion_point(field_get:ei.DLCItem.ext)
  return _internal_ext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DLCItem::set_ext(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 ext_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.DLCItem.ext)
}
inline std::string* DLCItem::mutable_ext() {
  std::string* _s = _internal_mutable_ext();
  // @@protoc_insertion_point(field_mutable:ei.DLCItem.ext)
  return _s;
}
inline const std::string& DLCItem::_internal_ext() const {
  return ext_.Get();
}
inline void DLCItem::_internal_set_ext(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  ext_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DLCItem::_internal_mutable_ext() {
  _has_bits_[0] |= 0x00000004u;
  return ext_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DLCItem::release_ext() {
  // @@protoc_insertion_point(field_release:ei.DLCItem.ext)
  if (!_internal_has_ext()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = ext_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ext_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ext_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DLCItem::set_allocated_ext(std::string* ext) {
  if (ext != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  ext_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ext,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ext_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ext_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.DLCItem.ext)
}

// optional bool compressed = 6;
inline bool DLCItem::_internal_has_compressed() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DLCItem::has_compressed() const {
  return _internal_has_compressed();
}
inline void DLCItem::clear_compressed() {
  compressed_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool DLCItem::_internal_compressed() const {
  return compressed_;
}
inline bool DLCItem::compressed() const {
  // @@protoc_insertion_point(field_get:ei.DLCItem.compressed)
  return _internal_compressed();
}
inline void DLCItem::_internal_set_compressed(bool value) {
  _has_bits_[0] |= 0x00000040u;
  compressed_ = value;
}
inline void DLCItem::set_compressed(bool value) {
  _internal_set_compressed(value);
  // @@protoc_insertion_point(field_set:ei.DLCItem.compressed)
}

// optional uint64 original_size = 7;
inline bool DLCItem::_internal_has_original_size() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DLCItem::has_original_size() const {
  return _internal_has_original_size();
}
inline void DLCItem::clear_original_size() {
  original_size_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000020u;
}
inline uint64_t DLCItem::_internal_original_size() const {
  return original_size_;
}
inline uint64_t DLCItem::original_size() const {
  // @@protoc_insertion_point(field_get:ei.DLCItem.original_size)
  return _internal_original_size();
}
inline void DLCItem::_internal_set_original_size(uint64_t value) {
  _has_bits_[0] |= 0x00000020u;
  original_size_ = value;
}
inline void DLCItem::set_original_size(uint64_t value) {
  _internal_set_original_size(value);
  // @@protoc_insertion_point(field_set:ei.DLCItem.original_size)
}

// optional string url = 4;
inline bool DLCItem::_internal_has_url() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DLCItem::has_url() const {
  return _internal_has_url();
}
inline void DLCItem::clear_url() {
  url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DLCItem::url() const {
  // @@protoc_insertion_point(field_get:ei.DLCItem.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DLCItem::set_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.DLCItem.url)
}
inline std::string* DLCItem::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:ei.DLCItem.url)
  return _s;
}
inline const std::string& DLCItem::_internal_url() const {
  return url_.Get();
}
inline void DLCItem::_internal_set_url(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DLCItem::_internal_mutable_url() {
  _has_bits_[0] |= 0x00000008u;
  return url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DLCItem::release_url() {
  // @@protoc_insertion_point(field_release:ei.DLCItem.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DLCItem::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.DLCItem.url)
}

// optional string checksum = 5;
inline bool DLCItem::_internal_has_checksum() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DLCItem::has_checksum() const {
  return _internal_has_checksum();
}
inline void DLCItem::clear_checksum() {
  checksum_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& DLCItem::checksum() const {
  // @@protoc_insertion_point(field_get:ei.DLCItem.checksum)
  return _internal_checksum();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DLCItem::set_checksum(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 checksum_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.DLCItem.checksum)
}
inline std::string* DLCItem::mutable_checksum() {
  std::string* _s = _internal_mutable_checksum();
  // @@protoc_insertion_point(field_mutable:ei.DLCItem.checksum)
  return _s;
}
inline const std::string& DLCItem::_internal_checksum() const {
  return checksum_.Get();
}
inline void DLCItem::_internal_set_checksum(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  checksum_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DLCItem::_internal_mutable_checksum() {
  _has_bits_[0] |= 0x00000010u;
  return checksum_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DLCItem::release_checksum() {
  // @@protoc_insertion_point(field_release:ei.DLCItem.checksum)
  if (!_internal_has_checksum()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = checksum_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (checksum_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    checksum_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DLCItem::set_allocated_checksum(std::string* checksum) {
  if (checksum != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  checksum_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), checksum,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (checksum_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    checksum_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.DLCItem.checksum)
}

// -------------------------------------------------------------------

// ShellSpec_ShellPiece

// optional .ei.ShellSpec.AssetType asset_type = 1;
inline bool ShellSpec_ShellPiece::_internal_has_asset_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShellSpec_ShellPiece::has_asset_type() const {
  return _internal_has_asset_type();
}
inline void ShellSpec_ShellPiece::clear_asset_type() {
  asset_type_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::ei::ShellSpec_AssetType ShellSpec_ShellPiece::_internal_asset_type() const {
  return static_cast< ::ei::ShellSpec_AssetType >(asset_type_);
}
inline ::ei::ShellSpec_AssetType ShellSpec_ShellPiece::asset_type() const {
  // @@protoc_insertion_point(field_get:ei.ShellSpec.ShellPiece.asset_type)
  return _internal_asset_type();
}
inline void ShellSpec_ShellPiece::_internal_set_asset_type(::ei::ShellSpec_AssetType value) {
  assert(::ei::ShellSpec_AssetType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  asset_type_ = value;
}
inline void ShellSpec_ShellPiece::set_asset_type(::ei::ShellSpec_AssetType value) {
  _internal_set_asset_type(value);
  // @@protoc_insertion_point(field_set:ei.ShellSpec.ShellPiece.asset_type)
}

// optional .ei.DLCItem dlc = 2;
inline bool ShellSpec_ShellPiece::_internal_has_dlc() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || dlc_ != nullptr);
  return value;
}
inline bool ShellSpec_ShellPiece::has_dlc() const {
  return _internal_has_dlc();
}
inline void ShellSpec_ShellPiece::clear_dlc() {
  if (dlc_ != nullptr) dlc_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ei::DLCItem& ShellSpec_ShellPiece::_internal_dlc() const {
  const ::ei::DLCItem* p = dlc_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::DLCItem&>(
      ::ei::_DLCItem_default_instance_);
}
inline const ::ei::DLCItem& ShellSpec_ShellPiece::dlc() const {
  // @@protoc_insertion_point(field_get:ei.ShellSpec.ShellPiece.dlc)
  return _internal_dlc();
}
inline void ShellSpec_ShellPiece::unsafe_arena_set_allocated_dlc(
    ::ei::DLCItem* dlc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dlc_);
  }
  dlc_ = dlc;
  if (dlc) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.ShellSpec.ShellPiece.dlc)
}
inline ::ei::DLCItem* ShellSpec_ShellPiece::release_dlc() {
  _has_bits_[0] &= ~0x00000001u;
  ::ei::DLCItem* temp = dlc_;
  dlc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::DLCItem* ShellSpec_ShellPiece::unsafe_arena_release_dlc() {
  // @@protoc_insertion_point(field_release:ei.ShellSpec.ShellPiece.dlc)
  _has_bits_[0] &= ~0x00000001u;
  ::ei::DLCItem* temp = dlc_;
  dlc_ = nullptr;
  return temp;
}
inline ::ei::DLCItem* ShellSpec_ShellPiece::_internal_mutable_dlc() {
  _has_bits_[0] |= 0x00000001u;
  if (dlc_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::DLCItem>(GetArenaForAllocation());
    dlc_ = p;
  }
  return dlc_;
}
inline ::ei::DLCItem* ShellSpec_ShellPiece::mutable_dlc() {
  ::ei::DLCItem* _msg = _internal_mutable_dlc();
  // @@protoc_insertion_point(field_mutable:ei.ShellSpec.ShellPiece.dlc)
  return _msg;
}
inline void ShellSpec_ShellPiece::set_allocated_dlc(::ei::DLCItem* dlc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dlc_;
  }
  if (dlc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::DLCItem>::GetOwningArena(dlc);
    if (message_arena != submessage_arena) {
      dlc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dlc, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  dlc_ = dlc;
  // @@protoc_insertion_point(field_set_allocated:ei.ShellSpec.ShellPiece.dlc)
}

// -------------------------------------------------------------------

// ShellSpec

// optional string identifier = 1;
inline bool ShellSpec::_internal_has_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShellSpec::has_identifier() const {
  return _internal_has_identifier();
}
inline void ShellSpec::clear_identifier() {
  identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ShellSpec::identifier() const {
  // @@protoc_insertion_point(field_get:ei.ShellSpec.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShellSpec::set_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ShellSpec.identifier)
}
inline std::string* ShellSpec::mutable_identifier() {
  std::string* _s = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:ei.ShellSpec.identifier)
  return _s;
}
inline const std::string& ShellSpec::_internal_identifier() const {
  return identifier_.Get();
}
inline void ShellSpec::_internal_set_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShellSpec::_internal_mutable_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShellSpec::release_identifier() {
  // @@protoc_insertion_point(field_release:ei.ShellSpec.identifier)
  if (!_internal_has_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShellSpec::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ShellSpec.identifier)
}

// optional .ei.ShellSpec.ShellPiece primary_piece = 12;
inline bool ShellSpec::_internal_has_primary_piece() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || primary_piece_ != nullptr);
  return value;
}
inline bool ShellSpec::has_primary_piece() const {
  return _internal_has_primary_piece();
}
inline void ShellSpec::clear_primary_piece() {
  if (primary_piece_ != nullptr) primary_piece_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ei::ShellSpec_ShellPiece& ShellSpec::_internal_primary_piece() const {
  const ::ei::ShellSpec_ShellPiece* p = primary_piece_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::ShellSpec_ShellPiece&>(
      ::ei::_ShellSpec_ShellPiece_default_instance_);
}
inline const ::ei::ShellSpec_ShellPiece& ShellSpec::primary_piece() const {
  // @@protoc_insertion_point(field_get:ei.ShellSpec.primary_piece)
  return _internal_primary_piece();
}
inline void ShellSpec::unsafe_arena_set_allocated_primary_piece(
    ::ei::ShellSpec_ShellPiece* primary_piece) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(primary_piece_);
  }
  primary_piece_ = primary_piece;
  if (primary_piece) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.ShellSpec.primary_piece)
}
inline ::ei::ShellSpec_ShellPiece* ShellSpec::release_primary_piece() {
  _has_bits_[0] &= ~0x00000008u;
  ::ei::ShellSpec_ShellPiece* temp = primary_piece_;
  primary_piece_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::ShellSpec_ShellPiece* ShellSpec::unsafe_arena_release_primary_piece() {
  // @@protoc_insertion_point(field_release:ei.ShellSpec.primary_piece)
  _has_bits_[0] &= ~0x00000008u;
  ::ei::ShellSpec_ShellPiece* temp = primary_piece_;
  primary_piece_ = nullptr;
  return temp;
}
inline ::ei::ShellSpec_ShellPiece* ShellSpec::_internal_mutable_primary_piece() {
  _has_bits_[0] |= 0x00000008u;
  if (primary_piece_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::ShellSpec_ShellPiece>(GetArenaForAllocation());
    primary_piece_ = p;
  }
  return primary_piece_;
}
inline ::ei::ShellSpec_ShellPiece* ShellSpec::mutable_primary_piece() {
  ::ei::ShellSpec_ShellPiece* _msg = _internal_mutable_primary_piece();
  // @@protoc_insertion_point(field_mutable:ei.ShellSpec.primary_piece)
  return _msg;
}
inline void ShellSpec::set_allocated_primary_piece(::ei::ShellSpec_ShellPiece* primary_piece) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete primary_piece_;
  }
  if (primary_piece) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::ShellSpec_ShellPiece>::GetOwningArena(primary_piece);
    if (message_arena != submessage_arena) {
      primary_piece = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, primary_piece, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  primary_piece_ = primary_piece;
  // @@protoc_insertion_point(field_set_allocated:ei.ShellSpec.primary_piece)
}

// repeated .ei.ShellSpec.ShellPiece pieces = 11;
inline int ShellSpec::_internal_pieces_size() const {
  return pieces_.size();
}
inline int ShellSpec::pieces_size() const {
  return _internal_pieces_size();
}
inline void ShellSpec::clear_pieces() {
  pieces_.Clear();
}
inline ::ei::ShellSpec_ShellPiece* ShellSpec::mutable_pieces(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ShellSpec.pieces)
  return pieces_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellSpec_ShellPiece >*
ShellSpec::mutable_pieces() {
  // @@protoc_insertion_point(field_mutable_list:ei.ShellSpec.pieces)
  return &pieces_;
}
inline const ::ei::ShellSpec_ShellPiece& ShellSpec::_internal_pieces(int index) const {
  return pieces_.Get(index);
}
inline const ::ei::ShellSpec_ShellPiece& ShellSpec::pieces(int index) const {
  // @@protoc_insertion_point(field_get:ei.ShellSpec.pieces)
  return _internal_pieces(index);
}
inline ::ei::ShellSpec_ShellPiece* ShellSpec::_internal_add_pieces() {
  return pieces_.Add();
}
inline ::ei::ShellSpec_ShellPiece* ShellSpec::add_pieces() {
  ::ei::ShellSpec_ShellPiece* _add = _internal_add_pieces();
  // @@protoc_insertion_point(field_add:ei.ShellSpec.pieces)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellSpec_ShellPiece >&
ShellSpec::pieces() const {
  // @@protoc_insertion_point(field_list:ei.ShellSpec.pieces)
  return pieces_;
}

// optional string name = 3;
inline bool ShellSpec::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShellSpec::has_name() const {
  return _internal_has_name();
}
inline void ShellSpec::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ShellSpec::name() const {
  // @@protoc_insertion_point(field_get:ei.ShellSpec.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShellSpec::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ShellSpec.name)
}
inline std::string* ShellSpec::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ei.ShellSpec.name)
  return _s;
}
inline const std::string& ShellSpec::_internal_name() const {
  return name_.Get();
}
inline void ShellSpec::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShellSpec::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000002u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShellSpec::release_name() {
  // @@protoc_insertion_point(field_release:ei.ShellSpec.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShellSpec::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ShellSpec.name)
}

// optional string set_identifier = 13;
inline bool ShellSpec::_internal_has_set_identifier() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ShellSpec::has_set_identifier() const {
  return _internal_has_set_identifier();
}
inline void ShellSpec::clear_set_identifier() {
  set_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ShellSpec::set_identifier() const {
  // @@protoc_insertion_point(field_get:ei.ShellSpec.set_identifier)
  return _internal_set_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShellSpec::set_set_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 set_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ShellSpec.set_identifier)
}
inline std::string* ShellSpec::mutable_set_identifier() {
  std::string* _s = _internal_mutable_set_identifier();
  // @@protoc_insertion_point(field_mutable:ei.ShellSpec.set_identifier)
  return _s;
}
inline const std::string& ShellSpec::_internal_set_identifier() const {
  return set_identifier_.Get();
}
inline void ShellSpec::_internal_set_set_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  set_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShellSpec::_internal_mutable_set_identifier() {
  _has_bits_[0] |= 0x00000004u;
  return set_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShellSpec::release_set_identifier() {
  // @@protoc_insertion_point(field_release:ei.ShellSpec.set_identifier)
  if (!_internal_has_set_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = set_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (set_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    set_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShellSpec::set_allocated_set_identifier(std::string* set_identifier) {
  if (set_identifier != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  set_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), set_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (set_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    set_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ShellSpec.set_identifier)
}

// optional uint32 price = 4;
inline bool ShellSpec::_internal_has_price() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ShellSpec::has_price() const {
  return _internal_has_price();
}
inline void ShellSpec::clear_price() {
  price_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t ShellSpec::_internal_price() const {
  return price_;
}
inline uint32_t ShellSpec::price() const {
  // @@protoc_insertion_point(field_get:ei.ShellSpec.price)
  return _internal_price();
}
inline void ShellSpec::_internal_set_price(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  price_ = value;
}
inline void ShellSpec::set_price(uint32_t value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:ei.ShellSpec.price)
}

// optional uint32 required_eop = 5;
inline bool ShellSpec::_internal_has_required_eop() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ShellSpec::has_required_eop() const {
  return _internal_has_required_eop();
}
inline void ShellSpec::clear_required_eop() {
  required_eop_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t ShellSpec::_internal_required_eop() const {
  return required_eop_;
}
inline uint32_t ShellSpec::required_eop() const {
  // @@protoc_insertion_point(field_get:ei.ShellSpec.required_eop)
  return _internal_required_eop();
}
inline void ShellSpec::_internal_set_required_eop(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  required_eop_ = value;
}
inline void ShellSpec::set_required_eop(uint32_t value) {
  _internal_set_required_eop(value);
  // @@protoc_insertion_point(field_set:ei.ShellSpec.required_eop)
}

// optional double required_soul_eggs = 6;
inline bool ShellSpec::_internal_has_required_soul_eggs() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ShellSpec::has_required_soul_eggs() const {
  return _internal_has_required_soul_eggs();
}
inline void ShellSpec::clear_required_soul_eggs() {
  required_soul_eggs_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double ShellSpec::_internal_required_soul_eggs() const {
  return required_soul_eggs_;
}
inline double ShellSpec::required_soul_eggs() const {
  // @@protoc_insertion_point(field_get:ei.ShellSpec.required_soul_eggs)
  return _internal_required_soul_eggs();
}
inline void ShellSpec::_internal_set_required_soul_eggs(double value) {
  _has_bits_[0] |= 0x00000040u;
  required_soul_eggs_ = value;
}
inline void ShellSpec::set_required_soul_eggs(double value) {
  _internal_set_required_soul_eggs(value);
  // @@protoc_insertion_point(field_set:ei.ShellSpec.required_soul_eggs)
}

// optional bool is_new = 14;
inline bool ShellSpec::_internal_has_is_new() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ShellSpec::has_is_new() const {
  return _internal_has_is_new();
}
inline void ShellSpec::clear_is_new() {
  is_new_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool ShellSpec::_internal_is_new() const {
  return is_new_;
}
inline bool ShellSpec::is_new() const {
  // @@protoc_insertion_point(field_get:ei.ShellSpec.is_new)
  return _internal_is_new();
}
inline void ShellSpec::_internal_set_is_new(bool value) {
  _has_bits_[0] |= 0x00000080u;
  is_new_ = value;
}
inline void ShellSpec::set_is_new(bool value) {
  _internal_set_is_new(value);
  // @@protoc_insertion_point(field_set:ei.ShellSpec.is_new)
}

// optional bool expires = 15;
inline bool ShellSpec::_internal_has_expires() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ShellSpec::has_expires() const {
  return _internal_has_expires();
}
inline void ShellSpec::clear_expires() {
  expires_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool ShellSpec::_internal_expires() const {
  return expires_;
}
inline bool ShellSpec::expires() const {
  // @@protoc_insertion_point(field_get:ei.ShellSpec.expires)
  return _internal_expires();
}
inline void ShellSpec::_internal_set_expires(bool value) {
  _has_bits_[0] |= 0x00000100u;
  expires_ = value;
}
inline void ShellSpec::set_expires(bool value) {
  _internal_set_expires(value);
  // @@protoc_insertion_point(field_set:ei.ShellSpec.expires)
}

// optional double seconds_remaining = 16;
inline bool ShellSpec::_internal_has_seconds_remaining() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ShellSpec::has_seconds_remaining() const {
  return _internal_has_seconds_remaining();
}
inline void ShellSpec::clear_seconds_remaining() {
  seconds_remaining_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline double ShellSpec::_internal_seconds_remaining() const {
  return seconds_remaining_;
}
inline double ShellSpec::seconds_remaining() const {
  // @@protoc_insertion_point(field_get:ei.ShellSpec.seconds_remaining)
  return _internal_seconds_remaining();
}
inline void ShellSpec::_internal_set_seconds_remaining(double value) {
  _has_bits_[0] |= 0x00000400u;
  seconds_remaining_ = value;
}
inline void ShellSpec::set_seconds_remaining(double value) {
  _internal_set_seconds_remaining(value);
  // @@protoc_insertion_point(field_set:ei.ShellSpec.seconds_remaining)
}

// optional bool default_appearance = 8;
inline bool ShellSpec::_internal_has_default_appearance() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ShellSpec::has_default_appearance() const {
  return _internal_has_default_appearance();
}
inline void ShellSpec::clear_default_appearance() {
  default_appearance_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool ShellSpec::_internal_default_appearance() const {
  return default_appearance_;
}
inline bool ShellSpec::default_appearance() const {
  // @@protoc_insertion_point(field_get:ei.ShellSpec.default_appearance)
  return _internal_default_appearance();
}
inline void ShellSpec::_internal_set_default_appearance(bool value) {
  _has_bits_[0] |= 0x00000200u;
  default_appearance_ = value;
}
inline void ShellSpec::set_default_appearance(bool value) {
  _internal_set_default_appearance(value);
  // @@protoc_insertion_point(field_set:ei.ShellSpec.default_appearance)
}

// -------------------------------------------------------------------

// ShellSetSpec_VariationInfo

// optional string identifier = 1;
inline bool ShellSetSpec_VariationInfo::_internal_has_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShellSetSpec_VariationInfo::has_identifier() const {
  return _internal_has_identifier();
}
inline void ShellSetSpec_VariationInfo::clear_identifier() {
  identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ShellSetSpec_VariationInfo::identifier() const {
  // @@protoc_insertion_point(field_get:ei.ShellSetSpec.VariationInfo.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShellSetSpec_VariationInfo::set_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ShellSetSpec.VariationInfo.identifier)
}
inline std::string* ShellSetSpec_VariationInfo::mutable_identifier() {
  std::string* _s = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:ei.ShellSetSpec.VariationInfo.identifier)
  return _s;
}
inline const std::string& ShellSetSpec_VariationInfo::_internal_identifier() const {
  return identifier_.Get();
}
inline void ShellSetSpec_VariationInfo::_internal_set_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShellSetSpec_VariationInfo::_internal_mutable_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShellSetSpec_VariationInfo::release_identifier() {
  // @@protoc_insertion_point(field_release:ei.ShellSetSpec.VariationInfo.identifier)
  if (!_internal_has_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShellSetSpec_VariationInfo::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ShellSetSpec.VariationInfo.identifier)
}

// optional string hex_color = 2;
inline bool ShellSetSpec_VariationInfo::_internal_has_hex_color() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShellSetSpec_VariationInfo::has_hex_color() const {
  return _internal_has_hex_color();
}
inline void ShellSetSpec_VariationInfo::clear_hex_color() {
  hex_color_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ShellSetSpec_VariationInfo::hex_color() const {
  // @@protoc_insertion_point(field_get:ei.ShellSetSpec.VariationInfo.hex_color)
  return _internal_hex_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShellSetSpec_VariationInfo::set_hex_color(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 hex_color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ShellSetSpec.VariationInfo.hex_color)
}
inline std::string* ShellSetSpec_VariationInfo::mutable_hex_color() {
  std::string* _s = _internal_mutable_hex_color();
  // @@protoc_insertion_point(field_mutable:ei.ShellSetSpec.VariationInfo.hex_color)
  return _s;
}
inline const std::string& ShellSetSpec_VariationInfo::_internal_hex_color() const {
  return hex_color_.Get();
}
inline void ShellSetSpec_VariationInfo::_internal_set_hex_color(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  hex_color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShellSetSpec_VariationInfo::_internal_mutable_hex_color() {
  _has_bits_[0] |= 0x00000002u;
  return hex_color_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShellSetSpec_VariationInfo::release_hex_color() {
  // @@protoc_insertion_point(field_release:ei.ShellSetSpec.VariationInfo.hex_color)
  if (!_internal_has_hex_color()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = hex_color_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hex_color_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hex_color_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShellSetSpec_VariationInfo::set_allocated_hex_color(std::string* hex_color) {
  if (hex_color != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  hex_color_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hex_color,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hex_color_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hex_color_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ShellSetSpec.VariationInfo.hex_color)
}

// optional uint32 price = 3;
inline bool ShellSetSpec_VariationInfo::_internal_has_price() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ShellSetSpec_VariationInfo::has_price() const {
  return _internal_has_price();
}
inline void ShellSetSpec_VariationInfo::clear_price() {
  price_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ShellSetSpec_VariationInfo::_internal_price() const {
  return price_;
}
inline uint32_t ShellSetSpec_VariationInfo::price() const {
  // @@protoc_insertion_point(field_get:ei.ShellSetSpec.VariationInfo.price)
  return _internal_price();
}
inline void ShellSetSpec_VariationInfo::_internal_set_price(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  price_ = value;
}
inline void ShellSetSpec_VariationInfo::set_price(uint32_t value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:ei.ShellSetSpec.VariationInfo.price)
}

// -------------------------------------------------------------------

// ShellSetSpec

// optional string identifier = 1;
inline bool ShellSetSpec::_internal_has_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShellSetSpec::has_identifier() const {
  return _internal_has_identifier();
}
inline void ShellSetSpec::clear_identifier() {
  identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ShellSetSpec::identifier() const {
  // @@protoc_insertion_point(field_get:ei.ShellSetSpec.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShellSetSpec::set_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ShellSetSpec.identifier)
}
inline std::string* ShellSetSpec::mutable_identifier() {
  std::string* _s = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:ei.ShellSetSpec.identifier)
  return _s;
}
inline const std::string& ShellSetSpec::_internal_identifier() const {
  return identifier_.Get();
}
inline void ShellSetSpec::_internal_set_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShellSetSpec::_internal_mutable_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShellSetSpec::release_identifier() {
  // @@protoc_insertion_point(field_release:ei.ShellSetSpec.identifier)
  if (!_internal_has_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShellSetSpec::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ShellSetSpec.identifier)
}

// optional string name = 2;
inline bool ShellSetSpec::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShellSetSpec::has_name() const {
  return _internal_has_name();
}
inline void ShellSetSpec::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ShellSetSpec::name() const {
  // @@protoc_insertion_point(field_get:ei.ShellSetSpec.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShellSetSpec::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ShellSetSpec.name)
}
inline std::string* ShellSetSpec::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ei.ShellSetSpec.name)
  return _s;
}
inline const std::string& ShellSetSpec::_internal_name() const {
  return name_.Get();
}
inline void ShellSetSpec::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShellSetSpec::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000002u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShellSetSpec::release_name() {
  // @@protoc_insertion_point(field_release:ei.ShellSetSpec.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShellSetSpec::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ShellSetSpec.name)
}

// optional uint32 price = 3;
inline bool ShellSetSpec::_internal_has_price() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ShellSetSpec::has_price() const {
  return _internal_has_price();
}
inline void ShellSetSpec::clear_price() {
  price_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t ShellSetSpec::_internal_price() const {
  return price_;
}
inline uint32_t ShellSetSpec::price() const {
  // @@protoc_insertion_point(field_get:ei.ShellSetSpec.price)
  return _internal_price();
}
inline void ShellSetSpec::_internal_set_price(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  price_ = value;
}
inline void ShellSetSpec::set_price(uint32_t value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:ei.ShellSetSpec.price)
}

// optional double price_mult_DEPRECATED = 8 [default = 1];
inline bool ShellSetSpec::_internal_has_price_mult_deprecated() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool ShellSetSpec::has_price_mult_deprecated() const {
  return _internal_has_price_mult_deprecated();
}
inline void ShellSetSpec::clear_price_mult_deprecated() {
  price_mult_deprecated_ = 1;
  _has_bits_[0] &= ~0x00008000u;
}
inline double ShellSetSpec::_internal_price_mult_deprecated() const {
  return price_mult_deprecated_;
}
inline double ShellSetSpec::price_mult_deprecated() const {
  // @@protoc_insertion_point(field_get:ei.ShellSetSpec.price_mult_DEPRECATED)
  return _internal_price_mult_deprecated();
}
inline void ShellSetSpec::_internal_set_price_mult_deprecated(double value) {
  _has_bits_[0] |= 0x00008000u;
  price_mult_deprecated_ = value;
}
inline void ShellSetSpec::set_price_mult_deprecated(double value) {
  _internal_set_price_mult_deprecated(value);
  // @@protoc_insertion_point(field_set:ei.ShellSetSpec.price_mult_DEPRECATED)
}

// optional double discount = 17;
inline bool ShellSetSpec::_internal_has_discount() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool ShellSetSpec::has_discount() const {
  return _internal_has_discount();
}
inline void ShellSetSpec::clear_discount() {
  discount_ = 0;
  _has_bits_[0] &= ~0x00004000u;
}
inline double ShellSetSpec::_internal_discount() const {
  return discount_;
}
inline double ShellSetSpec::discount() const {
  // @@protoc_insertion_point(field_get:ei.ShellSetSpec.discount)
  return _internal_discount();
}
inline void ShellSetSpec::_internal_set_discount(double value) {
  _has_bits_[0] |= 0x00004000u;
  discount_ = value;
}
inline void ShellSetSpec::set_discount(double value) {
  _internal_set_discount(value);
  // @@protoc_insertion_point(field_set:ei.ShellSetSpec.discount)
}

// optional uint32 required_eop = 4;
inline bool ShellSetSpec::_internal_has_required_eop() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ShellSetSpec::has_required_eop() const {
  return _internal_has_required_eop();
}
inline void ShellSetSpec::clear_required_eop() {
  required_eop_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t ShellSetSpec::_internal_required_eop() const {
  return required_eop_;
}
inline uint32_t ShellSetSpec::required_eop() const {
  // @@protoc_insertion_point(field_get:ei.ShellSetSpec.required_eop)
  return _internal_required_eop();
}
inline void ShellSetSpec::_internal_set_required_eop(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  required_eop_ = value;
}
inline void ShellSetSpec::set_required_eop(uint32_t value) {
  _internal_set_required_eop(value);
  // @@protoc_insertion_point(field_set:ei.ShellSetSpec.required_eop)
}

// optional double required_soul_eggs = 5;
inline bool ShellSetSpec::_internal_has_required_soul_eggs() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ShellSetSpec::has_required_soul_eggs() const {
  return _internal_has_required_soul_eggs();
}
inline void ShellSetSpec::clear_required_soul_eggs() {
  required_soul_eggs_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double ShellSetSpec::_internal_required_soul_eggs() const {
  return required_soul_eggs_;
}
inline double ShellSetSpec::required_soul_eggs() const {
  // @@protoc_insertion_point(field_get:ei.ShellSetSpec.required_soul_eggs)
  return _internal_required_soul_eggs();
}
inline void ShellSetSpec::_internal_set_required_soul_eggs(double value) {
  _has_bits_[0] |= 0x00000020u;
  required_soul_eggs_ = value;
}
inline void ShellSetSpec::set_required_soul_eggs(double value) {
  _internal_set_required_soul_eggs(value);
  // @@protoc_insertion_point(field_set:ei.ShellSetSpec.required_soul_eggs)
}

// optional bool is_new = 9;
inline bool ShellSetSpec::_internal_has_is_new() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ShellSetSpec::has_is_new() const {
  return _internal_has_is_new();
}
inline void ShellSetSpec::clear_is_new() {
  is_new_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool ShellSetSpec::_internal_is_new() const {
  return is_new_;
}
inline bool ShellSetSpec::is_new() const {
  // @@protoc_insertion_point(field_get:ei.ShellSetSpec.is_new)
  return _internal_is_new();
}
inline void ShellSetSpec::_internal_set_is_new(bool value) {
  _has_bits_[0] |= 0x00000200u;
  is_new_ = value;
}
inline void ShellSetSpec::set_is_new(bool value) {
  _internal_set_is_new(value);
  // @@protoc_insertion_point(field_set:ei.ShellSetSpec.is_new)
}

// optional bool expires = 10;
inline bool ShellSetSpec::_internal_has_expires() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ShellSetSpec::has_expires() const {
  return _internal_has_expires();
}
inline void ShellSetSpec::clear_expires() {
  expires_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool ShellSetSpec::_internal_expires() const {
  return expires_;
}
inline bool ShellSetSpec::expires() const {
  // @@protoc_insertion_point(field_get:ei.ShellSetSpec.expires)
  return _internal_expires();
}
inline void ShellSetSpec::_internal_set_expires(bool value) {
  _has_bits_[0] |= 0x00000400u;
  expires_ = value;
}
inline void ShellSetSpec::set_expires(bool value) {
  _internal_set_expires(value);
  // @@protoc_insertion_point(field_set:ei.ShellSetSpec.expires)
}

// optional double seconds_remaining = 11;
inline bool ShellSetSpec::_internal_has_seconds_remaining() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool ShellSetSpec::has_seconds_remaining() const {
  return _internal_has_seconds_remaining();
}
inline void ShellSetSpec::clear_seconds_remaining() {
  seconds_remaining_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline double ShellSetSpec::_internal_seconds_remaining() const {
  return seconds_remaining_;
}
inline double ShellSetSpec::seconds_remaining() const {
  // @@protoc_insertion_point(field_get:ei.ShellSetSpec.seconds_remaining)
  return _internal_seconds_remaining();
}
inline void ShellSetSpec::_internal_set_seconds_remaining(double value) {
  _has_bits_[0] |= 0x00002000u;
  seconds_remaining_ = value;
}
inline void ShellSetSpec::set_seconds_remaining(double value) {
  _internal_set_seconds_remaining(value);
  // @@protoc_insertion_point(field_set:ei.ShellSetSpec.seconds_remaining)
}

// optional bool decorator = 14;
inline bool ShellSetSpec::_internal_has_decorator() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool ShellSetSpec::has_decorator() const {
  return _internal_has_decorator();
}
inline void ShellSetSpec::clear_decorator() {
  decorator_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool ShellSetSpec::_internal_decorator() const {
  return decorator_;
}
inline bool ShellSetSpec::decorator() const {
  // @@protoc_insertion_point(field_get:ei.ShellSetSpec.decorator)
  return _internal_decorator();
}
inline void ShellSetSpec::_internal_set_decorator(bool value) {
  _has_bits_[0] |= 0x00000800u;
  decorator_ = value;
}
inline void ShellSetSpec::set_decorator(bool value) {
  _internal_set_decorator(value);
  // @@protoc_insertion_point(field_set:ei.ShellSetSpec.decorator)
}

// optional bool modified_geometry = 13;
inline bool ShellSetSpec::_internal_has_modified_geometry() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool ShellSetSpec::has_modified_geometry() const {
  return _internal_has_modified_geometry();
}
inline void ShellSetSpec::clear_modified_geometry() {
  modified_geometry_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool ShellSetSpec::_internal_modified_geometry() const {
  return modified_geometry_;
}
inline bool ShellSetSpec::modified_geometry() const {
  // @@protoc_insertion_point(field_get:ei.ShellSetSpec.modified_geometry)
  return _internal_modified_geometry();
}
inline void ShellSetSpec::_internal_set_modified_geometry(bool value) {
  _has_bits_[0] |= 0x00001000u;
  modified_geometry_ = value;
}
inline void ShellSetSpec::set_modified_geometry(bool value) {
  _internal_set_modified_geometry(value);
  // @@protoc_insertion_point(field_set:ei.ShellSetSpec.modified_geometry)
}

// optional bool element_set = 7;
inline bool ShellSetSpec::_internal_has_element_set() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ShellSetSpec::has_element_set() const {
  return _internal_has_element_set();
}
inline void ShellSetSpec::clear_element_set() {
  element_set_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool ShellSetSpec::_internal_element_set() const {
  return element_set_;
}
inline bool ShellSetSpec::element_set() const {
  // @@protoc_insertion_point(field_get:ei.ShellSetSpec.element_set)
  return _internal_element_set();
}
inline void ShellSetSpec::_internal_set_element_set(bool value) {
  _has_bits_[0] |= 0x00000040u;
  element_set_ = value;
}
inline void ShellSetSpec::set_element_set(bool value) {
  _internal_set_element_set(value);
  // @@protoc_insertion_point(field_set:ei.ShellSetSpec.element_set)
}

// optional string hex_base_color = 16;
inline bool ShellSetSpec::_internal_has_hex_base_color() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ShellSetSpec::has_hex_base_color() const {
  return _internal_has_hex_base_color();
}
inline void ShellSetSpec::clear_hex_base_color() {
  hex_base_color_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ShellSetSpec::hex_base_color() const {
  // @@protoc_insertion_point(field_get:ei.ShellSetSpec.hex_base_color)
  return _internal_hex_base_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShellSetSpec::set_hex_base_color(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 hex_base_color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ShellSetSpec.hex_base_color)
}
inline std::string* ShellSetSpec::mutable_hex_base_color() {
  std::string* _s = _internal_mutable_hex_base_color();
  // @@protoc_insertion_point(field_mutable:ei.ShellSetSpec.hex_base_color)
  return _s;
}
inline const std::string& ShellSetSpec::_internal_hex_base_color() const {
  return hex_base_color_.Get();
}
inline void ShellSetSpec::_internal_set_hex_base_color(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  hex_base_color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShellSetSpec::_internal_mutable_hex_base_color() {
  _has_bits_[0] |= 0x00000004u;
  return hex_base_color_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShellSetSpec::release_hex_base_color() {
  // @@protoc_insertion_point(field_release:ei.ShellSetSpec.hex_base_color)
  if (!_internal_has_hex_base_color()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = hex_base_color_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hex_base_color_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hex_base_color_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShellSetSpec::set_allocated_hex_base_color(std::string* hex_base_color) {
  if (hex_base_color != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  hex_base_color_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hex_base_color,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hex_base_color_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hex_base_color_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ShellSetSpec.hex_base_color)
}

// repeated .ei.ShellSetSpec.VariationInfo variations = 15;
inline int ShellSetSpec::_internal_variations_size() const {
  return variations_.size();
}
inline int ShellSetSpec::variations_size() const {
  return _internal_variations_size();
}
inline void ShellSetSpec::clear_variations() {
  variations_.Clear();
}
inline ::ei::ShellSetSpec_VariationInfo* ShellSetSpec::mutable_variations(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ShellSetSpec.variations)
  return variations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellSetSpec_VariationInfo >*
ShellSetSpec::mutable_variations() {
  // @@protoc_insertion_point(field_mutable_list:ei.ShellSetSpec.variations)
  return &variations_;
}
inline const ::ei::ShellSetSpec_VariationInfo& ShellSetSpec::_internal_variations(int index) const {
  return variations_.Get(index);
}
inline const ::ei::ShellSetSpec_VariationInfo& ShellSetSpec::variations(int index) const {
  // @@protoc_insertion_point(field_get:ei.ShellSetSpec.variations)
  return _internal_variations(index);
}
inline ::ei::ShellSetSpec_VariationInfo* ShellSetSpec::_internal_add_variations() {
  return variations_.Add();
}
inline ::ei::ShellSetSpec_VariationInfo* ShellSetSpec::add_variations() {
  ::ei::ShellSetSpec_VariationInfo* _add = _internal_add_variations();
  // @@protoc_insertion_point(field_add:ei.ShellSetSpec.variations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellSetSpec_VariationInfo >&
ShellSetSpec::variations() const {
  // @@protoc_insertion_point(field_list:ei.ShellSetSpec.variations)
  return variations_;
}

// optional bool default_appearance = 6;
inline bool ShellSetSpec::_internal_has_default_appearance() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ShellSetSpec::has_default_appearance() const {
  return _internal_has_default_appearance();
}
inline void ShellSetSpec::clear_default_appearance() {
  default_appearance_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool ShellSetSpec::_internal_default_appearance() const {
  return default_appearance_;
}
inline bool ShellSetSpec::default_appearance() const {
  // @@protoc_insertion_point(field_get:ei.ShellSetSpec.default_appearance)
  return _internal_default_appearance();
}
inline void ShellSetSpec::_internal_set_default_appearance(bool value) {
  _has_bits_[0] |= 0x00000080u;
  default_appearance_ = value;
}
inline void ShellSetSpec::set_default_appearance(bool value) {
  _internal_set_default_appearance(value);
  // @@protoc_insertion_point(field_set:ei.ShellSetSpec.default_appearance)
}

// optional bool custom_appearance = 12;
inline bool ShellSetSpec::_internal_has_custom_appearance() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ShellSetSpec::has_custom_appearance() const {
  return _internal_has_custom_appearance();
}
inline void ShellSetSpec::clear_custom_appearance() {
  custom_appearance_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool ShellSetSpec::_internal_custom_appearance() const {
  return custom_appearance_;
}
inline bool ShellSetSpec::custom_appearance() const {
  // @@protoc_insertion_point(field_get:ei.ShellSetSpec.custom_appearance)
  return _internal_custom_appearance();
}
inline void ShellSetSpec::_internal_set_custom_appearance(bool value) {
  _has_bits_[0] |= 0x00000100u;
  custom_appearance_ = value;
}
inline void ShellSetSpec::set_custom_appearance(bool value) {
  _internal_set_custom_appearance(value);
  // @@protoc_insertion_point(field_set:ei.ShellSetSpec.custom_appearance)
}

// -------------------------------------------------------------------

// ShellObjectSpec_LODPiece

// optional .ei.DLCItem dlc = 1;
inline bool ShellObjectSpec_LODPiece::_internal_has_dlc() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || dlc_ != nullptr);
  return value;
}
inline bool ShellObjectSpec_LODPiece::has_dlc() const {
  return _internal_has_dlc();
}
inline void ShellObjectSpec_LODPiece::clear_dlc() {
  if (dlc_ != nullptr) dlc_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ei::DLCItem& ShellObjectSpec_LODPiece::_internal_dlc() const {
  const ::ei::DLCItem* p = dlc_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::DLCItem&>(
      ::ei::_DLCItem_default_instance_);
}
inline const ::ei::DLCItem& ShellObjectSpec_LODPiece::dlc() const {
  // @@protoc_insertion_point(field_get:ei.ShellObjectSpec.LODPiece.dlc)
  return _internal_dlc();
}
inline void ShellObjectSpec_LODPiece::unsafe_arena_set_allocated_dlc(
    ::ei::DLCItem* dlc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dlc_);
  }
  dlc_ = dlc;
  if (dlc) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.ShellObjectSpec.LODPiece.dlc)
}
inline ::ei::DLCItem* ShellObjectSpec_LODPiece::release_dlc() {
  _has_bits_[0] &= ~0x00000001u;
  ::ei::DLCItem* temp = dlc_;
  dlc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::DLCItem* ShellObjectSpec_LODPiece::unsafe_arena_release_dlc() {
  // @@protoc_insertion_point(field_release:ei.ShellObjectSpec.LODPiece.dlc)
  _has_bits_[0] &= ~0x00000001u;
  ::ei::DLCItem* temp = dlc_;
  dlc_ = nullptr;
  return temp;
}
inline ::ei::DLCItem* ShellObjectSpec_LODPiece::_internal_mutable_dlc() {
  _has_bits_[0] |= 0x00000001u;
  if (dlc_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::DLCItem>(GetArenaForAllocation());
    dlc_ = p;
  }
  return dlc_;
}
inline ::ei::DLCItem* ShellObjectSpec_LODPiece::mutable_dlc() {
  ::ei::DLCItem* _msg = _internal_mutable_dlc();
  // @@protoc_insertion_point(field_mutable:ei.ShellObjectSpec.LODPiece.dlc)
  return _msg;
}
inline void ShellObjectSpec_LODPiece::set_allocated_dlc(::ei::DLCItem* dlc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dlc_;
  }
  if (dlc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::DLCItem>::GetOwningArena(dlc);
    if (message_arena != submessage_arena) {
      dlc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dlc, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  dlc_ = dlc;
  // @@protoc_insertion_point(field_set_allocated:ei.ShellObjectSpec.LODPiece.dlc)
}

// optional uint32 lod = 2;
inline bool ShellObjectSpec_LODPiece::_internal_has_lod() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShellObjectSpec_LODPiece::has_lod() const {
  return _internal_has_lod();
}
inline void ShellObjectSpec_LODPiece::clear_lod() {
  lod_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ShellObjectSpec_LODPiece::_internal_lod() const {
  return lod_;
}
inline uint32_t ShellObjectSpec_LODPiece::lod() const {
  // @@protoc_insertion_point(field_get:ei.ShellObjectSpec.LODPiece.lod)
  return _internal_lod();
}
inline void ShellObjectSpec_LODPiece::_internal_set_lod(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  lod_ = value;
}
inline void ShellObjectSpec_LODPiece::set_lod(uint32_t value) {
  _internal_set_lod(value);
  // @@protoc_insertion_point(field_set:ei.ShellObjectSpec.LODPiece.lod)
}

// -------------------------------------------------------------------

// ShellObjectSpec

// optional string identifier = 1;
inline bool ShellObjectSpec::_internal_has_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShellObjectSpec::has_identifier() const {
  return _internal_has_identifier();
}
inline void ShellObjectSpec::clear_identifier() {
  identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ShellObjectSpec::identifier() const {
  // @@protoc_insertion_point(field_get:ei.ShellObjectSpec.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShellObjectSpec::set_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ShellObjectSpec.identifier)
}
inline std::string* ShellObjectSpec::mutable_identifier() {
  std::string* _s = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:ei.ShellObjectSpec.identifier)
  return _s;
}
inline const std::string& ShellObjectSpec::_internal_identifier() const {
  return identifier_.Get();
}
inline void ShellObjectSpec::_internal_set_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShellObjectSpec::_internal_mutable_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShellObjectSpec::release_identifier() {
  // @@protoc_insertion_point(field_release:ei.ShellObjectSpec.identifier)
  if (!_internal_has_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShellObjectSpec::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ShellObjectSpec.identifier)
}

// optional string name = 2;
inline bool ShellObjectSpec::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShellObjectSpec::has_name() const {
  return _internal_has_name();
}
inline void ShellObjectSpec::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ShellObjectSpec::name() const {
  // @@protoc_insertion_point(field_get:ei.ShellObjectSpec.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShellObjectSpec::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ShellObjectSpec.name)
}
inline std::string* ShellObjectSpec::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ei.ShellObjectSpec.name)
  return _s;
}
inline const std::string& ShellObjectSpec::_internal_name() const {
  return name_.Get();
}
inline void ShellObjectSpec::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShellObjectSpec::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000002u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShellObjectSpec::release_name() {
  // @@protoc_insertion_point(field_release:ei.ShellObjectSpec.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShellObjectSpec::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ShellObjectSpec.name)
}

// optional .ei.ShellSpec.AssetType asset_type = 3;
inline bool ShellObjectSpec::_internal_has_asset_type() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool ShellObjectSpec::has_asset_type() const {
  return _internal_has_asset_type();
}
inline void ShellObjectSpec::clear_asset_type() {
  asset_type_ = 1;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::ei::ShellSpec_AssetType ShellObjectSpec::_internal_asset_type() const {
  return static_cast< ::ei::ShellSpec_AssetType >(asset_type_);
}
inline ::ei::ShellSpec_AssetType ShellObjectSpec::asset_type() const {
  // @@protoc_insertion_point(field_get:ei.ShellObjectSpec.asset_type)
  return _internal_asset_type();
}
inline void ShellObjectSpec::_internal_set_asset_type(::ei::ShellSpec_AssetType value) {
  assert(::ei::ShellSpec_AssetType_IsValid(value));
  _has_bits_[0] |= 0x00000800u;
  asset_type_ = value;
}
inline void ShellObjectSpec::set_asset_type(::ei::ShellSpec_AssetType value) {
  _internal_set_asset_type(value);
  // @@protoc_insertion_point(field_set:ei.ShellObjectSpec.asset_type)
}

// optional string object_class = 14;
inline bool ShellObjectSpec::_internal_has_object_class() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ShellObjectSpec::has_object_class() const {
  return _internal_has_object_class();
}
inline void ShellObjectSpec::clear_object_class() {
  object_class_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ShellObjectSpec::object_class() const {
  // @@protoc_insertion_point(field_get:ei.ShellObjectSpec.object_class)
  return _internal_object_class();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShellObjectSpec::set_object_class(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 object_class_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ShellObjectSpec.object_class)
}
inline std::string* ShellObjectSpec::mutable_object_class() {
  std::string* _s = _internal_mutable_object_class();
  // @@protoc_insertion_point(field_mutable:ei.ShellObjectSpec.object_class)
  return _s;
}
inline const std::string& ShellObjectSpec::_internal_object_class() const {
  return object_class_.Get();
}
inline void ShellObjectSpec::_internal_set_object_class(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  object_class_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShellObjectSpec::_internal_mutable_object_class() {
  _has_bits_[0] |= 0x00000004u;
  return object_class_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShellObjectSpec::release_object_class() {
  // @@protoc_insertion_point(field_release:ei.ShellObjectSpec.object_class)
  if (!_internal_has_object_class()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = object_class_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (object_class_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    object_class_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShellObjectSpec::set_allocated_object_class(std::string* object_class) {
  if (object_class != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  object_class_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), object_class,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (object_class_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    object_class_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ShellObjectSpec.object_class)
}

// optional uint32 price = 4;
inline bool ShellObjectSpec::_internal_has_price() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ShellObjectSpec::has_price() const {
  return _internal_has_price();
}
inline void ShellObjectSpec::clear_price() {
  price_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t ShellObjectSpec::_internal_price() const {
  return price_;
}
inline uint32_t ShellObjectSpec::price() const {
  // @@protoc_insertion_point(field_get:ei.ShellObjectSpec.price)
  return _internal_price();
}
inline void ShellObjectSpec::_internal_set_price(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  price_ = value;
}
inline void ShellObjectSpec::set_price(uint32_t value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:ei.ShellObjectSpec.price)
}

// optional uint32 required_eop = 5;
inline bool ShellObjectSpec::_internal_has_required_eop() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ShellObjectSpec::has_required_eop() const {
  return _internal_has_required_eop();
}
inline void ShellObjectSpec::clear_required_eop() {
  required_eop_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t ShellObjectSpec::_internal_required_eop() const {
  return required_eop_;
}
inline uint32_t ShellObjectSpec::required_eop() const {
  // @@protoc_insertion_point(field_get:ei.ShellObjectSpec.required_eop)
  return _internal_required_eop();
}
inline void ShellObjectSpec::_internal_set_required_eop(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  required_eop_ = value;
}
inline void ShellObjectSpec::set_required_eop(uint32_t value) {
  _internal_set_required_eop(value);
  // @@protoc_insertion_point(field_set:ei.ShellObjectSpec.required_eop)
}

// optional double required_soul_eggs = 6;
inline bool ShellObjectSpec::_internal_has_required_soul_eggs() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ShellObjectSpec::has_required_soul_eggs() const {
  return _internal_has_required_soul_eggs();
}
inline void ShellObjectSpec::clear_required_soul_eggs() {
  required_soul_eggs_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double ShellObjectSpec::_internal_required_soul_eggs() const {
  return required_soul_eggs_;
}
inline double ShellObjectSpec::required_soul_eggs() const {
  // @@protoc_insertion_point(field_get:ei.ShellObjectSpec.required_soul_eggs)
  return _internal_required_soul_eggs();
}
inline void ShellObjectSpec::_internal_set_required_soul_eggs(double value) {
  _has_bits_[0] |= 0x00000020u;
  required_soul_eggs_ = value;
}
inline void ShellObjectSpec::set_required_soul_eggs(double value) {
  _internal_set_required_soul_eggs(value);
  // @@protoc_insertion_point(field_set:ei.ShellObjectSpec.required_soul_eggs)
}

// optional bool is_new = 10;
inline bool ShellObjectSpec::_internal_has_is_new() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ShellObjectSpec::has_is_new() const {
  return _internal_has_is_new();
}
inline void ShellObjectSpec::clear_is_new() {
  is_new_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool ShellObjectSpec::_internal_is_new() const {
  return is_new_;
}
inline bool ShellObjectSpec::is_new() const {
  // @@protoc_insertion_point(field_get:ei.ShellObjectSpec.is_new)
  return _internal_is_new();
}
inline void ShellObjectSpec::_internal_set_is_new(bool value) {
  _has_bits_[0] |= 0x00000080u;
  is_new_ = value;
}
inline void ShellObjectSpec::set_is_new(bool value) {
  _internal_set_is_new(value);
  // @@protoc_insertion_point(field_set:ei.ShellObjectSpec.is_new)
}

// optional bool expires = 11;
inline bool ShellObjectSpec::_internal_has_expires() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ShellObjectSpec::has_expires() const {
  return _internal_has_expires();
}
inline void ShellObjectSpec::clear_expires() {
  expires_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool ShellObjectSpec::_internal_expires() const {
  return expires_;
}
inline bool ShellObjectSpec::expires() const {
  // @@protoc_insertion_point(field_get:ei.ShellObjectSpec.expires)
  return _internal_expires();
}
inline void ShellObjectSpec::_internal_set_expires(bool value) {
  _has_bits_[0] |= 0x00000100u;
  expires_ = value;
}
inline void ShellObjectSpec::set_expires(bool value) {
  _internal_set_expires(value);
  // @@protoc_insertion_point(field_set:ei.ShellObjectSpec.expires)
}

// optional double seconds_remaining = 12;
inline bool ShellObjectSpec::_internal_has_seconds_remaining() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ShellObjectSpec::has_seconds_remaining() const {
  return _internal_has_seconds_remaining();
}
inline void ShellObjectSpec::clear_seconds_remaining() {
  seconds_remaining_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double ShellObjectSpec::_internal_seconds_remaining() const {
  return seconds_remaining_;
}
inline double ShellObjectSpec::seconds_remaining() const {
  // @@protoc_insertion_point(field_get:ei.ShellObjectSpec.seconds_remaining)
  return _internal_seconds_remaining();
}
inline void ShellObjectSpec::_internal_set_seconds_remaining(double value) {
  _has_bits_[0] |= 0x00000040u;
  seconds_remaining_ = value;
}
inline void ShellObjectSpec::set_seconds_remaining(double value) {
  _internal_set_seconds_remaining(value);
  // @@protoc_insertion_point(field_set:ei.ShellObjectSpec.seconds_remaining)
}

// repeated double metadata = 7;
inline int ShellObjectSpec::_internal_metadata_size() const {
  return metadata_.size();
}
inline int ShellObjectSpec::metadata_size() const {
  return _internal_metadata_size();
}
inline void ShellObjectSpec::clear_metadata() {
  metadata_.Clear();
}
inline double ShellObjectSpec::_internal_metadata(int index) const {
  return metadata_.Get(index);
}
inline double ShellObjectSpec::metadata(int index) const {
  // @@protoc_insertion_point(field_get:ei.ShellObjectSpec.metadata)
  return _internal_metadata(index);
}
inline void ShellObjectSpec::set_metadata(int index, double value) {
  metadata_.Set(index, value);
  // @@protoc_insertion_point(field_set:ei.ShellObjectSpec.metadata)
}
inline void ShellObjectSpec::_internal_add_metadata(double value) {
  metadata_.Add(value);
}
inline void ShellObjectSpec::add_metadata(double value) {
  _internal_add_metadata(value);
  // @@protoc_insertion_point(field_add:ei.ShellObjectSpec.metadata)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
ShellObjectSpec::_internal_metadata() const {
  return metadata_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
ShellObjectSpec::metadata() const {
  // @@protoc_insertion_point(field_list:ei.ShellObjectSpec.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
ShellObjectSpec::_internal_mutable_metadata() {
  return &metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
ShellObjectSpec::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_list:ei.ShellObjectSpec.metadata)
  return _internal_mutable_metadata();
}

// optional bool no_hats = 13;
inline bool ShellObjectSpec::_internal_has_no_hats() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ShellObjectSpec::has_no_hats() const {
  return _internal_has_no_hats();
}
inline void ShellObjectSpec::clear_no_hats() {
  no_hats_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool ShellObjectSpec::_internal_no_hats() const {
  return no_hats_;
}
inline bool ShellObjectSpec::no_hats() const {
  // @@protoc_insertion_point(field_get:ei.ShellObjectSpec.no_hats)
  return _internal_no_hats();
}
inline void ShellObjectSpec::_internal_set_no_hats(bool value) {
  _has_bits_[0] |= 0x00000200u;
  no_hats_ = value;
}
inline void ShellObjectSpec::set_no_hats(bool value) {
  _internal_set_no_hats(value);
  // @@protoc_insertion_point(field_set:ei.ShellObjectSpec.no_hats)
}

// repeated .ei.ShellObjectSpec.LODPiece pieces = 8;
inline int ShellObjectSpec::_internal_pieces_size() const {
  return pieces_.size();
}
inline int ShellObjectSpec::pieces_size() const {
  return _internal_pieces_size();
}
inline void ShellObjectSpec::clear_pieces() {
  pieces_.Clear();
}
inline ::ei::ShellObjectSpec_LODPiece* ShellObjectSpec::mutable_pieces(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ShellObjectSpec.pieces)
  return pieces_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellObjectSpec_LODPiece >*
ShellObjectSpec::mutable_pieces() {
  // @@protoc_insertion_point(field_mutable_list:ei.ShellObjectSpec.pieces)
  return &pieces_;
}
inline const ::ei::ShellObjectSpec_LODPiece& ShellObjectSpec::_internal_pieces(int index) const {
  return pieces_.Get(index);
}
inline const ::ei::ShellObjectSpec_LODPiece& ShellObjectSpec::pieces(int index) const {
  // @@protoc_insertion_point(field_get:ei.ShellObjectSpec.pieces)
  return _internal_pieces(index);
}
inline ::ei::ShellObjectSpec_LODPiece* ShellObjectSpec::_internal_add_pieces() {
  return pieces_.Add();
}
inline ::ei::ShellObjectSpec_LODPiece* ShellObjectSpec::add_pieces() {
  ::ei::ShellObjectSpec_LODPiece* _add = _internal_add_pieces();
  // @@protoc_insertion_point(field_add:ei.ShellObjectSpec.pieces)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellObjectSpec_LODPiece >&
ShellObjectSpec::pieces() const {
  // @@protoc_insertion_point(field_list:ei.ShellObjectSpec.pieces)
  return pieces_;
}

// optional bool default_appearance = 9;
inline bool ShellObjectSpec::_internal_has_default_appearance() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ShellObjectSpec::has_default_appearance() const {
  return _internal_has_default_appearance();
}
inline void ShellObjectSpec::clear_default_appearance() {
  default_appearance_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool ShellObjectSpec::_internal_default_appearance() const {
  return default_appearance_;
}
inline bool ShellObjectSpec::default_appearance() const {
  // @@protoc_insertion_point(field_get:ei.ShellObjectSpec.default_appearance)
  return _internal_default_appearance();
}
inline void ShellObjectSpec::_internal_set_default_appearance(bool value) {
  _has_bits_[0] |= 0x00000400u;
  default_appearance_ = value;
}
inline void ShellObjectSpec::set_default_appearance(bool value) {
  _internal_set_default_appearance(value);
  // @@protoc_insertion_point(field_set:ei.ShellObjectSpec.default_appearance)
}

// -------------------------------------------------------------------

// ShellGroupSpec

// optional string identifier = 1;
inline bool ShellGroupSpec::_internal_has_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShellGroupSpec::has_identifier() const {
  return _internal_has_identifier();
}
inline void ShellGroupSpec::clear_identifier() {
  identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ShellGroupSpec::identifier() const {
  // @@protoc_insertion_point(field_get:ei.ShellGroupSpec.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShellGroupSpec::set_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ShellGroupSpec.identifier)
}
inline std::string* ShellGroupSpec::mutable_identifier() {
  std::string* _s = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:ei.ShellGroupSpec.identifier)
  return _s;
}
inline const std::string& ShellGroupSpec::_internal_identifier() const {
  return identifier_.Get();
}
inline void ShellGroupSpec::_internal_set_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShellGroupSpec::_internal_mutable_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShellGroupSpec::release_identifier() {
  // @@protoc_insertion_point(field_release:ei.ShellGroupSpec.identifier)
  if (!_internal_has_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShellGroupSpec::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ShellGroupSpec.identifier)
}

// optional string name = 2;
inline bool ShellGroupSpec::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShellGroupSpec::has_name() const {
  return _internal_has_name();
}
inline void ShellGroupSpec::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ShellGroupSpec::name() const {
  // @@protoc_insertion_point(field_get:ei.ShellGroupSpec.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShellGroupSpec::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ShellGroupSpec.name)
}
inline std::string* ShellGroupSpec::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ei.ShellGroupSpec.name)
  return _s;
}
inline const std::string& ShellGroupSpec::_internal_name() const {
  return name_.Get();
}
inline void ShellGroupSpec::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShellGroupSpec::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000002u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShellGroupSpec::release_name() {
  // @@protoc_insertion_point(field_release:ei.ShellGroupSpec.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShellGroupSpec::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ShellGroupSpec.name)
}

// optional .ei.ShellSpec.AssetType asset_type = 5;
inline bool ShellGroupSpec::_internal_has_asset_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ShellGroupSpec::has_asset_type() const {
  return _internal_has_asset_type();
}
inline void ShellGroupSpec::clear_asset_type() {
  asset_type_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::ei::ShellSpec_AssetType ShellGroupSpec::_internal_asset_type() const {
  return static_cast< ::ei::ShellSpec_AssetType >(asset_type_);
}
inline ::ei::ShellSpec_AssetType ShellGroupSpec::asset_type() const {
  // @@protoc_insertion_point(field_get:ei.ShellGroupSpec.asset_type)
  return _internal_asset_type();
}
inline void ShellGroupSpec::_internal_set_asset_type(::ei::ShellSpec_AssetType value) {
  assert(::ei::ShellSpec_AssetType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  asset_type_ = value;
}
inline void ShellGroupSpec::set_asset_type(::ei::ShellSpec_AssetType value) {
  _internal_set_asset_type(value);
  // @@protoc_insertion_point(field_set:ei.ShellGroupSpec.asset_type)
}

// repeated string member_ids = 3;
inline int ShellGroupSpec::_internal_member_ids_size() const {
  return member_ids_.size();
}
inline int ShellGroupSpec::member_ids_size() const {
  return _internal_member_ids_size();
}
inline void ShellGroupSpec::clear_member_ids() {
  member_ids_.Clear();
}
inline std::string* ShellGroupSpec::add_member_ids() {
  std::string* _s = _internal_add_member_ids();
  // @@protoc_insertion_point(field_add_mutable:ei.ShellGroupSpec.member_ids)
  return _s;
}
inline const std::string& ShellGroupSpec::_internal_member_ids(int index) const {
  return member_ids_.Get(index);
}
inline const std::string& ShellGroupSpec::member_ids(int index) const {
  // @@protoc_insertion_point(field_get:ei.ShellGroupSpec.member_ids)
  return _internal_member_ids(index);
}
inline std::string* ShellGroupSpec::mutable_member_ids(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ShellGroupSpec.member_ids)
  return member_ids_.Mutable(index);
}
inline void ShellGroupSpec::set_member_ids(int index, const std::string& value) {
  member_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ei.ShellGroupSpec.member_ids)
}
inline void ShellGroupSpec::set_member_ids(int index, std::string&& value) {
  member_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ei.ShellGroupSpec.member_ids)
}
inline void ShellGroupSpec::set_member_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  member_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ei.ShellGroupSpec.member_ids)
}
inline void ShellGroupSpec::set_member_ids(int index, const char* value, size_t size) {
  member_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ei.ShellGroupSpec.member_ids)
}
inline std::string* ShellGroupSpec::_internal_add_member_ids() {
  return member_ids_.Add();
}
inline void ShellGroupSpec::add_member_ids(const std::string& value) {
  member_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ei.ShellGroupSpec.member_ids)
}
inline void ShellGroupSpec::add_member_ids(std::string&& value) {
  member_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ei.ShellGroupSpec.member_ids)
}
inline void ShellGroupSpec::add_member_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  member_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ei.ShellGroupSpec.member_ids)
}
inline void ShellGroupSpec::add_member_ids(const char* value, size_t size) {
  member_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ei.ShellGroupSpec.member_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ShellGroupSpec::member_ids() const {
  // @@protoc_insertion_point(field_list:ei.ShellGroupSpec.member_ids)
  return member_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ShellGroupSpec::mutable_member_ids() {
  // @@protoc_insertion_point(field_mutable_list:ei.ShellGroupSpec.member_ids)
  return &member_ids_;
}

// optional double price_mult_DEPRECATED = 4;
inline bool ShellGroupSpec::_internal_has_price_mult_deprecated() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ShellGroupSpec::has_price_mult_deprecated() const {
  return _internal_has_price_mult_deprecated();
}
inline void ShellGroupSpec::clear_price_mult_deprecated() {
  price_mult_deprecated_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double ShellGroupSpec::_internal_price_mult_deprecated() const {
  return price_mult_deprecated_;
}
inline double ShellGroupSpec::price_mult_deprecated() const {
  // @@protoc_insertion_point(field_get:ei.ShellGroupSpec.price_mult_DEPRECATED)
  return _internal_price_mult_deprecated();
}
inline void ShellGroupSpec::_internal_set_price_mult_deprecated(double value) {
  _has_bits_[0] |= 0x00000004u;
  price_mult_deprecated_ = value;
}
inline void ShellGroupSpec::set_price_mult_deprecated(double value) {
  _internal_set_price_mult_deprecated(value);
  // @@protoc_insertion_point(field_set:ei.ShellGroupSpec.price_mult_DEPRECATED)
}

// -------------------------------------------------------------------

// DLCCatalog

// repeated .ei.DLCItem items = 1;
inline int DLCCatalog::_internal_items_size() const {
  return items_.size();
}
inline int DLCCatalog::items_size() const {
  return _internal_items_size();
}
inline void DLCCatalog::clear_items() {
  items_.Clear();
}
inline ::ei::DLCItem* DLCCatalog::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:ei.DLCCatalog.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::DLCItem >*
DLCCatalog::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:ei.DLCCatalog.items)
  return &items_;
}
inline const ::ei::DLCItem& DLCCatalog::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::ei::DLCItem& DLCCatalog::items(int index) const {
  // @@protoc_insertion_point(field_get:ei.DLCCatalog.items)
  return _internal_items(index);
}
inline ::ei::DLCItem* DLCCatalog::_internal_add_items() {
  return items_.Add();
}
inline ::ei::DLCItem* DLCCatalog::add_items() {
  ::ei::DLCItem* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:ei.DLCCatalog.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::DLCItem >&
DLCCatalog::items() const {
  // @@protoc_insertion_point(field_list:ei.DLCCatalog.items)
  return items_;
}

// repeated .ei.ShellSpec shells = 2;
inline int DLCCatalog::_internal_shells_size() const {
  return shells_.size();
}
inline int DLCCatalog::shells_size() const {
  return _internal_shells_size();
}
inline void DLCCatalog::clear_shells() {
  shells_.Clear();
}
inline ::ei::ShellSpec* DLCCatalog::mutable_shells(int index) {
  // @@protoc_insertion_point(field_mutable:ei.DLCCatalog.shells)
  return shells_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellSpec >*
DLCCatalog::mutable_shells() {
  // @@protoc_insertion_point(field_mutable_list:ei.DLCCatalog.shells)
  return &shells_;
}
inline const ::ei::ShellSpec& DLCCatalog::_internal_shells(int index) const {
  return shells_.Get(index);
}
inline const ::ei::ShellSpec& DLCCatalog::shells(int index) const {
  // @@protoc_insertion_point(field_get:ei.DLCCatalog.shells)
  return _internal_shells(index);
}
inline ::ei::ShellSpec* DLCCatalog::_internal_add_shells() {
  return shells_.Add();
}
inline ::ei::ShellSpec* DLCCatalog::add_shells() {
  ::ei::ShellSpec* _add = _internal_add_shells();
  // @@protoc_insertion_point(field_add:ei.DLCCatalog.shells)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellSpec >&
DLCCatalog::shells() const {
  // @@protoc_insertion_point(field_list:ei.DLCCatalog.shells)
  return shells_;
}

// repeated .ei.ShellSetSpec shell_sets = 3;
inline int DLCCatalog::_internal_shell_sets_size() const {
  return shell_sets_.size();
}
inline int DLCCatalog::shell_sets_size() const {
  return _internal_shell_sets_size();
}
inline void DLCCatalog::clear_shell_sets() {
  shell_sets_.Clear();
}
inline ::ei::ShellSetSpec* DLCCatalog::mutable_shell_sets(int index) {
  // @@protoc_insertion_point(field_mutable:ei.DLCCatalog.shell_sets)
  return shell_sets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellSetSpec >*
DLCCatalog::mutable_shell_sets() {
  // @@protoc_insertion_point(field_mutable_list:ei.DLCCatalog.shell_sets)
  return &shell_sets_;
}
inline const ::ei::ShellSetSpec& DLCCatalog::_internal_shell_sets(int index) const {
  return shell_sets_.Get(index);
}
inline const ::ei::ShellSetSpec& DLCCatalog::shell_sets(int index) const {
  // @@protoc_insertion_point(field_get:ei.DLCCatalog.shell_sets)
  return _internal_shell_sets(index);
}
inline ::ei::ShellSetSpec* DLCCatalog::_internal_add_shell_sets() {
  return shell_sets_.Add();
}
inline ::ei::ShellSetSpec* DLCCatalog::add_shell_sets() {
  ::ei::ShellSetSpec* _add = _internal_add_shell_sets();
  // @@protoc_insertion_point(field_add:ei.DLCCatalog.shell_sets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellSetSpec >&
DLCCatalog::shell_sets() const {
  // @@protoc_insertion_point(field_list:ei.DLCCatalog.shell_sets)
  return shell_sets_;
}

// repeated .ei.ShellObjectSpec shell_objects = 4;
inline int DLCCatalog::_internal_shell_objects_size() const {
  return shell_objects_.size();
}
inline int DLCCatalog::shell_objects_size() const {
  return _internal_shell_objects_size();
}
inline void DLCCatalog::clear_shell_objects() {
  shell_objects_.Clear();
}
inline ::ei::ShellObjectSpec* DLCCatalog::mutable_shell_objects(int index) {
  // @@protoc_insertion_point(field_mutable:ei.DLCCatalog.shell_objects)
  return shell_objects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellObjectSpec >*
DLCCatalog::mutable_shell_objects() {
  // @@protoc_insertion_point(field_mutable_list:ei.DLCCatalog.shell_objects)
  return &shell_objects_;
}
inline const ::ei::ShellObjectSpec& DLCCatalog::_internal_shell_objects(int index) const {
  return shell_objects_.Get(index);
}
inline const ::ei::ShellObjectSpec& DLCCatalog::shell_objects(int index) const {
  // @@protoc_insertion_point(field_get:ei.DLCCatalog.shell_objects)
  return _internal_shell_objects(index);
}
inline ::ei::ShellObjectSpec* DLCCatalog::_internal_add_shell_objects() {
  return shell_objects_.Add();
}
inline ::ei::ShellObjectSpec* DLCCatalog::add_shell_objects() {
  ::ei::ShellObjectSpec* _add = _internal_add_shell_objects();
  // @@protoc_insertion_point(field_add:ei.DLCCatalog.shell_objects)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellObjectSpec >&
DLCCatalog::shell_objects() const {
  // @@protoc_insertion_point(field_list:ei.DLCCatalog.shell_objects)
  return shell_objects_;
}

// repeated .ei.ShellGroupSpec shell_groups = 5;
inline int DLCCatalog::_internal_shell_groups_size() const {
  return shell_groups_.size();
}
inline int DLCCatalog::shell_groups_size() const {
  return _internal_shell_groups_size();
}
inline void DLCCatalog::clear_shell_groups() {
  shell_groups_.Clear();
}
inline ::ei::ShellGroupSpec* DLCCatalog::mutable_shell_groups(int index) {
  // @@protoc_insertion_point(field_mutable:ei.DLCCatalog.shell_groups)
  return shell_groups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellGroupSpec >*
DLCCatalog::mutable_shell_groups() {
  // @@protoc_insertion_point(field_mutable_list:ei.DLCCatalog.shell_groups)
  return &shell_groups_;
}
inline const ::ei::ShellGroupSpec& DLCCatalog::_internal_shell_groups(int index) const {
  return shell_groups_.Get(index);
}
inline const ::ei::ShellGroupSpec& DLCCatalog::shell_groups(int index) const {
  // @@protoc_insertion_point(field_get:ei.DLCCatalog.shell_groups)
  return _internal_shell_groups(index);
}
inline ::ei::ShellGroupSpec* DLCCatalog::_internal_add_shell_groups() {
  return shell_groups_.Add();
}
inline ::ei::ShellGroupSpec* DLCCatalog::add_shell_groups() {
  ::ei::ShellGroupSpec* _add = _internal_add_shell_groups();
  // @@protoc_insertion_point(field_add:ei.DLCCatalog.shell_groups)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellGroupSpec >&
DLCCatalog::shell_groups() const {
  // @@protoc_insertion_point(field_list:ei.DLCCatalog.shell_groups)
  return shell_groups_;
}

// -------------------------------------------------------------------

// ShellDB_ShellStatus

// optional string identifier = 1;
inline bool ShellDB_ShellStatus::_internal_has_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShellDB_ShellStatus::has_identifier() const {
  return _internal_has_identifier();
}
inline void ShellDB_ShellStatus::clear_identifier() {
  identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ShellDB_ShellStatus::identifier() const {
  // @@protoc_insertion_point(field_get:ei.ShellDB.ShellStatus.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShellDB_ShellStatus::set_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ShellDB.ShellStatus.identifier)
}
inline std::string* ShellDB_ShellStatus::mutable_identifier() {
  std::string* _s = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:ei.ShellDB.ShellStatus.identifier)
  return _s;
}
inline const std::string& ShellDB_ShellStatus::_internal_identifier() const {
  return identifier_.Get();
}
inline void ShellDB_ShellStatus::_internal_set_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShellDB_ShellStatus::_internal_mutable_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShellDB_ShellStatus::release_identifier() {
  // @@protoc_insertion_point(field_release:ei.ShellDB.ShellStatus.identifier)
  if (!_internal_has_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShellDB_ShellStatus::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ShellDB.ShellStatus.identifier)
}

// optional bool owned = 2;
inline bool ShellDB_ShellStatus::_internal_has_owned() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShellDB_ShellStatus::has_owned() const {
  return _internal_has_owned();
}
inline void ShellDB_ShellStatus::clear_owned() {
  owned_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ShellDB_ShellStatus::_internal_owned() const {
  return owned_;
}
inline bool ShellDB_ShellStatus::owned() const {
  // @@protoc_insertion_point(field_get:ei.ShellDB.ShellStatus.owned)
  return _internal_owned();
}
inline void ShellDB_ShellStatus::_internal_set_owned(bool value) {
  _has_bits_[0] |= 0x00000002u;
  owned_ = value;
}
inline void ShellDB_ShellStatus::set_owned(bool value) {
  _internal_set_owned(value);
  // @@protoc_insertion_point(field_set:ei.ShellDB.ShellStatus.owned)
}

// -------------------------------------------------------------------

// ShellDB_ShellElementStatus

// optional .ei.ShellDB.FarmElement element = 1;
inline bool ShellDB_ShellElementStatus::_internal_has_element() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShellDB_ShellElementStatus::has_element() const {
  return _internal_has_element();
}
inline void ShellDB_ShellElementStatus::clear_element() {
  element_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::ei::ShellDB_FarmElement ShellDB_ShellElementStatus::_internal_element() const {
  return static_cast< ::ei::ShellDB_FarmElement >(element_);
}
inline ::ei::ShellDB_FarmElement ShellDB_ShellElementStatus::element() const {
  // @@protoc_insertion_point(field_get:ei.ShellDB.ShellElementStatus.element)
  return _internal_element();
}
inline void ShellDB_ShellElementStatus::_internal_set_element(::ei::ShellDB_FarmElement value) {
  assert(::ei::ShellDB_FarmElement_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  element_ = value;
}
inline void ShellDB_ShellElementStatus::set_element(::ei::ShellDB_FarmElement value) {
  _internal_set_element(value);
  // @@protoc_insertion_point(field_set:ei.ShellDB.ShellElementStatus.element)
}

// optional string set_identifier = 2;
inline bool ShellDB_ShellElementStatus::_internal_has_set_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShellDB_ShellElementStatus::has_set_identifier() const {
  return _internal_has_set_identifier();
}
inline void ShellDB_ShellElementStatus::clear_set_identifier() {
  set_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ShellDB_ShellElementStatus::set_identifier() const {
  // @@protoc_insertion_point(field_get:ei.ShellDB.ShellElementStatus.set_identifier)
  return _internal_set_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShellDB_ShellElementStatus::set_set_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 set_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ShellDB.ShellElementStatus.set_identifier)
}
inline std::string* ShellDB_ShellElementStatus::mutable_set_identifier() {
  std::string* _s = _internal_mutable_set_identifier();
  // @@protoc_insertion_point(field_mutable:ei.ShellDB.ShellElementStatus.set_identifier)
  return _s;
}
inline const std::string& ShellDB_ShellElementStatus::_internal_set_identifier() const {
  return set_identifier_.Get();
}
inline void ShellDB_ShellElementStatus::_internal_set_set_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  set_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShellDB_ShellElementStatus::_internal_mutable_set_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return set_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShellDB_ShellElementStatus::release_set_identifier() {
  // @@protoc_insertion_point(field_release:ei.ShellDB.ShellElementStatus.set_identifier)
  if (!_internal_has_set_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = set_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (set_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    set_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShellDB_ShellElementStatus::set_allocated_set_identifier(std::string* set_identifier) {
  if (set_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  set_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), set_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (set_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    set_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ShellDB.ShellElementStatus.set_identifier)
}

// -------------------------------------------------------------------

// ShellDB_ShellSetVariationStatus

// optional string set_identifier = 1;
inline bool ShellDB_ShellSetVariationStatus::_internal_has_set_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShellDB_ShellSetVariationStatus::has_set_identifier() const {
  return _internal_has_set_identifier();
}
inline void ShellDB_ShellSetVariationStatus::clear_set_identifier() {
  set_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ShellDB_ShellSetVariationStatus::set_identifier() const {
  // @@protoc_insertion_point(field_get:ei.ShellDB.ShellSetVariationStatus.set_identifier)
  return _internal_set_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShellDB_ShellSetVariationStatus::set_set_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 set_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ShellDB.ShellSetVariationStatus.set_identifier)
}
inline std::string* ShellDB_ShellSetVariationStatus::mutable_set_identifier() {
  std::string* _s = _internal_mutable_set_identifier();
  // @@protoc_insertion_point(field_mutable:ei.ShellDB.ShellSetVariationStatus.set_identifier)
  return _s;
}
inline const std::string& ShellDB_ShellSetVariationStatus::_internal_set_identifier() const {
  return set_identifier_.Get();
}
inline void ShellDB_ShellSetVariationStatus::_internal_set_set_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  set_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShellDB_ShellSetVariationStatus::_internal_mutable_set_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return set_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShellDB_ShellSetVariationStatus::release_set_identifier() {
  // @@protoc_insertion_point(field_release:ei.ShellDB.ShellSetVariationStatus.set_identifier)
  if (!_internal_has_set_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = set_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (set_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    set_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShellDB_ShellSetVariationStatus::set_allocated_set_identifier(std::string* set_identifier) {
  if (set_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  set_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), set_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (set_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    set_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ShellDB.ShellSetVariationStatus.set_identifier)
}

// repeated string owned_variations = 2;
inline int ShellDB_ShellSetVariationStatus::_internal_owned_variations_size() const {
  return owned_variations_.size();
}
inline int ShellDB_ShellSetVariationStatus::owned_variations_size() const {
  return _internal_owned_variations_size();
}
inline void ShellDB_ShellSetVariationStatus::clear_owned_variations() {
  owned_variations_.Clear();
}
inline std::string* ShellDB_ShellSetVariationStatus::add_owned_variations() {
  std::string* _s = _internal_add_owned_variations();
  // @@protoc_insertion_point(field_add_mutable:ei.ShellDB.ShellSetVariationStatus.owned_variations)
  return _s;
}
inline const std::string& ShellDB_ShellSetVariationStatus::_internal_owned_variations(int index) const {
  return owned_variations_.Get(index);
}
inline const std::string& ShellDB_ShellSetVariationStatus::owned_variations(int index) const {
  // @@protoc_insertion_point(field_get:ei.ShellDB.ShellSetVariationStatus.owned_variations)
  return _internal_owned_variations(index);
}
inline std::string* ShellDB_ShellSetVariationStatus::mutable_owned_variations(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ShellDB.ShellSetVariationStatus.owned_variations)
  return owned_variations_.Mutable(index);
}
inline void ShellDB_ShellSetVariationStatus::set_owned_variations(int index, const std::string& value) {
  owned_variations_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ei.ShellDB.ShellSetVariationStatus.owned_variations)
}
inline void ShellDB_ShellSetVariationStatus::set_owned_variations(int index, std::string&& value) {
  owned_variations_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ei.ShellDB.ShellSetVariationStatus.owned_variations)
}
inline void ShellDB_ShellSetVariationStatus::set_owned_variations(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  owned_variations_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ei.ShellDB.ShellSetVariationStatus.owned_variations)
}
inline void ShellDB_ShellSetVariationStatus::set_owned_variations(int index, const char* value, size_t size) {
  owned_variations_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ei.ShellDB.ShellSetVariationStatus.owned_variations)
}
inline std::string* ShellDB_ShellSetVariationStatus::_internal_add_owned_variations() {
  return owned_variations_.Add();
}
inline void ShellDB_ShellSetVariationStatus::add_owned_variations(const std::string& value) {
  owned_variations_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ei.ShellDB.ShellSetVariationStatus.owned_variations)
}
inline void ShellDB_ShellSetVariationStatus::add_owned_variations(std::string&& value) {
  owned_variations_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ei.ShellDB.ShellSetVariationStatus.owned_variations)
}
inline void ShellDB_ShellSetVariationStatus::add_owned_variations(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  owned_variations_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ei.ShellDB.ShellSetVariationStatus.owned_variations)
}
inline void ShellDB_ShellSetVariationStatus::add_owned_variations(const char* value, size_t size) {
  owned_variations_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ei.ShellDB.ShellSetVariationStatus.owned_variations)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ShellDB_ShellSetVariationStatus::owned_variations() const {
  // @@protoc_insertion_point(field_list:ei.ShellDB.ShellSetVariationStatus.owned_variations)
  return owned_variations_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ShellDB_ShellSetVariationStatus::mutable_owned_variations() {
  // @@protoc_insertion_point(field_mutable_list:ei.ShellDB.ShellSetVariationStatus.owned_variations)
  return &owned_variations_;
}

// -------------------------------------------------------------------

// ShellDB_FarmConfiguration

// repeated .ei.ShellDB.ShellConfiguration shell_configs = 1;
inline int ShellDB_FarmConfiguration::_internal_shell_configs_size() const {
  return shell_configs_.size();
}
inline int ShellDB_FarmConfiguration::shell_configs_size() const {
  return _internal_shell_configs_size();
}
inline void ShellDB_FarmConfiguration::clear_shell_configs() {
  shell_configs_.Clear();
}
inline ::ei::ShellDB_ShellConfiguration* ShellDB_FarmConfiguration::mutable_shell_configs(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ShellDB.FarmConfiguration.shell_configs)
  return shell_configs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellConfiguration >*
ShellDB_FarmConfiguration::mutable_shell_configs() {
  // @@protoc_insertion_point(field_mutable_list:ei.ShellDB.FarmConfiguration.shell_configs)
  return &shell_configs_;
}
inline const ::ei::ShellDB_ShellConfiguration& ShellDB_FarmConfiguration::_internal_shell_configs(int index) const {
  return shell_configs_.Get(index);
}
inline const ::ei::ShellDB_ShellConfiguration& ShellDB_FarmConfiguration::shell_configs(int index) const {
  // @@protoc_insertion_point(field_get:ei.ShellDB.FarmConfiguration.shell_configs)
  return _internal_shell_configs(index);
}
inline ::ei::ShellDB_ShellConfiguration* ShellDB_FarmConfiguration::_internal_add_shell_configs() {
  return shell_configs_.Add();
}
inline ::ei::ShellDB_ShellConfiguration* ShellDB_FarmConfiguration::add_shell_configs() {
  ::ei::ShellDB_ShellConfiguration* _add = _internal_add_shell_configs();
  // @@protoc_insertion_point(field_add:ei.ShellDB.FarmConfiguration.shell_configs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellConfiguration >&
ShellDB_FarmConfiguration::shell_configs() const {
  // @@protoc_insertion_point(field_list:ei.ShellDB.FarmConfiguration.shell_configs)
  return shell_configs_;
}

// repeated .ei.ShellDB.ShellSetConfiguration shell_set_configs = 2;
inline int ShellDB_FarmConfiguration::_internal_shell_set_configs_size() const {
  return shell_set_configs_.size();
}
inline int ShellDB_FarmConfiguration::shell_set_configs_size() const {
  return _internal_shell_set_configs_size();
}
inline void ShellDB_FarmConfiguration::clear_shell_set_configs() {
  shell_set_configs_.Clear();
}
inline ::ei::ShellDB_ShellSetConfiguration* ShellDB_FarmConfiguration::mutable_shell_set_configs(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ShellDB.FarmConfiguration.shell_set_configs)
  return shell_set_configs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellSetConfiguration >*
ShellDB_FarmConfiguration::mutable_shell_set_configs() {
  // @@protoc_insertion_point(field_mutable_list:ei.ShellDB.FarmConfiguration.shell_set_configs)
  return &shell_set_configs_;
}
inline const ::ei::ShellDB_ShellSetConfiguration& ShellDB_FarmConfiguration::_internal_shell_set_configs(int index) const {
  return shell_set_configs_.Get(index);
}
inline const ::ei::ShellDB_ShellSetConfiguration& ShellDB_FarmConfiguration::shell_set_configs(int index) const {
  // @@protoc_insertion_point(field_get:ei.ShellDB.FarmConfiguration.shell_set_configs)
  return _internal_shell_set_configs(index);
}
inline ::ei::ShellDB_ShellSetConfiguration* ShellDB_FarmConfiguration::_internal_add_shell_set_configs() {
  return shell_set_configs_.Add();
}
inline ::ei::ShellDB_ShellSetConfiguration* ShellDB_FarmConfiguration::add_shell_set_configs() {
  ::ei::ShellDB_ShellSetConfiguration* _add = _internal_add_shell_set_configs();
  // @@protoc_insertion_point(field_add:ei.ShellDB.FarmConfiguration.shell_set_configs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellSetConfiguration >&
ShellDB_FarmConfiguration::shell_set_configs() const {
  // @@protoc_insertion_point(field_list:ei.ShellDB.FarmConfiguration.shell_set_configs)
  return shell_set_configs_;
}

// optional bool configure_chickens_by_group = 7;
inline bool ShellDB_FarmConfiguration::_internal_has_configure_chickens_by_group() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShellDB_FarmConfiguration::has_configure_chickens_by_group() const {
  return _internal_has_configure_chickens_by_group();
}
inline void ShellDB_FarmConfiguration::clear_configure_chickens_by_group() {
  configure_chickens_by_group_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool ShellDB_FarmConfiguration::_internal_configure_chickens_by_group() const {
  return configure_chickens_by_group_;
}
inline bool ShellDB_FarmConfiguration::configure_chickens_by_group() const {
  // @@protoc_insertion_point(field_get:ei.ShellDB.FarmConfiguration.configure_chickens_by_group)
  return _internal_configure_chickens_by_group();
}
inline void ShellDB_FarmConfiguration::_internal_set_configure_chickens_by_group(bool value) {
  _has_bits_[0] |= 0x00000001u;
  configure_chickens_by_group_ = value;
}
inline void ShellDB_FarmConfiguration::set_configure_chickens_by_group(bool value) {
  _internal_set_configure_chickens_by_group(value);
  // @@protoc_insertion_point(field_set:ei.ShellDB.FarmConfiguration.configure_chickens_by_group)
}

// repeated .ei.ShellDB.ShellGroupConfiguration group_configs = 8;
inline int ShellDB_FarmConfiguration::_internal_group_configs_size() const {
  return group_configs_.size();
}
inline int ShellDB_FarmConfiguration::group_configs_size() const {
  return _internal_group_configs_size();
}
inline void ShellDB_FarmConfiguration::clear_group_configs() {
  group_configs_.Clear();
}
inline ::ei::ShellDB_ShellGroupConfiguration* ShellDB_FarmConfiguration::mutable_group_configs(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ShellDB.FarmConfiguration.group_configs)
  return group_configs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellGroupConfiguration >*
ShellDB_FarmConfiguration::mutable_group_configs() {
  // @@protoc_insertion_point(field_mutable_list:ei.ShellDB.FarmConfiguration.group_configs)
  return &group_configs_;
}
inline const ::ei::ShellDB_ShellGroupConfiguration& ShellDB_FarmConfiguration::_internal_group_configs(int index) const {
  return group_configs_.Get(index);
}
inline const ::ei::ShellDB_ShellGroupConfiguration& ShellDB_FarmConfiguration::group_configs(int index) const {
  // @@protoc_insertion_point(field_get:ei.ShellDB.FarmConfiguration.group_configs)
  return _internal_group_configs(index);
}
inline ::ei::ShellDB_ShellGroupConfiguration* ShellDB_FarmConfiguration::_internal_add_group_configs() {
  return group_configs_.Add();
}
inline ::ei::ShellDB_ShellGroupConfiguration* ShellDB_FarmConfiguration::add_group_configs() {
  ::ei::ShellDB_ShellGroupConfiguration* _add = _internal_add_group_configs();
  // @@protoc_insertion_point(field_add:ei.ShellDB.FarmConfiguration.group_configs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellGroupConfiguration >&
ShellDB_FarmConfiguration::group_configs() const {
  // @@protoc_insertion_point(field_list:ei.ShellDB.FarmConfiguration.group_configs)
  return group_configs_;
}

// repeated .ei.ShellDB.ChickenConfig chicken_configs = 9;
inline int ShellDB_FarmConfiguration::_internal_chicken_configs_size() const {
  return chicken_configs_.size();
}
inline int ShellDB_FarmConfiguration::chicken_configs_size() const {
  return _internal_chicken_configs_size();
}
inline void ShellDB_FarmConfiguration::clear_chicken_configs() {
  chicken_configs_.Clear();
}
inline ::ei::ShellDB_ChickenConfig* ShellDB_FarmConfiguration::mutable_chicken_configs(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ShellDB.FarmConfiguration.chicken_configs)
  return chicken_configs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ChickenConfig >*
ShellDB_FarmConfiguration::mutable_chicken_configs() {
  // @@protoc_insertion_point(field_mutable_list:ei.ShellDB.FarmConfiguration.chicken_configs)
  return &chicken_configs_;
}
inline const ::ei::ShellDB_ChickenConfig& ShellDB_FarmConfiguration::_internal_chicken_configs(int index) const {
  return chicken_configs_.Get(index);
}
inline const ::ei::ShellDB_ChickenConfig& ShellDB_FarmConfiguration::chicken_configs(int index) const {
  // @@protoc_insertion_point(field_get:ei.ShellDB.FarmConfiguration.chicken_configs)
  return _internal_chicken_configs(index);
}
inline ::ei::ShellDB_ChickenConfig* ShellDB_FarmConfiguration::_internal_add_chicken_configs() {
  return chicken_configs_.Add();
}
inline ::ei::ShellDB_ChickenConfig* ShellDB_FarmConfiguration::add_chicken_configs() {
  ::ei::ShellDB_ChickenConfig* _add = _internal_add_chicken_configs();
  // @@protoc_insertion_point(field_add:ei.ShellDB.FarmConfiguration.chicken_configs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ChickenConfig >&
ShellDB_FarmConfiguration::chicken_configs() const {
  // @@protoc_insertion_point(field_list:ei.ShellDB.FarmConfiguration.chicken_configs)
  return chicken_configs_;
}

// -------------------------------------------------------------------

// ShellDB_ShellConfiguration

// optional .ei.ShellSpec.AssetType asset_type = 1;
inline bool ShellDB_ShellConfiguration::_internal_has_asset_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ShellDB_ShellConfiguration::has_asset_type() const {
  return _internal_has_asset_type();
}
inline void ShellDB_ShellConfiguration::clear_asset_type() {
  asset_type_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::ei::ShellSpec_AssetType ShellDB_ShellConfiguration::_internal_asset_type() const {
  return static_cast< ::ei::ShellSpec_AssetType >(asset_type_);
}
inline ::ei::ShellSpec_AssetType ShellDB_ShellConfiguration::asset_type() const {
  // @@protoc_insertion_point(field_get:ei.ShellDB.ShellConfiguration.asset_type)
  return _internal_asset_type();
}
inline void ShellDB_ShellConfiguration::_internal_set_asset_type(::ei::ShellSpec_AssetType value) {
  assert(::ei::ShellSpec_AssetType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  asset_type_ = value;
}
inline void ShellDB_ShellConfiguration::set_asset_type(::ei::ShellSpec_AssetType value) {
  _internal_set_asset_type(value);
  // @@protoc_insertion_point(field_set:ei.ShellDB.ShellConfiguration.asset_type)
}

// optional uint32 index = 2;
inline bool ShellDB_ShellConfiguration::_internal_has_index() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShellDB_ShellConfiguration::has_index() const {
  return _internal_has_index();
}
inline void ShellDB_ShellConfiguration::clear_index() {
  index_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ShellDB_ShellConfiguration::_internal_index() const {
  return index_;
}
inline uint32_t ShellDB_ShellConfiguration::index() const {
  // @@protoc_insertion_point(field_get:ei.ShellDB.ShellConfiguration.index)
  return _internal_index();
}
inline void ShellDB_ShellConfiguration::_internal_set_index(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  index_ = value;
}
inline void ShellDB_ShellConfiguration::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:ei.ShellDB.ShellConfiguration.index)
}

// optional string shell_identifier = 3;
inline bool ShellDB_ShellConfiguration::_internal_has_shell_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShellDB_ShellConfiguration::has_shell_identifier() const {
  return _internal_has_shell_identifier();
}
inline void ShellDB_ShellConfiguration::clear_shell_identifier() {
  shell_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ShellDB_ShellConfiguration::shell_identifier() const {
  // @@protoc_insertion_point(field_get:ei.ShellDB.ShellConfiguration.shell_identifier)
  return _internal_shell_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShellDB_ShellConfiguration::set_shell_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 shell_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ShellDB.ShellConfiguration.shell_identifier)
}
inline std::string* ShellDB_ShellConfiguration::mutable_shell_identifier() {
  std::string* _s = _internal_mutable_shell_identifier();
  // @@protoc_insertion_point(field_mutable:ei.ShellDB.ShellConfiguration.shell_identifier)
  return _s;
}
inline const std::string& ShellDB_ShellConfiguration::_internal_shell_identifier() const {
  return shell_identifier_.Get();
}
inline void ShellDB_ShellConfiguration::_internal_set_shell_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  shell_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShellDB_ShellConfiguration::_internal_mutable_shell_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return shell_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShellDB_ShellConfiguration::release_shell_identifier() {
  // @@protoc_insertion_point(field_release:ei.ShellDB.ShellConfiguration.shell_identifier)
  if (!_internal_has_shell_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = shell_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (shell_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    shell_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShellDB_ShellConfiguration::set_allocated_shell_identifier(std::string* shell_identifier) {
  if (shell_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  shell_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), shell_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (shell_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    shell_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ShellDB.ShellConfiguration.shell_identifier)
}

// -------------------------------------------------------------------

// ShellDB_ShellSetConfiguration

// optional .ei.ShellDB.FarmElement element = 1;
inline bool ShellDB_ShellSetConfiguration::_internal_has_element() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ShellDB_ShellSetConfiguration::has_element() const {
  return _internal_has_element();
}
inline void ShellDB_ShellSetConfiguration::clear_element() {
  element_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::ei::ShellDB_FarmElement ShellDB_ShellSetConfiguration::_internal_element() const {
  return static_cast< ::ei::ShellDB_FarmElement >(element_);
}
inline ::ei::ShellDB_FarmElement ShellDB_ShellSetConfiguration::element() const {
  // @@protoc_insertion_point(field_get:ei.ShellDB.ShellSetConfiguration.element)
  return _internal_element();
}
inline void ShellDB_ShellSetConfiguration::_internal_set_element(::ei::ShellDB_FarmElement value) {
  assert(::ei::ShellDB_FarmElement_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  element_ = value;
}
inline void ShellDB_ShellSetConfiguration::set_element(::ei::ShellDB_FarmElement value) {
  _internal_set_element(value);
  // @@protoc_insertion_point(field_set:ei.ShellDB.ShellSetConfiguration.element)
}

// optional uint32 index = 2;
inline bool ShellDB_ShellSetConfiguration::_internal_has_index() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ShellDB_ShellSetConfiguration::has_index() const {
  return _internal_has_index();
}
inline void ShellDB_ShellSetConfiguration::clear_index() {
  index_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t ShellDB_ShellSetConfiguration::_internal_index() const {
  return index_;
}
inline uint32_t ShellDB_ShellSetConfiguration::index() const {
  // @@protoc_insertion_point(field_get:ei.ShellDB.ShellSetConfiguration.index)
  return _internal_index();
}
inline void ShellDB_ShellSetConfiguration::_internal_set_index(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  index_ = value;
}
inline void ShellDB_ShellSetConfiguration::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:ei.ShellDB.ShellSetConfiguration.index)
}

// optional string shell_set_identifier = 3;
inline bool ShellDB_ShellSetConfiguration::_internal_has_shell_set_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShellDB_ShellSetConfiguration::has_shell_set_identifier() const {
  return _internal_has_shell_set_identifier();
}
inline void ShellDB_ShellSetConfiguration::clear_shell_set_identifier() {
  shell_set_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ShellDB_ShellSetConfiguration::shell_set_identifier() const {
  // @@protoc_insertion_point(field_get:ei.ShellDB.ShellSetConfiguration.shell_set_identifier)
  return _internal_shell_set_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShellDB_ShellSetConfiguration::set_shell_set_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 shell_set_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ShellDB.ShellSetConfiguration.shell_set_identifier)
}
inline std::string* ShellDB_ShellSetConfiguration::mutable_shell_set_identifier() {
  std::string* _s = _internal_mutable_shell_set_identifier();
  // @@protoc_insertion_point(field_mutable:ei.ShellDB.ShellSetConfiguration.shell_set_identifier)
  return _s;
}
inline const std::string& ShellDB_ShellSetConfiguration::_internal_shell_set_identifier() const {
  return shell_set_identifier_.Get();
}
inline void ShellDB_ShellSetConfiguration::_internal_set_shell_set_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  shell_set_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShellDB_ShellSetConfiguration::_internal_mutable_shell_set_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return shell_set_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShellDB_ShellSetConfiguration::release_shell_set_identifier() {
  // @@protoc_insertion_point(field_release:ei.ShellDB.ShellSetConfiguration.shell_set_identifier)
  if (!_internal_has_shell_set_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = shell_set_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (shell_set_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    shell_set_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShellDB_ShellSetConfiguration::set_allocated_shell_set_identifier(std::string* shell_set_identifier) {
  if (shell_set_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  shell_set_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), shell_set_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (shell_set_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    shell_set_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ShellDB.ShellSetConfiguration.shell_set_identifier)
}

// optional string variation_identifier = 4;
inline bool ShellDB_ShellSetConfiguration::_internal_has_variation_identifier() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShellDB_ShellSetConfiguration::has_variation_identifier() const {
  return _internal_has_variation_identifier();
}
inline void ShellDB_ShellSetConfiguration::clear_variation_identifier() {
  variation_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ShellDB_ShellSetConfiguration::variation_identifier() const {
  // @@protoc_insertion_point(field_get:ei.ShellDB.ShellSetConfiguration.variation_identifier)
  return _internal_variation_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShellDB_ShellSetConfiguration::set_variation_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 variation_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ShellDB.ShellSetConfiguration.variation_identifier)
}
inline std::string* ShellDB_ShellSetConfiguration::mutable_variation_identifier() {
  std::string* _s = _internal_mutable_variation_identifier();
  // @@protoc_insertion_point(field_mutable:ei.ShellDB.ShellSetConfiguration.variation_identifier)
  return _s;
}
inline const std::string& ShellDB_ShellSetConfiguration::_internal_variation_identifier() const {
  return variation_identifier_.Get();
}
inline void ShellDB_ShellSetConfiguration::_internal_set_variation_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  variation_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShellDB_ShellSetConfiguration::_internal_mutable_variation_identifier() {
  _has_bits_[0] |= 0x00000002u;
  return variation_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShellDB_ShellSetConfiguration::release_variation_identifier() {
  // @@protoc_insertion_point(field_release:ei.ShellDB.ShellSetConfiguration.variation_identifier)
  if (!_internal_has_variation_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = variation_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (variation_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    variation_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShellDB_ShellSetConfiguration::set_allocated_variation_identifier(std::string* variation_identifier) {
  if (variation_identifier != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  variation_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), variation_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (variation_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    variation_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ShellDB.ShellSetConfiguration.variation_identifier)
}

// optional string decorator_identifier = 5;
inline bool ShellDB_ShellSetConfiguration::_internal_has_decorator_identifier() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ShellDB_ShellSetConfiguration::has_decorator_identifier() const {
  return _internal_has_decorator_identifier();
}
inline void ShellDB_ShellSetConfiguration::clear_decorator_identifier() {
  decorator_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ShellDB_ShellSetConfiguration::decorator_identifier() const {
  // @@protoc_insertion_point(field_get:ei.ShellDB.ShellSetConfiguration.decorator_identifier)
  return _internal_decorator_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShellDB_ShellSetConfiguration::set_decorator_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 decorator_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ShellDB.ShellSetConfiguration.decorator_identifier)
}
inline std::string* ShellDB_ShellSetConfiguration::mutable_decorator_identifier() {
  std::string* _s = _internal_mutable_decorator_identifier();
  // @@protoc_insertion_point(field_mutable:ei.ShellDB.ShellSetConfiguration.decorator_identifier)
  return _s;
}
inline const std::string& ShellDB_ShellSetConfiguration::_internal_decorator_identifier() const {
  return decorator_identifier_.Get();
}
inline void ShellDB_ShellSetConfiguration::_internal_set_decorator_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  decorator_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShellDB_ShellSetConfiguration::_internal_mutable_decorator_identifier() {
  _has_bits_[0] |= 0x00000004u;
  return decorator_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShellDB_ShellSetConfiguration::release_decorator_identifier() {
  // @@protoc_insertion_point(field_release:ei.ShellDB.ShellSetConfiguration.decorator_identifier)
  if (!_internal_has_decorator_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = decorator_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (decorator_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    decorator_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShellDB_ShellSetConfiguration::set_allocated_decorator_identifier(std::string* decorator_identifier) {
  if (decorator_identifier != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  decorator_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), decorator_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (decorator_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    decorator_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ShellDB.ShellSetConfiguration.decorator_identifier)
}

// -------------------------------------------------------------------

// ShellDB_ShellGroupConfiguration

// optional .ei.ShellSpec.AssetType asset_type = 1;
inline bool ShellDB_ShellGroupConfiguration::_internal_has_asset_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShellDB_ShellGroupConfiguration::has_asset_type() const {
  return _internal_has_asset_type();
}
inline void ShellDB_ShellGroupConfiguration::clear_asset_type() {
  asset_type_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::ei::ShellSpec_AssetType ShellDB_ShellGroupConfiguration::_internal_asset_type() const {
  return static_cast< ::ei::ShellSpec_AssetType >(asset_type_);
}
inline ::ei::ShellSpec_AssetType ShellDB_ShellGroupConfiguration::asset_type() const {
  // @@protoc_insertion_point(field_get:ei.ShellDB.ShellGroupConfiguration.asset_type)
  return _internal_asset_type();
}
inline void ShellDB_ShellGroupConfiguration::_internal_set_asset_type(::ei::ShellSpec_AssetType value) {
  assert(::ei::ShellSpec_AssetType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  asset_type_ = value;
}
inline void ShellDB_ShellGroupConfiguration::set_asset_type(::ei::ShellSpec_AssetType value) {
  _internal_set_asset_type(value);
  // @@protoc_insertion_point(field_set:ei.ShellDB.ShellGroupConfiguration.asset_type)
}

// optional string group_identifier = 2;
inline bool ShellDB_ShellGroupConfiguration::_internal_has_group_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShellDB_ShellGroupConfiguration::has_group_identifier() const {
  return _internal_has_group_identifier();
}
inline void ShellDB_ShellGroupConfiguration::clear_group_identifier() {
  group_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ShellDB_ShellGroupConfiguration::group_identifier() const {
  // @@protoc_insertion_point(field_get:ei.ShellDB.ShellGroupConfiguration.group_identifier)
  return _internal_group_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShellDB_ShellGroupConfiguration::set_group_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 group_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ShellDB.ShellGroupConfiguration.group_identifier)
}
inline std::string* ShellDB_ShellGroupConfiguration::mutable_group_identifier() {
  std::string* _s = _internal_mutable_group_identifier();
  // @@protoc_insertion_point(field_mutable:ei.ShellDB.ShellGroupConfiguration.group_identifier)
  return _s;
}
inline const std::string& ShellDB_ShellGroupConfiguration::_internal_group_identifier() const {
  return group_identifier_.Get();
}
inline void ShellDB_ShellGroupConfiguration::_internal_set_group_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  group_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShellDB_ShellGroupConfiguration::_internal_mutable_group_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return group_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShellDB_ShellGroupConfiguration::release_group_identifier() {
  // @@protoc_insertion_point(field_release:ei.ShellDB.ShellGroupConfiguration.group_identifier)
  if (!_internal_has_group_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = group_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (group_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    group_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShellDB_ShellGroupConfiguration::set_allocated_group_identifier(std::string* group_identifier) {
  if (group_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  group_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), group_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (group_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    group_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ShellDB.ShellGroupConfiguration.group_identifier)
}

// -------------------------------------------------------------------

// ShellDB_ChickenConfig

// optional string chicken_identifier = 1;
inline bool ShellDB_ChickenConfig::_internal_has_chicken_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShellDB_ChickenConfig::has_chicken_identifier() const {
  return _internal_has_chicken_identifier();
}
inline void ShellDB_ChickenConfig::clear_chicken_identifier() {
  chicken_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ShellDB_ChickenConfig::chicken_identifier() const {
  // @@protoc_insertion_point(field_get:ei.ShellDB.ChickenConfig.chicken_identifier)
  return _internal_chicken_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShellDB_ChickenConfig::set_chicken_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 chicken_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ShellDB.ChickenConfig.chicken_identifier)
}
inline std::string* ShellDB_ChickenConfig::mutable_chicken_identifier() {
  std::string* _s = _internal_mutable_chicken_identifier();
  // @@protoc_insertion_point(field_mutable:ei.ShellDB.ChickenConfig.chicken_identifier)
  return _s;
}
inline const std::string& ShellDB_ChickenConfig::_internal_chicken_identifier() const {
  return chicken_identifier_.Get();
}
inline void ShellDB_ChickenConfig::_internal_set_chicken_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  chicken_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShellDB_ChickenConfig::_internal_mutable_chicken_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return chicken_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShellDB_ChickenConfig::release_chicken_identifier() {
  // @@protoc_insertion_point(field_release:ei.ShellDB.ChickenConfig.chicken_identifier)
  if (!_internal_has_chicken_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = chicken_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (chicken_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    chicken_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShellDB_ChickenConfig::set_allocated_chicken_identifier(std::string* chicken_identifier) {
  if (chicken_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  chicken_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chicken_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (chicken_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    chicken_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ShellDB.ChickenConfig.chicken_identifier)
}

// optional string hat_identifier = 2;
inline bool ShellDB_ChickenConfig::_internal_has_hat_identifier() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShellDB_ChickenConfig::has_hat_identifier() const {
  return _internal_has_hat_identifier();
}
inline void ShellDB_ChickenConfig::clear_hat_identifier() {
  hat_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ShellDB_ChickenConfig::hat_identifier() const {
  // @@protoc_insertion_point(field_get:ei.ShellDB.ChickenConfig.hat_identifier)
  return _internal_hat_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShellDB_ChickenConfig::set_hat_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 hat_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ShellDB.ChickenConfig.hat_identifier)
}
inline std::string* ShellDB_ChickenConfig::mutable_hat_identifier() {
  std::string* _s = _internal_mutable_hat_identifier();
  // @@protoc_insertion_point(field_mutable:ei.ShellDB.ChickenConfig.hat_identifier)
  return _s;
}
inline const std::string& ShellDB_ChickenConfig::_internal_hat_identifier() const {
  return hat_identifier_.Get();
}
inline void ShellDB_ChickenConfig::_internal_set_hat_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  hat_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShellDB_ChickenConfig::_internal_mutable_hat_identifier() {
  _has_bits_[0] |= 0x00000002u;
  return hat_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShellDB_ChickenConfig::release_hat_identifier() {
  // @@protoc_insertion_point(field_release:ei.ShellDB.ChickenConfig.hat_identifier)
  if (!_internal_has_hat_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = hat_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hat_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hat_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShellDB_ChickenConfig::set_allocated_hat_identifier(std::string* hat_identifier) {
  if (hat_identifier != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  hat_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hat_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hat_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hat_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ShellDB.ChickenConfig.hat_identifier)
}

// -------------------------------------------------------------------

// ShellDB

// repeated .ei.ShellDB.ShellStatus shell_inventory = 1;
inline int ShellDB::_internal_shell_inventory_size() const {
  return shell_inventory_.size();
}
inline int ShellDB::shell_inventory_size() const {
  return _internal_shell_inventory_size();
}
inline void ShellDB::clear_shell_inventory() {
  shell_inventory_.Clear();
}
inline ::ei::ShellDB_ShellStatus* ShellDB::mutable_shell_inventory(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ShellDB.shell_inventory)
  return shell_inventory_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellStatus >*
ShellDB::mutable_shell_inventory() {
  // @@protoc_insertion_point(field_mutable_list:ei.ShellDB.shell_inventory)
  return &shell_inventory_;
}
inline const ::ei::ShellDB_ShellStatus& ShellDB::_internal_shell_inventory(int index) const {
  return shell_inventory_.Get(index);
}
inline const ::ei::ShellDB_ShellStatus& ShellDB::shell_inventory(int index) const {
  // @@protoc_insertion_point(field_get:ei.ShellDB.shell_inventory)
  return _internal_shell_inventory(index);
}
inline ::ei::ShellDB_ShellStatus* ShellDB::_internal_add_shell_inventory() {
  return shell_inventory_.Add();
}
inline ::ei::ShellDB_ShellStatus* ShellDB::add_shell_inventory() {
  ::ei::ShellDB_ShellStatus* _add = _internal_add_shell_inventory();
  // @@protoc_insertion_point(field_add:ei.ShellDB.shell_inventory)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellStatus >&
ShellDB::shell_inventory() const {
  // @@protoc_insertion_point(field_list:ei.ShellDB.shell_inventory)
  return shell_inventory_;
}

// repeated .ei.ShellDB.ShellElementStatus shell_element_inventory = 5;
inline int ShellDB::_internal_shell_element_inventory_size() const {
  return shell_element_inventory_.size();
}
inline int ShellDB::shell_element_inventory_size() const {
  return _internal_shell_element_inventory_size();
}
inline void ShellDB::clear_shell_element_inventory() {
  shell_element_inventory_.Clear();
}
inline ::ei::ShellDB_ShellElementStatus* ShellDB::mutable_shell_element_inventory(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ShellDB.shell_element_inventory)
  return shell_element_inventory_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellElementStatus >*
ShellDB::mutable_shell_element_inventory() {
  // @@protoc_insertion_point(field_mutable_list:ei.ShellDB.shell_element_inventory)
  return &shell_element_inventory_;
}
inline const ::ei::ShellDB_ShellElementStatus& ShellDB::_internal_shell_element_inventory(int index) const {
  return shell_element_inventory_.Get(index);
}
inline const ::ei::ShellDB_ShellElementStatus& ShellDB::shell_element_inventory(int index) const {
  // @@protoc_insertion_point(field_get:ei.ShellDB.shell_element_inventory)
  return _internal_shell_element_inventory(index);
}
inline ::ei::ShellDB_ShellElementStatus* ShellDB::_internal_add_shell_element_inventory() {
  return shell_element_inventory_.Add();
}
inline ::ei::ShellDB_ShellElementStatus* ShellDB::add_shell_element_inventory() {
  ::ei::ShellDB_ShellElementStatus* _add = _internal_add_shell_element_inventory();
  // @@protoc_insertion_point(field_add:ei.ShellDB.shell_element_inventory)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellElementStatus >&
ShellDB::shell_element_inventory() const {
  // @@protoc_insertion_point(field_list:ei.ShellDB.shell_element_inventory)
  return shell_element_inventory_;
}

// repeated .ei.ShellDB.ShellSetVariationStatus shell_variation_inventory = 8;
inline int ShellDB::_internal_shell_variation_inventory_size() const {
  return shell_variation_inventory_.size();
}
inline int ShellDB::shell_variation_inventory_size() const {
  return _internal_shell_variation_inventory_size();
}
inline void ShellDB::clear_shell_variation_inventory() {
  shell_variation_inventory_.Clear();
}
inline ::ei::ShellDB_ShellSetVariationStatus* ShellDB::mutable_shell_variation_inventory(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ShellDB.shell_variation_inventory)
  return shell_variation_inventory_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellSetVariationStatus >*
ShellDB::mutable_shell_variation_inventory() {
  // @@protoc_insertion_point(field_mutable_list:ei.ShellDB.shell_variation_inventory)
  return &shell_variation_inventory_;
}
inline const ::ei::ShellDB_ShellSetVariationStatus& ShellDB::_internal_shell_variation_inventory(int index) const {
  return shell_variation_inventory_.Get(index);
}
inline const ::ei::ShellDB_ShellSetVariationStatus& ShellDB::shell_variation_inventory(int index) const {
  // @@protoc_insertion_point(field_get:ei.ShellDB.shell_variation_inventory)
  return _internal_shell_variation_inventory(index);
}
inline ::ei::ShellDB_ShellSetVariationStatus* ShellDB::_internal_add_shell_variation_inventory() {
  return shell_variation_inventory_.Add();
}
inline ::ei::ShellDB_ShellSetVariationStatus* ShellDB::add_shell_variation_inventory() {
  ::ei::ShellDB_ShellSetVariationStatus* _add = _internal_add_shell_variation_inventory();
  // @@protoc_insertion_point(field_add:ei.ShellDB.shell_variation_inventory)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellSetVariationStatus >&
ShellDB::shell_variation_inventory() const {
  // @@protoc_insertion_point(field_list:ei.ShellDB.shell_variation_inventory)
  return shell_variation_inventory_;
}

// repeated .ei.ShellDB.ShellStatus shell_set_inventory = 2;
inline int ShellDB::_internal_shell_set_inventory_size() const {
  return shell_set_inventory_.size();
}
inline int ShellDB::shell_set_inventory_size() const {
  return _internal_shell_set_inventory_size();
}
inline void ShellDB::clear_shell_set_inventory() {
  shell_set_inventory_.Clear();
}
inline ::ei::ShellDB_ShellStatus* ShellDB::mutable_shell_set_inventory(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ShellDB.shell_set_inventory)
  return shell_set_inventory_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellStatus >*
ShellDB::mutable_shell_set_inventory() {
  // @@protoc_insertion_point(field_mutable_list:ei.ShellDB.shell_set_inventory)
  return &shell_set_inventory_;
}
inline const ::ei::ShellDB_ShellStatus& ShellDB::_internal_shell_set_inventory(int index) const {
  return shell_set_inventory_.Get(index);
}
inline const ::ei::ShellDB_ShellStatus& ShellDB::shell_set_inventory(int index) const {
  // @@protoc_insertion_point(field_get:ei.ShellDB.shell_set_inventory)
  return _internal_shell_set_inventory(index);
}
inline ::ei::ShellDB_ShellStatus* ShellDB::_internal_add_shell_set_inventory() {
  return shell_set_inventory_.Add();
}
inline ::ei::ShellDB_ShellStatus* ShellDB::add_shell_set_inventory() {
  ::ei::ShellDB_ShellStatus* _add = _internal_add_shell_set_inventory();
  // @@protoc_insertion_point(field_add:ei.ShellDB.shell_set_inventory)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellStatus >&
ShellDB::shell_set_inventory() const {
  // @@protoc_insertion_point(field_list:ei.ShellDB.shell_set_inventory)
  return shell_set_inventory_;
}

// repeated .ei.ShellDB.ShellStatus shell_object_inventory = 4;
inline int ShellDB::_internal_shell_object_inventory_size() const {
  return shell_object_inventory_.size();
}
inline int ShellDB::shell_object_inventory_size() const {
  return _internal_shell_object_inventory_size();
}
inline void ShellDB::clear_shell_object_inventory() {
  shell_object_inventory_.Clear();
}
inline ::ei::ShellDB_ShellStatus* ShellDB::mutable_shell_object_inventory(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ShellDB.shell_object_inventory)
  return shell_object_inventory_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellStatus >*
ShellDB::mutable_shell_object_inventory() {
  // @@protoc_insertion_point(field_mutable_list:ei.ShellDB.shell_object_inventory)
  return &shell_object_inventory_;
}
inline const ::ei::ShellDB_ShellStatus& ShellDB::_internal_shell_object_inventory(int index) const {
  return shell_object_inventory_.Get(index);
}
inline const ::ei::ShellDB_ShellStatus& ShellDB::shell_object_inventory(int index) const {
  // @@protoc_insertion_point(field_get:ei.ShellDB.shell_object_inventory)
  return _internal_shell_object_inventory(index);
}
inline ::ei::ShellDB_ShellStatus* ShellDB::_internal_add_shell_object_inventory() {
  return shell_object_inventory_.Add();
}
inline ::ei::ShellDB_ShellStatus* ShellDB::add_shell_object_inventory() {
  ::ei::ShellDB_ShellStatus* _add = _internal_add_shell_object_inventory();
  // @@protoc_insertion_point(field_add:ei.ShellDB.shell_object_inventory)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_ShellStatus >&
ShellDB::shell_object_inventory() const {
  // @@protoc_insertion_point(field_list:ei.ShellDB.shell_object_inventory)
  return shell_object_inventory_;
}

// repeated .ei.ShellDB.FarmConfiguration farm_configs = 3;
inline int ShellDB::_internal_farm_configs_size() const {
  return farm_configs_.size();
}
inline int ShellDB::farm_configs_size() const {
  return _internal_farm_configs_size();
}
inline void ShellDB::clear_farm_configs() {
  farm_configs_.Clear();
}
inline ::ei::ShellDB_FarmConfiguration* ShellDB::mutable_farm_configs(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ShellDB.farm_configs)
  return farm_configs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_FarmConfiguration >*
ShellDB::mutable_farm_configs() {
  // @@protoc_insertion_point(field_mutable_list:ei.ShellDB.farm_configs)
  return &farm_configs_;
}
inline const ::ei::ShellDB_FarmConfiguration& ShellDB::_internal_farm_configs(int index) const {
  return farm_configs_.Get(index);
}
inline const ::ei::ShellDB_FarmConfiguration& ShellDB::farm_configs(int index) const {
  // @@protoc_insertion_point(field_get:ei.ShellDB.farm_configs)
  return _internal_farm_configs(index);
}
inline ::ei::ShellDB_FarmConfiguration* ShellDB::_internal_add_farm_configs() {
  return farm_configs_.Add();
}
inline ::ei::ShellDB_FarmConfiguration* ShellDB::add_farm_configs() {
  ::ei::ShellDB_FarmConfiguration* _add = _internal_add_farm_configs();
  // @@protoc_insertion_point(field_add:ei.ShellDB.farm_configs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ei::ShellDB_FarmConfiguration >&
ShellDB::farm_configs() const {
  // @@protoc_insertion_point(field_list:ei.ShellDB.farm_configs)
  return farm_configs_;
}

// repeated string new_shells_downloaded = 6;
inline int ShellDB::_internal_new_shells_downloaded_size() const {
  return new_shells_downloaded_.size();
}
inline int ShellDB::new_shells_downloaded_size() const {
  return _internal_new_shells_downloaded_size();
}
inline void ShellDB::clear_new_shells_downloaded() {
  new_shells_downloaded_.Clear();
}
inline std::string* ShellDB::add_new_shells_downloaded() {
  std::string* _s = _internal_add_new_shells_downloaded();
  // @@protoc_insertion_point(field_add_mutable:ei.ShellDB.new_shells_downloaded)
  return _s;
}
inline const std::string& ShellDB::_internal_new_shells_downloaded(int index) const {
  return new_shells_downloaded_.Get(index);
}
inline const std::string& ShellDB::new_shells_downloaded(int index) const {
  // @@protoc_insertion_point(field_get:ei.ShellDB.new_shells_downloaded)
  return _internal_new_shells_downloaded(index);
}
inline std::string* ShellDB::mutable_new_shells_downloaded(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ShellDB.new_shells_downloaded)
  return new_shells_downloaded_.Mutable(index);
}
inline void ShellDB::set_new_shells_downloaded(int index, const std::string& value) {
  new_shells_downloaded_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ei.ShellDB.new_shells_downloaded)
}
inline void ShellDB::set_new_shells_downloaded(int index, std::string&& value) {
  new_shells_downloaded_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ei.ShellDB.new_shells_downloaded)
}
inline void ShellDB::set_new_shells_downloaded(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  new_shells_downloaded_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ei.ShellDB.new_shells_downloaded)
}
inline void ShellDB::set_new_shells_downloaded(int index, const char* value, size_t size) {
  new_shells_downloaded_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ei.ShellDB.new_shells_downloaded)
}
inline std::string* ShellDB::_internal_add_new_shells_downloaded() {
  return new_shells_downloaded_.Add();
}
inline void ShellDB::add_new_shells_downloaded(const std::string& value) {
  new_shells_downloaded_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ei.ShellDB.new_shells_downloaded)
}
inline void ShellDB::add_new_shells_downloaded(std::string&& value) {
  new_shells_downloaded_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ei.ShellDB.new_shells_downloaded)
}
inline void ShellDB::add_new_shells_downloaded(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  new_shells_downloaded_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ei.ShellDB.new_shells_downloaded)
}
inline void ShellDB::add_new_shells_downloaded(const char* value, size_t size) {
  new_shells_downloaded_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ei.ShellDB.new_shells_downloaded)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ShellDB::new_shells_downloaded() const {
  // @@protoc_insertion_point(field_list:ei.ShellDB.new_shells_downloaded)
  return new_shells_downloaded_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ShellDB::mutable_new_shells_downloaded() {
  // @@protoc_insertion_point(field_mutable_list:ei.ShellDB.new_shells_downloaded)
  return &new_shells_downloaded_;
}

// repeated string new_shells_seen = 7;
inline int ShellDB::_internal_new_shells_seen_size() const {
  return new_shells_seen_.size();
}
inline int ShellDB::new_shells_seen_size() const {
  return _internal_new_shells_seen_size();
}
inline void ShellDB::clear_new_shells_seen() {
  new_shells_seen_.Clear();
}
inline std::string* ShellDB::add_new_shells_seen() {
  std::string* _s = _internal_add_new_shells_seen();
  // @@protoc_insertion_point(field_add_mutable:ei.ShellDB.new_shells_seen)
  return _s;
}
inline const std::string& ShellDB::_internal_new_shells_seen(int index) const {
  return new_shells_seen_.Get(index);
}
inline const std::string& ShellDB::new_shells_seen(int index) const {
  // @@protoc_insertion_point(field_get:ei.ShellDB.new_shells_seen)
  return _internal_new_shells_seen(index);
}
inline std::string* ShellDB::mutable_new_shells_seen(int index) {
  // @@protoc_insertion_point(field_mutable:ei.ShellDB.new_shells_seen)
  return new_shells_seen_.Mutable(index);
}
inline void ShellDB::set_new_shells_seen(int index, const std::string& value) {
  new_shells_seen_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ei.ShellDB.new_shells_seen)
}
inline void ShellDB::set_new_shells_seen(int index, std::string&& value) {
  new_shells_seen_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ei.ShellDB.new_shells_seen)
}
inline void ShellDB::set_new_shells_seen(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  new_shells_seen_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ei.ShellDB.new_shells_seen)
}
inline void ShellDB::set_new_shells_seen(int index, const char* value, size_t size) {
  new_shells_seen_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ei.ShellDB.new_shells_seen)
}
inline std::string* ShellDB::_internal_add_new_shells_seen() {
  return new_shells_seen_.Add();
}
inline void ShellDB::add_new_shells_seen(const std::string& value) {
  new_shells_seen_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ei.ShellDB.new_shells_seen)
}
inline void ShellDB::add_new_shells_seen(std::string&& value) {
  new_shells_seen_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ei.ShellDB.new_shells_seen)
}
inline void ShellDB::add_new_shells_seen(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  new_shells_seen_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ei.ShellDB.new_shells_seen)
}
inline void ShellDB::add_new_shells_seen(const char* value, size_t size) {
  new_shells_seen_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ei.ShellDB.new_shells_seen)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ShellDB::new_shells_seen() const {
  // @@protoc_insertion_point(field_list:ei.ShellDB.new_shells_seen)
  return new_shells_seen_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ShellDB::mutable_new_shells_seen() {
  // @@protoc_insertion_point(field_mutable_list:ei.ShellDB.new_shells_seen)
  return &new_shells_seen_;
}

// -------------------------------------------------------------------

// ShellsActionLog

// optional .ei.BasicRequestInfo rinfo = 8;
inline bool ShellsActionLog::_internal_has_rinfo() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || rinfo_ != nullptr);
  return value;
}
inline bool ShellsActionLog::has_rinfo() const {
  return _internal_has_rinfo();
}
inline void ShellsActionLog::clear_rinfo() {
  if (rinfo_ != nullptr) rinfo_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::ei::BasicRequestInfo& ShellsActionLog::_internal_rinfo() const {
  const ::ei::BasicRequestInfo* p = rinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ei::BasicRequestInfo&>(
      ::ei::_BasicRequestInfo_default_instance_);
}
inline const ::ei::BasicRequestInfo& ShellsActionLog::rinfo() const {
  // @@protoc_insertion_point(field_get:ei.ShellsActionLog.rinfo)
  return _internal_rinfo();
}
inline void ShellsActionLog::unsafe_arena_set_allocated_rinfo(
    ::ei::BasicRequestInfo* rinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rinfo_);
  }
  rinfo_ = rinfo;
  if (rinfo) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ei.ShellsActionLog.rinfo)
}
inline ::ei::BasicRequestInfo* ShellsActionLog::release_rinfo() {
  _has_bits_[0] &= ~0x00000010u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ei::BasicRequestInfo* ShellsActionLog::unsafe_arena_release_rinfo() {
  // @@protoc_insertion_point(field_release:ei.ShellsActionLog.rinfo)
  _has_bits_[0] &= ~0x00000010u;
  ::ei::BasicRequestInfo* temp = rinfo_;
  rinfo_ = nullptr;
  return temp;
}
inline ::ei::BasicRequestInfo* ShellsActionLog::_internal_mutable_rinfo() {
  _has_bits_[0] |= 0x00000010u;
  if (rinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ei::BasicRequestInfo>(GetArenaForAllocation());
    rinfo_ = p;
  }
  return rinfo_;
}
inline ::ei::BasicRequestInfo* ShellsActionLog::mutable_rinfo() {
  ::ei::BasicRequestInfo* _msg = _internal_mutable_rinfo();
  // @@protoc_insertion_point(field_mutable:ei.ShellsActionLog.rinfo)
  return _msg;
}
inline void ShellsActionLog::set_allocated_rinfo(::ei::BasicRequestInfo* rinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rinfo_;
  }
  if (rinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ei::BasicRequestInfo>::GetOwningArena(rinfo);
    if (message_arena != submessage_arena) {
      rinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  rinfo_ = rinfo;
  // @@protoc_insertion_point(field_set_allocated:ei.ShellsActionLog.rinfo)
}

// optional string user_id = 1;
inline bool ShellsActionLog::_internal_has_user_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShellsActionLog::has_user_id() const {
  return _internal_has_user_id();
}
inline void ShellsActionLog::clear_user_id() {
  user_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ShellsActionLog::user_id() const {
  // @@protoc_insertion_point(field_get:ei.ShellsActionLog.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShellsActionLog::set_user_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ShellsActionLog.user_id)
}
inline std::string* ShellsActionLog::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:ei.ShellsActionLog.user_id)
  return _s;
}
inline const std::string& ShellsActionLog::_internal_user_id() const {
  return user_id_.Get();
}
inline void ShellsActionLog::_internal_set_user_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShellsActionLog::_internal_mutable_user_id() {
  _has_bits_[0] |= 0x00000001u;
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShellsActionLog::release_user_id() {
  // @@protoc_insertion_point(field_release:ei.ShellsActionLog.user_id)
  if (!_internal_has_user_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = user_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShellsActionLog::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ShellsActionLog.user_id)
}

// optional string action = 2;
inline bool ShellsActionLog::_internal_has_action() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShellsActionLog::has_action() const {
  return _internal_has_action();
}
inline void ShellsActionLog::clear_action() {
  action_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ShellsActionLog::action() const {
  // @@protoc_insertion_point(field_get:ei.ShellsActionLog.action)
  return _internal_action();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShellsActionLog::set_action(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 action_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ShellsActionLog.action)
}
inline std::string* ShellsActionLog::mutable_action() {
  std::string* _s = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:ei.ShellsActionLog.action)
  return _s;
}
inline const std::string& ShellsActionLog::_internal_action() const {
  return action_.Get();
}
inline void ShellsActionLog::_internal_set_action(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  action_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShellsActionLog::_internal_mutable_action() {
  _has_bits_[0] |= 0x00000002u;
  return action_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShellsActionLog::release_action() {
  // @@protoc_insertion_point(field_release:ei.ShellsActionLog.action)
  if (!_internal_has_action()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = action_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (action_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    action_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShellsActionLog::set_allocated_action(std::string* action) {
  if (action != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  action_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), action,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (action_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    action_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ShellsActionLog.action)
}

// optional string sub_id = 3;
inline bool ShellsActionLog::_internal_has_sub_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ShellsActionLog::has_sub_id() const {
  return _internal_has_sub_id();
}
inline void ShellsActionLog::clear_sub_id() {
  sub_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ShellsActionLog::sub_id() const {
  // @@protoc_insertion_point(field_get:ei.ShellsActionLog.sub_id)
  return _internal_sub_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShellsActionLog::set_sub_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 sub_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ShellsActionLog.sub_id)
}
inline std::string* ShellsActionLog::mutable_sub_id() {
  std::string* _s = _internal_mutable_sub_id();
  // @@protoc_insertion_point(field_mutable:ei.ShellsActionLog.sub_id)
  return _s;
}
inline const std::string& ShellsActionLog::_internal_sub_id() const {
  return sub_id_.Get();
}
inline void ShellsActionLog::_internal_set_sub_id(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  sub_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShellsActionLog::_internal_mutable_sub_id() {
  _has_bits_[0] |= 0x00000004u;
  return sub_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShellsActionLog::release_sub_id() {
  // @@protoc_insertion_point(field_release:ei.ShellsActionLog.sub_id)
  if (!_internal_has_sub_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = sub_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sub_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sub_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShellsActionLog::set_allocated_sub_id(std::string* sub_id) {
  if (sub_id != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  sub_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sub_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sub_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sub_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ShellsActionLog.sub_id)
}

// optional .ei.ShellDB.FarmElement farm_element = 9;
inline bool ShellsActionLog::_internal_has_farm_element() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ShellsActionLog::has_farm_element() const {
  return _internal_has_farm_element();
}
inline void ShellsActionLog::clear_farm_element() {
  farm_element_ = 1;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::ei::ShellDB_FarmElement ShellsActionLog::_internal_farm_element() const {
  return static_cast< ::ei::ShellDB_FarmElement >(farm_element_);
}
inline ::ei::ShellDB_FarmElement ShellsActionLog::farm_element() const {
  // @@protoc_insertion_point(field_get:ei.ShellsActionLog.farm_element)
  return _internal_farm_element();
}
inline void ShellsActionLog::_internal_set_farm_element(::ei::ShellDB_FarmElement value) {
  assert(::ei::ShellDB_FarmElement_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  farm_element_ = value;
}
inline void ShellsActionLog::set_farm_element(::ei::ShellDB_FarmElement value) {
  _internal_set_farm_element(value);
  // @@protoc_insertion_point(field_set:ei.ShellsActionLog.farm_element)
}

// optional uint32 cost = 4;
inline bool ShellsActionLog::_internal_has_cost() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ShellsActionLog::has_cost() const {
  return _internal_has_cost();
}
inline void ShellsActionLog::clear_cost() {
  cost_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t ShellsActionLog::_internal_cost() const {
  return cost_;
}
inline uint32_t ShellsActionLog::cost() const {
  // @@protoc_insertion_point(field_get:ei.ShellsActionLog.cost)
  return _internal_cost();
}
inline void ShellsActionLog::_internal_set_cost(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  cost_ = value;
}
inline void ShellsActionLog::set_cost(uint32_t value) {
  _internal_set_cost(value);
  // @@protoc_insertion_point(field_set:ei.ShellsActionLog.cost)
}

// optional double approx_time = 5;
inline bool ShellsActionLog::_internal_has_approx_time() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ShellsActionLog::has_approx_time() const {
  return _internal_has_approx_time();
}
inline void ShellsActionLog::clear_approx_time() {
  approx_time_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double ShellsActionLog::_internal_approx_time() const {
  return approx_time_;
}
inline double ShellsActionLog::approx_time() const {
  // @@protoc_insertion_point(field_get:ei.ShellsActionLog.approx_time)
  return _internal_approx_time();
}
inline void ShellsActionLog::_internal_set_approx_time(double value) {
  _has_bits_[0] |= 0x00000020u;
  approx_time_ = value;
}
inline void ShellsActionLog::set_approx_time(double value) {
  _internal_set_approx_time(value);
  // @@protoc_insertion_point(field_set:ei.ShellsActionLog.approx_time)
}

// optional string version = 6;
inline bool ShellsActionLog::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ShellsActionLog::has_version() const {
  return _internal_has_version();
}
inline void ShellsActionLog::clear_version() {
  version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ShellsActionLog::version() const {
  // @@protoc_insertion_point(field_get:ei.ShellsActionLog.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShellsActionLog::set_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ei.ShellsActionLog.version)
}
inline std::string* ShellsActionLog::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:ei.ShellsActionLog.version)
  return _s;
}
inline const std::string& ShellsActionLog::_internal_version() const {
  return version_.Get();
}
inline void ShellsActionLog::_internal_set_version(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShellsActionLog::_internal_mutable_version() {
  _has_bits_[0] |= 0x00000008u;
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShellsActionLog::release_version() {
  // @@protoc_insertion_point(field_release:ei.ShellsActionLog.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = version_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShellsActionLog::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ei.ShellsActionLog.version)
}

// optional int32 farm_index = 7;
inline bool ShellsActionLog::_internal_has_farm_index() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ShellsActionLog::has_farm_index() const {
  return _internal_has_farm_index();
}
inline void ShellsActionLog::clear_farm_index() {
  farm_index_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline int32_t ShellsActionLog::_internal_farm_index() const {
  return farm_index_;
}
inline int32_t ShellsActionLog::farm_index() const {
  // @@protoc_insertion_point(field_get:ei.ShellsActionLog.farm_index)
  return _internal_farm_index();
}
inline void ShellsActionLog::_internal_set_farm_index(int32_t value) {
  _has_bits_[0] |= 0x00000080u;
  farm_index_ = value;
}
inline void ShellsActionLog::set_farm_index(int32_t value) {
  _internal_set_farm_index(value);
  // @@protoc_insertion_point(field_set:ei.ShellsActionLog.farm_index)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ei

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ei::EggIncFirstContactResponse_ErrorCodes> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ei::EggIncFirstContactResponse_ErrorCodes>() {
  return ::ei::EggIncFirstContactResponse_ErrorCodes_descriptor();
}
template <> struct is_proto_enum< ::ei::ContractCoopStatusResponse_MemberStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ei::ContractCoopStatusResponse_MemberStatus>() {
  return ::ei::ContractCoopStatusResponse_MemberStatus_descriptor();
}
template <> struct is_proto_enum< ::ei::KickPlayerCoopRequest_Reason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ei::KickPlayerCoopRequest_Reason>() {
  return ::ei::KickPlayerCoopRequest_Reason_descriptor();
}
template <> struct is_proto_enum< ::ei::MissionInfo_Spaceship> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ei::MissionInfo_Spaceship>() {
  return ::ei::MissionInfo_Spaceship_descriptor();
}
template <> struct is_proto_enum< ::ei::MissionInfo_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ei::MissionInfo_Status>() {
  return ::ei::MissionInfo_Status_descriptor();
}
template <> struct is_proto_enum< ::ei::MissionInfo_DurationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ei::MissionInfo_DurationType>() {
  return ::ei::MissionInfo_DurationType_descriptor();
}
template <> struct is_proto_enum< ::ei::ArtifactSpec_Name> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ei::ArtifactSpec_Name>() {
  return ::ei::ArtifactSpec_Name_descriptor();
}
template <> struct is_proto_enum< ::ei::ArtifactSpec_Level> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ei::ArtifactSpec_Level>() {
  return ::ei::ArtifactSpec_Level_descriptor();
}
template <> struct is_proto_enum< ::ei::ArtifactSpec_Rarity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ei::ArtifactSpec_Rarity>() {
  return ::ei::ArtifactSpec_Rarity_descriptor();
}
template <> struct is_proto_enum< ::ei::ArtifactSpec_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ei::ArtifactSpec_Type>() {
  return ::ei::ArtifactSpec_Type_descriptor();
}
template <> struct is_proto_enum< ::ei::SaveBackupResponse_ErrorCodes> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ei::SaveBackupResponse_ErrorCodes>() {
  return ::ei::SaveBackupResponse_ErrorCodes_descriptor();
}
template <> struct is_proto_enum< ::ei::ShellSpec_AssetType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ei::ShellSpec_AssetType>() {
  return ::ei::ShellSpec_AssetType_descriptor();
}
template <> struct is_proto_enum< ::ei::ShellDB_FarmElement> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ei::ShellDB_FarmElement>() {
  return ::ei::ShellDB_FarmElement_descriptor();
}
template <> struct is_proto_enum< ::ei::Platform> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ei::Platform>() {
  return ::ei::Platform_descriptor();
}
template <> struct is_proto_enum< ::ei::DeviceFormFactor> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ei::DeviceFormFactor>() {
  return ::ei::DeviceFormFactor_descriptor();
}
template <> struct is_proto_enum< ::ei::AdNetwork> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ei::AdNetwork>() {
  return ::ei::AdNetwork_descriptor();
}
template <> struct is_proto_enum< ::ei::Egg> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ei::Egg>() {
  return ::ei::Egg_descriptor();
}
template <> struct is_proto_enum< ::ei::FarmType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ei::FarmType>() {
  return ::ei::FarmType_descriptor();
}
template <> struct is_proto_enum< ::ei::GoalType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ei::GoalType>() {
  return ::ei::GoalType_descriptor();
}
template <> struct is_proto_enum< ::ei::RewardType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ei::RewardType>() {
  return ::ei::RewardType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ei_2eproto
