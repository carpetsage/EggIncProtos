// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ei.proto

#include "ei.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace ei {
PROTOBUF_CONSTEXPR Backup_Settings::Backup_Settings(
    ::_pbi::ConstantInitialized)
  : sfx_(false)
  , music_(false)
  , low_battery_mode_(false)
  , low_performance_mode_(false)
  , force_touch_chicken_btn_(false)
  , notifications_queried_(false)
  , notifications_on_(false)
  , notify_daily_gift_(false)
  , coppa_queried_(false)
  , coppa_restricted_(false)
  , gdpr_consent_queried_(false)
  , gdpr_age_restricted_(false)
  , last_day_age_queried_(0u)
  , gdpr_consent_given_(false)
  , age_queried_(false)
  , age_restricted_(false)
  , data_collection_consent_queried_(false)
  , data_collection_consent_given_(false)
  , low_performance_(false)
  , auto_stop_fueling_(false)
  , last_backup_time_(0)
  , user_ads_enabled_(true)
  , user_cloud_enabled_(true)
  , user_analytics_enabled_(true)
  , user_personalized_ads_enabled_(true){}
struct Backup_SettingsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Backup_SettingsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Backup_SettingsDefaultTypeInternal() {}
  union {
    Backup_Settings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Backup_SettingsDefaultTypeInternal _Backup_Settings_default_instance_;
PROTOBUF_CONSTEXPR Backup_Tutorial::Backup_Tutorial(
    ::_pbi::ConstantInitialized)
  : tutorial_shown_()
  , intro_shown_(false)
  , click_tutorial_shown_(false)
  , buy_hab_shown_(false)
  , hire_vehicle_shown_(false)
  , q_num_shown_(false)
  , s_num_shown_(false)
  , contracts_tab_shown_(false)
  , contract_info_shown_(false)
  , join_coop_shown_(false)
  , switch_farm_shown_(false){}
struct Backup_TutorialDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Backup_TutorialDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Backup_TutorialDefaultTypeInternal() {}
  union {
    Backup_Tutorial _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Backup_TutorialDefaultTypeInternal _Backup_Tutorial_default_instance_;
PROTOBUF_CONSTEXPR Backup_Stats::Backup_Stats(
    ::_pbi::ConstantInitialized)
  : egg_totals_old_()
  , egg_totals_()
  , refill_uses_(uint64_t{0u})
  , video_doubler_uses_(uint64_t{0u})
  , warp_1_uses_(uint64_t{0u})
  , warp_8_uses_(uint64_t{0u})
  , drone_takedowns_(uint64_t{0u})
  , unlimited_chickens_uses_(uint64_t{0u})
  , num_prestiges_(uint64_t{0u})
  , drone_takedowns_elite_(uint64_t{0u})
  , num_piggy_breaks_(uint64_t{0u})
  , iap_packs_purchased_(uint64_t{0u})
  , boosts_used_(uint64_t{0u})
  , time_piggy_filled_realtime_(0)
  , time_piggy_full_gametime_(0)
  , lost_piggy_increments_(uint64_t{0u})
  , piggy_full_(false)
  , piggy_found_full_(false){}
struct Backup_StatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Backup_StatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Backup_StatsDefaultTypeInternal() {}
  union {
    Backup_Stats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Backup_StatsDefaultTypeInternal _Backup_Stats_default_instance_;
PROTOBUF_CONSTEXPR Backup_Game::Backup_Game(
    ::_pbi::ConstantInitialized)
  : epic_research_()
  , news_()
  , achievements_()
  , max_farm_size_reached_()
  , egg_medal_level_()
  , boosts_()
  , golden_eggs_earned_(uint64_t{0u})
  , golden_eggs_spent_(uint64_t{0u})
  , soul_eggs_(uint64_t{0u})
  , prestige_cash_earned_(0)
  , lifetime_cash_earned_(0)
  , piggy_bank_(uint64_t{0u})
  , next_daily_gift_time_(0)
  , last_news_time_(0)
  , current_multiplier_(0)
  , current_multiplier_expiration_(0)
  , permit_level_(0u)
  , last_daily_gift_collected_day_(0u)
  , uncliamed_golden_eggs_(uint64_t{0u})
  , unclaimed_soul_eggs_(uint64_t{0u})
  , eggs_of_prophecy_(uint64_t{0u})
  , unclaimed_eggs_of_prophecy_(uint64_t{0u})
  , current_farm_(0u)
  , num_daily_gifts_collected_(0u)
  , long_idle_notification_threshold_(0)
  , long_idle_reward_(0)
  , piggy_full_alert_shown_(false)
  , hyperloop_station_(false)
  , long_idle_notification_set_(false)
  , force_elite_contracts_(false)
  , total_time_cheats_detected_(0u)
  , prestige_soul_boost_cash_(0)
  , soul_eggs_d_(0)
  , unclaimed_soul_eggs_d_(0)
  , new_player_event_end_time_(0)
  , shell_scripts_earned_(uint64_t{0u})
  , shell_scripts_spent_(uint64_t{0u})
  , unclaimed_shell_scripts_(uint64_t{0u})
  , max_egg_reached_(1)
{}
struct Backup_GameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Backup_GameDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Backup_GameDefaultTypeInternal() {}
  union {
    Backup_Game _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Backup_GameDefaultTypeInternal _Backup_Game_default_instance_;
PROTOBUF_CONSTEXPR Backup_Artifacts::Backup_Artifacts(
    ::_pbi::ConstantInitialized)
  : tank_fuels_()
  , item_being_infused_(nullptr)
  , spec_being_infused_(nullptr)
  , infusing_eggs_required_(0)
  , eggs_infused_(0)
  , last_fueled_ship_(0)

  , infusing_(false)
  , tank_filling_enabled_(false)
  , enabled_(false)
  , intro_shown_(false)
  , inventory_score_(0)
  , crafting_xp_(0)
  , tank_level_(0u)
  , flow_percentage_artifacts_(0.5)
  , egg_type_infusing_(1)

  , fueling_enabled_(true)
  , infusing_enabled_deprecated_(true){}
struct Backup_ArtifactsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Backup_ArtifactsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Backup_ArtifactsDefaultTypeInternal() {}
  union {
    Backup_Artifacts _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Backup_ArtifactsDefaultTypeInternal _Backup_Artifacts_default_instance_;
PROTOBUF_CONSTEXPR Backup_Shells::Backup_Shells(
    ::_pbi::ConstantInitialized)
  : num_new_()
  , intro_alert_(false)
  , contracts_intro_alert_(false){}
struct Backup_ShellsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Backup_ShellsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Backup_ShellsDefaultTypeInternal() {}
  union {
    Backup_Shells _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Backup_ShellsDefaultTypeInternal _Backup_Shells_default_instance_;
PROTOBUF_CONSTEXPR Backup_Simulation::Backup_Simulation(
    ::_pbi::ConstantInitialized)
  : habs_()
  , hab_population_()
  , hab_population_indound_()
  , hab_incubator_popuplation_()
  , vehicles_()
  , common_research_()
  , train_length_()
  , active_boosts_()
  , contract_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , cash_earned_(0)
  , cash_spent_(0)
  , unclaimed_cash_(0)
  , last_step_time_(0)
  , num_chickens_(uint64_t{0u})
  , num_chickens_unsettled_(uint64_t{0u})
  , num_chickens_running_(uint64_t{0u})
  , eggs_laid_(0)
  , eggs_paid_for_(0)
  , hatchery_population_(0)
  , silos_owned_(0u)
  , time_cheats_detected_(0u)
  , time_cheat_debt_(0)
  , boost_tokens_received_(0u)
  , boost_tokens_spent_(0u)
  , unclaimed_boost_tokens_(0u)
  , boost_tokens_given_(0u)
  , gametime_until_next_boost_token_(0)
  , eggs_shipped_(0)
  , last_cash_boost_time_(0)
  , egg_type_(1)

  , farm_type_(1)
{}
struct Backup_SimulationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Backup_SimulationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Backup_SimulationDefaultTypeInternal() {}
  union {
    Backup_Simulation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Backup_SimulationDefaultTypeInternal _Backup_Simulation_default_instance_;
PROTOBUF_CONSTEXPR Backup_Mission::Backup_Mission(
    ::_pbi::ConstantInitialized)
  : missions_()
  , current_missions_()
  , current_mission_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , reference_value_(0){}
struct Backup_MissionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Backup_MissionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Backup_MissionDefaultTypeInternal() {}
  union {
    Backup_Mission _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Backup_MissionDefaultTypeInternal _Backup_Mission_default_instance_;
PROTOBUF_CONSTEXPR Backup_Misc::Backup_Misc(
    ::_pbi::ConstantInitialized)
  : friend_rank_(uint64_t{0u})
  , friend_rank_pop_(uint64_t{0u})
  , global_rank_(uint64_t{0u})
  , global_rank_pop_(uint64_t{0u})
  , chicken_btn_pref_big_(false)
  , free_hatchery_refill_given_(false)
  , challenges_alert_(false)
  , trophy_alert_(false)
  , ar_alert_(false)
  , contracts_alert_(false)
  , contracts_alert_v2_(false)
  , coop_alert_(false)
  , coop_alert_v2_(false)
  , switch_alert_(false)
  , egg_of_prophecy_alert_(false)
  , boost_token_alert_(false)
  , soul_egg_alert_(false)
  , backup_reminder_alert_(false)
  , last_share_farm_value_(10000000)
  , last_share_swarm_farm_value_(10000000)
  , last_share_swarm_size_(140)
  , last_prestige_alert_soul_eggs_deprecated_(uint64_t{45u}){}
struct Backup_MiscDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Backup_MiscDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Backup_MiscDefaultTypeInternal() {}
  union {
    Backup_Misc _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Backup_MiscDefaultTypeInternal _Backup_Misc_default_instance_;
PROTOBUF_CONSTEXPR Backup_ResearchItem::Backup_ResearchItem(
    ::_pbi::ConstantInitialized)
  : id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , level_(0u){}
struct Backup_ResearchItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Backup_ResearchItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Backup_ResearchItemDefaultTypeInternal() {}
  union {
    Backup_ResearchItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Backup_ResearchItemDefaultTypeInternal _Backup_ResearchItem_default_instance_;
PROTOBUF_CONSTEXPR Backup_NewsHeadline::Backup_NewsHeadline(
    ::_pbi::ConstantInitialized)
  : id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , read_(false){}
struct Backup_NewsHeadlineDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Backup_NewsHeadlineDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Backup_NewsHeadlineDefaultTypeInternal() {}
  union {
    Backup_NewsHeadline _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Backup_NewsHeadlineDefaultTypeInternal _Backup_NewsHeadline_default_instance_;
PROTOBUF_CONSTEXPR Backup_AchievementInfo::Backup_AchievementInfo(
    ::_pbi::ConstantInitialized)
  : id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , achieved_(false){}
struct Backup_AchievementInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Backup_AchievementInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Backup_AchievementInfoDefaultTypeInternal() {}
  union {
    Backup_AchievementInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Backup_AchievementInfoDefaultTypeInternal _Backup_AchievementInfo_default_instance_;
PROTOBUF_CONSTEXPR Backup_ActiveBoost::Backup_ActiveBoost(
    ::_pbi::ConstantInitialized)
  : boost_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , time_remaining_(0)
  , reference_value_(0){}
struct Backup_ActiveBoostDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Backup_ActiveBoostDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Backup_ActiveBoostDefaultTypeInternal() {}
  union {
    Backup_ActiveBoost _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Backup_ActiveBoostDefaultTypeInternal _Backup_ActiveBoost_default_instance_;
PROTOBUF_CONSTEXPR Backup_OwnedBoost::Backup_OwnedBoost(
    ::_pbi::ConstantInitialized)
  : boost_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , count_(0u){}
struct Backup_OwnedBoostDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Backup_OwnedBoostDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Backup_OwnedBoostDefaultTypeInternal() {}
  union {
    Backup_OwnedBoost _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Backup_OwnedBoostDefaultTypeInternal _Backup_OwnedBoost_default_instance_;
PROTOBUF_CONSTEXPR Backup_MissionInfo::Backup_MissionInfo(
    ::_pbi::ConstantInitialized)
  : id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , reference_value_(0)
  , completed_(false){}
struct Backup_MissionInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Backup_MissionInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Backup_MissionInfoDefaultTypeInternal() {}
  union {
    Backup_MissionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Backup_MissionInfoDefaultTypeInternal _Backup_MissionInfo_default_instance_;
PROTOBUF_CONSTEXPR Backup::Backup(
    ::_pbi::ConstantInitialized)
  : farms_()
  , read_mail_ids_()
  , user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , user_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , game_services_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , device_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , ei_user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , signature_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , settings_(nullptr)
  , tutorial_(nullptr)
  , stats_(nullptr)
  , game_(nullptr)
  , sim_(nullptr)
  , mission_(nullptr)
  , misc_(nullptr)
  , contracts_(nullptr)
  , artifacts_(nullptr)
  , artifacts_db_(nullptr)
  , shell_db_(nullptr)
  , shells_(nullptr)
  , approx_time_(0)
  , version_(0u)
  , force_offer_backup_(false)
  , force_backup_(false)
  , checksum_(uint64_t{0u}){}
struct BackupDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BackupDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BackupDefaultTypeInternal() {}
  union {
    Backup _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BackupDefaultTypeInternal _Backup_default_instance_;
PROTOBUF_CONSTEXPR EggIncFirstContactRequest::EggIncFirstContactRequest(
    ::_pbi::ConstantInitialized)
  : user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , ei_user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , device_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , username_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , game_services_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , rinfo_(nullptr)
  , client_version_(0u)
  , platform_(1)
{}
struct EggIncFirstContactRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EggIncFirstContactRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EggIncFirstContactRequestDefaultTypeInternal() {}
  union {
    EggIncFirstContactRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EggIncFirstContactRequestDefaultTypeInternal _EggIncFirstContactRequest_default_instance_;
PROTOBUF_CONSTEXPR EggIncFirstContactResponse::EggIncFirstContactResponse(
    ::_pbi::ConstantInitialized)
  : ids_transferred_()
  , ei_user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , error_message_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , backup_(nullptr)
  , error_code_(0u){}
struct EggIncFirstContactResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EggIncFirstContactResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EggIncFirstContactResponseDefaultTypeInternal() {}
  union {
    EggIncFirstContactResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EggIncFirstContactResponseDefaultTypeInternal _EggIncFirstContactResponse_default_instance_;
PROTOBUF_CONSTEXPR EggIncAdConfig::EggIncAdConfig(
    ::_pbi::ConstantInitialized)
  : network_priority_(){}
struct EggIncAdConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EggIncAdConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EggIncAdConfigDefaultTypeInternal() {}
  union {
    EggIncAdConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EggIncAdConfigDefaultTypeInternal _EggIncAdConfig_default_instance_;
PROTOBUF_CONSTEXPR DailyGiftInfo::DailyGiftInfo(
    ::_pbi::ConstantInitialized)
  : seconds_to_next_day_(0)
  , current_day_(0u){}
struct DailyGiftInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DailyGiftInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DailyGiftInfoDefaultTypeInternal() {}
  union {
    DailyGiftInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DailyGiftInfoDefaultTypeInternal _DailyGiftInfo_default_instance_;
PROTOBUF_CONSTEXPR SalesInfoRequest::SalesInfoRequest(
    ::_pbi::ConstantInitialized)
  : user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , seconds_full_realtime_(0)
  , piggy_full_(false)
  , piggy_found_full_(false)
  , lost_increments_(0u)
  , seconds_full_gametime_(0)
  , current_client_version_(0u){}
struct SalesInfoRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SalesInfoRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SalesInfoRequestDefaultTypeInternal() {}
  union {
    SalesInfoRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SalesInfoRequestDefaultTypeInternal _SalesInfoRequest_default_instance_;
PROTOBUF_CONSTEXPR IAPSaleEntry::IAPSaleEntry(
    ::_pbi::ConstantInitialized)
  : product_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , discount_string_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , sale_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , seconds_remaining_(0){}
struct IAPSaleEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IAPSaleEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IAPSaleEntryDefaultTypeInternal() {}
  union {
    IAPSaleEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IAPSaleEntryDefaultTypeInternal _IAPSaleEntry_default_instance_;
PROTOBUF_CONSTEXPR SalesInfo::SalesInfo(
    ::_pbi::ConstantInitialized)
  : sales_(){}
struct SalesInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SalesInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SalesInfoDefaultTypeInternal() {}
  union {
    SalesInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SalesInfoDefaultTypeInternal _SalesInfo_default_instance_;
PROTOBUF_CONSTEXPR EggIncEvent::EggIncEvent(
    ::_pbi::ConstantInitialized)
  : identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , type_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , subtitle_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , seconds_remaining_(0)
  , multiplier_(0)
  , start_time_(0)
  , duration_(0)
  , cc_only_(false){}
struct EggIncEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EggIncEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EggIncEventDefaultTypeInternal() {}
  union {
    EggIncEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EggIncEventDefaultTypeInternal _EggIncEvent_default_instance_;
PROTOBUF_CONSTEXPR EggIncCurrentEvents::EggIncCurrentEvents(
    ::_pbi::ConstantInitialized)
  : events_(){}
struct EggIncCurrentEventsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EggIncCurrentEventsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EggIncCurrentEventsDefaultTypeInternal() {}
  union {
    EggIncCurrentEvents _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EggIncCurrentEventsDefaultTypeInternal _EggIncCurrentEvents_default_instance_;
PROTOBUF_CONSTEXPR DeviceInfo::DeviceInfo(
    ::_pbi::ConstantInitialized)
  : device_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , platform_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , form_factor_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , device_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , platform_version_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , locale_country_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , locale_language_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , gpu_vendor_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , gpu_model_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , device_bucket_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , advertising_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , screen_width_(0u)
  , screen_height_(0u){}
struct DeviceInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceInfoDefaultTypeInternal() {}
  union {
    DeviceInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceInfoDefaultTypeInternal _DeviceInfo_default_instance_;
PROTOBUF_CONSTEXPR AppInfo::AppInfo(
    ::_pbi::ConstantInitialized)
  : version_str_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , sale_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , sessions_(0u)
  , num_prestiges_(0u)
  , soul_eggs_(uint64_t{0u})
  , gold_earned_(uint64_t{0u})
  , current_egg_(0u)
  , current_mission_(0u)
  , gold_spent_(uint64_t{0u})
  , num_piggy_breaks_(uint64_t{0u})
  , piggy_size_(0u)
  , permit_level_(0u)
  , iap_packs_purchased_(uint64_t{0u})
  , unlimited_chickens_uses_(uint64_t{0u})
  , refill_uses_(uint64_t{0u})
  , video_doubler_uses_(uint64_t{0u})
  , short_warp_uses_(uint64_t{0u})
  , long_warp_uses_(uint64_t{0u})
  , drone_takedowns_(uint64_t{0u})
  , drone_takedowns_elite_(uint64_t{0u})
  , egg_level_(0)
  , struggle_factor_(0)
  , time_piggy_full_realtime_(0)
  , time_piggy_full_gametime_(0)
  , lost_piggy_increments_(uint64_t{0u})
  , verified_piggy_breaks_(uint64_t{0u})
  , trophies_unlocked_(false)
  , piggy_full_(false)
  , piggy_found_full_(false){}
struct AppInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AppInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AppInfoDefaultTypeInternal() {}
  union {
    AppInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AppInfoDefaultTypeInternal _AppInfo_default_instance_;
PROTOBUF_CONSTEXPR ActionKeyValuePair::ActionKeyValuePair(
    ::_pbi::ConstantInitialized)
  : key_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , value_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct ActionKeyValuePairDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActionKeyValuePairDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActionKeyValuePairDefaultTypeInternal() {}
  union {
    ActionKeyValuePair _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActionKeyValuePairDefaultTypeInternal _ActionKeyValuePair_default_instance_;
PROTOBUF_CONSTEXPR GenericAction::GenericAction(
    ::_pbi::ConstantInitialized)
  : data_()
  , user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , action_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , advertising_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , app_(nullptr)
  , device_(nullptr)
  , approx_time_(0)
  , approx_time_dep_(0){}
struct GenericActionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GenericActionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GenericActionDefaultTypeInternal() {}
  union {
    GenericAction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GenericActionDefaultTypeInternal _GenericAction_default_instance_;
PROTOBUF_CONSTEXPR GenericActionBatchRequest::GenericActionBatchRequest(
    ::_pbi::ConstantInitialized)
  : actions_()
  , rinfo_(nullptr){}
struct GenericActionBatchRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GenericActionBatchRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GenericActionBatchRequestDefaultTypeInternal() {}
  union {
    GenericActionBatchRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GenericActionBatchRequestDefaultTypeInternal _GenericActionBatchRequest_default_instance_;
PROTOBUF_CONSTEXPR VerifyPurchaseRequest::VerifyPurchaseRequest(
    ::_pbi::ConstantInitialized)
  : sku_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , transaction_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , receipt_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , platform_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , original_transaction_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , log_(nullptr)
  , rinfo_(nullptr)
  , sandbox_(false){}
struct VerifyPurchaseRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VerifyPurchaseRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VerifyPurchaseRequestDefaultTypeInternal() {}
  union {
    VerifyPurchaseRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VerifyPurchaseRequestDefaultTypeInternal _VerifyPurchaseRequest_default_instance_;
PROTOBUF_CONSTEXPR VerifyPurchaseResponse::VerifyPurchaseResponse(
    ::_pbi::ConstantInitialized)
  : message_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , verified_(false){}
struct VerifyPurchaseResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VerifyPurchaseResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VerifyPurchaseResponseDefaultTypeInternal() {}
  union {
    VerifyPurchaseResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VerifyPurchaseResponseDefaultTypeInternal _VerifyPurchaseResponse_default_instance_;
PROTOBUF_CONSTEXPR CurrencyFlowLog::CurrencyFlowLog(
    ::_pbi::ConstantInitialized)
  : user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , location_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , version_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , platform_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , approx_time_(0)
  , amount_(int64_t{0})
  , soul_eggs_(0)
  , tickets_spent_(uint64_t{0u})
  , gold_spent_(uint64_t{0u})
  , currency_(1)
{}
struct CurrencyFlowLogDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CurrencyFlowLogDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CurrencyFlowLogDefaultTypeInternal() {}
  union {
    CurrencyFlowLog _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CurrencyFlowLogDefaultTypeInternal _CurrencyFlowLog_default_instance_;
PROTOBUF_CONSTEXPR CurrencyFlowBatchRequest::CurrencyFlowBatchRequest(
    ::_pbi::ConstantInitialized)
  : logs_()
  , rinfo_(nullptr){}
struct CurrencyFlowBatchRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CurrencyFlowBatchRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CurrencyFlowBatchRequestDefaultTypeInternal() {}
  union {
    CurrencyFlowBatchRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CurrencyFlowBatchRequestDefaultTypeInternal _CurrencyFlowBatchRequest_default_instance_;
PROTOBUF_CONSTEXPR Reward::Reward(
    ::_pbi::ConstantInitialized)
  : reward_sub_type_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , reward_amount_(0)
  , reward_type_(1)
{}
struct RewardDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RewardDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RewardDefaultTypeInternal() {}
  union {
    Reward _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RewardDefaultTypeInternal _Reward_default_instance_;
PROTOBUF_CONSTEXPR GameModifier::GameModifier(
    ::_pbi::ConstantInitialized)
  : description_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , value_(0)
  , dimension_(1)
{}
struct GameModifierDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GameModifierDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GameModifierDefaultTypeInternal() {}
  union {
    GameModifier _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GameModifierDefaultTypeInternal _GameModifier_default_instance_;
PROTOBUF_CONSTEXPR Contract_Goal::Contract_Goal(
    ::_pbi::ConstantInitialized)
  : reward_sub_type_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , target_amount_(0)
  , reward_amount_(0)
  , target_soul_eggs_(0)
  , type_(1)

  , reward_type_(1)
{}
struct Contract_GoalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Contract_GoalDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Contract_GoalDefaultTypeInternal() {}
  union {
    Contract_Goal _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Contract_GoalDefaultTypeInternal _Contract_Goal_default_instance_;
PROTOBUF_CONSTEXPR Contract_GoalSet::Contract_GoalSet(
    ::_pbi::ConstantInitialized)
  : goals_(){}
struct Contract_GoalSetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Contract_GoalSetDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Contract_GoalSetDefaultTypeInternal() {}
  union {
    Contract_GoalSet _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Contract_GoalSetDefaultTypeInternal _Contract_GoalSet_default_instance_;
PROTOBUF_CONSTEXPR Contract_GradeSpec::Contract_GradeSpec(
    ::_pbi::ConstantInitialized)
  : goals_()
  , modifiers_()
  , length_seconds_(0)
  , grade_(0)
{}
struct Contract_GradeSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Contract_GradeSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Contract_GradeSpecDefaultTypeInternal() {}
  union {
    Contract_GradeSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Contract_GradeSpecDefaultTypeInternal _Contract_GradeSpec_default_instance_;
PROTOBUF_CONSTEXPR Contract::Contract(
    ::_pbi::ConstantInitialized)
  : goals_()
  , goal_sets_()
  , grade_specs_()
  , identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , description_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , key_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , season_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , expiration_time_(0)
  , length_seconds_(0)
  , max_coop_size_(0u)
  , max_boosts_(0u)
  , max_soul_eggs_(0)
  , min_client_version_(0u)
  , coop_allowed_(false)
  , leggacy_(false)
  , cc_only_(false)
  , debug_(false)
  , start_time_(0)
  , egg_(1)

  , minutes_per_token_(60)
  , chicken_run_cooldown_minutes_(180){}
struct ContractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContractDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContractDefaultTypeInternal() {}
  union {
    Contract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContractDefaultTypeInternal _Contract_default_instance_;
PROTOBUF_CONSTEXPR ContractPlayerInfo::ContractPlayerInfo(
    ::_pbi::ConstantInitialized)
  : unread_evaluations_()
  , issues_()
  , last_evaluation_version_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , total_cxp_(0)
  , grade_(0)

  , status_(0)

  , last_evaluation_time_(0)
  , grade_score_(0)
  , target_soul_power_(0)
  , target_grade_score_(0)
  , soul_power_(0)
  , grade_progress_(0)
  , season_cxp_(0)
  , issue_score_(0){}
struct ContractPlayerInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContractPlayerInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContractPlayerInfoDefaultTypeInternal() {}
  union {
    ContractPlayerInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContractPlayerInfoDefaultTypeInternal _ContractPlayerInfo_default_instance_;
PROTOBUF_CONSTEXPR ContractEvaluation::ContractEvaluation(
    ::_pbi::ConstantInitialized)
  : notes_()
  , issues_()
  , season_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , contract_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , coop_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , version_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , cxp_(0)
  , grade_performance_(0)
  , grade_(0)

  , contribution_ratio_(0)
  , completion_percent_(0)
  , completion_time_(0)
  , chicken_runs_sent_(0u)
  , gift_tokens_sent_(0u)
  , original_length_(0)
  , old_league_(0)
  , gift_tokens_received_(0u)
  , teamwork_score_(0)
  , other_bonuses_(0)
  , buff_time_value_(0)
  , boost_token_allotment_(0u)
  , coop_size_(0u)
  , replay_(false)
  , old_goals_(false)
  , solo_(false)
  , counted_in_season_(false)
  , time_cheats_(0u)
  , last_contribution_time_(0)
  , soul_power_(0)
  , cxp_change_(0)
  , evaluation_start_time_(0)
  , status_(0)
{}
struct ContractEvaluationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContractEvaluationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContractEvaluationDefaultTypeInternal() {}
  union {
    ContractEvaluation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContractEvaluationDefaultTypeInternal _ContractEvaluation_default_instance_;
PROTOBUF_CONSTEXPR ContractCitation::ContractCitation(
    ::_pbi::ConstantInitialized)
  : timestamp_(0)
  , issue_(0)

  , grade_(0)
{}
struct ContractCitationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContractCitationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContractCitationDefaultTypeInternal() {}
  union {
    ContractCitation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContractCitationDefaultTypeInternal _ContractCitation_default_instance_;
PROTOBUF_CONSTEXPR ContractEvaluationBatch_Pair::ContractEvaluationBatch_Pair(
    ::_pbi::ConstantInitialized)
  : user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , cev_(nullptr){}
struct ContractEvaluationBatch_PairDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContractEvaluationBatch_PairDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContractEvaluationBatch_PairDefaultTypeInternal() {}
  union {
    ContractEvaluationBatch_Pair _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContractEvaluationBatch_PairDefaultTypeInternal _ContractEvaluationBatch_Pair_default_instance_;
PROTOBUF_CONSTEXPR ContractEvaluationBatch::ContractEvaluationBatch(
    ::_pbi::ConstantInitialized)
  : evals_(){}
struct ContractEvaluationBatchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContractEvaluationBatchDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContractEvaluationBatchDefaultTypeInternal() {}
  union {
    ContractEvaluationBatch _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContractEvaluationBatchDefaultTypeInternal _ContractEvaluationBatch_default_instance_;
PROTOBUF_CONSTEXPR CoopCompletionSnapshot_ContributorSnapshot::CoopCompletionSnapshot_ContributorSnapshot(
    ::_pbi::ConstantInitialized)
  : user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , contribution_(0)
  , soul_power_(0)
  , tokens_(0u)
  , tokens_spent_(0u)
  , last_contribution_time_(0){}
struct CoopCompletionSnapshot_ContributorSnapshotDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CoopCompletionSnapshot_ContributorSnapshotDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CoopCompletionSnapshot_ContributorSnapshotDefaultTypeInternal() {}
  union {
    CoopCompletionSnapshot_ContributorSnapshot _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CoopCompletionSnapshot_ContributorSnapshotDefaultTypeInternal _CoopCompletionSnapshot_ContributorSnapshot_default_instance_;
PROTOBUF_CONSTEXPR CoopCompletionSnapshot::CoopCompletionSnapshot(
    ::_pbi::ConstantInitialized)
  : contributors_(){}
struct CoopCompletionSnapshotDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CoopCompletionSnapshotDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CoopCompletionSnapshotDefaultTypeInternal() {}
  union {
    CoopCompletionSnapshot _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CoopCompletionSnapshotDefaultTypeInternal _CoopCompletionSnapshot_default_instance_;
PROTOBUF_CONSTEXPR BasicRequestInfo::BasicRequestInfo(
    ::_pbi::ConstantInitialized)
  : ei_user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , version_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , build_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , platform_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , country_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , language_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , client_version_(0u)
  , debug_(false){}
struct BasicRequestInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BasicRequestInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BasicRequestInfoDefaultTypeInternal() {}
  union {
    BasicRequestInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BasicRequestInfoDefaultTypeInternal _BasicRequestInfo_default_instance_;
PROTOBUF_CONSTEXPR ContractSimConfig_ContractGradeSimConfig_GoalParams::ContractSimConfig_ContractGradeSimConfig_GoalParams(
    ::_pbi::ConstantInitialized)
  : target_se_(0)
  , cps_mult_(0)
  , earnings_mult_(0)
  , time_efficacy_(0){}
struct ContractSimConfig_ContractGradeSimConfig_GoalParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContractSimConfig_ContractGradeSimConfig_GoalParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContractSimConfig_ContractGradeSimConfig_GoalParamsDefaultTypeInternal() {}
  union {
    ContractSimConfig_ContractGradeSimConfig_GoalParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContractSimConfig_ContractGradeSimConfig_GoalParamsDefaultTypeInternal _ContractSimConfig_ContractGradeSimConfig_GoalParams_default_instance_;
PROTOBUF_CONSTEXPR ContractSimConfig_ContractGradeSimConfig::ContractSimConfig_ContractGradeSimConfig(
    ::_pbi::ConstantInitialized)
  : goal_params_()
  , grade_(0)
{}
struct ContractSimConfig_ContractGradeSimConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContractSimConfig_ContractGradeSimConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContractSimConfig_ContractGradeSimConfigDefaultTypeInternal() {}
  union {
    ContractSimConfig_ContractGradeSimConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContractSimConfig_ContractGradeSimConfigDefaultTypeInternal _ContractSimConfig_ContractGradeSimConfig_default_instance_;
PROTOBUF_CONSTEXPR ContractSimConfig::ContractSimConfig(
    ::_pbi::ConstantInitialized)
  : grade_configs_(){}
struct ContractSimConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContractSimConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContractSimConfigDefaultTypeInternal() {}
  union {
    ContractSimConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContractSimConfigDefaultTypeInternal _ContractSimConfig_default_instance_;
PROTOBUF_CONSTEXPR ContractSimPoll::ContractSimPoll(
    ::_pbi::ConstantInitialized)
  : client_version_(0u){}
struct ContractSimPollDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContractSimPollDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContractSimPollDefaultTypeInternal() {}
  union {
    ContractSimPoll _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContractSimPollDefaultTypeInternal _ContractSimPoll_default_instance_;
PROTOBUF_CONSTEXPR ContractSimPollResponse::ContractSimPollResponse(
    ::_pbi::ConstantInitialized)
  : contract_to_simulate_(nullptr)
  , sim_config_(nullptr){}
struct ContractSimPollResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContractSimPollResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContractSimPollResponseDefaultTypeInternal() {}
  union {
    ContractSimPollResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContractSimPollResponseDefaultTypeInternal _ContractSimPollResponse_default_instance_;
PROTOBUF_CONSTEXPR ContractSimResultUpdate_GoalInfo::ContractSimResultUpdate_GoalInfo(
    ::_pbi::ConstantInitialized)
  : grade_(0)

  , goal_index_(0u)
  , projected_eggs_laid_(0){}
struct ContractSimResultUpdate_GoalInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContractSimResultUpdate_GoalInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContractSimResultUpdate_GoalInfoDefaultTypeInternal() {}
  union {
    ContractSimResultUpdate_GoalInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContractSimResultUpdate_GoalInfoDefaultTypeInternal _ContractSimResultUpdate_GoalInfo_default_instance_;
PROTOBUF_CONSTEXPR ContractSimResultUpdate::ContractSimResultUpdate(
    ::_pbi::ConstantInitialized)
  : goal_infos_()
  , contract_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct ContractSimResultUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContractSimResultUpdateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContractSimResultUpdateDefaultTypeInternal() {}
  union {
    ContractSimResultUpdate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContractSimResultUpdateDefaultTypeInternal _ContractSimResultUpdate_default_instance_;
PROTOBUF_CONSTEXPR ContractsRequest::ContractsRequest(
    ::_pbi::ConstantInitialized)
  : user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , soul_eggs_(0)
  , client_version_(0u){}
struct ContractsRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContractsRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContractsRequestDefaultTypeInternal() {}
  union {
    ContractsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContractsRequestDefaultTypeInternal _ContractsRequest_default_instance_;
PROTOBUF_CONSTEXPR ContractsResponse::ContractsResponse(
    ::_pbi::ConstantInitialized)
  : contracts_()
  , warning_message_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , server_time_(0)
  , max_eop_(1000u){}
struct ContractsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContractsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContractsResponseDefaultTypeInternal() {}
  union {
    ContractsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContractsResponseDefaultTypeInternal _ContractsResponse_default_instance_;
PROTOBUF_CONSTEXPR ContractCoopStatusRequest::ContractCoopStatusRequest(
    ::_pbi::ConstantInitialized)
  : contract_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , coop_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , rinfo_(nullptr)
  , client_version_(0u){}
struct ContractCoopStatusRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContractCoopStatusRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContractCoopStatusRequestDefaultTypeInternal() {}
  union {
    ContractCoopStatusRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContractCoopStatusRequestDefaultTypeInternal _ContractCoopStatusRequest_default_instance_;
PROTOBUF_CONSTEXPR FarmProductionParams::FarmProductionParams(
    ::_pbi::ConstantInitialized)
  : farm_population_(0)
  , farm_capacity_(0)
  , elr_(0)
  , ihr_(0)
  , sr_(0)
  , delivered_(0){}
struct FarmProductionParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FarmProductionParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FarmProductionParamsDefaultTypeInternal() {}
  union {
    FarmProductionParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FarmProductionParamsDefaultTypeInternal _FarmProductionParams_default_instance_;
PROTOBUF_CONSTEXPR PlayerFarmInfo::PlayerFarmInfo(
    ::_pbi::ConstantInitialized)
  : egg_medal_level_()
  , epic_research_()
  , habs_()
  , hab_population_()
  , vehicles_()
  , train_length_()
  , common_research_()
  , active_boosts_()
  , equipped_artifacts_()
  , hab_capacity_()
  , farm_appearance_(nullptr)
  , soul_eggs_(0)
  , eggs_of_prophecy_(uint64_t{0u})
  , permit_level_(0u)
  , hyperloop_station_(false)
  , cash_on_hand_(0)
  , silos_owned_(0u)
  , boost_tokens_on_hand_(0u)
  , artifact_inventory_score_(uint64_t{0u})
  , timestamp_(0)
  , client_version_(0u)
  , egg_type_(1)
{}
struct PlayerFarmInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerFarmInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerFarmInfoDefaultTypeInternal() {}
  union {
    PlayerFarmInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerFarmInfoDefaultTypeInternal _PlayerFarmInfo_default_instance_;
PROTOBUF_CONSTEXPR ContractCoopStatusResponse_ContributionInfo::ContractCoopStatusResponse_ContributionInfo(
    ::_pbi::ConstantInitialized)
  : buff_history_()
  , user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , user_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , push_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , contract_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , uuid_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , production_params_(nullptr)
  , farm_info_(nullptr)
  , contribution_amount_(0)
  , contribution_rate_(0)
  , rank_change_(0)
  , ban_votes_(0u)
  , soul_power_(0)
  , active_(false)
  , leech_(false)
  , time_cheat_detected_(false)
  , autojoined_(false)
  , boost_tokens_(0u)
  , chicken_run_cooldown_(0)
  , boost_tokens_spent_(0u)
  , platform_(1)
{}
struct ContractCoopStatusResponse_ContributionInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContractCoopStatusResponse_ContributionInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContractCoopStatusResponse_ContributionInfoDefaultTypeInternal() {}
  union {
    ContractCoopStatusResponse_ContributionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContractCoopStatusResponse_ContributionInfoDefaultTypeInternal _ContractCoopStatusResponse_ContributionInfo_default_instance_;
PROTOBUF_CONSTEXPR ContractCoopStatusResponse_CoopGift::ContractCoopStatusResponse_CoopGift(
    ::_pbi::ConstantInitialized)
  : user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , user_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , amount_(0u){}
struct ContractCoopStatusResponse_CoopGiftDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContractCoopStatusResponse_CoopGiftDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContractCoopStatusResponse_CoopGiftDefaultTypeInternal() {}
  union {
    ContractCoopStatusResponse_CoopGift _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContractCoopStatusResponse_CoopGiftDefaultTypeInternal _ContractCoopStatusResponse_CoopGift_default_instance_;
PROTOBUF_CONSTEXPR ContractCoopStatusResponse_ChickenRun::ContractCoopStatusResponse_ChickenRun(
    ::_pbi::ConstantInitialized)
  : user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , user_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , amount_(uint64_t{0u}){}
struct ContractCoopStatusResponse_ChickenRunDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContractCoopStatusResponse_ChickenRunDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContractCoopStatusResponse_ChickenRunDefaultTypeInternal() {}
  union {
    ContractCoopStatusResponse_ChickenRun _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContractCoopStatusResponse_ChickenRunDefaultTypeInternal _ContractCoopStatusResponse_ChickenRun_default_instance_;
PROTOBUF_CONSTEXPR ContractCoopStatusResponse::ContractCoopStatusResponse(
    ::_pbi::ConstantInitialized)
  : contributors_()
  , gifts_()
  , chicken_runs_()
  , contract_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , coop_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , creator_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , total_amount_(0)
  , seconds_remaining_(0)
  , grace_period_seconds_remaining_(0)
  , local_timestamp_(0)
  , auto_generated_(false)
  , public__(false)
  , all_goals_achieved_(false)
  , all_members_reporting_(false){}
struct ContractCoopStatusResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContractCoopStatusResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContractCoopStatusResponseDefaultTypeInternal() {}
  union {
    ContractCoopStatusResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContractCoopStatusResponseDefaultTypeInternal _ContractCoopStatusResponse_default_instance_;
PROTOBUF_CONSTEXPR LocalContract::LocalContract(
    ::_pbi::ConstantInitialized)
  : reported_uuids_()
  , coop_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , coop_user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , contract_(nullptr)
  , evaluation_(nullptr)
  , time_accepted_(0)
  , coop_shared_end_time_(0)
  , last_amount_when_reward_given_(0)
  , accepted_(false)
  , cancelled_(false)
  , new__(false)
  , coop_contribution_finalized_(false)
  , boosts_used_(0u)
  , coop_grace_period_end_time_(0)
  , coop_last_uploaded_contribution_(0)
  , num_goals_achieved_(0u)
  , league_(0u)
  , last_nag_time_(0)
  , grade_(0)

  , coop_share_farm_(false)
  , points_replay_(false){}
struct LocalContractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LocalContractDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LocalContractDefaultTypeInternal() {}
  union {
    LocalContract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LocalContractDefaultTypeInternal _LocalContract_default_instance_;
PROTOBUF_CONSTEXPR MyContracts::MyContracts(
    ::_pbi::ConstantInitialized)
  : contracts_()
  , archive_()
  , contract_ids_seen_()
  , current_coop_statuses_()
  , last_cpi_(nullptr)
  , last_grade_progress_shown_(0)
  , initial_grade_revealed_(false)
  , show_advanced_evaluations_(false){}
struct MyContractsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MyContractsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MyContractsDefaultTypeInternal() {}
  union {
    MyContracts _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MyContractsDefaultTypeInternal _MyContracts_default_instance_;
PROTOBUF_CONSTEXPR QueryCoopRequest::QueryCoopRequest(
    ::_pbi::ConstantInitialized)
  : contract_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , coop_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , rinfo_(nullptr)
  , client_version_(0u)
  , league_(0u)
  , grade_(0)
{}
struct QueryCoopRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QueryCoopRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QueryCoopRequestDefaultTypeInternal() {}
  union {
    QueryCoopRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QueryCoopRequestDefaultTypeInternal _QueryCoopRequest_default_instance_;
PROTOBUF_CONSTEXPR QueryCoopResponse::QueryCoopResponse(
    ::_pbi::ConstantInitialized)
  : exists_(false)
  , full_(false)
  , expired_(false)
  , different_league_(false)
  , different_grade_(false)
  , cc_only_(false)
  , banned_(false){}
struct QueryCoopResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QueryCoopResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QueryCoopResponseDefaultTypeInternal() {}
  union {
    QueryCoopResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QueryCoopResponseDefaultTypeInternal _QueryCoopResponse_default_instance_;
PROTOBUF_CONSTEXPR CreateCoopRequest::CreateCoopRequest(
    ::_pbi::ConstantInitialized)
  : contract_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , coop_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , user_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , rinfo_(nullptr)
  , seconds_remaining_(0)
  , soul_power_(0)
  , client_version_(0u)
  , league_(0u)
  , eop_(0)
  , grade_(0)

  , public__(false)
  , cc_only_(false)
  , platform_(1)
{}
struct CreateCoopRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateCoopRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateCoopRequestDefaultTypeInternal() {}
  union {
    CreateCoopRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateCoopRequestDefaultTypeInternal _CreateCoopRequest_default_instance_;
PROTOBUF_CONSTEXPR CreateCoopResponse::CreateCoopResponse(
    ::_pbi::ConstantInitialized)
  : message_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , success_(false){}
struct CreateCoopResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateCoopResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateCoopResponseDefaultTypeInternal() {}
  union {
    CreateCoopResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateCoopResponseDefaultTypeInternal _CreateCoopResponse_default_instance_;
PROTOBUF_CONSTEXPR JoinCoopRequest::JoinCoopRequest(
    ::_pbi::ConstantInitialized)
  : contract_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , coop_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , user_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , rinfo_(nullptr)
  , soul_power_(0)
  , client_version_(0u)
  , league_(0u)
  , seconds_remaining_(0)
  , eop_(0)
  , grade_(0)

  , platform_(1)
{}
struct JoinCoopRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR JoinCoopRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~JoinCoopRequestDefaultTypeInternal() {}
  union {
    JoinCoopRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 JoinCoopRequestDefaultTypeInternal _JoinCoopRequest_default_instance_;
PROTOBUF_CONSTEXPR JoinCoopResponse::JoinCoopResponse(
    ::_pbi::ConstantInitialized)
  : message_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , coop_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , seconds_remaining_(0)
  , success_(false)
  , banned_(false)
  , can_start_(false)
  , num_members_(0u)
  , match_percent_(0)
  , status_(0)

  , grade_(0)
{}
struct JoinCoopResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR JoinCoopResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~JoinCoopResponseDefaultTypeInternal() {}
  union {
    JoinCoopResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 JoinCoopResponseDefaultTypeInternal _JoinCoopResponse_default_instance_;
PROTOBUF_CONSTEXPR AutoJoinCoopRequest::AutoJoinCoopRequest(
    ::_pbi::ConstantInitialized)
  : contract_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , user_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , rinfo_(nullptr)
  , soul_power_(0)
  , seconds_remaining_(0)
  , client_version_(0u)
  , league_(0u)
  , eop_(0)
  , grade_(0)

  , platform_(1)
{}
struct AutoJoinCoopRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AutoJoinCoopRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AutoJoinCoopRequestDefaultTypeInternal() {}
  union {
    AutoJoinCoopRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AutoJoinCoopRequestDefaultTypeInternal _AutoJoinCoopRequest_default_instance_;
PROTOBUF_CONSTEXPR UpdateCoopPermissionsRequest::UpdateCoopPermissionsRequest(
    ::_pbi::ConstantInitialized)
  : contract_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , coop_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , requesting_user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , rinfo_(nullptr)
  , public__(false)
  , client_version_(0u){}
struct UpdateCoopPermissionsRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateCoopPermissionsRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateCoopPermissionsRequestDefaultTypeInternal() {}
  union {
    UpdateCoopPermissionsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateCoopPermissionsRequestDefaultTypeInternal _UpdateCoopPermissionsRequest_default_instance_;
PROTOBUF_CONSTEXPR UpdateCoopPermissionsResponse::UpdateCoopPermissionsResponse(
    ::_pbi::ConstantInitialized)
  : message_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , success_(false){}
struct UpdateCoopPermissionsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateCoopPermissionsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateCoopPermissionsResponseDefaultTypeInternal() {}
  union {
    UpdateCoopPermissionsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateCoopPermissionsResponseDefaultTypeInternal _UpdateCoopPermissionsResponse_default_instance_;
PROTOBUF_CONSTEXPR LeaveCoopRequest::LeaveCoopRequest(
    ::_pbi::ConstantInitialized)
  : contract_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , coop_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , player_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , rinfo_(nullptr)
  , client_version_(0u){}
struct LeaveCoopRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LeaveCoopRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LeaveCoopRequestDefaultTypeInternal() {}
  union {
    LeaveCoopRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LeaveCoopRequestDefaultTypeInternal _LeaveCoopRequest_default_instance_;
PROTOBUF_CONSTEXPR GiftPlayerCoopRequest::GiftPlayerCoopRequest(
    ::_pbi::ConstantInitialized)
  : contract_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , coop_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , player_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , requesting_user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , requesting_user_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , rinfo_(nullptr)
  , amount_(0u)
  , client_version_(0u){}
struct GiftPlayerCoopRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GiftPlayerCoopRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GiftPlayerCoopRequestDefaultTypeInternal() {}
  union {
    GiftPlayerCoopRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GiftPlayerCoopRequestDefaultTypeInternal _GiftPlayerCoopRequest_default_instance_;
PROTOBUF_CONSTEXPR SendChickenRunCoopRequest::SendChickenRunCoopRequest(
    ::_pbi::ConstantInitialized)
  : contract_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , coop_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , player_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , requesting_user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , requesting_user_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , rinfo_(nullptr)
  , farm_pop_(uint64_t{0u})
  , client_version_(0u){}
struct SendChickenRunCoopRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SendChickenRunCoopRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SendChickenRunCoopRequestDefaultTypeInternal() {}
  union {
    SendChickenRunCoopRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SendChickenRunCoopRequestDefaultTypeInternal _SendChickenRunCoopRequest_default_instance_;
PROTOBUF_CONSTEXPR ReportPlayerCoopRequest::ReportPlayerCoopRequest(
    ::_pbi::ConstantInitialized)
  : contract_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , coop_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , rinfo_(nullptr)
  , reason_(0)
{}
struct ReportPlayerCoopRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReportPlayerCoopRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReportPlayerCoopRequestDefaultTypeInternal() {}
  union {
    ReportPlayerCoopRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReportPlayerCoopRequestDefaultTypeInternal _ReportPlayerCoopRequest_default_instance_;
PROTOBUF_CONSTEXPR KickPlayerCoopRequest::KickPlayerCoopRequest(
    ::_pbi::ConstantInitialized)
  : contract_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , coop_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , player_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , requesting_user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , rinfo_(nullptr)
  , client_version_(0u)
  , reason_(0)
{}
struct KickPlayerCoopRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KickPlayerCoopRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KickPlayerCoopRequestDefaultTypeInternal() {}
  union {
    KickPlayerCoopRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KickPlayerCoopRequestDefaultTypeInternal _KickPlayerCoopRequest_default_instance_;
PROTOBUF_CONSTEXPR ContractCoopStatusUpdateRequest::ContractCoopStatusUpdateRequest(
    ::_pbi::ConstantInitialized)
  : user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , contract_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , coop_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , push_user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , rinfo_(nullptr)
  , production_params_(nullptr)
  , farm_info_(nullptr)
  , amount_(0)
  , rate_(0)
  , soul_power_(0)
  , time_cheats_detected_(0u)
  , boost_tokens_(0u)
  , boost_tokens_spent_(0u)
  , eop_(0u)
  , egg_laying_rate_buff_(1)
  , earnings_buff_(1){}
struct ContractCoopStatusUpdateRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContractCoopStatusUpdateRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContractCoopStatusUpdateRequestDefaultTypeInternal() {}
  union {
    ContractCoopStatusUpdateRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContractCoopStatusUpdateRequestDefaultTypeInternal _ContractCoopStatusUpdateRequest_default_instance_;
PROTOBUF_CONSTEXPR ContractCoopStatusUpdateResponse::ContractCoopStatusUpdateResponse(
    ::_pbi::ConstantInitialized)
  : finalized_(false)
  , exists_(false)
  , status_(0)
{}
struct ContractCoopStatusUpdateResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContractCoopStatusUpdateResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContractCoopStatusUpdateResponseDefaultTypeInternal() {}
  union {
    ContractCoopStatusUpdateResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContractCoopStatusUpdateResponseDefaultTypeInternal _ContractCoopStatusUpdateResponse_default_instance_;
PROTOBUF_CONSTEXPR CoopBuffState::CoopBuffState(
    ::_pbi::ConstantInitialized)
  : server_timestamp_(0)
  , egg_laying_rate_(1)
  , earnings_(1){}
struct CoopBuffStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CoopBuffStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CoopBuffStateDefaultTypeInternal() {}
  union {
    CoopBuffState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CoopBuffStateDefaultTypeInternal _CoopBuffState_default_instance_;
PROTOBUF_CONSTEXPR CoopBuffHistory::CoopBuffHistory(
    ::_pbi::ConstantInitialized)
  : history_(){}
struct CoopBuffHistoryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CoopBuffHistoryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CoopBuffHistoryDefaultTypeInternal() {}
  union {
    CoopBuffHistory _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CoopBuffHistoryDefaultTypeInternal _CoopBuffHistory_default_instance_;
PROTOBUF_CONSTEXPR CoopChickenRunEntry::CoopChickenRunEntry(
    ::_pbi::ConstantInitialized)
  : user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , server_timestamp_(0){}
struct CoopChickenRunEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CoopChickenRunEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CoopChickenRunEntryDefaultTypeInternal() {}
  union {
    CoopChickenRunEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CoopChickenRunEntryDefaultTypeInternal _CoopChickenRunEntry_default_instance_;
PROTOBUF_CONSTEXPR CoopLastChickenRunTimes::CoopLastChickenRunTimes(
    ::_pbi::ConstantInitialized)
  : entries_(){}
struct CoopLastChickenRunTimesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CoopLastChickenRunTimesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CoopLastChickenRunTimesDefaultTypeInternal() {}
  union {
    CoopLastChickenRunTimes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CoopLastChickenRunTimesDefaultTypeInternal _CoopLastChickenRunTimes_default_instance_;
PROTOBUF_CONSTEXPR LeaderboardAnalysis_Chunk::LeaderboardAnalysis_Chunk(
    ::_pbi::ConstantInitialized)
  : start_cursor_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , end_cursor_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , start_index_(0u)
  , end_index_(0u)
  , high_score_(0)
  , low_score_(0){}
struct LeaderboardAnalysis_ChunkDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LeaderboardAnalysis_ChunkDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LeaderboardAnalysis_ChunkDefaultTypeInternal() {}
  union {
    LeaderboardAnalysis_Chunk _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LeaderboardAnalysis_ChunkDefaultTypeInternal _LeaderboardAnalysis_Chunk_default_instance_;
PROTOBUF_CONSTEXPR LeaderboardAnalysis::LeaderboardAnalysis(
    ::_pbi::ConstantInitialized)
  : chunks_()
  , high_score_(0)
  , low_score_(0)
  , count_(0u){}
struct LeaderboardAnalysisDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LeaderboardAnalysisDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LeaderboardAnalysisDefaultTypeInternal() {}
  union {
    LeaderboardAnalysis _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LeaderboardAnalysisDefaultTypeInternal _LeaderboardAnalysis_default_instance_;
PROTOBUF_CONSTEXPR LeaderboardInfo_Season::LeaderboardInfo_Season(
    ::_pbi::ConstantInitialized)
  : scope_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct LeaderboardInfo_SeasonDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LeaderboardInfo_SeasonDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LeaderboardInfo_SeasonDefaultTypeInternal() {}
  union {
    LeaderboardInfo_Season _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LeaderboardInfo_SeasonDefaultTypeInternal _LeaderboardInfo_Season_default_instance_;
PROTOBUF_CONSTEXPR LeaderboardInfo::LeaderboardInfo(
    ::_pbi::ConstantInitialized)
  : seasons_()
  , all_time_scope_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct LeaderboardInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LeaderboardInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LeaderboardInfoDefaultTypeInternal() {}
  union {
    LeaderboardInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LeaderboardInfoDefaultTypeInternal _LeaderboardInfo_default_instance_;
PROTOBUF_CONSTEXPR LeaderboardRequest::LeaderboardRequest(
    ::_pbi::ConstantInitialized)
  : scope_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , rinfo_(nullptr)
  , grade_(0)
{}
struct LeaderboardRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LeaderboardRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LeaderboardRequestDefaultTypeInternal() {}
  union {
    LeaderboardRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LeaderboardRequestDefaultTypeInternal _LeaderboardRequest_default_instance_;
PROTOBUF_CONSTEXPR LeaderboardResponse_Entry::LeaderboardResponse_Entry(
    ::_pbi::ConstantInitialized)
  : alias_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , score_(0)
  , rank_(0u){}
struct LeaderboardResponse_EntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LeaderboardResponse_EntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LeaderboardResponse_EntryDefaultTypeInternal() {}
  union {
    LeaderboardResponse_Entry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LeaderboardResponse_EntryDefaultTypeInternal _LeaderboardResponse_Entry_default_instance_;
PROTOBUF_CONSTEXPR LeaderboardResponse::LeaderboardResponse(
    ::_pbi::ConstantInitialized)
  : top_entries_()
  , scope_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , grade_(0)

  , count_(0u)
  , score_(0)
  , rank_(0u){}
struct LeaderboardResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LeaderboardResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LeaderboardResponseDefaultTypeInternal() {}
  union {
    LeaderboardResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LeaderboardResponseDefaultTypeInternal _LeaderboardResponse_default_instance_;
PROTOBUF_CONSTEXPR ContractsArchive::ContractsArchive(
    ::_pbi::ConstantInitialized)
  : archive_(){}
struct ContractsArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContractsArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContractsArchiveDefaultTypeInternal() {}
  union {
    ContractsArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContractsArchiveDefaultTypeInternal _ContractsArchive_default_instance_;
PROTOBUF_CONSTEXPR ContractAction::ContractAction(
    ::_pbi::ConstantInitialized)
  : user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , action_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , dest_user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , contract_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , coop_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , reward_subtype_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , boost_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , approx_time_(0)
  , grade_(0u)
  , reward_type_(0u)
  , autojoin_(false)
  , replay_(false)
  , points_replay_(false)
  , public__(false)
  , goal_index_(0u)
  , reward_amount_(0)
  , tokens_(0u)
  , kick_reason_(0u)
  , cc_only_(false){}
struct ContractActionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContractActionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContractActionDefaultTypeInternal() {}
  union {
    ContractAction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContractActionDefaultTypeInternal _ContractAction_default_instance_;
PROTOBUF_CONSTEXPR UserDataInfoRequest::UserDataInfoRequest(
    ::_pbi::ConstantInitialized)
  : user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , device_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , rinfo_(nullptr)
  , backup_checksum_(uint64_t{0u}){}
struct UserDataInfoRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserDataInfoRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserDataInfoRequestDefaultTypeInternal() {}
  union {
    UserDataInfoRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserDataInfoRequestDefaultTypeInternal _UserDataInfoRequest_default_instance_;
PROTOBUF_CONSTEXPR UserDataInfoResponse::UserDataInfoResponse(
    ::_pbi::ConstantInitialized)
  : coop_memberships_()
  , backup_checksum_(uint64_t{0u})
  , backup_total_cash_(0){}
struct UserDataInfoResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserDataInfoResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserDataInfoResponseDefaultTypeInternal() {}
  union {
    UserDataInfoResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserDataInfoResponseDefaultTypeInternal _UserDataInfoResponse_default_instance_;
PROTOBUF_CONSTEXPR ClearAllUserDataRequest::ClearAllUserDataRequest(
    ::_pbi::ConstantInitialized)
  : user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , device_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , rinfo_(nullptr)
  , backup_checksum_(uint64_t{0u}){}
struct ClearAllUserDataRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClearAllUserDataRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClearAllUserDataRequestDefaultTypeInternal() {}
  union {
    ClearAllUserDataRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClearAllUserDataRequestDefaultTypeInternal _ClearAllUserDataRequest_default_instance_;
PROTOBUF_CONSTEXPR ServerGift::ServerGift(
    ::_pbi::ConstantInitialized)
  : user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , reward_sub_type_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , reward_amount_(0)
  , reward_type_(1)
{}
struct ServerGiftDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServerGiftDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServerGiftDefaultTypeInternal() {}
  union {
    ServerGift _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServerGiftDefaultTypeInternal _ServerGift_default_instance_;
PROTOBUF_CONSTEXPR LiveConfig_BoostsConfig_ItemConfig::LiveConfig_BoostsConfig_ItemConfig(
    ::_pbi::ConstantInitialized)
  : boost_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , price_(0u)
  , token_price_(0u)
  , se_required_(0){}
struct LiveConfig_BoostsConfig_ItemConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LiveConfig_BoostsConfig_ItemConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LiveConfig_BoostsConfig_ItemConfigDefaultTypeInternal() {}
  union {
    LiveConfig_BoostsConfig_ItemConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LiveConfig_BoostsConfig_ItemConfigDefaultTypeInternal _LiveConfig_BoostsConfig_ItemConfig_default_instance_;
PROTOBUF_CONSTEXPR LiveConfig_BoostsConfig::LiveConfig_BoostsConfig(
    ::_pbi::ConstantInitialized)
  : item_configs_()
  , cash_boost_cooloff_time_(0){}
struct LiveConfig_BoostsConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LiveConfig_BoostsConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LiveConfig_BoostsConfigDefaultTypeInternal() {}
  union {
    LiveConfig_BoostsConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LiveConfig_BoostsConfigDefaultTypeInternal _LiveConfig_BoostsConfig_default_instance_;
PROTOBUF_CONSTEXPR LiveConfig_GiftConfig_GiftValueConfig::LiveConfig_GiftConfig_GiftValueConfig(
    ::_pbi::ConstantInitialized)
  : gift_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , rand_min_(0)
  , rand_max_(0)
  , amount_(0)
  , video_min_(0)
  , video_max_(0){}
struct LiveConfig_GiftConfig_GiftValueConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LiveConfig_GiftConfig_GiftValueConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LiveConfig_GiftConfig_GiftValueConfigDefaultTypeInternal() {}
  union {
    LiveConfig_GiftConfig_GiftValueConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LiveConfig_GiftConfig_GiftValueConfigDefaultTypeInternal _LiveConfig_GiftConfig_GiftValueConfig_default_instance_;
PROTOBUF_CONSTEXPR LiveConfig_GiftConfig_GiftMuConfig::LiveConfig_GiftConfig_GiftMuConfig(
    ::_pbi::ConstantInitialized)
  : min_spent_(0)
  , max_spent_(0)
  , overall_mult_(0){}
struct LiveConfig_GiftConfig_GiftMuConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LiveConfig_GiftConfig_GiftMuConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LiveConfig_GiftConfig_GiftMuConfigDefaultTypeInternal() {}
  union {
    LiveConfig_GiftConfig_GiftMuConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LiveConfig_GiftConfig_GiftMuConfigDefaultTypeInternal _LiveConfig_GiftConfig_GiftMuConfig_default_instance_;
PROTOBUF_CONSTEXPR LiveConfig_GiftConfig::LiveConfig_GiftConfig(
    ::_pbi::ConstantInitialized)
  : gift_configs_()
  , random_gift_mu_config_(nullptr)
  , video_gift_mu_config_(nullptr)
  , package_interval_(0)
  , video_offer_interval_(0)
  , video_offer_interval_contract_(0)
  , video_offer_interval_piggy_full_(0)
  , video_offer_interval_piggy_extra_full_(0)
  , package_interval_contract_(0)
  , package_interval_piggy_full_(0)
  , package_interval_piggy_extra_full_(0)
  , gift_mu_min_spent_(0)
  , gift_mu_max_spent_(0)
  , gift_mu_overall_mult_(0)
  , video_reset_on_idle_(false)
  , package_reset_on_idle_(false){}
struct LiveConfig_GiftConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LiveConfig_GiftConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LiveConfig_GiftConfigDefaultTypeInternal() {}
  union {
    LiveConfig_GiftConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LiveConfig_GiftConfigDefaultTypeInternal _LiveConfig_GiftConfig_default_instance_;
PROTOBUF_CONSTEXPR LiveConfig_MiscConfig::LiveConfig_MiscConfig(
    ::_pbi::ConstantInitialized)
  : ask_to_track_message_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , ask_to_track_min_soul_eggs_(0)
  , ask_to_track_(false)
  , ask_to_track_show_pre_dialog_(false)
  , ask_to_track_after_privacy_(false)
  , contracts_club_available_(false)
  , shells_intro_tickets_(0u)
  , chicken_run_boost_percentage_(0)
  , shells_max_free_chicken_configs_(0u)
  , shells_intro_alert_threshold_(0u)
  , contracts_expert_league_min_soul_power_(0)
  , new_player_event_duration_(0)
  , contracts_beta_(false){}
struct LiveConfig_MiscConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LiveConfig_MiscConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LiveConfig_MiscConfigDefaultTypeInternal() {}
  union {
    LiveConfig_MiscConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LiveConfig_MiscConfigDefaultTypeInternal _LiveConfig_MiscConfig_default_instance_;
PROTOBUF_CONSTEXPR LiveConfig::LiveConfig(
    ::_pbi::ConstantInitialized)
  : config_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , boosts_config_(nullptr)
  , gift_config_(nullptr)
  , misc_config_(nullptr){}
struct LiveConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LiveConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LiveConfigDefaultTypeInternal() {}
  union {
    LiveConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LiveConfigDefaultTypeInternal _LiveConfig_default_instance_;
PROTOBUF_CONSTEXPR InGameMail::InGameMail(
    ::_pbi::ConstantInitialized)
  : builds_()
  , id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , title_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , message_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , action_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , url_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , date_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , gold_tip_(0)
  , platform_(0u)
  , min_client_version_(0u)
  , min_soul_eggs_(0)
  , min_mystical_bonus_(0)
  , max_client_version_(0u){}
struct InGameMailDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InGameMailDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InGameMailDefaultTypeInternal() {}
  union {
    InGameMail _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InGameMailDefaultTypeInternal _InGameMail_default_instance_;
PROTOBUF_CONSTEXPR MailDB::MailDB(
    ::_pbi::ConstantInitialized)
  : mail_(){}
struct MailDBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MailDBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MailDBDefaultTypeInternal() {}
  union {
    MailDB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MailDBDefaultTypeInternal _MailDB_default_instance_;
PROTOBUF_CONSTEXPR PeriodicalsResponse::PeriodicalsResponse(
    ::_pbi::ConstantInitialized)
  : gifts_()
  , evaluations_()
  , sales_(nullptr)
  , events_(nullptr)
  , contracts_(nullptr)
  , live_config_(nullptr)
  , mail_bag_(nullptr)
  , contract_player_info_(nullptr){}
struct PeriodicalsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PeriodicalsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PeriodicalsResponseDefaultTypeInternal() {}
  union {
    PeriodicalsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PeriodicalsResponseDefaultTypeInternal _PeriodicalsResponse_default_instance_;
PROTOBUF_CONSTEXPR GetPeriodicalsRequest::GetPeriodicalsRequest(
    ::_pbi::ConstantInitialized)
  : user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , rinfo_(nullptr)
  , seconds_full_realtime_(0)
  , seconds_full_gametime_(0)
  , soul_eggs_(0)
  , lost_increments_(0u)
  , piggy_full_(false)
  , piggy_found_full_(false)
  , contracts_unlocked_(false)
  , artifacts_unlocked_(false)
  , current_client_version_(0u)
  , debug_(false)
  , mystical_earnings_mult_(0)
  , eop_(0u){}
struct GetPeriodicalsRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetPeriodicalsRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetPeriodicalsRequestDefaultTypeInternal() {}
  union {
    GetPeriodicalsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetPeriodicalsRequestDefaultTypeInternal _GetPeriodicalsRequest_default_instance_;
PROTOBUF_CONSTEXPR ConfigRequest::ConfigRequest(
    ::_pbi::ConstantInitialized)
  : rinfo_(nullptr)
  , soul_eggs_(0)
  , artifacts_enabled_(false)
  , fuel_tank_unlocked_(false){}
struct ConfigRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConfigRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConfigRequestDefaultTypeInternal() {}
  union {
    ConfigRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConfigRequestDefaultTypeInternal _ConfigRequest_default_instance_;
PROTOBUF_CONSTEXPR ConfigResponse::ConfigResponse(
    ::_pbi::ConstantInitialized)
  : live_config_(nullptr)
  , mail_bag_(nullptr)
  , dlc_catalog_(nullptr){}
struct ConfigResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConfigResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConfigResponseDefaultTypeInternal() {}
  union {
    ConfigResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConfigResponseDefaultTypeInternal _ConfigResponse_default_instance_;
PROTOBUF_CONSTEXPR AdAttributionRawData::AdAttributionRawData(
    ::_pbi::ConstantInitialized)
  : device_ad_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , ad_network_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , json_data_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct AdAttributionRawDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AdAttributionRawDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AdAttributionRawDataDefaultTypeInternal() {}
  union {
    AdAttributionRawData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AdAttributionRawDataDefaultTypeInternal _AdAttributionRawData_default_instance_;
PROTOBUF_CONSTEXPR AdAttributionRow::AdAttributionRow(
    ::_pbi::ConstantInitialized)
  : user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , ad_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , ad_network_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , campaign_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , keyword_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , extra_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , click_date_(0)
  , download_date_(0)
  , approx_time_(0){}
struct AdAttributionRowDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AdAttributionRowDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AdAttributionRowDefaultTypeInternal() {}
  union {
    AdAttributionRow _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AdAttributionRowDefaultTypeInternal _AdAttributionRow_default_instance_;
PROTOBUF_CONSTEXPR AdAttributionInfo::AdAttributionInfo(
    ::_pbi::ConstantInitialized)
  : device_ad_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , network_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , org_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , org_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , campaign_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , campaign_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , click_date_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , conversion_date_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , conversion_type_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , geo_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , adgroup_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , adgroup_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , keyword_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , keyword_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , keyword_extra_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , creativeset_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , creativeset_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , attribution_(false){}
struct AdAttributionInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AdAttributionInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AdAttributionInfoDefaultTypeInternal() {}
  union {
    AdAttributionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AdAttributionInfoDefaultTypeInternal _AdAttributionInfo_default_instance_;
PROTOBUF_CONSTEXPR ArtifactsClientInfo_LaunchCount::ArtifactsClientInfo_LaunchCount(
    ::_pbi::ConstantInitialized)
  : ship_(0)

  , num_launches_(0u)
  , launch_points_(0){}
struct ArtifactsClientInfo_LaunchCountDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ArtifactsClientInfo_LaunchCountDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ArtifactsClientInfo_LaunchCountDefaultTypeInternal() {}
  union {
    ArtifactsClientInfo_LaunchCount _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ArtifactsClientInfo_LaunchCountDefaultTypeInternal _ArtifactsClientInfo_LaunchCount_default_instance_;
PROTOBUF_CONSTEXPR ArtifactsClientInfo::ArtifactsClientInfo(
    ::_pbi::ConstantInitialized)
  : launch_counts_()
  , mission_capacity_mult_(0)
  , mission_duration_mult_(0)
  , mission_ftl_duration_mult_(0){}
struct ArtifactsClientInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ArtifactsClientInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ArtifactsClientInfoDefaultTypeInternal() {}
  union {
    ArtifactsClientInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ArtifactsClientInfoDefaultTypeInternal _ArtifactsClientInfo_default_instance_;
PROTOBUF_CONSTEXPR MissionInfo_Fuel::MissionInfo_Fuel(
    ::_pbi::ConstantInitialized)
  : amount_(0)
  , egg_(1)
{}
struct MissionInfo_FuelDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MissionInfo_FuelDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MissionInfo_FuelDefaultTypeInternal() {}
  union {
    MissionInfo_Fuel _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MissionInfo_FuelDefaultTypeInternal _MissionInfo_Fuel_default_instance_;
PROTOBUF_CONSTEXPR MissionInfo::MissionInfo(
    ::_pbi::ConstantInitialized)
  : fuel_()
  , identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , mission_log_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , ship_(0)

  , status_(0)

  , duration_seconds_(0)
  , seconds_remaining_(0)
  , duration_type_(0)

  , capacity_(0u)
  , start_time_derived_(0)
  , quality_bump_(0)
  , level_(0u){}
struct MissionInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MissionInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MissionInfoDefaultTypeInternal() {}
  union {
    MissionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MissionInfoDefaultTypeInternal _MissionInfo_default_instance_;
PROTOBUF_CONSTEXPR ArtifactSpec::ArtifactSpec(
    ::_pbi::ConstantInitialized)
  : name_(0)

  , level_(0)

  , rarity_(0)

  , egg_(1)
{}
struct ArtifactSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ArtifactSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ArtifactSpecDefaultTypeInternal() {}
  union {
    ArtifactSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ArtifactSpecDefaultTypeInternal _ArtifactSpec_default_instance_;
PROTOBUF_CONSTEXPR CompleteArtifact::CompleteArtifact(
    ::_pbi::ConstantInitialized)
  : stones_()
  , spec_(nullptr){}
struct CompleteArtifactDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CompleteArtifactDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CompleteArtifactDefaultTypeInternal() {}
  union {
    CompleteArtifact _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CompleteArtifactDefaultTypeInternal _CompleteArtifact_default_instance_;
PROTOBUF_CONSTEXPR ArtifactInventoryItem::ArtifactInventoryItem(
    ::_pbi::ConstantInitialized)
  : server_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , artifact_(nullptr)
  , item_id_(uint64_t{0u})
  , quantity_(0){}
struct ArtifactInventoryItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ArtifactInventoryItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ArtifactInventoryItemDefaultTypeInternal() {}
  union {
    ArtifactInventoryItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ArtifactInventoryItemDefaultTypeInternal _ArtifactInventoryItem_default_instance_;
PROTOBUF_CONSTEXPR InventorySlot::InventorySlot(
    ::_pbi::ConstantInitialized)
  : occupied_(false)
  , item_id_(0u){}
struct InventorySlotDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InventorySlotDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InventorySlotDefaultTypeInternal() {}
  union {
    InventorySlot _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InventorySlotDefaultTypeInternal _InventorySlot_default_instance_;
PROTOBUF_CONSTEXPR ArtifactsConfigurationRequest::ArtifactsConfigurationRequest(
    ::_pbi::ConstantInitialized)
  : rinfo_(nullptr)
  , client_version_(0u){}
struct ArtifactsConfigurationRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ArtifactsConfigurationRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ArtifactsConfigurationRequestDefaultTypeInternal() {}
  union {
    ArtifactsConfigurationRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ArtifactsConfigurationRequestDefaultTypeInternal _ArtifactsConfigurationRequest_default_instance_;
PROTOBUF_CONSTEXPR ArtifactsConfigurationResponse_MissionParameters_Duration::ArtifactsConfigurationResponse_MissionParameters_Duration(
    ::_pbi::ConstantInitialized)
  : seconds_(0)
  , duration_type_(0)

  , quality_(0)
  , min_quality_(0)
  , max_quality_(0)
  , capacity_(0u)
  , level_capacity_bump_(0u)
  , level_quality_bump_(0){}
struct ArtifactsConfigurationResponse_MissionParameters_DurationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ArtifactsConfigurationResponse_MissionParameters_DurationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ArtifactsConfigurationResponse_MissionParameters_DurationDefaultTypeInternal() {}
  union {
    ArtifactsConfigurationResponse_MissionParameters_Duration _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ArtifactsConfigurationResponse_MissionParameters_DurationDefaultTypeInternal _ArtifactsConfigurationResponse_MissionParameters_Duration_default_instance_;
PROTOBUF_CONSTEXPR ArtifactsConfigurationResponse_MissionParameters::ArtifactsConfigurationResponse_MissionParameters(
    ::_pbi::ConstantInitialized)
  : durations_()
  , level_mission_requirements_()
  , ship_(0)

  , capacity_deprecated_(0u){}
struct ArtifactsConfigurationResponse_MissionParametersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ArtifactsConfigurationResponse_MissionParametersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ArtifactsConfigurationResponse_MissionParametersDefaultTypeInternal() {}
  union {
    ArtifactsConfigurationResponse_MissionParameters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ArtifactsConfigurationResponse_MissionParametersDefaultTypeInternal _ArtifactsConfigurationResponse_MissionParameters_default_instance_;
PROTOBUF_CONSTEXPR ArtifactsConfigurationResponse_ArtifactParameters::ArtifactsConfigurationResponse_ArtifactParameters(
    ::_pbi::ConstantInitialized)
  : spec_(nullptr)
  , base_quality_(0)
  , value_(0)
  , odds_multiplier_(0)
  , crafting_price_(0)
  , crafting_price_low_(0)
  , crafting_price_curve_(0)
  , crafting_xp_(uint64_t{0u})
  , crafting_price_domain_(0u){}
struct ArtifactsConfigurationResponse_ArtifactParametersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ArtifactsConfigurationResponse_ArtifactParametersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ArtifactsConfigurationResponse_ArtifactParametersDefaultTypeInternal() {}
  union {
    ArtifactsConfigurationResponse_ArtifactParameters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ArtifactsConfigurationResponse_ArtifactParametersDefaultTypeInternal _ArtifactsConfigurationResponse_ArtifactParameters_default_instance_;
PROTOBUF_CONSTEXPR ArtifactsConfigurationResponse_CraftingLevelInfo::ArtifactsConfigurationResponse_CraftingLevelInfo(
    ::_pbi::ConstantInitialized)
  : xp_required_(0)
  , rarity_mult_(0){}
struct ArtifactsConfigurationResponse_CraftingLevelInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ArtifactsConfigurationResponse_CraftingLevelInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ArtifactsConfigurationResponse_CraftingLevelInfoDefaultTypeInternal() {}
  union {
    ArtifactsConfigurationResponse_CraftingLevelInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ArtifactsConfigurationResponse_CraftingLevelInfoDefaultTypeInternal _ArtifactsConfigurationResponse_CraftingLevelInfo_default_instance_;
PROTOBUF_CONSTEXPR ArtifactsConfigurationResponse::ArtifactsConfigurationResponse(
    ::_pbi::ConstantInitialized)
  : mission_parameters_()
  , artifact_parameters_()
  , crafting_level_infos_(){}
struct ArtifactsConfigurationResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ArtifactsConfigurationResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ArtifactsConfigurationResponseDefaultTypeInternal() {}
  union {
    ArtifactsConfigurationResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ArtifactsConfigurationResponseDefaultTypeInternal _ArtifactsConfigurationResponse_default_instance_;
PROTOBUF_CONSTEXPR MissionRequest::MissionRequest(
    ::_pbi::ConstantInitialized)
  : ei_user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , info_(nullptr)
  , rinfo_(nullptr)
  , client_info_(nullptr)
  , client_version_(0u){}
struct MissionRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MissionRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MissionRequestDefaultTypeInternal() {}
  union {
    MissionRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MissionRequestDefaultTypeInternal _MissionRequest_default_instance_;
PROTOBUF_CONSTEXPR MissionResponse::MissionResponse(
    ::_pbi::ConstantInitialized)
  : info_(nullptr)
  , success_(false){}
struct MissionResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MissionResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MissionResponseDefaultTypeInternal() {}
  union {
    MissionResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MissionResponseDefaultTypeInternal _MissionResponse_default_instance_;
PROTOBUF_CONSTEXPR CompleteMissionResponse_SecureArtifactSpec::CompleteMissionResponse_SecureArtifactSpec(
    ::_pbi::ConstantInitialized)
  : server_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , spec_(nullptr){}
struct CompleteMissionResponse_SecureArtifactSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CompleteMissionResponse_SecureArtifactSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CompleteMissionResponse_SecureArtifactSpecDefaultTypeInternal() {}
  union {
    CompleteMissionResponse_SecureArtifactSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CompleteMissionResponse_SecureArtifactSpecDefaultTypeInternal _CompleteMissionResponse_SecureArtifactSpec_default_instance_;
PROTOBUF_CONSTEXPR CompleteMissionResponse::CompleteMissionResponse(
    ::_pbi::ConstantInitialized)
  : artifacts_()
  , other_rewards_()
  , ei_user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , info_(nullptr)
  , success_(false){}
struct CompleteMissionResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CompleteMissionResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CompleteMissionResponseDefaultTypeInternal() {}
  union {
    CompleteMissionResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CompleteMissionResponseDefaultTypeInternal _CompleteMissionResponse_default_instance_;
PROTOBUF_CONSTEXPR CollectContractArtifactRewardsRequest::CollectContractArtifactRewardsRequest(
    ::_pbi::ConstantInitialized)
  : contract_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , rinfo_(nullptr)
  , goal_index_(0u)
  , best_ship_(0)

  , league_(0u)
  , grade_(0)
{}
struct CollectContractArtifactRewardsRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CollectContractArtifactRewardsRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CollectContractArtifactRewardsRequestDefaultTypeInternal() {}
  union {
    CollectContractArtifactRewardsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CollectContractArtifactRewardsRequestDefaultTypeInternal _CollectContractArtifactRewardsRequest_default_instance_;
PROTOBUF_CONSTEXPR CraftArtifactRequest::CraftArtifactRequest(
    ::_pbi::ConstantInitialized)
  : ingredients_()
  , ei_user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , spec_(nullptr)
  , rinfo_(nullptr)
  , item_id_(uint64_t{0u})
  , gold_price_paid_(0)
  , crafting_xp_(0)
  , crafting_count_(0u){}
struct CraftArtifactRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CraftArtifactRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CraftArtifactRequestDefaultTypeInternal() {}
  union {
    CraftArtifactRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CraftArtifactRequestDefaultTypeInternal _CraftArtifactRequest_default_instance_;
PROTOBUF_CONSTEXPR CraftArtifactResponse::CraftArtifactResponse(
    ::_pbi::ConstantInitialized)
  : server_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , ei_user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , item_id_(uint64_t{0u})
  , rarity_achieved_(0)
{}
struct CraftArtifactResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CraftArtifactResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CraftArtifactResponseDefaultTypeInternal() {}
  union {
    CraftArtifactResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CraftArtifactResponseDefaultTypeInternal _CraftArtifactResponse_default_instance_;
PROTOBUF_CONSTEXPR ConsumeArtifactRequest::ConsumeArtifactRequest(
    ::_pbi::ConstantInitialized)
  : additional_server_ids_()
  , additional_item_ids_()
  , ei_user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , artifact_server_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , spec_(nullptr)
  , rinfo_(nullptr)
  , original_item_id_(uint64_t{0u})
  , quantity_(0u){}
struct ConsumeArtifactRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConsumeArtifactRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConsumeArtifactRequestDefaultTypeInternal() {}
  union {
    ConsumeArtifactRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConsumeArtifactRequestDefaultTypeInternal _ConsumeArtifactRequest_default_instance_;
PROTOBUF_CONSTEXPR ConsumeArtifactResponse::ConsumeArtifactResponse(
    ::_pbi::ConstantInitialized)
  : byproducts_()
  , other_rewards_()
  , additional_item_ids_()
  , ei_user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , original_item_id_(uint64_t{0u})
  , success_(false){}
struct ConsumeArtifactResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConsumeArtifactResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConsumeArtifactResponseDefaultTypeInternal() {}
  union {
    ConsumeArtifactResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConsumeArtifactResponseDefaultTypeInternal _ConsumeArtifactResponse_default_instance_;
PROTOBUF_CONSTEXPR AuthenticateArtifactResponse::AuthenticateArtifactResponse(
    ::_pbi::ConstantInitialized)
  : ei_user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , original_item_id_(uint64_t{0u})
  , success_(false)
  , demote_(false)
  , delete__(false){}
struct AuthenticateArtifactResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthenticateArtifactResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthenticateArtifactResponseDefaultTypeInternal() {}
  union {
    AuthenticateArtifactResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthenticateArtifactResponseDefaultTypeInternal _AuthenticateArtifactResponse_default_instance_;
PROTOBUF_CONSTEXPR SetArtifactRequest::SetArtifactRequest(
    ::_pbi::ConstantInitialized)
  : stones_()
  , rinfo_(nullptr)
  , artifact_(nullptr)
  , gold_price_paid_(0){}
struct SetArtifactRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetArtifactRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetArtifactRequestDefaultTypeInternal() {}
  union {
    SetArtifactRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetArtifactRequestDefaultTypeInternal _SetArtifactRequest_default_instance_;
PROTOBUF_CONSTEXPR SetArtifactResponse::SetArtifactResponse(
    ::_pbi::ConstantInitialized)
  : ei_user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , original_item_id_(uint64_t{0u})
  , success_(false){}
struct SetArtifactResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetArtifactResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetArtifactResponseDefaultTypeInternal() {}
  union {
    SetArtifactResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetArtifactResponseDefaultTypeInternal _SetArtifactResponse_default_instance_;
PROTOBUF_CONSTEXPR ArtifactsDB_ActiveArtifactSlot::ArtifactsDB_ActiveArtifactSlot(
    ::_pbi::ConstantInitialized)
  : item_id_(uint64_t{0u})
  , occupied_(false){}
struct ArtifactsDB_ActiveArtifactSlotDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ArtifactsDB_ActiveArtifactSlotDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ArtifactsDB_ActiveArtifactSlotDefaultTypeInternal() {}
  union {
    ArtifactsDB_ActiveArtifactSlot _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ArtifactsDB_ActiveArtifactSlotDefaultTypeInternal _ArtifactsDB_ActiveArtifactSlot_default_instance_;
PROTOBUF_CONSTEXPR ArtifactsDB_ActiveArtifactSet::ArtifactsDB_ActiveArtifactSet(
    ::_pbi::ConstantInitialized)
  : slots_(){}
struct ArtifactsDB_ActiveArtifactSetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ArtifactsDB_ActiveArtifactSetDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ArtifactsDB_ActiveArtifactSetDefaultTypeInternal() {}
  union {
    ArtifactsDB_ActiveArtifactSet _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ArtifactsDB_ActiveArtifactSetDefaultTypeInternal _ArtifactsDB_ActiveArtifactSet_default_instance_;
PROTOBUF_CONSTEXPR ArtifactsDB_CraftableArtifact::ArtifactsDB_CraftableArtifact(
    ::_pbi::ConstantInitialized)
  : spec_(nullptr)
  , count_(0u)
  , discovered_(false)
  , craftable_(false)
  , recipe_discovered_(false)
  , seen_(false){}
struct ArtifactsDB_CraftableArtifactDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ArtifactsDB_CraftableArtifactDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ArtifactsDB_CraftableArtifactDefaultTypeInternal() {}
  union {
    ArtifactsDB_CraftableArtifact _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ArtifactsDB_CraftableArtifactDefaultTypeInternal _ArtifactsDB_CraftableArtifact_default_instance_;
PROTOBUF_CONSTEXPR ArtifactsDB::ArtifactsDB(
    ::_pbi::ConstantInitialized)
  : inventory_items_()
  , inventory_slots_()
  , mission_infos_()
  , mission_archive_()
  , active_artifacts_()
  , discovered_artifacts_deprecated_()
  , craftable_artifacts_deprecated_()
  , crafting_counts_deprecated_()
  , active_artifact_sets_()
  , artifact_status_()
  , item_sequence_(uint64_t{0u}){}
struct ArtifactsDBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ArtifactsDBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ArtifactsDBDefaultTypeInternal() {}
  union {
    ArtifactsDB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ArtifactsDBDefaultTypeInternal _ArtifactsDB_default_instance_;
PROTOBUF_CONSTEXPR AuthenticatedMessage::AuthenticatedMessage(
    ::_pbi::ConstantInitialized)
  : message_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , code_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , version_(0u)
  , compressed_(false)
  , original_size_(0u){}
struct AuthenticatedMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthenticatedMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthenticatedMessageDefaultTypeInternal() {}
  union {
    AuthenticatedMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthenticatedMessageDefaultTypeInternal _AuthenticatedMessage_default_instance_;
PROTOBUF_CONSTEXPR LogCompleteMissionPayload::LogCompleteMissionPayload(
    ::_pbi::ConstantInitialized)
  : req_(nullptr)
  , res_(nullptr){}
struct LogCompleteMissionPayloadDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LogCompleteMissionPayloadDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LogCompleteMissionPayloadDefaultTypeInternal() {}
  union {
    LogCompleteMissionPayload _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LogCompleteMissionPayloadDefaultTypeInternal _LogCompleteMissionPayload_default_instance_;
PROTOBUF_CONSTEXPR LogCraftArtifactPayload::LogCraftArtifactPayload(
    ::_pbi::ConstantInitialized)
  : req_(nullptr)
  , res_(nullptr){}
struct LogCraftArtifactPayloadDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LogCraftArtifactPayloadDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LogCraftArtifactPayloadDefaultTypeInternal() {}
  union {
    LogCraftArtifactPayload _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LogCraftArtifactPayloadDefaultTypeInternal _LogCraftArtifactPayload_default_instance_;
PROTOBUF_CONSTEXPR LogConsumeArtifactPayload::LogConsumeArtifactPayload(
    ::_pbi::ConstantInitialized)
  : req_(nullptr)
  , res_(nullptr){}
struct LogConsumeArtifactPayloadDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LogConsumeArtifactPayloadDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LogConsumeArtifactPayloadDefaultTypeInternal() {}
  union {
    LogConsumeArtifactPayload _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LogConsumeArtifactPayloadDefaultTypeInternal _LogConsumeArtifactPayload_default_instance_;
PROTOBUF_CONSTEXPR LogSetArtifactPayload::LogSetArtifactPayload(
    ::_pbi::ConstantInitialized)
  : req_(nullptr)
  , res_(nullptr){}
struct LogSetArtifactPayloadDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LogSetArtifactPayloadDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LogSetArtifactPayloadDefaultTypeInternal() {}
  union {
    LogSetArtifactPayload _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LogSetArtifactPayloadDefaultTypeInternal _LogSetArtifactPayload_default_instance_;
PROTOBUF_CONSTEXPR AccountTransferPayload::AccountTransferPayload(
    ::_pbi::ConstantInitialized)
  : from_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , to_ei_user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct AccountTransferPayloadDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccountTransferPayloadDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccountTransferPayloadDefaultTypeInternal() {}
  union {
    AccountTransferPayload _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccountTransferPayloadDefaultTypeInternal _AccountTransferPayload_default_instance_;
PROTOBUF_CONSTEXPR SaveBackupResponse::SaveBackupResponse(
    ::_pbi::ConstantInitialized)
  : message_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , existing_backup_(nullptr)
  , success_(false)
  , error_code_(0u){}
struct SaveBackupResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SaveBackupResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SaveBackupResponseDefaultTypeInternal() {}
  union {
    SaveBackupResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SaveBackupResponseDefaultTypeInternal _SaveBackupResponse_default_instance_;
PROTOBUF_CONSTEXPR CleanAccountRequest::CleanAccountRequest(
    ::_pbi::ConstantInitialized)
  : ei_user_id_to_keep_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , game_services_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct CleanAccountRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CleanAccountRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CleanAccountRequestDefaultTypeInternal() {}
  union {
    CleanAccountRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CleanAccountRequestDefaultTypeInternal _CleanAccountRequest_default_instance_;
PROTOBUF_CONSTEXPR ReturnEDTPayload::ReturnEDTPayload(
    ::_pbi::ConstantInitialized)
  : ei_user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct ReturnEDTPayloadDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReturnEDTPayloadDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReturnEDTPayloadDefaultTypeInternal() {}
  union {
    ReturnEDTPayload _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReturnEDTPayloadDefaultTypeInternal _ReturnEDTPayload_default_instance_;
PROTOBUF_CONSTEXPR DLCItem::DLCItem(
    ::_pbi::ConstantInitialized)
  : name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , directory_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , ext_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , url_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , checksum_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , original_size_(uint64_t{0u})
  , compressed_(false){}
struct DLCItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DLCItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DLCItemDefaultTypeInternal() {}
  union {
    DLCItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DLCItemDefaultTypeInternal _DLCItem_default_instance_;
PROTOBUF_CONSTEXPR ShellSpec_ShellPiece::ShellSpec_ShellPiece(
    ::_pbi::ConstantInitialized)
  : dlc_(nullptr)
  , asset_type_(1)
{}
struct ShellSpec_ShellPieceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShellSpec_ShellPieceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShellSpec_ShellPieceDefaultTypeInternal() {}
  union {
    ShellSpec_ShellPiece _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShellSpec_ShellPieceDefaultTypeInternal _ShellSpec_ShellPiece_default_instance_;
PROTOBUF_CONSTEXPR ShellSpec::ShellSpec(
    ::_pbi::ConstantInitialized)
  : pieces_()
  , alt_assets_()
  , identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , set_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , required_parent_shell_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , primary_piece_(nullptr)
  , price_(0u)
  , required_eop_(0u)
  , required_soul_eggs_(0)
  , seconds_remaining_(0)
  , seconds_until_available_(0)
  , modified_geometry_(false)
  , is_new_(false)
  , expires_(false)
  , default_appearance_(false){}
struct ShellSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShellSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShellSpecDefaultTypeInternal() {}
  union {
    ShellSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShellSpecDefaultTypeInternal _ShellSpec_default_instance_;
PROTOBUF_CONSTEXPR ShellSetSpec_VariationSpec::ShellSetSpec_VariationSpec(
    ::_pbi::ConstantInitialized)
  : identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , hex_color_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , price_(0u)
  , default_appearance_(false)
  , custom_appearance_(false)
  , sort_priority_(0){}
struct ShellSetSpec_VariationSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShellSetSpec_VariationSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShellSetSpec_VariationSpecDefaultTypeInternal() {}
  union {
    ShellSetSpec_VariationSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShellSetSpec_VariationSpecDefaultTypeInternal _ShellSetSpec_VariationSpec_default_instance_;
PROTOBUF_CONSTEXPR ShellSetSpec::ShellSetSpec(
    ::_pbi::ConstantInitialized)
  : variations_()
  , identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , hex_base_color_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , required_parent_set_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , icon_(nullptr)
  , price_(0u)
  , required_eop_(0u)
  , required_soul_eggs_(0)
  , element_set_(false)
  , default_appearance_(false)
  , custom_appearance_(false)
  , is_new_(false)
  , expires_(false)
  , decorator_(false)
  , modified_geometry_(false)
  , seconds_remaining_(0)
  , discount_(0)
  , seconds_until_available_(0)
  , price_mult_deprecated_(1){}
struct ShellSetSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShellSetSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShellSetSpecDefaultTypeInternal() {}
  union {
    ShellSetSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShellSetSpecDefaultTypeInternal _ShellSetSpec_default_instance_;
PROTOBUF_CONSTEXPR ShellObjectSpec_LODPiece::ShellObjectSpec_LODPiece(
    ::_pbi::ConstantInitialized)
  : dlc_(nullptr)
  , lod_(0u){}
struct ShellObjectSpec_LODPieceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShellObjectSpec_LODPieceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShellObjectSpec_LODPieceDefaultTypeInternal() {}
  union {
    ShellObjectSpec_LODPiece _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShellObjectSpec_LODPieceDefaultTypeInternal _ShellObjectSpec_LODPiece_default_instance_;
PROTOBUF_CONSTEXPR ShellObjectSpec::ShellObjectSpec(
    ::_pbi::ConstantInitialized)
  : metadata_()
  , pieces_()
  , icon_colors_()
  , identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , object_class_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , price_(0u)
  , required_eop_(0u)
  , required_soul_eggs_(0)
  , is_new_(false)
  , expires_(false)
  , no_hats_(false)
  , default_appearance_(false)
  , chicken_animation_(0)

  , seconds_remaining_(0)
  , seconds_until_available_(0)
  , sort_priority_(0)
  , asset_type_(1)
{}
struct ShellObjectSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShellObjectSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShellObjectSpecDefaultTypeInternal() {}
  union {
    ShellObjectSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShellObjectSpecDefaultTypeInternal _ShellObjectSpec_default_instance_;
PROTOBUF_CONSTEXPR ShellGroupSpec::ShellGroupSpec(
    ::_pbi::ConstantInitialized)
  : member_ids_()
  , identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , price_mult_deprecated_(0)
  , asset_type_(1)
{}
struct ShellGroupSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShellGroupSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShellGroupSpecDefaultTypeInternal() {}
  union {
    ShellGroupSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShellGroupSpecDefaultTypeInternal _ShellGroupSpec_default_instance_;
PROTOBUF_CONSTEXPR DLCCatalog::DLCCatalog(
    ::_pbi::ConstantInitialized)
  : items_()
  , shells_()
  , shell_sets_()
  , shell_objects_()
  , shell_groups_()
  , decorators_(){}
struct DLCCatalogDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DLCCatalogDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DLCCatalogDefaultTypeInternal() {}
  union {
    DLCCatalog _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DLCCatalogDefaultTypeInternal _DLCCatalog_default_instance_;
PROTOBUF_CONSTEXPR ShellDB_ShellStatus::ShellDB_ShellStatus(
    ::_pbi::ConstantInitialized)
  : identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , owned_(false){}
struct ShellDB_ShellStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShellDB_ShellStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShellDB_ShellStatusDefaultTypeInternal() {}
  union {
    ShellDB_ShellStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShellDB_ShellStatusDefaultTypeInternal _ShellDB_ShellStatus_default_instance_;
PROTOBUF_CONSTEXPR ShellDB_ShellElementStatus::ShellDB_ShellElementStatus(
    ::_pbi::ConstantInitialized)
  : set_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , element_(1)
{}
struct ShellDB_ShellElementStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShellDB_ShellElementStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShellDB_ShellElementStatusDefaultTypeInternal() {}
  union {
    ShellDB_ShellElementStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShellDB_ShellElementStatusDefaultTypeInternal _ShellDB_ShellElementStatus_default_instance_;
PROTOBUF_CONSTEXPR ShellDB_ShellSetVariationStatus::ShellDB_ShellSetVariationStatus(
    ::_pbi::ConstantInitialized)
  : owned_variations_()
  , set_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct ShellDB_ShellSetVariationStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShellDB_ShellSetVariationStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShellDB_ShellSetVariationStatusDefaultTypeInternal() {}
  union {
    ShellDB_ShellSetVariationStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShellDB_ShellSetVariationStatusDefaultTypeInternal _ShellDB_ShellSetVariationStatus_default_instance_;
PROTOBUF_CONSTEXPR ShellDB_FarmConfiguration::ShellDB_FarmConfiguration(
    ::_pbi::ConstantInitialized)
  : shell_configs_()
  , shell_set_configs_()
  , group_configs_()
  , chicken_configs_()
  , configure_chickens_by_group_(false){}
struct ShellDB_FarmConfigurationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShellDB_FarmConfigurationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShellDB_FarmConfigurationDefaultTypeInternal() {}
  union {
    ShellDB_FarmConfiguration _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShellDB_FarmConfigurationDefaultTypeInternal _ShellDB_FarmConfiguration_default_instance_;
PROTOBUF_CONSTEXPR ShellDB_SavedFarmConfiguration::ShellDB_SavedFarmConfiguration(
    ::_pbi::ConstantInitialized)
  : name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , config_(nullptr)
  , client_save_time_(0){}
struct ShellDB_SavedFarmConfigurationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShellDB_SavedFarmConfigurationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShellDB_SavedFarmConfigurationDefaultTypeInternal() {}
  union {
    ShellDB_SavedFarmConfiguration _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShellDB_SavedFarmConfigurationDefaultTypeInternal _ShellDB_SavedFarmConfiguration_default_instance_;
PROTOBUF_CONSTEXPR ShellDB_ShellConfiguration::ShellDB_ShellConfiguration(
    ::_pbi::ConstantInitialized)
  : shell_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , index_(0u)
  , asset_type_(1)
{}
struct ShellDB_ShellConfigurationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShellDB_ShellConfigurationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShellDB_ShellConfigurationDefaultTypeInternal() {}
  union {
    ShellDB_ShellConfiguration _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShellDB_ShellConfigurationDefaultTypeInternal _ShellDB_ShellConfiguration_default_instance_;
PROTOBUF_CONSTEXPR ShellDB_ShellSetConfiguration::ShellDB_ShellSetConfiguration(
    ::_pbi::ConstantInitialized)
  : shell_set_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , variation_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , decorator_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , index_(0u)
  , element_(1)
{}
struct ShellDB_ShellSetConfigurationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShellDB_ShellSetConfigurationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShellDB_ShellSetConfigurationDefaultTypeInternal() {}
  union {
    ShellDB_ShellSetConfiguration _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShellDB_ShellSetConfigurationDefaultTypeInternal _ShellDB_ShellSetConfiguration_default_instance_;
PROTOBUF_CONSTEXPR ShellDB_ShellGroupConfiguration::ShellDB_ShellGroupConfiguration(
    ::_pbi::ConstantInitialized)
  : group_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , asset_type_(1)
{}
struct ShellDB_ShellGroupConfigurationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShellDB_ShellGroupConfigurationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShellDB_ShellGroupConfigurationDefaultTypeInternal() {}
  union {
    ShellDB_ShellGroupConfiguration _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShellDB_ShellGroupConfigurationDefaultTypeInternal _ShellDB_ShellGroupConfiguration_default_instance_;
PROTOBUF_CONSTEXPR ShellDB_ChickenConfig::ShellDB_ChickenConfig(
    ::_pbi::ConstantInitialized)
  : chicken_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , hat_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct ShellDB_ChickenConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShellDB_ChickenConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShellDB_ChickenConfigDefaultTypeInternal() {}
  union {
    ShellDB_ChickenConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShellDB_ChickenConfigDefaultTypeInternal _ShellDB_ChickenConfig_default_instance_;
PROTOBUF_CONSTEXPR ShellDB::ShellDB(
    ::_pbi::ConstantInitialized)
  : shell_inventory_()
  , shell_set_inventory_()
  , farm_configs_()
  , shell_object_inventory_()
  , shell_element_inventory_()
  , new_shells_downloaded_()
  , new_shells_seen_()
  , shell_variation_inventory_()
  , saved_configs_(){}
struct ShellDBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShellDBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShellDBDefaultTypeInternal() {}
  union {
    ShellDB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShellDBDefaultTypeInternal _ShellDB_default_instance_;
PROTOBUF_CONSTEXPR ShellsActionLog::ShellsActionLog(
    ::_pbi::ConstantInitialized)
  : user_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , action_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , sub_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , version_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , rinfo_(nullptr)
  , approx_time_(0)
  , cost_(0u)
  , farm_index_(0)
  , soul_eggs_(0)
  , tickets_spent_(uint64_t{0u})
  , gold_spent_(uint64_t{0u})
  , farm_element_(1)
{}
struct ShellsActionLogDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShellsActionLogDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShellsActionLogDefaultTypeInternal() {}
  union {
    ShellsActionLog _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShellsActionLogDefaultTypeInternal _ShellsActionLog_default_instance_;
PROTOBUF_CONSTEXPR UserVerificationAnalysis::UserVerificationAnalysis(
    ::_pbi::ConstantInitialized)
  : invalid_contracts_()
  , start_time_(0)
  , completion_time_(0)
  , overall_status_(0)

  , verified_piggy_breaks_(0u)
  , verified_other_iap_(0u)
  , unverified_iap_(0u)
  , artifacts_collected_(0)
  , artifacts_consumed_(0)
  , missions_completed_(0u)
  , num_coop_memberships_(0u)
  , artifacts_in_inventory_(0)
  , gold_earned_(0)
  , num_prestiges_(0)
  , soul_eggs_(0)
  , valid_contracts_(0u)
  , iap_status_(0)

  , verified_pro_permit_(false)
  , regular_iap_buyer_(false)
  , regular_iap_cheater_(false)
  , excessive_consumes_(false)
  , artifacts_status_(0)

  , gold_spent_crafting_(0)
  , contracts_status_(0)

  , eggs_of_prophecy_(0u)
  , excessive_inventory_(false)
  , excessive_spend_(false)
  , excessive_eop_(false)
  , excessive_invalid_contracts_(false)
  , verified_(false)
  , verification_override_(false)
  , verification_override_value_(false){}
struct UserVerificationAnalysisDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserVerificationAnalysisDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserVerificationAnalysisDefaultTypeInternal() {}
  union {
    UserVerificationAnalysis _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserVerificationAnalysisDefaultTypeInternal _UserVerificationAnalysis_default_instance_;
PROTOBUF_CONSTEXPR UserSubscriptionInfo_HistoryEntry::UserSubscriptionInfo_HistoryEntry(
    ::_pbi::ConstantInitialized)
  : message_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , message_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , timestamp_(0){}
struct UserSubscriptionInfo_HistoryEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserSubscriptionInfo_HistoryEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserSubscriptionInfo_HistoryEntryDefaultTypeInternal() {}
  union {
    UserSubscriptionInfo_HistoryEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserSubscriptionInfo_HistoryEntryDefaultTypeInternal _UserSubscriptionInfo_HistoryEntry_default_instance_;
PROTOBUF_CONSTEXPR UserSubscriptionInfo::UserSubscriptionInfo(
    ::_pbi::ConstantInitialized)
  : history_()
  , past_user_ids_()
  , original_transaction_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , store_status_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , linked_transaction_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , first_subscribed_(0)
  , period_end_(0)
  , last_updated_(0)
  , status_(0)

  , subscription_level_(0)

  , next_subscription_level_(0)

  , lock_next_subscription_level_(false)
  , acknowledged_(false)
  , auto_renew_(false)
  , sandbox_(false)
  , platform_(1)
{}
struct UserSubscriptionInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserSubscriptionInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserSubscriptionInfoDefaultTypeInternal() {}
  union {
    UserSubscriptionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserSubscriptionInfoDefaultTypeInternal _UserSubscriptionInfo_default_instance_;
PROTOBUF_CONSTEXPR SubscriptionChangeHintRequest::SubscriptionChangeHintRequest(
    ::_pbi::ConstantInitialized)
  : original_transaction_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , rinfo_(nullptr)
  , next_subscription_level_(0)
{}
struct SubscriptionChangeHintRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubscriptionChangeHintRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubscriptionChangeHintRequestDefaultTypeInternal() {}
  union {
    SubscriptionChangeHintRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubscriptionChangeHintRequestDefaultTypeInternal _SubscriptionChangeHintRequest_default_instance_;
PROTOBUF_CONSTEXPR CXPEvalRolloutInfo::CXPEvalRolloutInfo(
    ::_pbi::ConstantInitialized)
  : current_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , basis_points_(0u){}
struct CXPEvalRolloutInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CXPEvalRolloutInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CXPEvalRolloutInfoDefaultTypeInternal() {}
  union {
    CXPEvalRolloutInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CXPEvalRolloutInfoDefaultTypeInternal _CXPEvalRolloutInfo_default_instance_;
}  // namespace ei
static ::_pb::Metadata file_level_metadata_ei_2eproto[179];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_ei_2eproto[32];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_ei_2eproto = nullptr;

const uint32_t TableStruct_ei_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Settings, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Settings, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Settings, sfx_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Settings, music_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Settings, low_battery_mode_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Settings, low_performance_mode_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Settings, force_touch_chicken_btn_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Settings, notifications_queried_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Settings, notifications_on_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Settings, notify_daily_gift_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Settings, coppa_queried_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Settings, coppa_restricted_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Settings, gdpr_consent_queried_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Settings, gdpr_age_restricted_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Settings, gdpr_consent_given_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Settings, age_queried_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Settings, age_restricted_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Settings, data_collection_consent_queried_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Settings, data_collection_consent_given_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Settings, last_day_age_queried_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Settings, user_ads_enabled_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Settings, user_cloud_enabled_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Settings, user_analytics_enabled_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Settings, user_personalized_ads_enabled_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Settings, low_performance_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Settings, auto_stop_fueling_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Settings, last_backup_time_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  14,
  15,
  16,
  17,
  12,
  21,
  22,
  23,
  24,
  18,
  19,
  20,
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Tutorial, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Tutorial, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Tutorial, intro_shown_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Tutorial, click_tutorial_shown_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Tutorial, buy_hab_shown_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Tutorial, hire_vehicle_shown_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Tutorial, q_num_shown_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Tutorial, s_num_shown_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Tutorial, contracts_tab_shown_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Tutorial, contract_info_shown_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Tutorial, join_coop_shown_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Tutorial, switch_farm_shown_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Tutorial, tutorial_shown_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Stats, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Stats, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Stats, egg_totals_old_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Stats, egg_totals_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Stats, unlimited_chickens_uses_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Stats, refill_uses_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Stats, warp_1_uses_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Stats, warp_8_uses_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Stats, boosts_used_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Stats, video_doubler_uses_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Stats, drone_takedowns_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Stats, drone_takedowns_elite_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Stats, num_prestiges_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Stats, num_piggy_breaks_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Stats, iap_packs_purchased_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Stats, piggy_full_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Stats, piggy_found_full_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Stats, time_piggy_filled_realtime_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Stats, time_piggy_full_gametime_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Stats, lost_piggy_increments_),
  ~0u,
  ~0u,
  5,
  0,
  2,
  3,
  10,
  1,
  4,
  7,
  6,
  8,
  9,
  14,
  15,
  11,
  12,
  13,
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, current_farm_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, max_egg_reached_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, golden_eggs_earned_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, golden_eggs_spent_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, uncliamed_golden_eggs_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, soul_eggs_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, unclaimed_soul_eggs_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, soul_eggs_d_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, unclaimed_soul_eggs_d_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, eggs_of_prophecy_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, unclaimed_eggs_of_prophecy_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, shell_scripts_earned_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, shell_scripts_spent_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, unclaimed_shell_scripts_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, prestige_cash_earned_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, prestige_soul_boost_cash_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, lifetime_cash_earned_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, piggy_bank_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, piggy_full_alert_shown_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, permit_level_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, epic_research_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, hyperloop_station_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, next_daily_gift_time_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, last_daily_gift_collected_day_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, num_daily_gifts_collected_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, news_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, last_news_time_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, current_multiplier_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, current_multiplier_expiration_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, achievements_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, max_farm_size_reached_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, egg_medal_level_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, long_idle_notification_set_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, long_idle_notification_threshold_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, long_idle_reward_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, boosts_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, total_time_cheats_detected_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, force_elite_contracts_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Game, new_player_event_end_time_),
  16,
  32,
  0,
  1,
  12,
  2,
  13,
  26,
  27,
  14,
  15,
  29,
  30,
  31,
  3,
  25,
  4,
  5,
  20,
  10,
  ~0u,
  21,
  6,
  11,
  17,
  ~0u,
  7,
  8,
  9,
  ~0u,
  ~0u,
  ~0u,
  22,
  18,
  19,
  ~0u,
  24,
  23,
  28,
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Artifacts, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Artifacts, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Artifacts, infusing_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Artifacts, item_being_infused_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Artifacts, spec_being_infused_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Artifacts, egg_type_infusing_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Artifacts, infusing_eggs_required_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Artifacts, eggs_infused_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Artifacts, flow_percentage_artifacts_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Artifacts, fueling_enabled_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Artifacts, tank_filling_enabled_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Artifacts, tank_level_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Artifacts, tank_fuels_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Artifacts, last_fueled_ship_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Artifacts, inventory_score_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Artifacts, crafting_xp_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Artifacts, enabled_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Artifacts, intro_shown_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Artifacts, infusing_enabled_deprecated_),
  5,
  0,
  1,
  13,
  2,
  3,
  12,
  14,
  6,
  11,
  ~0u,
  4,
  9,
  10,
  7,
  8,
  15,
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Shells, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Shells, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Shells, intro_alert_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Shells, contracts_intro_alert_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Shells, num_new_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, egg_type_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, farm_type_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, contract_id_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, cash_earned_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, cash_spent_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, unclaimed_cash_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, last_step_time_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, num_chickens_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, num_chickens_unsettled_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, num_chickens_running_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, eggs_laid_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, eggs_shipped_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, eggs_paid_for_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, silos_owned_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, habs_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, hab_population_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, hab_population_indound_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, hab_incubator_popuplation_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, hatchery_population_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, vehicles_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, train_length_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, common_research_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, active_boosts_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, last_cash_boost_time_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, time_cheats_detected_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, time_cheat_debt_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, boost_tokens_received_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, boost_tokens_spent_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, boost_tokens_given_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, unclaimed_boost_tokens_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Simulation, gametime_until_next_boost_token_),
  21,
  22,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  19,
  9,
  11,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  10,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  20,
  12,
  13,
  14,
  15,
  17,
  16,
  18,
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Mission, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Mission, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Mission, current_mission_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Mission, reference_value_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Mission, current_missions_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Mission, missions_),
  0,
  1,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Misc, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Misc, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Misc, chicken_btn_pref_big_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Misc, free_hatchery_refill_given_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Misc, last_share_farm_value_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Misc, last_share_swarm_farm_value_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Misc, last_share_swarm_size_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Misc, last_prestige_alert_soul_eggs_deprecated_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Misc, friend_rank_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Misc, friend_rank_pop_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Misc, global_rank_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Misc, global_rank_pop_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Misc, challenges_alert_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Misc, trophy_alert_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Misc, ar_alert_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Misc, contracts_alert_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Misc, contracts_alert_v2_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Misc, coop_alert_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Misc, coop_alert_v2_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Misc, switch_alert_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Misc, egg_of_prophecy_alert_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Misc, boost_token_alert_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Misc, soul_egg_alert_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_Misc, backup_reminder_alert_),
  4,
  5,
  18,
  19,
  20,
  21,
  0,
  1,
  2,
  3,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  PROTOBUF_FIELD_OFFSET(::ei::Backup_ResearchItem, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_ResearchItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::Backup_ResearchItem, id_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_ResearchItem, level_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ei::Backup_NewsHeadline, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_NewsHeadline, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::Backup_NewsHeadline, id_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_NewsHeadline, read_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ei::Backup_AchievementInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_AchievementInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::Backup_AchievementInfo, id_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_AchievementInfo, achieved_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ei::Backup_ActiveBoost, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_ActiveBoost, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::Backup_ActiveBoost, boost_id_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_ActiveBoost, time_remaining_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_ActiveBoost, reference_value_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::ei::Backup_OwnedBoost, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_OwnedBoost, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::Backup_OwnedBoost, boost_id_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_OwnedBoost, count_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ei::Backup_MissionInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_MissionInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::Backup_MissionInfo, id_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_MissionInfo, completed_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup_MissionInfo, reference_value_),
  0,
  2,
  1,
  PROTOBUF_FIELD_OFFSET(::ei::Backup, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::Backup, user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup, ei_user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup, game_services_id_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup, device_id_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup, user_name_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup, approx_time_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup, version_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup, force_offer_backup_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup, force_backup_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup, settings_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup, tutorial_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup, stats_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup, game_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup, artifacts_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup, shells_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup, sim_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup, farms_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup, mission_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup, misc_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup, contracts_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup, artifacts_db_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup, shell_db_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup, read_mail_ids_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup, checksum_),
  PROTOBUF_FIELD_OFFSET(::ei::Backup, signature_),
  0,
  4,
  2,
  3,
  1,
  18,
  19,
  20,
  21,
  6,
  7,
  8,
  9,
  14,
  17,
  10,
  ~0u,
  11,
  12,
  13,
  15,
  16,
  ~0u,
  22,
  5,
  PROTOBUF_FIELD_OFFSET(::ei::EggIncFirstContactRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::EggIncFirstContactRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::EggIncFirstContactRequest, rinfo_),
  PROTOBUF_FIELD_OFFSET(::ei::EggIncFirstContactRequest, ei_user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::EggIncFirstContactRequest, user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::EggIncFirstContactRequest, game_services_id_),
  PROTOBUF_FIELD_OFFSET(::ei::EggIncFirstContactRequest, device_id_),
  PROTOBUF_FIELD_OFFSET(::ei::EggIncFirstContactRequest, username_),
  PROTOBUF_FIELD_OFFSET(::ei::EggIncFirstContactRequest, client_version_),
  PROTOBUF_FIELD_OFFSET(::ei::EggIncFirstContactRequest, platform_),
  5,
  1,
  0,
  4,
  2,
  3,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::ei::EggIncFirstContactResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::EggIncFirstContactResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::EggIncFirstContactResponse, ei_user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::EggIncFirstContactResponse, ids_transferred_),
  PROTOBUF_FIELD_OFFSET(::ei::EggIncFirstContactResponse, error_code_),
  PROTOBUF_FIELD_OFFSET(::ei::EggIncFirstContactResponse, error_message_),
  PROTOBUF_FIELD_OFFSET(::ei::EggIncFirstContactResponse, backup_),
  0,
  ~0u,
  3,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ei::EggIncAdConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::EggIncAdConfig, network_priority_),
  PROTOBUF_FIELD_OFFSET(::ei::DailyGiftInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::DailyGiftInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::DailyGiftInfo, current_day_),
  PROTOBUF_FIELD_OFFSET(::ei::DailyGiftInfo, seconds_to_next_day_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::ei::SalesInfoRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::SalesInfoRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::SalesInfoRequest, user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::SalesInfoRequest, piggy_full_),
  PROTOBUF_FIELD_OFFSET(::ei::SalesInfoRequest, piggy_found_full_),
  PROTOBUF_FIELD_OFFSET(::ei::SalesInfoRequest, seconds_full_realtime_),
  PROTOBUF_FIELD_OFFSET(::ei::SalesInfoRequest, seconds_full_gametime_),
  PROTOBUF_FIELD_OFFSET(::ei::SalesInfoRequest, lost_increments_),
  PROTOBUF_FIELD_OFFSET(::ei::SalesInfoRequest, current_client_version_),
  0,
  2,
  3,
  1,
  5,
  4,
  6,
  PROTOBUF_FIELD_OFFSET(::ei::IAPSaleEntry, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::IAPSaleEntry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::IAPSaleEntry, product_id_),
  PROTOBUF_FIELD_OFFSET(::ei::IAPSaleEntry, seconds_remaining_),
  PROTOBUF_FIELD_OFFSET(::ei::IAPSaleEntry, discount_string_),
  PROTOBUF_FIELD_OFFSET(::ei::IAPSaleEntry, sale_id_),
  0,
  3,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ei::SalesInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::SalesInfo, sales_),
  PROTOBUF_FIELD_OFFSET(::ei::EggIncEvent, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::EggIncEvent, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::EggIncEvent, identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::EggIncEvent, seconds_remaining_),
  PROTOBUF_FIELD_OFFSET(::ei::EggIncEvent, type_),
  PROTOBUF_FIELD_OFFSET(::ei::EggIncEvent, multiplier_),
  PROTOBUF_FIELD_OFFSET(::ei::EggIncEvent, subtitle_),
  PROTOBUF_FIELD_OFFSET(::ei::EggIncEvent, start_time_),
  PROTOBUF_FIELD_OFFSET(::ei::EggIncEvent, duration_),
  PROTOBUF_FIELD_OFFSET(::ei::EggIncEvent, cc_only_),
  0,
  3,
  1,
  4,
  2,
  5,
  6,
  7,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ei::EggIncCurrentEvents, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::EggIncCurrentEvents, events_),
  PROTOBUF_FIELD_OFFSET(::ei::DeviceInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::DeviceInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::DeviceInfo, device_id_),
  PROTOBUF_FIELD_OFFSET(::ei::DeviceInfo, advertising_id_),
  PROTOBUF_FIELD_OFFSET(::ei::DeviceInfo, platform_),
  PROTOBUF_FIELD_OFFSET(::ei::DeviceInfo, form_factor_),
  PROTOBUF_FIELD_OFFSET(::ei::DeviceInfo, device_name_),
  PROTOBUF_FIELD_OFFSET(::ei::DeviceInfo, platform_version_),
  PROTOBUF_FIELD_OFFSET(::ei::DeviceInfo, locale_country_),
  PROTOBUF_FIELD_OFFSET(::ei::DeviceInfo, locale_language_),
  PROTOBUF_FIELD_OFFSET(::ei::DeviceInfo, gpu_vendor_),
  PROTOBUF_FIELD_OFFSET(::ei::DeviceInfo, gpu_model_),
  PROTOBUF_FIELD_OFFSET(::ei::DeviceInfo, device_bucket_),
  PROTOBUF_FIELD_OFFSET(::ei::DeviceInfo, screen_width_),
  PROTOBUF_FIELD_OFFSET(::ei::DeviceInfo, screen_height_),
  0,
  10,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  11,
  12,
  PROTOBUF_FIELD_OFFSET(::ei::AppInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::AppInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::AppInfo, version_str_),
  PROTOBUF_FIELD_OFFSET(::ei::AppInfo, sessions_),
  PROTOBUF_FIELD_OFFSET(::ei::AppInfo, num_prestiges_),
  PROTOBUF_FIELD_OFFSET(::ei::AppInfo, soul_eggs_),
  PROTOBUF_FIELD_OFFSET(::ei::AppInfo, current_egg_),
  PROTOBUF_FIELD_OFFSET(::ei::AppInfo, gold_earned_),
  PROTOBUF_FIELD_OFFSET(::ei::AppInfo, gold_spent_),
  PROTOBUF_FIELD_OFFSET(::ei::AppInfo, current_mission_),
  PROTOBUF_FIELD_OFFSET(::ei::AppInfo, piggy_size_),
  PROTOBUF_FIELD_OFFSET(::ei::AppInfo, num_piggy_breaks_),
  PROTOBUF_FIELD_OFFSET(::ei::AppInfo, verified_piggy_breaks_),
  PROTOBUF_FIELD_OFFSET(::ei::AppInfo, iap_packs_purchased_),
  PROTOBUF_FIELD_OFFSET(::ei::AppInfo, permit_level_),
  PROTOBUF_FIELD_OFFSET(::ei::AppInfo, video_doubler_uses_),
  PROTOBUF_FIELD_OFFSET(::ei::AppInfo, drone_takedowns_),
  PROTOBUF_FIELD_OFFSET(::ei::AppInfo, drone_takedowns_elite_),
  PROTOBUF_FIELD_OFFSET(::ei::AppInfo, trophies_unlocked_),
  PROTOBUF_FIELD_OFFSET(::ei::AppInfo, egg_level_),
  PROTOBUF_FIELD_OFFSET(::ei::AppInfo, struggle_factor_),
  PROTOBUF_FIELD_OFFSET(::ei::AppInfo, piggy_full_),
  PROTOBUF_FIELD_OFFSET(::ei::AppInfo, piggy_found_full_),
  PROTOBUF_FIELD_OFFSET(::ei::AppInfo, time_piggy_full_realtime_),
  PROTOBUF_FIELD_OFFSET(::ei::AppInfo, time_piggy_full_gametime_),
  PROTOBUF_FIELD_OFFSET(::ei::AppInfo, lost_piggy_increments_),
  PROTOBUF_FIELD_OFFSET(::ei::AppInfo, sale_id_),
  PROTOBUF_FIELD_OFFSET(::ei::AppInfo, unlimited_chickens_uses_),
  PROTOBUF_FIELD_OFFSET(::ei::AppInfo, refill_uses_),
  PROTOBUF_FIELD_OFFSET(::ei::AppInfo, short_warp_uses_),
  PROTOBUF_FIELD_OFFSET(::ei::AppInfo, long_warp_uses_),
  0,
  2,
  3,
  4,
  6,
  5,
  8,
  7,
  10,
  9,
  25,
  12,
  11,
  15,
  18,
  19,
  26,
  20,
  21,
  27,
  28,
  22,
  23,
  24,
  1,
  13,
  14,
  16,
  17,
  PROTOBUF_FIELD_OFFSET(::ei::ActionKeyValuePair, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ActionKeyValuePair, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ActionKeyValuePair, key_),
  PROTOBUF_FIELD_OFFSET(::ei::ActionKeyValuePair, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ei::GenericAction, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::GenericAction, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::GenericAction, user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::GenericAction, advertising_id_),
  PROTOBUF_FIELD_OFFSET(::ei::GenericAction, approx_time_dep_),
  PROTOBUF_FIELD_OFFSET(::ei::GenericAction, approx_time_),
  PROTOBUF_FIELD_OFFSET(::ei::GenericAction, action_name_),
  PROTOBUF_FIELD_OFFSET(::ei::GenericAction, data_),
  PROTOBUF_FIELD_OFFSET(::ei::GenericAction, app_),
  PROTOBUF_FIELD_OFFSET(::ei::GenericAction, device_),
  0,
  2,
  6,
  5,
  1,
  ~0u,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::ei::GenericActionBatchRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::GenericActionBatchRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::GenericActionBatchRequest, rinfo_),
  PROTOBUF_FIELD_OFFSET(::ei::GenericActionBatchRequest, actions_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::ei::VerifyPurchaseRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::VerifyPurchaseRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::VerifyPurchaseRequest, rinfo_),
  PROTOBUF_FIELD_OFFSET(::ei::VerifyPurchaseRequest, sku_),
  PROTOBUF_FIELD_OFFSET(::ei::VerifyPurchaseRequest, transaction_id_),
  PROTOBUF_FIELD_OFFSET(::ei::VerifyPurchaseRequest, original_transaction_id_),
  PROTOBUF_FIELD_OFFSET(::ei::VerifyPurchaseRequest, receipt_),
  PROTOBUF_FIELD_OFFSET(::ei::VerifyPurchaseRequest, platform_),
  PROTOBUF_FIELD_OFFSET(::ei::VerifyPurchaseRequest, sandbox_),
  PROTOBUF_FIELD_OFFSET(::ei::VerifyPurchaseRequest, log_),
  6,
  0,
  1,
  4,
  2,
  3,
  7,
  5,
  PROTOBUF_FIELD_OFFSET(::ei::VerifyPurchaseResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::VerifyPurchaseResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::VerifyPurchaseResponse, verified_),
  PROTOBUF_FIELD_OFFSET(::ei::VerifyPurchaseResponse, message_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::ei::CurrencyFlowLog, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::CurrencyFlowLog, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::CurrencyFlowLog, user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::CurrencyFlowLog, approx_time_),
  PROTOBUF_FIELD_OFFSET(::ei::CurrencyFlowLog, currency_),
  PROTOBUF_FIELD_OFFSET(::ei::CurrencyFlowLog, amount_),
  PROTOBUF_FIELD_OFFSET(::ei::CurrencyFlowLog, location_),
  PROTOBUF_FIELD_OFFSET(::ei::CurrencyFlowLog, version_),
  PROTOBUF_FIELD_OFFSET(::ei::CurrencyFlowLog, platform_),
  PROTOBUF_FIELD_OFFSET(::ei::CurrencyFlowLog, soul_eggs_),
  PROTOBUF_FIELD_OFFSET(::ei::CurrencyFlowLog, tickets_spent_),
  PROTOBUF_FIELD_OFFSET(::ei::CurrencyFlowLog, gold_spent_),
  0,
  4,
  9,
  5,
  1,
  2,
  3,
  6,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::ei::CurrencyFlowBatchRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::CurrencyFlowBatchRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::CurrencyFlowBatchRequest, rinfo_),
  PROTOBUF_FIELD_OFFSET(::ei::CurrencyFlowBatchRequest, logs_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::ei::Reward, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::Reward, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::Reward, reward_type_),
  PROTOBUF_FIELD_OFFSET(::ei::Reward, reward_sub_type_),
  PROTOBUF_FIELD_OFFSET(::ei::Reward, reward_amount_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ei::GameModifier, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::GameModifier, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::GameModifier, dimension_),
  PROTOBUF_FIELD_OFFSET(::ei::GameModifier, value_),
  PROTOBUF_FIELD_OFFSET(::ei::GameModifier, description_),
  2,
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::ei::Contract_Goal, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract_Goal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::Contract_Goal, type_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract_Goal, target_amount_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract_Goal, reward_type_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract_Goal, reward_sub_type_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract_Goal, reward_amount_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract_Goal, target_soul_eggs_),
  4,
  1,
  5,
  0,
  2,
  3,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ei::Contract_GoalSet, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::Contract_GoalSet, goals_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract_GradeSpec, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract_GradeSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::Contract_GradeSpec, grade_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract_GradeSpec, goals_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract_GradeSpec, modifiers_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract_GradeSpec, length_seconds_),
  1,
  ~0u,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::ei::Contract, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::Contract, identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract, name_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract, description_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract, egg_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract, goals_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract, goal_sets_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract, grade_specs_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract, season_id_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract, coop_allowed_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract, max_coop_size_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract, max_boosts_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract, minutes_per_token_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract, chicken_run_cooldown_minutes_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract, start_time_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract, expiration_time_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract, length_seconds_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract, max_soul_eggs_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract, min_client_version_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract, leggacy_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract, cc_only_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract, debug_),
  PROTOBUF_FIELD_OFFSET(::ei::Contract, key_),
  0,
  1,
  2,
  16,
  ~0u,
  ~0u,
  ~0u,
  4,
  11,
  7,
  8,
  17,
  18,
  15,
  5,
  6,
  9,
  10,
  12,
  13,
  14,
  3,
  PROTOBUF_FIELD_OFFSET(::ei::ContractPlayerInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractPlayerInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ContractPlayerInfo, grade_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractPlayerInfo, total_cxp_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractPlayerInfo, season_cxp_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractPlayerInfo, grade_score_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractPlayerInfo, target_grade_score_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractPlayerInfo, soul_power_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractPlayerInfo, target_soul_power_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractPlayerInfo, grade_progress_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractPlayerInfo, issues_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractPlayerInfo, issue_score_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractPlayerInfo, status_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractPlayerInfo, last_evaluation_time_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractPlayerInfo, last_evaluation_version_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractPlayerInfo, unread_evaluations_),
  2,
  1,
  10,
  5,
  7,
  8,
  6,
  9,
  ~0u,
  11,
  3,
  4,
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, contract_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, coop_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, cxp_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, replay_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, cxp_change_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, grade_performance_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, old_league_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, old_goals_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, grade_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, contribution_ratio_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, completion_percent_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, original_length_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, coop_size_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, solo_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, soul_power_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, last_contribution_time_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, completion_time_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, chicken_runs_sent_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, gift_tokens_sent_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, gift_tokens_received_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, boost_token_allotment_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, buff_time_value_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, teamwork_score_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, other_bonuses_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, counted_in_season_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, season_id_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, time_cheats_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, issues_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, notes_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, version_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, evaluation_start_time_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluation, status_),
  1,
  2,
  4,
  20,
  27,
  5,
  13,
  21,
  6,
  7,
  8,
  12,
  19,
  22,
  26,
  25,
  9,
  10,
  11,
  14,
  18,
  17,
  15,
  16,
  23,
  0,
  24,
  ~0u,
  ~0u,
  3,
  28,
  29,
  PROTOBUF_FIELD_OFFSET(::ei::ContractCitation, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCitation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ContractCitation, issue_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCitation, timestamp_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCitation, grade_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluationBatch_Pair, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluationBatch_Pair, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluationBatch_Pair, user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluationBatch_Pair, cev_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluationBatch, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ContractEvaluationBatch, evals_),
  PROTOBUF_FIELD_OFFSET(::ei::CoopCompletionSnapshot_ContributorSnapshot, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::CoopCompletionSnapshot_ContributorSnapshot, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::CoopCompletionSnapshot_ContributorSnapshot, contribution_),
  PROTOBUF_FIELD_OFFSET(::ei::CoopCompletionSnapshot_ContributorSnapshot, last_contribution_time_),
  PROTOBUF_FIELD_OFFSET(::ei::CoopCompletionSnapshot_ContributorSnapshot, soul_power_),
  PROTOBUF_FIELD_OFFSET(::ei::CoopCompletionSnapshot_ContributorSnapshot, user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::CoopCompletionSnapshot_ContributorSnapshot, tokens_),
  PROTOBUF_FIELD_OFFSET(::ei::CoopCompletionSnapshot_ContributorSnapshot, tokens_spent_),
  1,
  5,
  2,
  0,
  3,
  4,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ei::CoopCompletionSnapshot, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::CoopCompletionSnapshot, contributors_),
  PROTOBUF_FIELD_OFFSET(::ei::BasicRequestInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::BasicRequestInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::BasicRequestInfo, ei_user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::BasicRequestInfo, client_version_),
  PROTOBUF_FIELD_OFFSET(::ei::BasicRequestInfo, version_),
  PROTOBUF_FIELD_OFFSET(::ei::BasicRequestInfo, build_),
  PROTOBUF_FIELD_OFFSET(::ei::BasicRequestInfo, platform_),
  PROTOBUF_FIELD_OFFSET(::ei::BasicRequestInfo, country_),
  PROTOBUF_FIELD_OFFSET(::ei::BasicRequestInfo, language_),
  PROTOBUF_FIELD_OFFSET(::ei::BasicRequestInfo, debug_),
  0,
  6,
  1,
  2,
  3,
  4,
  5,
  7,
  PROTOBUF_FIELD_OFFSET(::ei::ContractSimConfig_ContractGradeSimConfig_GoalParams, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractSimConfig_ContractGradeSimConfig_GoalParams, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ContractSimConfig_ContractGradeSimConfig_GoalParams, target_se_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractSimConfig_ContractGradeSimConfig_GoalParams, cps_mult_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractSimConfig_ContractGradeSimConfig_GoalParams, earnings_mult_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractSimConfig_ContractGradeSimConfig_GoalParams, time_efficacy_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::ei::ContractSimConfig_ContractGradeSimConfig, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractSimConfig_ContractGradeSimConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ContractSimConfig_ContractGradeSimConfig, grade_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractSimConfig_ContractGradeSimConfig, goal_params_),
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ei::ContractSimConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ContractSimConfig, grade_configs_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractSimPoll, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractSimPoll, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ContractSimPoll, client_version_),
  0,
  PROTOBUF_FIELD_OFFSET(::ei::ContractSimPollResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractSimPollResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ContractSimPollResponse, contract_to_simulate_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractSimPollResponse, sim_config_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ei::ContractSimResultUpdate_GoalInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractSimResultUpdate_GoalInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ContractSimResultUpdate_GoalInfo, grade_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractSimResultUpdate_GoalInfo, goal_index_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractSimResultUpdate_GoalInfo, projected_eggs_laid_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::ei::ContractSimResultUpdate, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractSimResultUpdate, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ContractSimResultUpdate, contract_id_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractSimResultUpdate, goal_infos_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::ei::ContractsRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ContractsRequest, soul_eggs_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractsRequest, client_version_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractsRequest, user_id_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::ei::ContractsResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ContractsResponse, contracts_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractsResponse, warning_message_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractsResponse, server_time_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractsResponse, max_eop_),
  ~0u,
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusRequest, rinfo_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusRequest, contract_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusRequest, coop_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusRequest, user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusRequest, client_version_),
  3,
  0,
  1,
  2,
  4,
  PROTOBUF_FIELD_OFFSET(::ei::FarmProductionParams, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::FarmProductionParams, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::FarmProductionParams, farm_population_),
  PROTOBUF_FIELD_OFFSET(::ei::FarmProductionParams, farm_capacity_),
  PROTOBUF_FIELD_OFFSET(::ei::FarmProductionParams, elr_),
  PROTOBUF_FIELD_OFFSET(::ei::FarmProductionParams, ihr_),
  PROTOBUF_FIELD_OFFSET(::ei::FarmProductionParams, sr_),
  PROTOBUF_FIELD_OFFSET(::ei::FarmProductionParams, delivered_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::ei::PlayerFarmInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::PlayerFarmInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::PlayerFarmInfo, client_version_),
  PROTOBUF_FIELD_OFFSET(::ei::PlayerFarmInfo, soul_eggs_),
  PROTOBUF_FIELD_OFFSET(::ei::PlayerFarmInfo, eggs_of_prophecy_),
  PROTOBUF_FIELD_OFFSET(::ei::PlayerFarmInfo, permit_level_),
  PROTOBUF_FIELD_OFFSET(::ei::PlayerFarmInfo, hyperloop_station_),
  PROTOBUF_FIELD_OFFSET(::ei::PlayerFarmInfo, egg_medal_level_),
  PROTOBUF_FIELD_OFFSET(::ei::PlayerFarmInfo, epic_research_),
  PROTOBUF_FIELD_OFFSET(::ei::PlayerFarmInfo, egg_type_),
  PROTOBUF_FIELD_OFFSET(::ei::PlayerFarmInfo, cash_on_hand_),
  PROTOBUF_FIELD_OFFSET(::ei::PlayerFarmInfo, habs_),
  PROTOBUF_FIELD_OFFSET(::ei::PlayerFarmInfo, hab_population_),
  PROTOBUF_FIELD_OFFSET(::ei::PlayerFarmInfo, hab_capacity_),
  PROTOBUF_FIELD_OFFSET(::ei::PlayerFarmInfo, vehicles_),
  PROTOBUF_FIELD_OFFSET(::ei::PlayerFarmInfo, train_length_),
  PROTOBUF_FIELD_OFFSET(::ei::PlayerFarmInfo, silos_owned_),
  PROTOBUF_FIELD_OFFSET(::ei::PlayerFarmInfo, common_research_),
  PROTOBUF_FIELD_OFFSET(::ei::PlayerFarmInfo, active_boosts_),
  PROTOBUF_FIELD_OFFSET(::ei::PlayerFarmInfo, boost_tokens_on_hand_),
  PROTOBUF_FIELD_OFFSET(::ei::PlayerFarmInfo, equipped_artifacts_),
  PROTOBUF_FIELD_OFFSET(::ei::PlayerFarmInfo, artifact_inventory_score_),
  PROTOBUF_FIELD_OFFSET(::ei::PlayerFarmInfo, farm_appearance_),
  PROTOBUF_FIELD_OFFSET(::ei::PlayerFarmInfo, timestamp_),
  10,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  11,
  5,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  6,
  ~0u,
  ~0u,
  7,
  ~0u,
  8,
  0,
  9,
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_ContributionInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_ContributionInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_ContributionInfo, uuid_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_ContributionInfo, user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_ContributionInfo, user_name_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_ContributionInfo, contract_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_ContributionInfo, contribution_amount_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_ContributionInfo, contribution_rate_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_ContributionInfo, soul_power_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_ContributionInfo, production_params_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_ContributionInfo, farm_info_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_ContributionInfo, rank_change_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_ContributionInfo, active_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_ContributionInfo, leech_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_ContributionInfo, time_cheat_detected_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_ContributionInfo, platform_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_ContributionInfo, push_id_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_ContributionInfo, ban_votes_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_ContributionInfo, autojoined_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_ContributionInfo, boost_tokens_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_ContributionInfo, boost_tokens_spent_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_ContributionInfo, buff_history_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_ContributionInfo, chicken_run_cooldown_),
  4,
  0,
  1,
  3,
  7,
  8,
  11,
  5,
  6,
  9,
  12,
  13,
  14,
  19,
  2,
  10,
  15,
  16,
  18,
  ~0u,
  17,
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_CoopGift, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_CoopGift, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_CoopGift, user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_CoopGift, user_name_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_CoopGift, amount_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_ChickenRun, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_ChickenRun, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_ChickenRun, user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_ChickenRun, user_name_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse_ChickenRun, amount_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse, contract_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse, total_amount_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse, coop_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse, contributors_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse, auto_generated_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse, public__),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse, creator_id_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse, seconds_remaining_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse, all_goals_achieved_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse, all_members_reporting_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse, grace_period_seconds_remaining_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse, gifts_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse, chicken_runs_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusResponse, local_timestamp_),
  0,
  3,
  1,
  ~0u,
  7,
  8,
  2,
  4,
  9,
  10,
  5,
  ~0u,
  ~0u,
  6,
  PROTOBUF_FIELD_OFFSET(::ei::LocalContract, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::LocalContract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::LocalContract, contract_),
  PROTOBUF_FIELD_OFFSET(::ei::LocalContract, coop_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::LocalContract, accepted_),
  PROTOBUF_FIELD_OFFSET(::ei::LocalContract, time_accepted_),
  PROTOBUF_FIELD_OFFSET(::ei::LocalContract, cancelled_),
  PROTOBUF_FIELD_OFFSET(::ei::LocalContract, new__),
  PROTOBUF_FIELD_OFFSET(::ei::LocalContract, coop_shared_end_time_),
  PROTOBUF_FIELD_OFFSET(::ei::LocalContract, coop_grace_period_end_time_),
  PROTOBUF_FIELD_OFFSET(::ei::LocalContract, coop_contribution_finalized_),
  PROTOBUF_FIELD_OFFSET(::ei::LocalContract, coop_last_uploaded_contribution_),
  PROTOBUF_FIELD_OFFSET(::ei::LocalContract, coop_user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::LocalContract, coop_share_farm_),
  PROTOBUF_FIELD_OFFSET(::ei::LocalContract, last_amount_when_reward_given_),
  PROTOBUF_FIELD_OFFSET(::ei::LocalContract, num_goals_achieved_),
  PROTOBUF_FIELD_OFFSET(::ei::LocalContract, boosts_used_),
  PROTOBUF_FIELD_OFFSET(::ei::LocalContract, points_replay_),
  PROTOBUF_FIELD_OFFSET(::ei::LocalContract, league_),
  PROTOBUF_FIELD_OFFSET(::ei::LocalContract, grade_),
  PROTOBUF_FIELD_OFFSET(::ei::LocalContract, last_nag_time_),
  PROTOBUF_FIELD_OFFSET(::ei::LocalContract, evaluation_),
  PROTOBUF_FIELD_OFFSET(::ei::LocalContract, reported_uuids_),
  2,
  0,
  7,
  4,
  8,
  9,
  5,
  12,
  10,
  13,
  1,
  18,
  6,
  14,
  11,
  19,
  15,
  17,
  16,
  3,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::ei::MyContracts, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::MyContracts, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::MyContracts, contract_ids_seen_),
  PROTOBUF_FIELD_OFFSET(::ei::MyContracts, contracts_),
  PROTOBUF_FIELD_OFFSET(::ei::MyContracts, archive_),
  PROTOBUF_FIELD_OFFSET(::ei::MyContracts, current_coop_statuses_),
  PROTOBUF_FIELD_OFFSET(::ei::MyContracts, last_cpi_),
  PROTOBUF_FIELD_OFFSET(::ei::MyContracts, initial_grade_revealed_),
  PROTOBUF_FIELD_OFFSET(::ei::MyContracts, last_grade_progress_shown_),
  PROTOBUF_FIELD_OFFSET(::ei::MyContracts, show_advanced_evaluations_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  2,
  1,
  3,
  PROTOBUF_FIELD_OFFSET(::ei::QueryCoopRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::QueryCoopRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::QueryCoopRequest, rinfo_),
  PROTOBUF_FIELD_OFFSET(::ei::QueryCoopRequest, contract_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::QueryCoopRequest, coop_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::QueryCoopRequest, league_),
  PROTOBUF_FIELD_OFFSET(::ei::QueryCoopRequest, grade_),
  PROTOBUF_FIELD_OFFSET(::ei::QueryCoopRequest, client_version_),
  2,
  0,
  1,
  4,
  5,
  3,
  PROTOBUF_FIELD_OFFSET(::ei::QueryCoopResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::QueryCoopResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::QueryCoopResponse, exists_),
  PROTOBUF_FIELD_OFFSET(::ei::QueryCoopResponse, full_),
  PROTOBUF_FIELD_OFFSET(::ei::QueryCoopResponse, expired_),
  PROTOBUF_FIELD_OFFSET(::ei::QueryCoopResponse, different_league_),
  PROTOBUF_FIELD_OFFSET(::ei::QueryCoopResponse, different_grade_),
  PROTOBUF_FIELD_OFFSET(::ei::QueryCoopResponse, cc_only_),
  PROTOBUF_FIELD_OFFSET(::ei::QueryCoopResponse, banned_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::ei::CreateCoopRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::CreateCoopRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::CreateCoopRequest, rinfo_),
  PROTOBUF_FIELD_OFFSET(::ei::CreateCoopRequest, contract_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::CreateCoopRequest, coop_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::CreateCoopRequest, public__),
  PROTOBUF_FIELD_OFFSET(::ei::CreateCoopRequest, cc_only_),
  PROTOBUF_FIELD_OFFSET(::ei::CreateCoopRequest, seconds_remaining_),
  PROTOBUF_FIELD_OFFSET(::ei::CreateCoopRequest, user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::CreateCoopRequest, user_name_),
  PROTOBUF_FIELD_OFFSET(::ei::CreateCoopRequest, soul_power_),
  PROTOBUF_FIELD_OFFSET(::ei::CreateCoopRequest, eop_),
  PROTOBUF_FIELD_OFFSET(::ei::CreateCoopRequest, league_),
  PROTOBUF_FIELD_OFFSET(::ei::CreateCoopRequest, grade_),
  PROTOBUF_FIELD_OFFSET(::ei::CreateCoopRequest, platform_),
  PROTOBUF_FIELD_OFFSET(::ei::CreateCoopRequest, client_version_),
  4,
  0,
  1,
  11,
  12,
  5,
  2,
  3,
  6,
  9,
  8,
  10,
  13,
  7,
  PROTOBUF_FIELD_OFFSET(::ei::CreateCoopResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::CreateCoopResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::CreateCoopResponse, success_),
  PROTOBUF_FIELD_OFFSET(::ei::CreateCoopResponse, message_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::ei::JoinCoopRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::JoinCoopRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::JoinCoopRequest, rinfo_),
  PROTOBUF_FIELD_OFFSET(::ei::JoinCoopRequest, contract_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::JoinCoopRequest, coop_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::JoinCoopRequest, user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::JoinCoopRequest, user_name_),
  PROTOBUF_FIELD_OFFSET(::ei::JoinCoopRequest, soul_power_),
  PROTOBUF_FIELD_OFFSET(::ei::JoinCoopRequest, eop_),
  PROTOBUF_FIELD_OFFSET(::ei::JoinCoopRequest, league_),
  PROTOBUF_FIELD_OFFSET(::ei::JoinCoopRequest, grade_),
  PROTOBUF_FIELD_OFFSET(::ei::JoinCoopRequest, platform_),
  PROTOBUF_FIELD_OFFSET(::ei::JoinCoopRequest, seconds_remaining_),
  PROTOBUF_FIELD_OFFSET(::ei::JoinCoopRequest, client_version_),
  4,
  0,
  1,
  2,
  3,
  5,
  9,
  7,
  10,
  11,
  8,
  6,
  PROTOBUF_FIELD_OFFSET(::ei::JoinCoopResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::JoinCoopResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::JoinCoopResponse, success_),
  PROTOBUF_FIELD_OFFSET(::ei::JoinCoopResponse, message_),
  PROTOBUF_FIELD_OFFSET(::ei::JoinCoopResponse, banned_),
  PROTOBUF_FIELD_OFFSET(::ei::JoinCoopResponse, coop_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::JoinCoopResponse, seconds_remaining_),
  PROTOBUF_FIELD_OFFSET(::ei::JoinCoopResponse, match_percent_),
  PROTOBUF_FIELD_OFFSET(::ei::JoinCoopResponse, num_members_),
  PROTOBUF_FIELD_OFFSET(::ei::JoinCoopResponse, status_),
  PROTOBUF_FIELD_OFFSET(::ei::JoinCoopResponse, grade_),
  PROTOBUF_FIELD_OFFSET(::ei::JoinCoopResponse, can_start_),
  3,
  0,
  4,
  1,
  2,
  7,
  6,
  8,
  9,
  5,
  PROTOBUF_FIELD_OFFSET(::ei::AutoJoinCoopRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::AutoJoinCoopRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::AutoJoinCoopRequest, rinfo_),
  PROTOBUF_FIELD_OFFSET(::ei::AutoJoinCoopRequest, contract_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::AutoJoinCoopRequest, user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::AutoJoinCoopRequest, user_name_),
  PROTOBUF_FIELD_OFFSET(::ei::AutoJoinCoopRequest, soul_power_),
  PROTOBUF_FIELD_OFFSET(::ei::AutoJoinCoopRequest, eop_),
  PROTOBUF_FIELD_OFFSET(::ei::AutoJoinCoopRequest, league_),
  PROTOBUF_FIELD_OFFSET(::ei::AutoJoinCoopRequest, grade_),
  PROTOBUF_FIELD_OFFSET(::ei::AutoJoinCoopRequest, seconds_remaining_),
  PROTOBUF_FIELD_OFFSET(::ei::AutoJoinCoopRequest, platform_),
  PROTOBUF_FIELD_OFFSET(::ei::AutoJoinCoopRequest, client_version_),
  3,
  0,
  1,
  2,
  4,
  8,
  7,
  9,
  5,
  10,
  6,
  PROTOBUF_FIELD_OFFSET(::ei::UpdateCoopPermissionsRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::UpdateCoopPermissionsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::UpdateCoopPermissionsRequest, rinfo_),
  PROTOBUF_FIELD_OFFSET(::ei::UpdateCoopPermissionsRequest, contract_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::UpdateCoopPermissionsRequest, coop_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::UpdateCoopPermissionsRequest, requesting_user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::UpdateCoopPermissionsRequest, public__),
  PROTOBUF_FIELD_OFFSET(::ei::UpdateCoopPermissionsRequest, client_version_),
  3,
  0,
  1,
  2,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::ei::UpdateCoopPermissionsResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::UpdateCoopPermissionsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::UpdateCoopPermissionsResponse, success_),
  PROTOBUF_FIELD_OFFSET(::ei::UpdateCoopPermissionsResponse, message_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::ei::LeaveCoopRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::LeaveCoopRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::LeaveCoopRequest, rinfo_),
  PROTOBUF_FIELD_OFFSET(::ei::LeaveCoopRequest, contract_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::LeaveCoopRequest, coop_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::LeaveCoopRequest, player_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::LeaveCoopRequest, client_version_),
  3,
  0,
  1,
  2,
  4,
  PROTOBUF_FIELD_OFFSET(::ei::GiftPlayerCoopRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::GiftPlayerCoopRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::GiftPlayerCoopRequest, rinfo_),
  PROTOBUF_FIELD_OFFSET(::ei::GiftPlayerCoopRequest, contract_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::GiftPlayerCoopRequest, coop_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::GiftPlayerCoopRequest, player_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::GiftPlayerCoopRequest, requesting_user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::GiftPlayerCoopRequest, requesting_user_name_),
  PROTOBUF_FIELD_OFFSET(::ei::GiftPlayerCoopRequest, amount_),
  PROTOBUF_FIELD_OFFSET(::ei::GiftPlayerCoopRequest, client_version_),
  5,
  0,
  1,
  2,
  3,
  4,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::ei::SendChickenRunCoopRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::SendChickenRunCoopRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::SendChickenRunCoopRequest, rinfo_),
  PROTOBUF_FIELD_OFFSET(::ei::SendChickenRunCoopRequest, contract_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::SendChickenRunCoopRequest, coop_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::SendChickenRunCoopRequest, player_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::SendChickenRunCoopRequest, requesting_user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::SendChickenRunCoopRequest, requesting_user_name_),
  PROTOBUF_FIELD_OFFSET(::ei::SendChickenRunCoopRequest, farm_pop_),
  PROTOBUF_FIELD_OFFSET(::ei::SendChickenRunCoopRequest, client_version_),
  5,
  0,
  1,
  2,
  3,
  4,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::ei::ReportPlayerCoopRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ReportPlayerCoopRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ReportPlayerCoopRequest, rinfo_),
  PROTOBUF_FIELD_OFFSET(::ei::ReportPlayerCoopRequest, contract_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::ReportPlayerCoopRequest, coop_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::ReportPlayerCoopRequest, user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::ReportPlayerCoopRequest, reason_),
  3,
  0,
  1,
  2,
  4,
  PROTOBUF_FIELD_OFFSET(::ei::KickPlayerCoopRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::KickPlayerCoopRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::KickPlayerCoopRequest, rinfo_),
  PROTOBUF_FIELD_OFFSET(::ei::KickPlayerCoopRequest, contract_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::KickPlayerCoopRequest, coop_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::KickPlayerCoopRequest, player_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::KickPlayerCoopRequest, requesting_user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::KickPlayerCoopRequest, reason_),
  PROTOBUF_FIELD_OFFSET(::ei::KickPlayerCoopRequest, client_version_),
  4,
  0,
  1,
  2,
  3,
  6,
  5,
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusUpdateRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusUpdateRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusUpdateRequest, rinfo_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusUpdateRequest, user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusUpdateRequest, contract_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusUpdateRequest, coop_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusUpdateRequest, push_user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusUpdateRequest, amount_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusUpdateRequest, rate_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusUpdateRequest, time_cheats_detected_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusUpdateRequest, soul_power_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusUpdateRequest, eop_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusUpdateRequest, boost_tokens_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusUpdateRequest, boost_tokens_spent_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusUpdateRequest, production_params_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusUpdateRequest, farm_info_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusUpdateRequest, egg_laying_rate_buff_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusUpdateRequest, earnings_buff_),
  4,
  0,
  1,
  2,
  3,
  7,
  8,
  10,
  9,
  13,
  11,
  12,
  5,
  6,
  14,
  15,
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusUpdateResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusUpdateResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusUpdateResponse, finalized_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusUpdateResponse, exists_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractCoopStatusUpdateResponse, status_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::ei::CoopBuffState, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::CoopBuffState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::CoopBuffState, egg_laying_rate_),
  PROTOBUF_FIELD_OFFSET(::ei::CoopBuffState, earnings_),
  PROTOBUF_FIELD_OFFSET(::ei::CoopBuffState, server_timestamp_),
  1,
  2,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ei::CoopBuffHistory, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::CoopBuffHistory, history_),
  PROTOBUF_FIELD_OFFSET(::ei::CoopChickenRunEntry, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::CoopChickenRunEntry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::CoopChickenRunEntry, user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::CoopChickenRunEntry, server_timestamp_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ei::CoopLastChickenRunTimes, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::CoopLastChickenRunTimes, entries_),
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardAnalysis_Chunk, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardAnalysis_Chunk, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardAnalysis_Chunk, start_index_),
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardAnalysis_Chunk, end_index_),
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardAnalysis_Chunk, high_score_),
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardAnalysis_Chunk, low_score_),
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardAnalysis_Chunk, start_cursor_),
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardAnalysis_Chunk, end_cursor_),
  2,
  3,
  4,
  5,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardAnalysis, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardAnalysis, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardAnalysis, chunks_),
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardAnalysis, count_),
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardAnalysis, high_score_),
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardAnalysis, low_score_),
  ~0u,
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardInfo_Season, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardInfo_Season, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardInfo_Season, scope_),
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardInfo_Season, name_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardInfo, seasons_),
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardInfo, all_time_scope_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardRequest, rinfo_),
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardRequest, scope_),
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardRequest, grade_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardResponse_Entry, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardResponse_Entry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardResponse_Entry, rank_),
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardResponse_Entry, alias_),
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardResponse_Entry, score_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardResponse, scope_),
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardResponse, grade_),
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardResponse, top_entries_),
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardResponse, count_),
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardResponse, rank_),
  PROTOBUF_FIELD_OFFSET(::ei::LeaderboardResponse, score_),
  0,
  1,
  ~0u,
  2,
  4,
  3,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ei::ContractsArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ContractsArchive, archive_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractAction, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractAction, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ContractAction, user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractAction, action_name_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractAction, approx_time_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractAction, dest_user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractAction, contract_id_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractAction, coop_id_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractAction, autojoin_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractAction, grade_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractAction, replay_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractAction, points_replay_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractAction, reward_type_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractAction, reward_subtype_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractAction, reward_amount_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractAction, goal_index_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractAction, boost_id_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractAction, tokens_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractAction, kick_reason_),
  PROTOBUF_FIELD_OFFSET(::ei::ContractAction, public__),
  PROTOBUF_FIELD_OFFSET(::ei::ContractAction, cc_only_),
  0,
  1,
  7,
  2,
  3,
  4,
  10,
  8,
  11,
  12,
  9,
  5,
  15,
  14,
  6,
  16,
  17,
  13,
  18,
  PROTOBUF_FIELD_OFFSET(::ei::UserDataInfoRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::UserDataInfoRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::UserDataInfoRequest, rinfo_),
  PROTOBUF_FIELD_OFFSET(::ei::UserDataInfoRequest, user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::UserDataInfoRequest, device_id_),
  PROTOBUF_FIELD_OFFSET(::ei::UserDataInfoRequest, backup_checksum_),
  2,
  0,
  1,
  3,
  PROTOBUF_FIELD_OFFSET(::ei::UserDataInfoResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::UserDataInfoResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::UserDataInfoResponse, backup_checksum_),
  PROTOBUF_FIELD_OFFSET(::ei::UserDataInfoResponse, backup_total_cash_),
  PROTOBUF_FIELD_OFFSET(::ei::UserDataInfoResponse, coop_memberships_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::ei::ClearAllUserDataRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ClearAllUserDataRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ClearAllUserDataRequest, rinfo_),
  PROTOBUF_FIELD_OFFSET(::ei::ClearAllUserDataRequest, user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::ClearAllUserDataRequest, device_id_),
  PROTOBUF_FIELD_OFFSET(::ei::ClearAllUserDataRequest, backup_checksum_),
  2,
  0,
  1,
  3,
  PROTOBUF_FIELD_OFFSET(::ei::ServerGift, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ServerGift, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ServerGift, user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::ServerGift, reward_type_),
  PROTOBUF_FIELD_OFFSET(::ei::ServerGift, reward_sub_type_),
  PROTOBUF_FIELD_OFFSET(::ei::ServerGift, reward_amount_),
  0,
  3,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_BoostsConfig_ItemConfig, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_BoostsConfig_ItemConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_BoostsConfig_ItemConfig, boost_id_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_BoostsConfig_ItemConfig, price_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_BoostsConfig_ItemConfig, token_price_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_BoostsConfig_ItemConfig, se_required_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_BoostsConfig, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_BoostsConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_BoostsConfig, item_configs_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_BoostsConfig, cash_boost_cooloff_time_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_GiftConfig_GiftValueConfig, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_GiftConfig_GiftValueConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_GiftConfig_GiftValueConfig, gift_id_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_GiftConfig_GiftValueConfig, amount_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_GiftConfig_GiftValueConfig, rand_min_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_GiftConfig_GiftValueConfig, rand_max_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_GiftConfig_GiftValueConfig, video_min_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_GiftConfig_GiftValueConfig, video_max_),
  0,
  3,
  1,
  2,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_GiftConfig_GiftMuConfig, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_GiftConfig_GiftMuConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_GiftConfig_GiftMuConfig, min_spent_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_GiftConfig_GiftMuConfig, max_spent_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_GiftConfig_GiftMuConfig, overall_mult_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_GiftConfig, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_GiftConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_GiftConfig, gift_configs_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_GiftConfig, gift_mu_min_spent_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_GiftConfig, gift_mu_max_spent_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_GiftConfig, gift_mu_overall_mult_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_GiftConfig, random_gift_mu_config_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_GiftConfig, video_gift_mu_config_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_GiftConfig, package_interval_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_GiftConfig, video_offer_interval_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_GiftConfig, video_offer_interval_contract_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_GiftConfig, video_offer_interval_piggy_full_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_GiftConfig, video_offer_interval_piggy_extra_full_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_GiftConfig, video_reset_on_idle_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_GiftConfig, package_interval_contract_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_GiftConfig, package_interval_piggy_full_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_GiftConfig, package_interval_piggy_extra_full_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_GiftConfig, package_reset_on_idle_),
  ~0u,
  10,
  11,
  12,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  13,
  7,
  8,
  9,
  14,
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_MiscConfig, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_MiscConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_MiscConfig, ask_to_track_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_MiscConfig, ask_to_track_min_soul_eggs_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_MiscConfig, ask_to_track_message_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_MiscConfig, ask_to_track_show_pre_dialog_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_MiscConfig, ask_to_track_after_privacy_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_MiscConfig, chicken_run_boost_percentage_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_MiscConfig, shells_intro_tickets_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_MiscConfig, shells_max_free_chicken_configs_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_MiscConfig, shells_intro_alert_threshold_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_MiscConfig, contracts_expert_league_min_soul_power_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_MiscConfig, new_player_event_duration_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_MiscConfig, contracts_club_available_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig_MiscConfig, contracts_beta_),
  2,
  1,
  0,
  3,
  4,
  7,
  6,
  8,
  9,
  10,
  11,
  5,
  12,
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig, config_id_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig, boosts_config_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig, gift_config_),
  PROTOBUF_FIELD_OFFSET(::ei::LiveConfig, misc_config_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::ei::InGameMail, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::InGameMail, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::InGameMail, id_),
  PROTOBUF_FIELD_OFFSET(::ei::InGameMail, title_),
  PROTOBUF_FIELD_OFFSET(::ei::InGameMail, date_),
  PROTOBUF_FIELD_OFFSET(::ei::InGameMail, message_),
  PROTOBUF_FIELD_OFFSET(::ei::InGameMail, action_),
  PROTOBUF_FIELD_OFFSET(::ei::InGameMail, url_),
  PROTOBUF_FIELD_OFFSET(::ei::InGameMail, platform_),
  PROTOBUF_FIELD_OFFSET(::ei::InGameMail, builds_),
  PROTOBUF_FIELD_OFFSET(::ei::InGameMail, min_client_version_),
  PROTOBUF_FIELD_OFFSET(::ei::InGameMail, max_client_version_),
  PROTOBUF_FIELD_OFFSET(::ei::InGameMail, min_soul_eggs_),
  PROTOBUF_FIELD_OFFSET(::ei::InGameMail, min_mystical_bonus_),
  PROTOBUF_FIELD_OFFSET(::ei::InGameMail, gold_tip_),
  0,
  1,
  5,
  2,
  3,
  4,
  7,
  ~0u,
  8,
  11,
  9,
  10,
  6,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ei::MailDB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::MailDB, mail_),
  PROTOBUF_FIELD_OFFSET(::ei::PeriodicalsResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::PeriodicalsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::PeriodicalsResponse, sales_),
  PROTOBUF_FIELD_OFFSET(::ei::PeriodicalsResponse, events_),
  PROTOBUF_FIELD_OFFSET(::ei::PeriodicalsResponse, contracts_),
  PROTOBUF_FIELD_OFFSET(::ei::PeriodicalsResponse, evaluations_),
  PROTOBUF_FIELD_OFFSET(::ei::PeriodicalsResponse, gifts_),
  PROTOBUF_FIELD_OFFSET(::ei::PeriodicalsResponse, live_config_),
  PROTOBUF_FIELD_OFFSET(::ei::PeriodicalsResponse, mail_bag_),
  PROTOBUF_FIELD_OFFSET(::ei::PeriodicalsResponse, contract_player_info_),
  0,
  1,
  2,
  ~0u,
  ~0u,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::ei::GetPeriodicalsRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::GetPeriodicalsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::GetPeriodicalsRequest, rinfo_),
  PROTOBUF_FIELD_OFFSET(::ei::GetPeriodicalsRequest, user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::GetPeriodicalsRequest, piggy_full_),
  PROTOBUF_FIELD_OFFSET(::ei::GetPeriodicalsRequest, piggy_found_full_),
  PROTOBUF_FIELD_OFFSET(::ei::GetPeriodicalsRequest, seconds_full_realtime_),
  PROTOBUF_FIELD_OFFSET(::ei::GetPeriodicalsRequest, seconds_full_gametime_),
  PROTOBUF_FIELD_OFFSET(::ei::GetPeriodicalsRequest, lost_increments_),
  PROTOBUF_FIELD_OFFSET(::ei::GetPeriodicalsRequest, soul_eggs_),
  PROTOBUF_FIELD_OFFSET(::ei::GetPeriodicalsRequest, mystical_earnings_mult_),
  PROTOBUF_FIELD_OFFSET(::ei::GetPeriodicalsRequest, eop_),
  PROTOBUF_FIELD_OFFSET(::ei::GetPeriodicalsRequest, contracts_unlocked_),
  PROTOBUF_FIELD_OFFSET(::ei::GetPeriodicalsRequest, artifacts_unlocked_),
  PROTOBUF_FIELD_OFFSET(::ei::GetPeriodicalsRequest, current_client_version_),
  PROTOBUF_FIELD_OFFSET(::ei::GetPeriodicalsRequest, debug_),
  1,
  0,
  6,
  7,
  2,
  3,
  5,
  4,
  12,
  13,
  8,
  9,
  10,
  11,
  PROTOBUF_FIELD_OFFSET(::ei::ConfigRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ConfigRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ConfigRequest, rinfo_),
  PROTOBUF_FIELD_OFFSET(::ei::ConfigRequest, soul_eggs_),
  PROTOBUF_FIELD_OFFSET(::ei::ConfigRequest, artifacts_enabled_),
  PROTOBUF_FIELD_OFFSET(::ei::ConfigRequest, fuel_tank_unlocked_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::ei::ConfigResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ConfigResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ConfigResponse, live_config_),
  PROTOBUF_FIELD_OFFSET(::ei::ConfigResponse, mail_bag_),
  PROTOBUF_FIELD_OFFSET(::ei::ConfigResponse, dlc_catalog_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionRawData, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionRawData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionRawData, device_ad_id_),
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionRawData, user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionRawData, ad_network_),
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionRawData, json_data_),
  0,
  3,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionRow, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionRow, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionRow, user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionRow, ad_id_),
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionRow, ad_network_),
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionRow, campaign_),
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionRow, keyword_),
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionRow, extra_),
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionRow, click_date_),
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionRow, download_date_),
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionRow, approx_time_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionInfo, device_ad_id_),
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionInfo, network_name_),
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionInfo, attribution_),
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionInfo, org_name_),
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionInfo, org_id_),
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionInfo, campaign_name_),
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionInfo, campaign_id_),
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionInfo, click_date_),
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionInfo, conversion_date_),
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionInfo, conversion_type_),
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionInfo, geo_),
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionInfo, adgroup_name_),
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionInfo, adgroup_id_),
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionInfo, keyword_),
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionInfo, keyword_id_),
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionInfo, keyword_extra_),
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionInfo, creativeset_name_),
  PROTOBUF_FIELD_OFFSET(::ei::AdAttributionInfo, creativeset_id_),
  0,
  1,
  17,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsClientInfo_LaunchCount, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsClientInfo_LaunchCount, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsClientInfo_LaunchCount, ship_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsClientInfo_LaunchCount, num_launches_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsClientInfo_LaunchCount, launch_points_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsClientInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsClientInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsClientInfo, mission_capacity_mult_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsClientInfo, mission_duration_mult_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsClientInfo, mission_ftl_duration_mult_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsClientInfo, launch_counts_),
  0,
  1,
  2,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::ei::MissionInfo_Fuel, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::MissionInfo_Fuel, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::MissionInfo_Fuel, egg_),
  PROTOBUF_FIELD_OFFSET(::ei::MissionInfo_Fuel, amount_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::ei::MissionInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::MissionInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::MissionInfo, ship_),
  PROTOBUF_FIELD_OFFSET(::ei::MissionInfo, status_),
  PROTOBUF_FIELD_OFFSET(::ei::MissionInfo, duration_type_),
  PROTOBUF_FIELD_OFFSET(::ei::MissionInfo, fuel_),
  PROTOBUF_FIELD_OFFSET(::ei::MissionInfo, level_),
  PROTOBUF_FIELD_OFFSET(::ei::MissionInfo, duration_seconds_),
  PROTOBUF_FIELD_OFFSET(::ei::MissionInfo, capacity_),
  PROTOBUF_FIELD_OFFSET(::ei::MissionInfo, quality_bump_),
  PROTOBUF_FIELD_OFFSET(::ei::MissionInfo, seconds_remaining_),
  PROTOBUF_FIELD_OFFSET(::ei::MissionInfo, start_time_derived_),
  PROTOBUF_FIELD_OFFSET(::ei::MissionInfo, mission_log_),
  PROTOBUF_FIELD_OFFSET(::ei::MissionInfo, identifier_),
  2,
  3,
  6,
  ~0u,
  10,
  4,
  7,
  9,
  5,
  8,
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactSpec, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactSpec, name_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactSpec, level_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactSpec, rarity_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactSpec, egg_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::ei::CompleteArtifact, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::CompleteArtifact, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::CompleteArtifact, spec_),
  PROTOBUF_FIELD_OFFSET(::ei::CompleteArtifact, stones_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactInventoryItem, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactInventoryItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactInventoryItem, item_id_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactInventoryItem, artifact_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactInventoryItem, quantity_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactInventoryItem, server_id_),
  2,
  1,
  3,
  0,
  PROTOBUF_FIELD_OFFSET(::ei::InventorySlot, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::InventorySlot, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::InventorySlot, occupied_),
  PROTOBUF_FIELD_OFFSET(::ei::InventorySlot, item_id_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationRequest, rinfo_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationRequest, client_version_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse_MissionParameters_Duration, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse_MissionParameters_Duration, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse_MissionParameters_Duration, duration_type_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse_MissionParameters_Duration, seconds_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse_MissionParameters_Duration, quality_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse_MissionParameters_Duration, min_quality_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse_MissionParameters_Duration, max_quality_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse_MissionParameters_Duration, capacity_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse_MissionParameters_Duration, level_capacity_bump_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse_MissionParameters_Duration, level_quality_bump_),
  1,
  0,
  2,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse_MissionParameters, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse_MissionParameters, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse_MissionParameters, ship_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse_MissionParameters, durations_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse_MissionParameters, level_mission_requirements_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse_MissionParameters, capacity_deprecated_),
  0,
  ~0u,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse_ArtifactParameters, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse_ArtifactParameters, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse_ArtifactParameters, spec_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse_ArtifactParameters, base_quality_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse_ArtifactParameters, odds_multiplier_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse_ArtifactParameters, value_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse_ArtifactParameters, crafting_price_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse_ArtifactParameters, crafting_price_low_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse_ArtifactParameters, crafting_price_domain_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse_ArtifactParameters, crafting_price_curve_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse_ArtifactParameters, crafting_xp_),
  0,
  1,
  3,
  2,
  4,
  5,
  8,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse_CraftingLevelInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse_CraftingLevelInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse_CraftingLevelInfo, xp_required_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse_CraftingLevelInfo, rarity_mult_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse, mission_parameters_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse, artifact_parameters_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsConfigurationResponse, crafting_level_infos_),
  PROTOBUF_FIELD_OFFSET(::ei::MissionRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::MissionRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::MissionRequest, rinfo_),
  PROTOBUF_FIELD_OFFSET(::ei::MissionRequest, client_version_),
  PROTOBUF_FIELD_OFFSET(::ei::MissionRequest, ei_user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::MissionRequest, info_),
  PROTOBUF_FIELD_OFFSET(::ei::MissionRequest, client_info_),
  2,
  4,
  0,
  1,
  3,
  PROTOBUF_FIELD_OFFSET(::ei::MissionResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::MissionResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::MissionResponse, success_),
  PROTOBUF_FIELD_OFFSET(::ei::MissionResponse, info_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::ei::CompleteMissionResponse_SecureArtifactSpec, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::CompleteMissionResponse_SecureArtifactSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::CompleteMissionResponse_SecureArtifactSpec, spec_),
  PROTOBUF_FIELD_OFFSET(::ei::CompleteMissionResponse_SecureArtifactSpec, server_id_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::ei::CompleteMissionResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::CompleteMissionResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::CompleteMissionResponse, success_),
  PROTOBUF_FIELD_OFFSET(::ei::CompleteMissionResponse, info_),
  PROTOBUF_FIELD_OFFSET(::ei::CompleteMissionResponse, artifacts_),
  PROTOBUF_FIELD_OFFSET(::ei::CompleteMissionResponse, other_rewards_),
  PROTOBUF_FIELD_OFFSET(::ei::CompleteMissionResponse, ei_user_id_),
  2,
  1,
  ~0u,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::ei::CollectContractArtifactRewardsRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::CollectContractArtifactRewardsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::CollectContractArtifactRewardsRequest, rinfo_),
  PROTOBUF_FIELD_OFFSET(::ei::CollectContractArtifactRewardsRequest, contract_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::CollectContractArtifactRewardsRequest, league_),
  PROTOBUF_FIELD_OFFSET(::ei::CollectContractArtifactRewardsRequest, grade_),
  PROTOBUF_FIELD_OFFSET(::ei::CollectContractArtifactRewardsRequest, goal_index_),
  PROTOBUF_FIELD_OFFSET(::ei::CollectContractArtifactRewardsRequest, best_ship_),
  1,
  0,
  4,
  5,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::ei::CraftArtifactRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::CraftArtifactRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::CraftArtifactRequest, rinfo_),
  PROTOBUF_FIELD_OFFSET(::ei::CraftArtifactRequest, ei_user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::CraftArtifactRequest, spec_),
  PROTOBUF_FIELD_OFFSET(::ei::CraftArtifactRequest, item_id_),
  PROTOBUF_FIELD_OFFSET(::ei::CraftArtifactRequest, gold_price_paid_),
  PROTOBUF_FIELD_OFFSET(::ei::CraftArtifactRequest, crafting_count_),
  PROTOBUF_FIELD_OFFSET(::ei::CraftArtifactRequest, crafting_xp_),
  PROTOBUF_FIELD_OFFSET(::ei::CraftArtifactRequest, ingredients_),
  2,
  0,
  1,
  3,
  4,
  6,
  5,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::ei::CraftArtifactResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::CraftArtifactResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::CraftArtifactResponse, item_id_),
  PROTOBUF_FIELD_OFFSET(::ei::CraftArtifactResponse, ei_user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::CraftArtifactResponse, rarity_achieved_),
  PROTOBUF_FIELD_OFFSET(::ei::CraftArtifactResponse, server_id_),
  2,
  1,
  3,
  0,
  PROTOBUF_FIELD_OFFSET(::ei::ConsumeArtifactRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ConsumeArtifactRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ConsumeArtifactRequest, rinfo_),
  PROTOBUF_FIELD_OFFSET(::ei::ConsumeArtifactRequest, ei_user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::ConsumeArtifactRequest, spec_),
  PROTOBUF_FIELD_OFFSET(::ei::ConsumeArtifactRequest, artifact_server_id_),
  PROTOBUF_FIELD_OFFSET(::ei::ConsumeArtifactRequest, original_item_id_),
  PROTOBUF_FIELD_OFFSET(::ei::ConsumeArtifactRequest, additional_server_ids_),
  PROTOBUF_FIELD_OFFSET(::ei::ConsumeArtifactRequest, additional_item_ids_),
  PROTOBUF_FIELD_OFFSET(::ei::ConsumeArtifactRequest, quantity_),
  3,
  0,
  2,
  1,
  4,
  ~0u,
  ~0u,
  5,
  PROTOBUF_FIELD_OFFSET(::ei::ConsumeArtifactResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ConsumeArtifactResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ConsumeArtifactResponse, success_),
  PROTOBUF_FIELD_OFFSET(::ei::ConsumeArtifactResponse, original_item_id_),
  PROTOBUF_FIELD_OFFSET(::ei::ConsumeArtifactResponse, additional_item_ids_),
  PROTOBUF_FIELD_OFFSET(::ei::ConsumeArtifactResponse, byproducts_),
  PROTOBUF_FIELD_OFFSET(::ei::ConsumeArtifactResponse, other_rewards_),
  PROTOBUF_FIELD_OFFSET(::ei::ConsumeArtifactResponse, ei_user_id_),
  2,
  1,
  ~0u,
  ~0u,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::ei::AuthenticateArtifactResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::AuthenticateArtifactResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::AuthenticateArtifactResponse, success_),
  PROTOBUF_FIELD_OFFSET(::ei::AuthenticateArtifactResponse, original_item_id_),
  PROTOBUF_FIELD_OFFSET(::ei::AuthenticateArtifactResponse, demote_),
  PROTOBUF_FIELD_OFFSET(::ei::AuthenticateArtifactResponse, delete__),
  PROTOBUF_FIELD_OFFSET(::ei::AuthenticateArtifactResponse, ei_user_id_),
  2,
  1,
  3,
  4,
  0,
  PROTOBUF_FIELD_OFFSET(::ei::SetArtifactRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::SetArtifactRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::SetArtifactRequest, rinfo_),
  PROTOBUF_FIELD_OFFSET(::ei::SetArtifactRequest, artifact_),
  PROTOBUF_FIELD_OFFSET(::ei::SetArtifactRequest, stones_),
  PROTOBUF_FIELD_OFFSET(::ei::SetArtifactRequest, gold_price_paid_),
  0,
  1,
  ~0u,
  2,
  PROTOBUF_FIELD_OFFSET(::ei::SetArtifactResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::SetArtifactResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::SetArtifactResponse, success_),
  PROTOBUF_FIELD_OFFSET(::ei::SetArtifactResponse, original_item_id_),
  PROTOBUF_FIELD_OFFSET(::ei::SetArtifactResponse, ei_user_id_),
  2,
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsDB_ActiveArtifactSlot, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsDB_ActiveArtifactSlot, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsDB_ActiveArtifactSlot, occupied_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsDB_ActiveArtifactSlot, item_id_),
  1,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsDB_ActiveArtifactSet, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsDB_ActiveArtifactSet, slots_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsDB_CraftableArtifact, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsDB_CraftableArtifact, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsDB_CraftableArtifact, spec_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsDB_CraftableArtifact, discovered_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsDB_CraftableArtifact, craftable_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsDB_CraftableArtifact, recipe_discovered_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsDB_CraftableArtifact, seen_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsDB_CraftableArtifact, count_),
  0,
  2,
  3,
  4,
  5,
  1,
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsDB, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsDB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsDB, inventory_items_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsDB, item_sequence_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsDB, inventory_slots_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsDB, active_artifacts_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsDB, active_artifact_sets_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsDB, artifact_status_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsDB, mission_infos_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsDB, mission_archive_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsDB, discovered_artifacts_deprecated_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsDB, craftable_artifacts_deprecated_),
  PROTOBUF_FIELD_OFFSET(::ei::ArtifactsDB, crafting_counts_deprecated_),
  ~0u,
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::ei::AuthenticatedMessage, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::AuthenticatedMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::AuthenticatedMessage, message_),
  PROTOBUF_FIELD_OFFSET(::ei::AuthenticatedMessage, version_),
  PROTOBUF_FIELD_OFFSET(::ei::AuthenticatedMessage, code_),
  PROTOBUF_FIELD_OFFSET(::ei::AuthenticatedMessage, compressed_),
  PROTOBUF_FIELD_OFFSET(::ei::AuthenticatedMessage, original_size_),
  0,
  2,
  1,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::ei::LogCompleteMissionPayload, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::LogCompleteMissionPayload, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::LogCompleteMissionPayload, req_),
  PROTOBUF_FIELD_OFFSET(::ei::LogCompleteMissionPayload, res_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ei::LogCraftArtifactPayload, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::LogCraftArtifactPayload, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::LogCraftArtifactPayload, req_),
  PROTOBUF_FIELD_OFFSET(::ei::LogCraftArtifactPayload, res_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ei::LogConsumeArtifactPayload, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::LogConsumeArtifactPayload, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::LogConsumeArtifactPayload, req_),
  PROTOBUF_FIELD_OFFSET(::ei::LogConsumeArtifactPayload, res_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ei::LogSetArtifactPayload, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::LogSetArtifactPayload, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::LogSetArtifactPayload, req_),
  PROTOBUF_FIELD_OFFSET(::ei::LogSetArtifactPayload, res_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ei::AccountTransferPayload, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::AccountTransferPayload, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::AccountTransferPayload, from_id_),
  PROTOBUF_FIELD_OFFSET(::ei::AccountTransferPayload, to_ei_user_id_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ei::SaveBackupResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::SaveBackupResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::SaveBackupResponse, success_),
  PROTOBUF_FIELD_OFFSET(::ei::SaveBackupResponse, error_code_),
  PROTOBUF_FIELD_OFFSET(::ei::SaveBackupResponse, message_),
  PROTOBUF_FIELD_OFFSET(::ei::SaveBackupResponse, existing_backup_),
  2,
  3,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ei::CleanAccountRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::CleanAccountRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::CleanAccountRequest, ei_user_id_to_keep_),
  PROTOBUF_FIELD_OFFSET(::ei::CleanAccountRequest, game_services_id_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ei::ReturnEDTPayload, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ReturnEDTPayload, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ReturnEDTPayload, ei_user_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::ei::DLCItem, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::DLCItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::DLCItem, name_),
  PROTOBUF_FIELD_OFFSET(::ei::DLCItem, directory_),
  PROTOBUF_FIELD_OFFSET(::ei::DLCItem, ext_),
  PROTOBUF_FIELD_OFFSET(::ei::DLCItem, compressed_),
  PROTOBUF_FIELD_OFFSET(::ei::DLCItem, original_size_),
  PROTOBUF_FIELD_OFFSET(::ei::DLCItem, url_),
  PROTOBUF_FIELD_OFFSET(::ei::DLCItem, checksum_),
  0,
  1,
  2,
  6,
  5,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::ei::ShellSpec_ShellPiece, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSpec_ShellPiece, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ShellSpec_ShellPiece, asset_type_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSpec_ShellPiece, dlc_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::ei::ShellSpec, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ShellSpec, identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSpec, primary_piece_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSpec, pieces_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSpec, alt_assets_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSpec, name_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSpec, set_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSpec, modified_geometry_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSpec, price_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSpec, required_eop_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSpec, required_soul_eggs_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSpec, required_parent_shell_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSpec, is_new_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSpec, expires_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSpec, seconds_until_available_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSpec, seconds_remaining_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSpec, default_appearance_),
  0,
  4,
  ~0u,
  ~0u,
  1,
  2,
  10,
  5,
  6,
  7,
  3,
  11,
  12,
  9,
  8,
  13,
  PROTOBUF_FIELD_OFFSET(::ei::ShellSetSpec_VariationSpec, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSetSpec_VariationSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ShellSetSpec_VariationSpec, identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSetSpec_VariationSpec, hex_color_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSetSpec_VariationSpec, price_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSetSpec_VariationSpec, sort_priority_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSetSpec_VariationSpec, default_appearance_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSetSpec_VariationSpec, custom_appearance_),
  0,
  1,
  2,
  5,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::ei::ShellSetSpec, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSetSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ShellSetSpec, identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSetSpec, name_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSetSpec, price_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSetSpec, price_mult_deprecated_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSetSpec, discount_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSetSpec, required_eop_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSetSpec, required_soul_eggs_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSetSpec, required_parent_set_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSetSpec, is_new_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSetSpec, expires_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSetSpec, seconds_until_available_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSetSpec, seconds_remaining_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSetSpec, decorator_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSetSpec, modified_geometry_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSetSpec, element_set_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSetSpec, hex_base_color_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSetSpec, variations_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSetSpec, icon_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSetSpec, default_appearance_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellSetSpec, custom_appearance_),
  0,
  1,
  5,
  18,
  16,
  6,
  7,
  3,
  11,
  12,
  17,
  15,
  13,
  14,
  8,
  2,
  ~0u,
  4,
  9,
  10,
  PROTOBUF_FIELD_OFFSET(::ei::ShellObjectSpec_LODPiece, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellObjectSpec_LODPiece, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ShellObjectSpec_LODPiece, dlc_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellObjectSpec_LODPiece, lod_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ei::ShellObjectSpec, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellObjectSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ShellObjectSpec, identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellObjectSpec, name_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellObjectSpec, asset_type_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellObjectSpec, object_class_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellObjectSpec, icon_colors_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellObjectSpec, price_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellObjectSpec, required_eop_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellObjectSpec, required_soul_eggs_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellObjectSpec, is_new_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellObjectSpec, expires_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellObjectSpec, seconds_until_available_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellObjectSpec, seconds_remaining_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellObjectSpec, metadata_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellObjectSpec, no_hats_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellObjectSpec, chicken_animation_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellObjectSpec, sort_priority_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellObjectSpec, pieces_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellObjectSpec, default_appearance_),
  0,
  1,
  14,
  2,
  ~0u,
  3,
  4,
  5,
  6,
  7,
  12,
  11,
  ~0u,
  8,
  10,
  13,
  ~0u,
  9,
  PROTOBUF_FIELD_OFFSET(::ei::ShellGroupSpec, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellGroupSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ShellGroupSpec, identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellGroupSpec, name_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellGroupSpec, asset_type_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellGroupSpec, member_ids_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellGroupSpec, price_mult_deprecated_),
  0,
  1,
  3,
  ~0u,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ei::DLCCatalog, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::DLCCatalog, items_),
  PROTOBUF_FIELD_OFFSET(::ei::DLCCatalog, shells_),
  PROTOBUF_FIELD_OFFSET(::ei::DLCCatalog, shell_sets_),
  PROTOBUF_FIELD_OFFSET(::ei::DLCCatalog, decorators_),
  PROTOBUF_FIELD_OFFSET(::ei::DLCCatalog, shell_objects_),
  PROTOBUF_FIELD_OFFSET(::ei::DLCCatalog, shell_groups_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_ShellStatus, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_ShellStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_ShellStatus, identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_ShellStatus, owned_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_ShellElementStatus, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_ShellElementStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_ShellElementStatus, element_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_ShellElementStatus, set_identifier_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_ShellSetVariationStatus, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_ShellSetVariationStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_ShellSetVariationStatus, set_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_ShellSetVariationStatus, owned_variations_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_FarmConfiguration, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_FarmConfiguration, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_FarmConfiguration, shell_configs_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_FarmConfiguration, shell_set_configs_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_FarmConfiguration, configure_chickens_by_group_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_FarmConfiguration, group_configs_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_FarmConfiguration, chicken_configs_),
  ~0u,
  ~0u,
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_SavedFarmConfiguration, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_SavedFarmConfiguration, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_SavedFarmConfiguration, name_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_SavedFarmConfiguration, config_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_SavedFarmConfiguration, client_save_time_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_ShellConfiguration, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_ShellConfiguration, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_ShellConfiguration, asset_type_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_ShellConfiguration, index_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_ShellConfiguration, shell_identifier_),
  2,
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_ShellSetConfiguration, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_ShellSetConfiguration, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_ShellSetConfiguration, element_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_ShellSetConfiguration, index_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_ShellSetConfiguration, shell_set_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_ShellSetConfiguration, variation_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_ShellSetConfiguration, decorator_identifier_),
  4,
  3,
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_ShellGroupConfiguration, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_ShellGroupConfiguration, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_ShellGroupConfiguration, asset_type_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_ShellGroupConfiguration, group_identifier_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_ChickenConfig, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_ChickenConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_ChickenConfig, chicken_identifier_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB_ChickenConfig, hat_identifier_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB, shell_inventory_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB, shell_element_inventory_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB, shell_variation_inventory_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB, shell_set_inventory_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB, shell_object_inventory_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB, farm_configs_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB, saved_configs_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB, new_shells_downloaded_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellDB, new_shells_seen_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellsActionLog, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellsActionLog, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::ShellsActionLog, rinfo_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellsActionLog, user_id_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellsActionLog, action_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellsActionLog, sub_id_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellsActionLog, farm_element_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellsActionLog, cost_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellsActionLog, approx_time_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellsActionLog, version_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellsActionLog, farm_index_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellsActionLog, soul_eggs_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellsActionLog, tickets_spent_),
  PROTOBUF_FIELD_OFFSET(::ei::ShellsActionLog, gold_spent_),
  4,
  0,
  1,
  2,
  11,
  6,
  5,
  3,
  7,
  8,
  9,
  10,
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, overall_status_),
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, start_time_),
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, completion_time_),
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, num_prestiges_),
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, soul_eggs_),
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, eggs_of_prophecy_),
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, iap_status_),
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, verified_pro_permit_),
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, verified_piggy_breaks_),
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, verified_other_iap_),
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, unverified_iap_),
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, gold_earned_),
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, regular_iap_buyer_),
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, regular_iap_cheater_),
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, artifacts_status_),
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, missions_completed_),
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, artifacts_collected_),
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, artifacts_consumed_),
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, artifacts_in_inventory_),
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, gold_spent_crafting_),
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, excessive_consumes_),
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, excessive_inventory_),
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, excessive_spend_),
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, contracts_status_),
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, num_coop_memberships_),
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, valid_contracts_),
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, invalid_contracts_),
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, excessive_eop_),
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, excessive_invalid_contracts_),
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, verified_),
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, verification_override_),
  PROTOBUF_FIELD_OFFSET(::ei::UserVerificationAnalysis, verification_override_value_),
  2,
  0,
  1,
  12,
  13,
  23,
  15,
  16,
  3,
  4,
  5,
  11,
  17,
  18,
  20,
  8,
  6,
  7,
  10,
  21,
  19,
  24,
  25,
  22,
  9,
  14,
  ~0u,
  26,
  27,
  28,
  29,
  30,
  PROTOBUF_FIELD_OFFSET(::ei::UserSubscriptionInfo_HistoryEntry, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::UserSubscriptionInfo_HistoryEntry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::UserSubscriptionInfo_HistoryEntry, timestamp_),
  PROTOBUF_FIELD_OFFSET(::ei::UserSubscriptionInfo_HistoryEntry, message_id_),
  PROTOBUF_FIELD_OFFSET(::ei::UserSubscriptionInfo_HistoryEntry, message_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ei::UserSubscriptionInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::UserSubscriptionInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::UserSubscriptionInfo, subscription_level_),
  PROTOBUF_FIELD_OFFSET(::ei::UserSubscriptionInfo, next_subscription_level_),
  PROTOBUF_FIELD_OFFSET(::ei::UserSubscriptionInfo, lock_next_subscription_level_),
  PROTOBUF_FIELD_OFFSET(::ei::UserSubscriptionInfo, platform_),
  PROTOBUF_FIELD_OFFSET(::ei::UserSubscriptionInfo, original_transaction_id_),
  PROTOBUF_FIELD_OFFSET(::ei::UserSubscriptionInfo, linked_transaction_id_),
  PROTOBUF_FIELD_OFFSET(::ei::UserSubscriptionInfo, acknowledged_),
  PROTOBUF_FIELD_OFFSET(::ei::UserSubscriptionInfo, first_subscribed_),
  PROTOBUF_FIELD_OFFSET(::ei::UserSubscriptionInfo, period_end_),
  PROTOBUF_FIELD_OFFSET(::ei::UserSubscriptionInfo, status_),
  PROTOBUF_FIELD_OFFSET(::ei::UserSubscriptionInfo, store_status_),
  PROTOBUF_FIELD_OFFSET(::ei::UserSubscriptionInfo, auto_renew_),
  PROTOBUF_FIELD_OFFSET(::ei::UserSubscriptionInfo, sandbox_),
  PROTOBUF_FIELD_OFFSET(::ei::UserSubscriptionInfo, last_updated_),
  PROTOBUF_FIELD_OFFSET(::ei::UserSubscriptionInfo, history_),
  PROTOBUF_FIELD_OFFSET(::ei::UserSubscriptionInfo, past_user_ids_),
  7,
  8,
  9,
  13,
  0,
  2,
  10,
  3,
  4,
  6,
  1,
  11,
  12,
  5,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::ei::SubscriptionChangeHintRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::SubscriptionChangeHintRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::SubscriptionChangeHintRequest, rinfo_),
  PROTOBUF_FIELD_OFFSET(::ei::SubscriptionChangeHintRequest, original_transaction_id_),
  PROTOBUF_FIELD_OFFSET(::ei::SubscriptionChangeHintRequest, next_subscription_level_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::ei::CXPEvalRolloutInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ei::CXPEvalRolloutInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ei::CXPEvalRolloutInfo, current_id_),
  PROTOBUF_FIELD_OFFSET(::ei::CXPEvalRolloutInfo, basis_points_),
  0,
  1,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 31, -1, sizeof(::ei::Backup_Settings)},
  { 56, 73, -1, sizeof(::ei::Backup_Tutorial)},
  { 84, 108, -1, sizeof(::ei::Backup_Stats)},
  { 126, 171, -1, sizeof(::ei::Backup_Game)},
  { 210, 233, -1, sizeof(::ei::Backup_Artifacts)},
  { 250, 259, -1, sizeof(::ei::Backup_Shells)},
  { 262, 299, -1, sizeof(::ei::Backup_Simulation)},
  { 330, 340, -1, sizeof(::ei::Backup_Mission)},
  { 344, 372, -1, sizeof(::ei::Backup_Misc)},
  { 394, 402, -1, sizeof(::ei::Backup_ResearchItem)},
  { 404, 412, -1, sizeof(::ei::Backup_NewsHeadline)},
  { 414, 422, -1, sizeof(::ei::Backup_AchievementInfo)},
  { 424, 433, -1, sizeof(::ei::Backup_ActiveBoost)},
  { 436, 444, -1, sizeof(::ei::Backup_OwnedBoost)},
  { 446, 455, -1, sizeof(::ei::Backup_MissionInfo)},
  { 458, 489, -1, sizeof(::ei::Backup)},
  { 514, 528, -1, sizeof(::ei::EggIncFirstContactRequest)},
  { 536, 547, -1, sizeof(::ei::EggIncFirstContactResponse)},
  { 552, -1, -1, sizeof(::ei::EggIncAdConfig)},
  { 559, 567, -1, sizeof(::ei::DailyGiftInfo)},
  { 569, 582, -1, sizeof(::ei::SalesInfoRequest)},
  { 589, 599, -1, sizeof(::ei::IAPSaleEntry)},
  { 603, -1, -1, sizeof(::ei::SalesInfo)},
  { 610, 624, -1, sizeof(::ei::EggIncEvent)},
  { 632, -1, -1, sizeof(::ei::EggIncCurrentEvents)},
  { 639, 658, -1, sizeof(::ei::DeviceInfo)},
  { 671, 706, -1, sizeof(::ei::AppInfo)},
  { 735, 743, -1, sizeof(::ei::ActionKeyValuePair)},
  { 745, 759, -1, sizeof(::ei::GenericAction)},
  { 767, 775, -1, sizeof(::ei::GenericActionBatchRequest)},
  { 777, 791, -1, sizeof(::ei::VerifyPurchaseRequest)},
  { 799, 807, -1, sizeof(::ei::VerifyPurchaseResponse)},
  { 809, 825, -1, sizeof(::ei::CurrencyFlowLog)},
  { 835, 843, -1, sizeof(::ei::CurrencyFlowBatchRequest)},
  { 845, 854, -1, sizeof(::ei::Reward)},
  { 857, 866, -1, sizeof(::ei::GameModifier)},
  { 869, 881, -1, sizeof(::ei::Contract_Goal)},
  { 887, -1, -1, sizeof(::ei::Contract_GoalSet)},
  { 894, 904, -1, sizeof(::ei::Contract_GradeSpec)},
  { 908, 936, -1, sizeof(::ei::Contract)},
  { 958, 978, -1, sizeof(::ei::ContractPlayerInfo)},
  { 992, 1030, -1, sizeof(::ei::ContractEvaluation)},
  { 1062, 1071, -1, sizeof(::ei::ContractCitation)},
  { 1074, 1082, -1, sizeof(::ei::ContractEvaluationBatch_Pair)},
  { 1084, -1, -1, sizeof(::ei::ContractEvaluationBatch)},
  { 1091, 1103, -1, sizeof(::ei::CoopCompletionSnapshot_ContributorSnapshot)},
  { 1109, -1, -1, sizeof(::ei::CoopCompletionSnapshot)},
  { 1116, 1130, -1, sizeof(::ei::BasicRequestInfo)},
  { 1138, 1148, -1, sizeof(::ei::ContractSimConfig_ContractGradeSimConfig_GoalParams)},
  { 1152, 1160, -1, sizeof(::ei::ContractSimConfig_ContractGradeSimConfig)},
  { 1162, -1, -1, sizeof(::ei::ContractSimConfig)},
  { 1169, 1176, -1, sizeof(::ei::ContractSimPoll)},
  { 1177, 1185, -1, sizeof(::ei::ContractSimPollResponse)},
  { 1187, 1196, -1, sizeof(::ei::ContractSimResultUpdate_GoalInfo)},
  { 1199, 1207, -1, sizeof(::ei::ContractSimResultUpdate)},
  { 1209, 1218, -1, sizeof(::ei::ContractsRequest)},
  { 1221, 1231, -1, sizeof(::ei::ContractsResponse)},
  { 1235, 1246, -1, sizeof(::ei::ContractCoopStatusRequest)},
  { 1251, 1263, -1, sizeof(::ei::FarmProductionParams)},
  { 1269, 1297, -1, sizeof(::ei::PlayerFarmInfo)},
  { 1319, 1346, -1, sizeof(::ei::ContractCoopStatusResponse_ContributionInfo)},
  { 1367, 1376, -1, sizeof(::ei::ContractCoopStatusResponse_CoopGift)},
  { 1379, 1388, -1, sizeof(::ei::ContractCoopStatusResponse_ChickenRun)},
  { 1391, 1411, -1, sizeof(::ei::ContractCoopStatusResponse)},
  { 1425, 1452, -1, sizeof(::ei::LocalContract)},
  { 1473, 1487, -1, sizeof(::ei::MyContracts)},
  { 1495, 1507, -1, sizeof(::ei::QueryCoopRequest)},
  { 1513, 1526, -1, sizeof(::ei::QueryCoopResponse)},
  { 1533, 1553, -1, sizeof(::ei::CreateCoopRequest)},
  { 1567, 1575, -1, sizeof(::ei::CreateCoopResponse)},
  { 1577, 1595, -1, sizeof(::ei::JoinCoopRequest)},
  { 1607, 1623, -1, sizeof(::ei::JoinCoopResponse)},
  { 1633, 1650, -1, sizeof(::ei::AutoJoinCoopRequest)},
  { 1661, 1673, -1, sizeof(::ei::UpdateCoopPermissionsRequest)},
  { 1679, 1687, -1, sizeof(::ei::UpdateCoopPermissionsResponse)},
  { 1689, 1700, -1, sizeof(::ei::LeaveCoopRequest)},
  { 1705, 1719, -1, sizeof(::ei::GiftPlayerCoopRequest)},
  { 1727, 1741, -1, sizeof(::ei::SendChickenRunCoopRequest)},
  { 1749, 1760, -1, sizeof(::ei::ReportPlayerCoopRequest)},
  { 1765, 1778, -1, sizeof(::ei::KickPlayerCoopRequest)},
  { 1785, 1807, -1, sizeof(::ei::ContractCoopStatusUpdateRequest)},
  { 1823, 1832, -1, sizeof(::ei::ContractCoopStatusUpdateResponse)},
  { 1835, 1844, -1, sizeof(::ei::CoopBuffState)},
  { 1847, -1, -1, sizeof(::ei::CoopBuffHistory)},
  { 1854, 1862, -1, sizeof(::ei::CoopChickenRunEntry)},
  { 1864, -1, -1, sizeof(::ei::CoopLastChickenRunTimes)},
  { 1871, 1883, -1, sizeof(::ei::LeaderboardAnalysis_Chunk)},
  { 1889, 1899, -1, sizeof(::ei::LeaderboardAnalysis)},
  { 1903, 1911, -1, sizeof(::ei::LeaderboardInfo_Season)},
  { 1913, 1921, -1, sizeof(::ei::LeaderboardInfo)},
  { 1923, 1932, -1, sizeof(::ei::LeaderboardRequest)},
  { 1935, 1944, -1, sizeof(::ei::LeaderboardResponse_Entry)},
  { 1947, 1959, -1, sizeof(::ei::LeaderboardResponse)},
  { 1965, -1, -1, sizeof(::ei::ContractsArchive)},
  { 1972, 1997, -1, sizeof(::ei::ContractAction)},
  { 2016, 2026, -1, sizeof(::ei::UserDataInfoRequest)},
  { 2030, 2039, -1, sizeof(::ei::UserDataInfoResponse)},
  { 2042, 2052, -1, sizeof(::ei::ClearAllUserDataRequest)},
  { 2056, 2066, -1, sizeof(::ei::ServerGift)},
  { 2070, 2080, -1, sizeof(::ei::LiveConfig_BoostsConfig_ItemConfig)},
  { 2084, 2092, -1, sizeof(::ei::LiveConfig_BoostsConfig)},
  { 2094, 2106, -1, sizeof(::ei::LiveConfig_GiftConfig_GiftValueConfig)},
  { 2112, 2121, -1, sizeof(::ei::LiveConfig_GiftConfig_GiftMuConfig)},
  { 2124, 2146, -1, sizeof(::ei::LiveConfig_GiftConfig)},
  { 2162, 2181, -1, sizeof(::ei::LiveConfig_MiscConfig)},
  { 2194, 2204, -1, sizeof(::ei::LiveConfig)},
  { 2208, 2227, -1, sizeof(::ei::InGameMail)},
  { 2240, -1, -1, sizeof(::ei::MailDB)},
  { 2247, 2261, -1, sizeof(::ei::PeriodicalsResponse)},
  { 2269, 2289, -1, sizeof(::ei::GetPeriodicalsRequest)},
  { 2303, 2313, -1, sizeof(::ei::ConfigRequest)},
  { 2317, 2326, -1, sizeof(::ei::ConfigResponse)},
  { 2329, 2339, -1, sizeof(::ei::AdAttributionRawData)},
  { 2343, 2358, -1, sizeof(::ei::AdAttributionRow)},
  { 2367, 2391, -1, sizeof(::ei::AdAttributionInfo)},
  { 2409, 2418, -1, sizeof(::ei::ArtifactsClientInfo_LaunchCount)},
  { 2421, 2431, -1, sizeof(::ei::ArtifactsClientInfo)},
  { 2435, 2443, -1, sizeof(::ei::MissionInfo_Fuel)},
  { 2445, 2463, -1, sizeof(::ei::MissionInfo)},
  { 2475, 2485, -1, sizeof(::ei::ArtifactSpec)},
  { 2489, 2497, -1, sizeof(::ei::CompleteArtifact)},
  { 2499, 2509, -1, sizeof(::ei::ArtifactInventoryItem)},
  { 2513, 2521, -1, sizeof(::ei::InventorySlot)},
  { 2523, 2531, -1, sizeof(::ei::ArtifactsConfigurationRequest)},
  { 2533, 2547, -1, sizeof(::ei::ArtifactsConfigurationResponse_MissionParameters_Duration)},
  { 2555, 2565, -1, sizeof(::ei::ArtifactsConfigurationResponse_MissionParameters)},
  { 2569, 2584, -1, sizeof(::ei::ArtifactsConfigurationResponse_ArtifactParameters)},
  { 2593, 2601, -1, sizeof(::ei::ArtifactsConfigurationResponse_CraftingLevelInfo)},
  { 2603, -1, -1, sizeof(::ei::ArtifactsConfigurationResponse)},
  { 2612, 2623, -1, sizeof(::ei::MissionRequest)},
  { 2628, 2636, -1, sizeof(::ei::MissionResponse)},
  { 2638, 2646, -1, sizeof(::ei::CompleteMissionResponse_SecureArtifactSpec)},
  { 2648, 2659, -1, sizeof(::ei::CompleteMissionResponse)},
  { 2664, 2676, -1, sizeof(::ei::CollectContractArtifactRewardsRequest)},
  { 2682, 2696, -1, sizeof(::ei::CraftArtifactRequest)},
  { 2704, 2714, -1, sizeof(::ei::CraftArtifactResponse)},
  { 2718, 2732, -1, sizeof(::ei::ConsumeArtifactRequest)},
  { 2740, 2752, -1, sizeof(::ei::ConsumeArtifactResponse)},
  { 2758, 2769, -1, sizeof(::ei::AuthenticateArtifactResponse)},
  { 2774, 2784, -1, sizeof(::ei::SetArtifactRequest)},
  { 2788, 2797, -1, sizeof(::ei::SetArtifactResponse)},
  { 2800, 2808, -1, sizeof(::ei::ArtifactsDB_ActiveArtifactSlot)},
  { 2810, -1, -1, sizeof(::ei::ArtifactsDB_ActiveArtifactSet)},
  { 2817, 2829, -1, sizeof(::ei::ArtifactsDB_CraftableArtifact)},
  { 2835, 2852, -1, sizeof(::ei::ArtifactsDB)},
  { 2863, 2874, -1, sizeof(::ei::AuthenticatedMessage)},
  { 2879, 2887, -1, sizeof(::ei::LogCompleteMissionPayload)},
  { 2889, 2897, -1, sizeof(::ei::LogCraftArtifactPayload)},
  { 2899, 2907, -1, sizeof(::ei::LogConsumeArtifactPayload)},
  { 2909, 2917, -1, sizeof(::ei::LogSetArtifactPayload)},
  { 2919, 2927, -1, sizeof(::ei::AccountTransferPayload)},
  { 2929, 2939, -1, sizeof(::ei::SaveBackupResponse)},
  { 2943, 2951, -1, sizeof(::ei::CleanAccountRequest)},
  { 2953, 2960, -1, sizeof(::ei::ReturnEDTPayload)},
  { 2961, 2974, -1, sizeof(::ei::DLCItem)},
  { 2981, 2989, -1, sizeof(::ei::ShellSpec_ShellPiece)},
  { 2991, 3013, -1, sizeof(::ei::ShellSpec)},
  { 3029, 3041, -1, sizeof(::ei::ShellSetSpec_VariationSpec)},
  { 3047, 3073, -1, sizeof(::ei::ShellSetSpec)},
  { 3093, 3101, -1, sizeof(::ei::ShellObjectSpec_LODPiece)},
  { 3103, 3127, -1, sizeof(::ei::ShellObjectSpec)},
  { 3145, 3156, -1, sizeof(::ei::ShellGroupSpec)},
  { 3161, -1, -1, sizeof(::ei::DLCCatalog)},
  { 3173, 3181, -1, sizeof(::ei::ShellDB_ShellStatus)},
  { 3183, 3191, -1, sizeof(::ei::ShellDB_ShellElementStatus)},
  { 3193, 3201, -1, sizeof(::ei::ShellDB_ShellSetVariationStatus)},
  { 3203, 3214, -1, sizeof(::ei::ShellDB_FarmConfiguration)},
  { 3219, 3228, -1, sizeof(::ei::ShellDB_SavedFarmConfiguration)},
  { 3231, 3240, -1, sizeof(::ei::ShellDB_ShellConfiguration)},
  { 3243, 3254, -1, sizeof(::ei::ShellDB_ShellSetConfiguration)},
  { 3259, 3267, -1, sizeof(::ei::ShellDB_ShellGroupConfiguration)},
  { 3269, 3277, -1, sizeof(::ei::ShellDB_ChickenConfig)},
  { 3279, -1, -1, sizeof(::ei::ShellDB)},
  { 3294, 3312, -1, sizeof(::ei::ShellsActionLog)},
  { 3324, 3362, -1, sizeof(::ei::UserVerificationAnalysis)},
  { 3394, 3403, -1, sizeof(::ei::UserSubscriptionInfo_HistoryEntry)},
  { 3406, 3428, -1, sizeof(::ei::UserSubscriptionInfo)},
  { 3444, 3453, -1, sizeof(::ei::SubscriptionChangeHintRequest)},
  { 3456, 3464, -1, sizeof(::ei::CXPEvalRolloutInfo)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::ei::_Backup_Settings_default_instance_._instance,
  &::ei::_Backup_Tutorial_default_instance_._instance,
  &::ei::_Backup_Stats_default_instance_._instance,
  &::ei::_Backup_Game_default_instance_._instance,
  &::ei::_Backup_Artifacts_default_instance_._instance,
  &::ei::_Backup_Shells_default_instance_._instance,
  &::ei::_Backup_Simulation_default_instance_._instance,
  &::ei::_Backup_Mission_default_instance_._instance,
  &::ei::_Backup_Misc_default_instance_._instance,
  &::ei::_Backup_ResearchItem_default_instance_._instance,
  &::ei::_Backup_NewsHeadline_default_instance_._instance,
  &::ei::_Backup_AchievementInfo_default_instance_._instance,
  &::ei::_Backup_ActiveBoost_default_instance_._instance,
  &::ei::_Backup_OwnedBoost_default_instance_._instance,
  &::ei::_Backup_MissionInfo_default_instance_._instance,
  &::ei::_Backup_default_instance_._instance,
  &::ei::_EggIncFirstContactRequest_default_instance_._instance,
  &::ei::_EggIncFirstContactResponse_default_instance_._instance,
  &::ei::_EggIncAdConfig_default_instance_._instance,
  &::ei::_DailyGiftInfo_default_instance_._instance,
  &::ei::_SalesInfoRequest_default_instance_._instance,
  &::ei::_IAPSaleEntry_default_instance_._instance,
  &::ei::_SalesInfo_default_instance_._instance,
  &::ei::_EggIncEvent_default_instance_._instance,
  &::ei::_EggIncCurrentEvents_default_instance_._instance,
  &::ei::_DeviceInfo_default_instance_._instance,
  &::ei::_AppInfo_default_instance_._instance,
  &::ei::_ActionKeyValuePair_default_instance_._instance,
  &::ei::_GenericAction_default_instance_._instance,
  &::ei::_GenericActionBatchRequest_default_instance_._instance,
  &::ei::_VerifyPurchaseRequest_default_instance_._instance,
  &::ei::_VerifyPurchaseResponse_default_instance_._instance,
  &::ei::_CurrencyFlowLog_default_instance_._instance,
  &::ei::_CurrencyFlowBatchRequest_default_instance_._instance,
  &::ei::_Reward_default_instance_._instance,
  &::ei::_GameModifier_default_instance_._instance,
  &::ei::_Contract_Goal_default_instance_._instance,
  &::ei::_Contract_GoalSet_default_instance_._instance,
  &::ei::_Contract_GradeSpec_default_instance_._instance,
  &::ei::_Contract_default_instance_._instance,
  &::ei::_ContractPlayerInfo_default_instance_._instance,
  &::ei::_ContractEvaluation_default_instance_._instance,
  &::ei::_ContractCitation_default_instance_._instance,
  &::ei::_ContractEvaluationBatch_Pair_default_instance_._instance,
  &::ei::_ContractEvaluationBatch_default_instance_._instance,
  &::ei::_CoopCompletionSnapshot_ContributorSnapshot_default_instance_._instance,
  &::ei::_CoopCompletionSnapshot_default_instance_._instance,
  &::ei::_BasicRequestInfo_default_instance_._instance,
  &::ei::_ContractSimConfig_ContractGradeSimConfig_GoalParams_default_instance_._instance,
  &::ei::_ContractSimConfig_ContractGradeSimConfig_default_instance_._instance,
  &::ei::_ContractSimConfig_default_instance_._instance,
  &::ei::_ContractSimPoll_default_instance_._instance,
  &::ei::_ContractSimPollResponse_default_instance_._instance,
  &::ei::_ContractSimResultUpdate_GoalInfo_default_instance_._instance,
  &::ei::_ContractSimResultUpdate_default_instance_._instance,
  &::ei::_ContractsRequest_default_instance_._instance,
  &::ei::_ContractsResponse_default_instance_._instance,
  &::ei::_ContractCoopStatusRequest_default_instance_._instance,
  &::ei::_FarmProductionParams_default_instance_._instance,
  &::ei::_PlayerFarmInfo_default_instance_._instance,
  &::ei::_ContractCoopStatusResponse_ContributionInfo_default_instance_._instance,
  &::ei::_ContractCoopStatusResponse_CoopGift_default_instance_._instance,
  &::ei::_ContractCoopStatusResponse_ChickenRun_default_instance_._instance,
  &::ei::_ContractCoopStatusResponse_default_instance_._instance,
  &::ei::_LocalContract_default_instance_._instance,
  &::ei::_MyContracts_default_instance_._instance,
  &::ei::_QueryCoopRequest_default_instance_._instance,
  &::ei::_QueryCoopResponse_default_instance_._instance,
  &::ei::_CreateCoopRequest_default_instance_._instance,
  &::ei::_CreateCoopResponse_default_instance_._instance,
  &::ei::_JoinCoopRequest_default_instance_._instance,
  &::ei::_JoinCoopResponse_default_instance_._instance,
  &::ei::_AutoJoinCoopRequest_default_instance_._instance,
  &::ei::_UpdateCoopPermissionsRequest_default_instance_._instance,
  &::ei::_UpdateCoopPermissionsResponse_default_instance_._instance,
  &::ei::_LeaveCoopRequest_default_instance_._instance,
  &::ei::_GiftPlayerCoopRequest_default_instance_._instance,
  &::ei::_SendChickenRunCoopRequest_default_instance_._instance,
  &::ei::_ReportPlayerCoopRequest_default_instance_._instance,
  &::ei::_KickPlayerCoopRequest_default_instance_._instance,
  &::ei::_ContractCoopStatusUpdateRequest_default_instance_._instance,
  &::ei::_ContractCoopStatusUpdateResponse_default_instance_._instance,
  &::ei::_CoopBuffState_default_instance_._instance,
  &::ei::_CoopBuffHistory_default_instance_._instance,
  &::ei::_CoopChickenRunEntry_default_instance_._instance,
  &::ei::_CoopLastChickenRunTimes_default_instance_._instance,
  &::ei::_LeaderboardAnalysis_Chunk_default_instance_._instance,
  &::ei::_LeaderboardAnalysis_default_instance_._instance,
  &::ei::_LeaderboardInfo_Season_default_instance_._instance,
  &::ei::_LeaderboardInfo_default_instance_._instance,
  &::ei::_LeaderboardRequest_default_instance_._instance,
  &::ei::_LeaderboardResponse_Entry_default_instance_._instance,
  &::ei::_LeaderboardResponse_default_instance_._instance,
  &::ei::_ContractsArchive_default_instance_._instance,
  &::ei::_ContractAction_default_instance_._instance,
  &::ei::_UserDataInfoRequest_default_instance_._instance,
  &::ei::_UserDataInfoResponse_default_instance_._instance,
  &::ei::_ClearAllUserDataRequest_default_instance_._instance,
  &::ei::_ServerGift_default_instance_._instance,
  &::ei::_LiveConfig_BoostsConfig_ItemConfig_default_instance_._instance,
  &::ei::_LiveConfig_BoostsConfig_default_instance_._instance,
  &::ei::_LiveConfig_GiftConfig_GiftValueConfig_default_instance_._instance,
  &::ei::_LiveConfig_GiftConfig_GiftMuConfig_default_instance_._instance,
  &::ei::_LiveConfig_GiftConfig_default_instance_._instance,
  &::ei::_LiveConfig_MiscConfig_default_instance_._instance,
  &::ei::_LiveConfig_default_instance_._instance,
  &::ei::_InGameMail_default_instance_._instance,
  &::ei::_MailDB_default_instance_._instance,
  &::ei::_PeriodicalsResponse_default_instance_._instance,
  &::ei::_GetPeriodicalsRequest_default_instance_._instance,
  &::ei::_ConfigRequest_default_instance_._instance,
  &::ei::_ConfigResponse_default_instance_._instance,
  &::ei::_AdAttributionRawData_default_instance_._instance,
  &::ei::_AdAttributionRow_default_instance_._instance,
  &::ei::_AdAttributionInfo_default_instance_._instance,
  &::ei::_ArtifactsClientInfo_LaunchCount_default_instance_._instance,
  &::ei::_ArtifactsClientInfo_default_instance_._instance,
  &::ei::_MissionInfo_Fuel_default_instance_._instance,
  &::ei::_MissionInfo_default_instance_._instance,
  &::ei::_ArtifactSpec_default_instance_._instance,
  &::ei::_CompleteArtifact_default_instance_._instance,
  &::ei::_ArtifactInventoryItem_default_instance_._instance,
  &::ei::_InventorySlot_default_instance_._instance,
  &::ei::_ArtifactsConfigurationRequest_default_instance_._instance,
  &::ei::_ArtifactsConfigurationResponse_MissionParameters_Duration_default_instance_._instance,
  &::ei::_ArtifactsConfigurationResponse_MissionParameters_default_instance_._instance,
  &::ei::_ArtifactsConfigurationResponse_ArtifactParameters_default_instance_._instance,
  &::ei::_ArtifactsConfigurationResponse_CraftingLevelInfo_default_instance_._instance,
  &::ei::_ArtifactsConfigurationResponse_default_instance_._instance,
  &::ei::_MissionRequest_default_instance_._instance,
  &::ei::_MissionResponse_default_instance_._instance,
  &::ei::_CompleteMissionResponse_SecureArtifactSpec_default_instance_._instance,
  &::ei::_CompleteMissionResponse_default_instance_._instance,
  &::ei::_CollectContractArtifactRewardsRequest_default_instance_._instance,
  &::ei::_CraftArtifactRequest_default_instance_._instance,
  &::ei::_CraftArtifactResponse_default_instance_._instance,
  &::ei::_ConsumeArtifactRequest_default_instance_._instance,
  &::ei::_ConsumeArtifactResponse_default_instance_._instance,
  &::ei::_AuthenticateArtifactResponse_default_instance_._instance,
  &::ei::_SetArtifactRequest_default_instance_._instance,
  &::ei::_SetArtifactResponse_default_instance_._instance,
  &::ei::_ArtifactsDB_ActiveArtifactSlot_default_instance_._instance,
  &::ei::_ArtifactsDB_ActiveArtifactSet_default_instance_._instance,
  &::ei::_ArtifactsDB_CraftableArtifact_default_instance_._instance,
  &::ei::_ArtifactsDB_default_instance_._instance,
  &::ei::_AuthenticatedMessage_default_instance_._instance,
  &::ei::_LogCompleteMissionPayload_default_instance_._instance,
  &::ei::_LogCraftArtifactPayload_default_instance_._instance,
  &::ei::_LogConsumeArtifactPayload_default_instance_._instance,
  &::ei::_LogSetArtifactPayload_default_instance_._instance,
  &::ei::_AccountTransferPayload_default_instance_._instance,
  &::ei::_SaveBackupResponse_default_instance_._instance,
  &::ei::_CleanAccountRequest_default_instance_._instance,
  &::ei::_ReturnEDTPayload_default_instance_._instance,
  &::ei::_DLCItem_default_instance_._instance,
  &::ei::_ShellSpec_ShellPiece_default_instance_._instance,
  &::ei::_ShellSpec_default_instance_._instance,
  &::ei::_ShellSetSpec_VariationSpec_default_instance_._instance,
  &::ei::_ShellSetSpec_default_instance_._instance,
  &::ei::_ShellObjectSpec_LODPiece_default_instance_._instance,
  &::ei::_ShellObjectSpec_default_instance_._instance,
  &::ei::_ShellGroupSpec_default_instance_._instance,
  &::ei::_DLCCatalog_default_instance_._instance,
  &::ei::_ShellDB_ShellStatus_default_instance_._instance,
  &::ei::_ShellDB_ShellElementStatus_default_instance_._instance,
  &::ei::_ShellDB_ShellSetVariationStatus_default_instance_._instance,
  &::ei::_ShellDB_FarmConfiguration_default_instance_._instance,
  &::ei::_ShellDB_SavedFarmConfiguration_default_instance_._instance,
  &::ei::_ShellDB_ShellConfiguration_default_instance_._instance,
  &::ei::_ShellDB_ShellSetConfiguration_default_instance_._instance,
  &::ei::_ShellDB_ShellGroupConfiguration_default_instance_._instance,
  &::ei::_ShellDB_ChickenConfig_default_instance_._instance,
  &::ei::_ShellDB_default_instance_._instance,
  &::ei::_ShellsActionLog_default_instance_._instance,
  &::ei::_UserVerificationAnalysis_default_instance_._instance,
  &::ei::_UserSubscriptionInfo_HistoryEntry_default_instance_._instance,
  &::ei::_UserSubscriptionInfo_default_instance_._instance,
  &::ei::_SubscriptionChangeHintRequest_default_instance_._instance,
  &::ei::_CXPEvalRolloutInfo_default_instance_._instance,
};

const char descriptor_table_protodef_ei_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\010ei.proto\022\002ei\"\266/\n\006Backup\022\017\n\007user_id\030\001 \001"
  "(\t\022\022\n\nei_user_id\030\022 \001(\t\022\030\n\020game_services_"
  "id\030\020 \001(\t\022\021\n\tdevice_id\030\021 \001(\t\022\021\n\tuser_name"
  "\030\002 \001(\t\022\023\n\013approx_time\030\003 \001(\001\022\022\n\007version\030\025"
  " \001(\r:\0010\022\032\n\022force_offer_backup\030\024 \001(\010\022\024\n\014f"
  "orce_backup\030\026 \001(\010\022%\n\010settings\030\004 \001(\0132\023.ei"
  ".Backup.Settings\022%\n\010tutorial\030\005 \001(\0132\023.ei."
  "Backup.Tutorial\022\037\n\005stats\030\006 \001(\0132\020.ei.Back"
  "up.Stats\022\035\n\004game\030\007 \001(\0132\017.ei.Backup.Game\022"
  "\'\n\tartifacts\030\016 \001(\0132\024.ei.Backup.Artifacts"
  "\022!\n\006shells\030\031 \001(\0132\021.ei.Backup.Shells\022\"\n\003s"
  "im\030\010 \001(\0132\025.ei.Backup.Simulation\022$\n\005farms"
  "\030\014 \003(\0132\025.ei.Backup.Simulation\022#\n\007mission"
  "\030\t \001(\0132\022.ei.Backup.Mission\022\035\n\004misc\030\n \001(\013"
  "2\017.ei.Backup.Misc\022\"\n\tcontracts\030\r \001(\0132\017.e"
  "i.MyContracts\022%\n\014artifacts_db\030\017 \001(\0132\017.ei"
  ".ArtifactsDB\022\035\n\010shell_db\030\030 \001(\0132\013.ei.Shel"
  "lDB\022\025\n\rread_mail_ids\030\027 \003(\t\022\020\n\010checksum\030d"
  " \001(\004\022\021\n\tsignature\030e \001(\t\032\340\005\n\010Settings\022\013\n\003"
  "sfx\030\001 \001(\010\022\r\n\005music\030\002 \001(\010\022\030\n\020low_battery_"
  "mode\030\003 \001(\010\022\034\n\024low_performance_mode\030\004 \001(\010"
  "\022\037\n\027force_touch_chicken_btn\030\t \001(\010\022\035\n\025not"
  "ifications_queried\030\005 \001(\010\022\030\n\020notification"
  "s_on\030\006 \001(\010\022\031\n\021notify_daily_gift\030\013 \001(\010\022\025\n"
  "\rcoppa_queried\030\007 \001(\010\022\030\n\020coppa_restricted"
  "\030\010 \001(\010\022\034\n\024gdpr_consent_queried\030\014 \001(\010\022\033\n\023"
  "gdpr_age_restricted\030\020 \001(\010\022\032\n\022gdpr_consen"
  "t_given\030\r \001(\010\022\023\n\013age_queried\030\022 \001(\010\022\035\n\016ag"
  "e_restricted\030\023 \001(\010:\005false\022\'\n\037data_collec"
  "tion_consent_queried\030\024 \001(\010\022%\n\035data_colle"
  "ction_consent_given\030\025 \001(\010\022\034\n\024last_day_ag"
  "e_queried\030\021 \001(\r\022\036\n\020user_ads_enabled\030\016 \001("
  "\010:\004true\022 \n\022user_cloud_enabled\030\017 \001(\010:\004tru"
  "e\022$\n\026user_analytics_enabled\030\026 \001(\010:\004true\022"
  "+\n\035user_personalized_ads_enabled\030\027 \001(\010:\004"
  "true\022\027\n\017low_performance\030\n \001(\010\022\031\n\021auto_st"
  "op_fueling\030\031 \001(\010\022\030\n\020last_backup_time\030\030 \001"
  "(\001\032\240\002\n\010Tutorial\022\023\n\013intro_shown\030\001 \001(\010\022\034\n\024"
  "click_tutorial_shown\030\002 \001(\010\022\025\n\rbuy_hab_sh"
  "own\030\003 \001(\010\022\032\n\022hire_vehicle_shown\030\004 \001(\010\022\023\n"
  "\013q_num_shown\030\005 \001(\010\022\023\n\013s_num_shown\030\006 \001(\010\022"
  "\033\n\023contracts_tab_shown\030\007 \001(\010\022\033\n\023contract"
  "_info_shown\030\010 \001(\010\022\027\n\017join_coop_shown\030\t \001"
  "(\010\022\031\n\021switch_farm_shown\030\n \001(\010\022\026\n\016tutoria"
  "l_shown\030\013 \003(\010\032\335\003\n\005Stats\022\026\n\016egg_totals_OL"
  "D\030\001 \003(\004\022\022\n\negg_totals\030\010 \003(\001\022\037\n\027unlimited"
  "_chickens_uses\030\007 \001(\004\022\023\n\013refill_uses\030\002 \001("
  "\004\022\023\n\013warp_1_uses\030\004 \001(\004\022\023\n\013warp_8_uses\030\005 "
  "\001(\004\022\023\n\013boosts_used\030\r \001(\004\022\032\n\022video_double"
  "r_uses\030\003 \001(\004\022\027\n\017drone_takedowns\030\006 \001(\004\022\035\n"
  "\025drone_takedowns_elite\030\n \001(\004\022\025\n\rnum_pres"
  "tiges\030\t \001(\004\022\030\n\020num_piggy_breaks\030\013 \001(\004\022\033\n"
  "\023iap_packs_purchased\030\014 \001(\004\022\022\n\npiggy_full"
  "\030\016 \001(\010\022\030\n\020piggy_found_full\030\017 \001(\010\022\"\n\032time"
  "_piggy_filled_realtime\030\020 \001(\001\022 \n\030time_pig"
  "gy_full_gametime\030\021 \001(\001\022\035\n\025lost_piggy_inc"
  "rements\030\022 \001(\004\032\321\t\n\004Game\022\027\n\014current_farm\030\026"
  " \001(\r:\0010\022 \n\017max_egg_reached\030\001 \001(\0162\007.ei.Eg"
  "g\022\032\n\022golden_eggs_earned\030\002 \001(\004\022\031\n\021golden_"
  "eggs_spent\030\003 \001(\004\022\035\n\025uncliamed_golden_egg"
  "s\030\020 \001(\004\022\021\n\tsoul_eggs\030\004 \001(\004\022\033\n\023unclaimed_"
  "soul_eggs\030\021 \001(\004\022\023\n\013soul_eggs_d\030\" \001(\001\022\035\n\025"
  "unclaimed_soul_eggs_d\030# \001(\001\022\030\n\020eggs_of_p"
  "rophecy\030\027 \001(\004\022\"\n\032unclaimed_eggs_of_proph"
  "ecy\030\030 \001(\004\022\034\n\024shell_scripts_earned\030& \001(\004\022"
  "\033\n\023shell_scripts_spent\030\' \001(\004\022\037\n\027unclaime"
  "d_shell_scripts\030( \001(\004\022\034\n\024prestige_cash_e"
  "arned\030\005 \001(\001\022 \n\030prestige_soul_boost_cash\030"
  "! \001(\001\022\034\n\024lifetime_cash_earned\030\006 \001(\001\022\022\n\np"
  "iggy_bank\030\007 \001(\004\022\036\n\026piggy_full_alert_show"
  "n\030\037 \001(\010\022\024\n\014permit_level\030\010 \001(\r\022.\n\repic_re"
  "search\030\t \003(\0132\027.ei.Backup.ResearchItem\022\031\n"
  "\021hyperloop_station\030\035 \001(\010\022\034\n\024next_daily_g"
  "ift_time\030\n \001(\001\022%\n\035last_daily_gift_collec"
  "ted_day\030\024 \001(\r\022!\n\031num_daily_gifts_collect"
  "ed\030\034 \001(\r\022%\n\004news\030\013 \003(\0132\027.ei.Backup.NewsH"
  "eadline\022\026\n\016last_news_time\030\014 \001(\001\022\032\n\022curre"
  "nt_multiplier\030\r \001(\001\022%\n\035current_multiplie"
  "r_expiration\030\016 \001(\001\0220\n\014achievements\030\017 \003(\013"
  "2\032.ei.Backup.AchievementInfo\022\035\n\025max_farm"
  "_size_reached\030\022 \003(\004\022\027\n\017egg_medal_level\030\023"
  " \003(\r\022\"\n\032long_idle_notification_set\030\031 \001(\010"
  "\022(\n long_idle_notification_threshold\030\032 \001"
  "(\001\022\030\n\020long_idle_reward\030\033 \001(\001\022%\n\006boosts\030\036"
  " \003(\0132\025.ei.Backup.OwnedBoost\022\"\n\032total_tim"
  "e_cheats_detected\030  \001(\r\022\035\n\025force_elite_c"
  "ontracts\030$ \001(\010\022!\n\031new_player_event_end_t"
  "ime\030% \001(\001\032\235\004\n\tArtifacts\022\020\n\010infusing\030\001 \001("
  "\010\0225\n\022item_being_infused\030\002 \001(\0132\031.ei.Artif"
  "actInventoryItem\022,\n\022spec_being_infused\030\r"
  " \001(\0132\020.ei.ArtifactSpec\022\"\n\021egg_type_infus"
  "ing\030\003 \001(\0162\007.ei.Egg\022\036\n\026infusing_eggs_requ"
  "ired\030\004 \001(\001\022\024\n\014eggs_infused\030\005 \001(\001\022&\n\031flow"
  "_percentage_artifacts\030\006 \001(\001:\0030.5\022\035\n\017fuel"
  "ing_enabled\030\007 \001(\010:\004true\022\034\n\024tank_filling_"
  "enabled\030\016 \001(\010\022\022\n\ntank_level\030\017 \001(\r\022\022\n\ntan"
  "k_fuels\030\020 \003(\001\0223\n\020last_fueled_ship\030\t \001(\0162"
  "\031.ei.MissionInfo.Spaceship\022\027\n\017inventory_"
  "score\030\n \001(\001\022\023\n\013crafting_xp\030\021 \001(\001\022\017\n\007enab"
  "led\030\013 \001(\010\022\023\n\013intro_shown\030\014 \001(\010\022)\n\033infusi"
  "ng_enabled_DEPRECATED\030\010 \001(\010:\004true\032M\n\006She"
  "lls\022\023\n\013intro_alert\030\001 \001(\010\022\035\n\025contracts_in"
  "tro_alert\030\002 \001(\010\022\017\n\007num_new\030\003 \003(\005\032\343\006\n\nSim"
  "ulation\022\031\n\010egg_type\030\001 \001(\0162\007.ei.Egg\022\037\n\tfa"
  "rm_type\030\023 \001(\0162\014.ei.FarmType\022\023\n\013contract_"
  "id\030\024 \001(\t\022\023\n\013cash_earned\030\002 \001(\001\022\022\n\ncash_sp"
  "ent\030\003 \001(\001\022\026\n\016unclaimed_cash\030\004 \001(\001\022\026\n\016las"
  "t_step_time\030\005 \001(\001\022\024\n\014num_chickens\030\006 \001(\004\022"
  "\036\n\026num_chickens_unsettled\030\007 \001(\004\022\034\n\024num_c"
  "hickens_running\030\010 \001(\004\022\021\n\teggs_laid\030\t \001(\001"
  "\022\024\n\014eggs_shipped\030\036 \001(\001\022\025\n\reggs_paid_for\030"
  "\n \001(\001\022\023\n\013silos_owned\030\013 \001(\r\022\014\n\004habs\030\014 \003(\r"
  "\022\026\n\016hab_population\030\r \003(\004\022\036\n\026hab_populati"
  "on_indound\030\016 \003(\004\022!\n\031hab_incubator_popupl"
  "ation\030\017 \003(\001\022\033\n\023hatchery_population\030\020 \001(\001"
  "\022\020\n\010vehicles\030\021 \003(\r\022\024\n\014train_length\030\025 \003(\r"
  "\0220\n\017common_research\030\022 \003(\0132\027.ei.Backup.Re"
  "searchItem\022-\n\ractive_boosts\030\026 \003(\0132\026.ei.B"
  "ackup.ActiveBoost\022\034\n\024last_cash_boost_tim"
  "e\030\037 \001(\001\022\034\n\024time_cheats_detected\030\027 \001(\r\022\027\n"
  "\017time_cheat_debt\030\030 \001(\001\022\035\n\025boost_tokens_r"
  "eceived\030\031 \001(\r\022\032\n\022boost_tokens_spent\030\032 \001("
  "\r\022\032\n\022boost_tokens_given\030\034 \001(\r\022\036\n\026unclaim"
  "ed_boost_tokens\030\033 \001(\r\022\'\n\037gametime_until_"
  "next_boost_token\030\035 \001(\001\032\177\n\007Mission\022\027\n\017cur"
  "rent_mission\030\001 \001(\t\022\027\n\017reference_value\030\002 "
  "\001(\001\022\030\n\020current_missions\030\004 \003(\t\022(\n\010mission"
  "s\030\003 \003(\0132\026.ei.Backup.MissionInfo\032\377\004\n\004Misc"
  "\022\034\n\024chicken_btn_pref_big\030\001 \001(\010\022\"\n\032free_h"
  "atchery_refill_given\030\002 \001(\010\022\'\n\025last_share"
  "_farm_value\030\003 \001(\001:\01010000000\022-\n\033last_shar"
  "e_swarm_farm_value\030\004 \001(\001:\01010000000\022\"\n\025la"
  "st_share_swarm_size\030\005 \001(\001:\003140\0224\n(last_p"
  "restige_alert_soul_eggs_DEPRECATED\030\n \001(\004"
  ":\00245\022\023\n\013friend_rank\030\006 \001(\004\022\027\n\017friend_rank"
  "_pop\030\007 \001(\004\022\023\n\013global_rank\030\010 \001(\004\022\027\n\017globa"
  "l_rank_pop\030\t \001(\004\022\030\n\020challenges_alert\030\024 \001"
  "(\010\022\024\n\014trophy_alert\030\013 \001(\010\022\020\n\010ar_alert\030\014 \001"
  "(\010\022\027\n\017contracts_alert\030\r \001(\010\022\032\n\022contracts"
  "_alert_v2\030\025 \001(\010\022\022\n\ncoop_alert\030\016 \001(\010\022\025\n\rc"
  "oop_alert_v2\030\026 \001(\010\022\024\n\014switch_alert\030\017 \001(\010"
  "\022\035\n\025egg_of_prophecy_alert\030\020 \001(\010\022\031\n\021boost"
  "_token_alert\030\021 \001(\010\022\026\n\016soul_egg_alert\030\022 \001"
  "(\010\022\035\n\025backup_reminder_alert\030\023 \001(\010\032)\n\014Res"
  "earchItem\022\n\n\002id\030\001 \001(\t\022\r\n\005level\030\002 \001(\r\032(\n\014"
  "NewsHeadline\022\n\n\002id\030\001 \001(\t\022\014\n\004read\030\002 \001(\010\032/"
  "\n\017AchievementInfo\022\n\n\002id\030\001 \001(\t\022\020\n\010achieve"
  "d\030\002 \001(\010\032P\n\013ActiveBoost\022\020\n\010boost_id\030\001 \001(\t"
  "\022\026\n\016time_remaining\030\002 \001(\001\022\027\n\017reference_va"
  "lue\030\003 \001(\001\032-\n\nOwnedBoost\022\020\n\010boost_id\030\001 \001("
  "\t\022\r\n\005count\030\002 \001(\r\032E\n\013MissionInfo\022\n\n\002id\030\001 "
  "\001(\t\022\021\n\tcompleted\030\002 \001(\010\022\027\n\017reference_valu"
  "e\030\003 \001(\001\"\334\001\n\031EggIncFirstContactRequest\022#\n"
  "\005rinfo\030\010 \001(\0132\024.ei.BasicRequestInfo\022\022\n\nei"
  "_user_id\030\004 \001(\t\022\017\n\007user_id\030\001 \001(\t\022\030\n\020game_"
  "services_id\030\007 \001(\t\022\021\n\tdevice_id\030\005 \001(\t\022\020\n\010"
  "username\030\006 \001(\t\022\026\n\016client_version\030\002 \001(\r\022\036"
  "\n\010platform\030\003 \001(\0162\014.ei.Platform\"\366\001\n\032EggIn"
  "cFirstContactResponse\022\022\n\nei_user_id\030\002 \001("
  "\t\022\027\n\017ids_transferred\030\003 \003(\t\022\025\n\nerror_code"
  "\030\004 \001(\r:\0010\022\025\n\rerror_message\030\005 \001(\t\022\032\n\006back"
  "up\030\001 \001(\0132\n.ei.Backup\"a\n\nErrorCodes\022\014\n\010NO"
  "_ERROR\020\000\022\034\n\030EXISTING_USER_W_GAMER_ID\020\001\022\022"
  "\n\016USER_NOT_FOUND\020\002\022\023\n\017BACKUP_CONFLICT\020\003\""
  "9\n\016EggIncAdConfig\022\'\n\020network_priority\030\001 "
  "\003(\0162\r.ei.AdNetwork\"A\n\rDailyGiftInfo\022\023\n\013c"
  "urrent_day\030\001 \001(\r\022\033\n\023seconds_to_next_day\030"
  "\002 \001(\001\"\310\001\n\020SalesInfoRequest\022\017\n\007user_id\030\001 "
  "\001(\t\022\022\n\npiggy_full\030\002 \001(\010\022\030\n\020piggy_found_f"
  "ull\030\003 \001(\010\022\035\n\025seconds_full_realtime\030\004 \001(\001"
  "\022\035\n\025seconds_full_gametime\030\005 \001(\001\022\027\n\017lost_"
  "increments\030\007 \001(\r\022\036\n\026current_client_versi"
  "on\030\n \001(\r\"g\n\014IAPSaleEntry\022\022\n\nproduct_id\030\001"
  " \001(\t\022\031\n\021seconds_remaining\030\002 \001(\001\022\027\n\017disco"
  "unt_string\030\003 \001(\t\022\017\n\007sale_id\030\004 \001(\t\",\n\tSal"
  "esInfo\022\037\n\005sales\030\001 \003(\0132\020.ei.IAPSaleEntry\""
  "\247\001\n\013EggIncEvent\022\022\n\nidentifier\030\001 \001(\t\022\031\n\021s"
  "econds_remaining\030\002 \001(\001\022\014\n\004type\030\003 \001(\t\022\022\n\n"
  "multiplier\030\004 \001(\001\022\020\n\010subtitle\030\005 \001(\t\022\022\n\nst"
  "art_time\030\006 \001(\001\022\020\n\010duration\030\007 \001(\001\022\017\n\007cc_o"
  "nly\030\010 \001(\010\"6\n\023EggIncCurrentEvents\022\037\n\006even"
  "ts\030\001 \003(\0132\017.ei.EggIncEvent\"\251\002\n\nDeviceInfo"
  "\022\021\n\tdevice_id\030\001 \001(\t\022\026\n\016advertising_id\030\r "
  "\001(\t\022\020\n\010platform\030\002 \001(\t\022\023\n\013form_factor\030\003 \001"
  "(\t\022\023\n\013device_name\030\004 \001(\t\022\030\n\020platform_vers"
  "ion\030\005 \001(\t\022\026\n\016locale_country\030\006 \001(\t\022\027\n\017loc"
  "ale_language\030\007 \001(\t\022\022\n\ngpu_vendor\030\010 \001(\t\022\021"
  "\n\tgpu_model\030\t \001(\t\022\025\n\rdevice_bucket\030\n \001(\t"
  "\022\024\n\014screen_width\030\013 \001(\r\022\025\n\rscreen_height\030"
  "\014 \001(\r\"\325\005\n\007AppInfo\022\023\n\013version_str\030\001 \001(\t\022\020"
  "\n\010sessions\030\002 \001(\r\022\025\n\rnum_prestiges\030\003 \001(\r\022"
  "\021\n\tsoul_eggs\030\004 \001(\004\022\023\n\013current_egg\030\005 \001(\r\022"
  "\023\n\013gold_earned\030\006 \001(\004\022\022\n\ngold_spent\030\007 \001(\004"
  "\022\027\n\017current_mission\030\010 \001(\r\022\022\n\npiggy_size\030"
  "\t \001(\r\022\030\n\020num_piggy_breaks\030\n \001(\004\022\035\n\025verif"
  "ied_piggy_breaks\030\035 \001(\004\022\033\n\023iap_packs_purc"
  "hased\030\013 \001(\004\022\024\n\014permit_level\030\014 \001(\r\022\032\n\022vid"
  "eo_doubler_uses\030\017 \001(\004\022\027\n\017drone_takedowns"
  "\030\022 \001(\004\022\035\n\025drone_takedowns_elite\030\023 \001(\004\022\031\n"
  "\021trophies_unlocked\030\024 \001(\010\022\021\n\tegg_level\030\025 "
  "\001(\002\022\027\n\017struggle_factor\030\026 \001(\002\022\022\n\npiggy_fu"
  "ll\030\027 \001(\010\022\030\n\020piggy_found_full\030\030 \001(\010\022 \n\030ti"
  "me_piggy_full_realtime\030\031 \001(\001\022 \n\030time_pig"
  "gy_full_gametime\030\032 \001(\001\022\035\n\025lost_piggy_inc"
  "rements\030\033 \001(\004\022\017\n\007sale_id\030\034 \001(\t\022\037\n\027unlimi"
  "ted_chickens_uses\030\r \001(\004\022\023\n\013refill_uses\030\016"
  " \001(\004\022\027\n\017short_warp_uses\030\020 \001(\004\022\026\n\016long_wa"
  "rp_uses\030\021 \001(\004\"0\n\022ActionKeyValuePair\022\013\n\003k"
  "ey\030\001 \002(\t\022\r\n\005value\030\002 \002(\t\"\333\001\n\rGenericActio"
  "n\022\017\n\007user_id\030\001 \001(\t\022\026\n\016advertising_id\030\007 \001"
  "(\t\022\027\n\017approx_time_DEP\030\002 \001(\002\022\023\n\013approx_ti"
  "me\030\010 \001(\001\022\023\n\013action_name\030\003 \001(\t\022$\n\004data\030\004 "
  "\003(\0132\026.ei.ActionKeyValuePair\022\030\n\003app\030\005 \001(\013"
  "2\013.ei.AppInfo\022\036\n\006device\030\006 \001(\0132\016.ei.Devic"
  "eInfo\"d\n\031GenericActionBatchRequest\022#\n\005ri"
  "nfo\030\001 \001(\0132\024.ei.BasicRequestInfo\022\"\n\007actio"
  "ns\030\002 \003(\0132\021.ei.GenericAction\"\326\001\n\025VerifyPu"
  "rchaseRequest\022#\n\005rinfo\030\006 \001(\0132\024.ei.BasicR"
  "equestInfo\022\013\n\003sku\030\001 \001(\t\022\026\n\016transaction_i"
  "d\030\002 \001(\t\022\037\n\027original_transaction_id\030\010 \001(\t"
  "\022\017\n\007receipt\030\003 \001(\t\022\020\n\010platform\030\004 \001(\t\022\017\n\007s"
  "andbox\030\007 \001(\010\022\036\n\003log\030\005 \001(\0132\021.ei.GenericAc"
  "tion\";\n\026VerifyPurchaseResponse\022\020\n\010verifi"
  "ed\030\001 \001(\010\022\017\n\007message\030\002 \001(\t\"\334\001\n\017CurrencyFl"
  "owLog\022\017\n\007user_id\030\001 \001(\t\022\023\n\013approx_time\030\002 "
  "\001(\001\022 \n\010currency\030\003 \001(\0162\016.ei.RewardType\022\016\n"
  "\006amount\030\004 \001(\003\022\020\n\010location\030\005 \001(\t\022\017\n\007versi"
  "on\030\006 \001(\t\022\020\n\010platform\030\007 \001(\t\022\021\n\tsoul_eggs\030"
  "\010 \001(\001\022\025\n\rtickets_spent\030\t \001(\004\022\022\n\ngold_spe"
  "nt\030\n \001(\004\"b\n\030CurrencyFlowBatchRequest\022#\n\005"
  "rinfo\030\002 \001(\0132\024.ei.BasicRequestInfo\022!\n\004log"
  "s\030\001 \003(\0132\023.ei.CurrencyFlowLog\"]\n\006Reward\022#"
  "\n\013reward_type\030\001 \001(\0162\016.ei.RewardType\022\027\n\017r"
  "eward_sub_type\030\002 \001(\t\022\025\n\rreward_amount\030\003 "
  "\001(\001\"\245\002\n\014GameModifier\0221\n\tdimension\030\001 \001(\0162"
  "\036.ei.GameModifier.GameDimension\022\r\n\005value"
  "\030\002 \001(\001\022\023\n\013description\030\003 \001(\t\"\275\001\n\rGameDime"
  "nsion\022\014\n\010EARNINGS\020\001\022\021\n\rAWAY_EARNINGS\020\002\022\032"
  "\n\026INTERNAL_HATCHERY_RATE\020\003\022\023\n\017EGG_LAYING"
  "_RATE\020\004\022\025\n\021SHIPPING_CAPACITY\020\005\022\020\n\014HAB_CA"
  "PACITY\020\006\022\020\n\014VEHICLE_COST\020\007\022\014\n\010HAB_COST\020\010"
  "\022\021\n\rRESEARCH_COST\020\t\"\365\007\n\010Contract\022\022\n\niden"
  "tifier\030\001 \001(\t\022\014\n\004name\030\t \001(\t\022\023\n\013descriptio"
  "n\030\n \001(\t\022\024\n\003egg\030\002 \001(\0162\007.ei.Egg\022 \n\005goals\030\003"
  " \003(\0132\021.ei.Contract.Goal\022\'\n\tgoal_sets\030\020 \003"
  "(\0132\024.ei.Contract.GoalSet\022+\n\013grade_specs\030"
  "\024 \003(\0132\026.ei.Contract.GradeSpec\022\021\n\tseason_"
  "id\030\027 \001(\t\022\024\n\014coop_allowed\030\004 \001(\010\022\025\n\rmax_co"
  "op_size\030\005 \001(\r\022\022\n\nmax_boosts\030\014 \001(\r\022\035\n\021min"
  "utes_per_token\030\017 \001(\001:\00260\022)\n\034chicken_run_"
  "cooldown_minutes\030\022 \001(\001:\003180\022\022\n\nstart_tim"
  "e\030\021 \001(\001\022\027\n\017expiration_time\030\006 \001(\001\022\026\n\016leng"
  "th_seconds\030\007 \001(\001\022\025\n\rmax_soul_eggs\030\r \001(\001\022"
  "\032\n\022min_client_version\030\016 \001(\r\022\017\n\007leggacy\030\023"
  " \001(\010\022\017\n\007cc_only\030\026 \001(\010\022\r\n\005debug\030\013 \001(\010\022\013\n\003"
  "key\030\025 \001(\t\032\250\001\n\004Goal\022\032\n\004type\030\001 \001(\0162\014.ei.Go"
  "alType\022\025\n\rtarget_amount\030\002 \001(\001\022#\n\013reward_"
  "type\030\003 \001(\0162\016.ei.RewardType\022\027\n\017reward_sub"
  "_type\030\004 \001(\t\022\025\n\rreward_amount\030\005 \001(\001\022\030\n\020ta"
  "rget_soul_eggs\030\006 \001(\001\032+\n\007GoalSet\022 \n\005goals"
  "\030\001 \003(\0132\021.ei.Contract.Goal\032\223\001\n\tGradeSpec\022"
  "\'\n\005grade\030\001 \001(\0162\030.ei.Contract.PlayerGrade"
  "\022 \n\005goals\030\002 \003(\0132\021.ei.Contract.Goal\022#\n\tmo"
  "difiers\030\003 \003(\0132\020.ei.GameModifier\022\026\n\016lengt"
  "h_seconds\030\004 \001(\001\"b\n\013PlayerGrade\022\017\n\013GRADE_"
  "UNSET\020\000\022\013\n\007GRADE_C\020\001\022\013\n\007GRADE_B\020\002\022\013\n\007GRA"
  "DE_A\020\003\022\014\n\010GRADE_AA\020\004\022\r\n\tGRADE_AAA\020\005\"\237\004\n\022"
  "ContractPlayerInfo\022\'\n\005grade\030\001 \001(\0162\030.ei.C"
  "ontract.PlayerGrade\022\021\n\ttotal_cxp\030\002 \001(\001\022\022"
  "\n\nseason_cxp\030\r \001(\001\022\023\n\013grade_score\030\007 \001(\001\022"
  "\032\n\022target_grade_score\030\t \001(\001\022\022\n\nsoul_powe"
  "r\030\n \001(\001\022\031\n\021target_soul_power\030\010 \001(\001\022\026\n\016gr"
  "ade_progress\030\014 \001(\001\0223\n\006issues\030\013 \003(\0162#.ei."
  "ContractEvaluation.PoorBehavior\022\023\n\013issue"
  "_score\030\016 \001(\001\022-\n\006status\030\003 \001(\0162\035.ei.Contra"
  "ctPlayerInfo.Status\022\034\n\024last_evaluation_t"
  "ime\030\004 \001(\001\022\037\n\027last_evaluation_version\030\005 \001"
  "(\t\0222\n\022unread_evaluations\030\006 \003(\0132\026.ei.Cont"
  "ractEvaluation\"U\n\006Status\022\013\n\007UNKNOWN\020\000\022\017\n"
  "\013CALCULATING\020\001\022\017\n\013OUT_OF_DATE\020\002\022\016\n\nINCOM"
  "PLETE\020\004\022\014\n\010COMPLETE\020\003\"\242\010\n\022ContractEvalua"
  "tion\022\033\n\023contract_identifier\030( \001(\t\022\027\n\017coo"
  "p_identifier\030) \001(\t\022\013\n\003cxp\030\001 \001(\001\022\016\n\006repla"
  "y\030\030 \001(\010\022\022\n\ncxp_change\030\031 \001(\001\022\031\n\021grade_per"
  "formance\030\002 \001(\005\022\022\n\nold_league\030\t \001(\005\022\021\n\tol"
  "d_goals\030\n \001(\010\022\'\n\005grade\030\003 \001(\0162\030.ei.Contra"
  "ct.PlayerGrade\022\032\n\022contribution_ratio\030\004 \001"
  "(\001\022\032\n\022completion_percent\030\005 \001(\001\022\027\n\017origin"
  "al_length\030\013 \001(\001\022\021\n\tcoop_size\030\022 \001(\r\022\014\n\004so"
  "lo\030\032 \001(\010\022\022\n\nsoul_power\030\027 \001(\001\022\036\n\026last_con"
  "tribution_time\030\026 \001(\001\022\027\n\017completion_time\030"
  "\006 \001(\001\022\031\n\021chicken_runs_sent\030\007 \001(\r\022\030\n\020gift"
  "_tokens_sent\030\010 \001(\r\022\034\n\024gift_tokens_receiv"
  "ed\030\017 \001(\r\022\035\n\025boost_token_allotment\030\020 \001(\r\022"
  "\027\n\017buff_time_value\030\021 \001(\001\022\026\n\016teamwork_sco"
  "re\030\r \001(\001\022\025\n\rother_bonuses\030\016 \001(\001\022\031\n\021count"
  "ed_in_season\030\024 \001(\010\022\021\n\tseason_id\030\025 \001(\t\022\023\n"
  "\013time_cheats\030\033 \001(\r\0223\n\006issues\030\023 \003(\0162#.ei."
  "ContractEvaluation.PoorBehavior\022\r\n\005notes"
  "\030\014 \003(\t\022\017\n\007version\0302 \001(\t\022\035\n\025evaluation_st"
  "art_time\0303 \001(\001\022-\n\006status\0304 \001(\0162\035.ei.Cont"
  "ractEvaluation.Status\"\230\001\n\014PoorBehavior\022\010"
  "\n\004NONE\020\000\022\024\n\020LOW_CONTRIBUTION\020\001\022\024\n\020BAD_CO"
  "NTRIBUTION\020\002\022\033\n\027DISHONORABLY_DISCHARGED\020"
  "\003\022\021\n\rPOOR_TEAMWORK\020\004\022\022\n\016ABANDONED_COOP\020\005"
  "\022\016\n\nTIME_CHEAT\020\006\"@\n\006Status\022\013\n\007UNKNOWN\020\000\022"
  "\013\n\007PENDING\020\001\022\016\n\nEVALUATING\020\002\022\014\n\010COMPLETE"
  "\020\003\"\202\001\n\020ContractCitation\0222\n\005issue\030\001 \001(\0162#"
  ".ei.ContractEvaluation.PoorBehavior\022\021\n\tt"
  "imestamp\030\002 \001(\001\022\'\n\005grade\030\003 \001(\0162\030.ei.Contr"
  "act.PlayerGrade\"\210\001\n\027ContractEvaluationBa"
  "tch\022/\n\005evals\030\001 \003(\0132 .ei.ContractEvaluati"
  "onBatch.Pair\032<\n\004Pair\022\017\n\007user_id\030\001 \001(\t\022#\n"
  "\003cev\030\002 \001(\0132\026.ei.ContractEvaluation\"\367\001\n\026C"
  "oopCompletionSnapshot\022D\n\014contributors\030\001 "
  "\003(\0132..ei.CoopCompletionSnapshot.Contribu"
  "torSnapshot\032\226\001\n\023ContributorSnapshot\022\024\n\014c"
  "ontribution\030\001 \001(\001\022\036\n\026last_contribution_t"
  "ime\030\006 \001(\001\022\022\n\nsoul_power\030\002 \001(\001\022\017\n\007user_id"
  "\030\003 \001(\t\022\016\n\006tokens\030\004 \001(\r\022\024\n\014tokens_spent\030\005"
  " \001(\r\"\242\001\n\020BasicRequestInfo\022\022\n\nei_user_id\030"
  "\001 \001(\t\022\026\n\016client_version\030\002 \001(\r\022\017\n\007version"
  "\030\003 \001(\t\022\r\n\005build\030\004 \001(\t\022\020\n\010platform\030\005 \001(\t\022"
  "\017\n\007country\030\006 \001(\t\022\020\n\010language\030\007 \001(\t\022\r\n\005de"
  "bug\030\010 \001(\010\"\313\002\n\021ContractSimConfig\022C\n\rgrade"
  "_configs\030\001 \003(\0132,.ei.ContractSimConfig.Co"
  "ntractGradeSimConfig\032\360\001\n\026ContractGradeSi"
  "mConfig\022\'\n\005grade\030\001 \001(\0162\030.ei.Contract.Pla"
  "yerGrade\022L\n\013goal_params\030\002 \003(\01327.ei.Contr"
  "actSimConfig.ContractGradeSimConfig.Goal"
  "Params\032_\n\nGoalParams\022\021\n\ttarget_se\030\001 \001(\001\022"
  "\020\n\010cps_mult\030\002 \001(\001\022\025\n\rearnings_mult\030\003 \001(\001"
  "\022\025\n\rtime_efficacy\030\004 \001(\001\")\n\017ContractSimPo"
  "ll\022\026\n\016client_version\030\001 \001(\r\"p\n\027ContractSi"
  "mPollResponse\022*\n\024contract_to_simulate\030\001 "
  "\001(\0132\014.ei.Contract\022)\n\nsim_config\030\002 \001(\0132\025."
  "ei.ContractSimConfig\"\316\001\n\027ContractSimResu"
  "ltUpdate\022\023\n\013contract_id\030\001 \001(\t\0228\n\ngoal_in"
  "fos\030\002 \003(\0132$.ei.ContractSimResultUpdate.G"
  "oalInfo\032d\n\010GoalInfo\022\'\n\005grade\030\001 \001(\0162\030.ei."
  "Contract.PlayerGrade\022\022\n\ngoal_index\030\002 \001(\r"
  "\022\033\n\023projected_eggs_laid\030\003 \001(\001\"N\n\020Contrac"
  "tsRequest\022\021\n\tsoul_eggs\030\001 \001(\001\022\026\n\016client_v"
  "ersion\030\005 \001(\r\022\017\n\007user_id\030\002 \001(\t\"y\n\021Contrac"
  "tsResponse\022\037\n\tcontracts\030\001 \003(\0132\014.ei.Contr"
  "act\022\027\n\017warning_message\030\004 \001(\t\022\023\n\013server_t"
  "ime\030\002 \001(\001\022\025\n\007max_eop\030\003 \001(\r:\0041000\"\237\001\n\031Con"
  "tractCoopStatusRequest\022#\n\005rinfo\030\005 \001(\0132\024."
  "ei.BasicRequestInfo\022\033\n\023contract_identifi"
  "er\030\001 \001(\t\022\027\n\017coop_identifier\030\002 \001(\t\022\017\n\007use"
  "r_id\030\003 \001(\t\022\026\n\016client_version\030\004 \001(\r\"\177\n\024Fa"
  "rmProductionParams\022\027\n\017farm_population\030\001 "
  "\001(\001\022\025\n\rfarm_capacity\030\002 \001(\001\022\013\n\003elr\030\003 \001(\001\022"
  "\013\n\003ihr\030\004 \001(\001\022\n\n\002sr\030\005 \001(\001\022\021\n\tdelivered\030\006 "
  "\001(\001\"\227\005\n\016PlayerFarmInfo\022\026\n\016client_version"
  "\030\024 \001(\r\022\021\n\tsoul_eggs\030\001 \001(\001\022\030\n\020eggs_of_pro"
  "phecy\030\002 \001(\004\022\024\n\014permit_level\030\003 \001(\r\022\031\n\021hyp"
  "erloop_station\030\004 \001(\010\022\027\n\017egg_medal_level\030"
  "\005 \003(\r\022.\n\repic_research\030\006 \003(\0132\027.ei.Backup"
  ".ResearchItem\022\031\n\010egg_type\030\007 \001(\0162\007.ei.Egg"
  "\022\024\n\014cash_on_hand\030\010 \001(\001\022\014\n\004habs\030\t \003(\r\022\026\n\016"
  "hab_population\030\n \003(\004\022\024\n\014hab_capacity\030\025 \003"
  "(\004\022\020\n\010vehicles\030\013 \003(\r\022\024\n\014train_length\030\014 \003"
  "(\r\022\023\n\013silos_owned\030\r \001(\r\0220\n\017common_resear"
  "ch\030\016 \003(\0132\027.ei.Backup.ResearchItem\022-\n\ract"
  "ive_boosts\030\017 \003(\0132\026.ei.Backup.ActiveBoost"
  "\022\034\n\024boost_tokens_on_hand\030\020 \001(\r\0220\n\022equipp"
  "ed_artifacts\030\021 \003(\0132\024.ei.CompleteArtifact"
  "\022 \n\030artifact_inventory_score\030\022 \001(\004\0226\n\017fa"
  "rm_appearance\030\023 \001(\0132\035.ei.ShellDB.FarmCon"
  "figuration\022\021\n\ttimestamp\030\026 \001(\001\"\337\n\n\032Contra"
  "ctCoopStatusResponse\022\033\n\023contract_identif"
  "ier\030\001 \001(\t\022\024\n\014total_amount\030\002 \001(\001\022\027\n\017coop_"
  "identifier\030\003 \001(\t\022E\n\014contributors\030\004 \003(\0132/"
  ".ei.ContractCoopStatusResponse.Contribut"
  "ionInfo\022\026\n\016auto_generated\030\010 \001(\010\022\016\n\006publi"
  "c\030\n \001(\010\022\022\n\ncreator_id\030\t \001(\t\022\031\n\021seconds_r"
  "emaining\030\005 \001(\001\022\032\n\022all_goals_achieved\030\016 \001"
  "(\010\022\035\n\025all_members_reporting\030\006 \001(\010\022&\n\036gra"
  "ce_period_seconds_remaining\030\007 \001(\001\0226\n\005gif"
  "ts\030\013 \003(\0132\'.ei.ContractCoopStatusResponse"
  ".CoopGift\022\?\n\014chicken_runs\030\r \003(\0132).ei.Con"
  "tractCoopStatusResponse.ChickenRun\022\027\n\017lo"
  "cal_timestamp\030\014 \001(\001\032\253\004\n\020ContributionInfo"
  "\022\014\n\004uuid\030\025 \001(\t\022\017\n\007user_id\030\001 \001(\t\022\021\n\tuser_"
  "name\030\002 \001(\t\022\033\n\023contract_identifier\030\023 \001(\t\022"
  "\033\n\023contribution_amount\030\003 \001(\001\022\031\n\021contribu"
  "tion_rate\030\006 \001(\001\022\022\n\nsoul_power\030\013 \001(\001\0223\n\021p"
  "roduction_params\030\017 \001(\0132\030.ei.FarmProducti"
  "onParams\022%\n\tfarm_info\030\022 \001(\0132\022.ei.PlayerF"
  "armInfo\022\023\n\013rank_change\030\010 \001(\005\022\016\n\006active\030\004"
  " \001(\010\022\r\n\005leech\030\020 \001(\010\022\033\n\023time_cheat_detect"
  "ed\030\007 \001(\010\022\036\n\010platform\030\005 \001(\0162\014.ei.Platform"
  "\022\017\n\007push_id\030\t \001(\t\022\021\n\tban_votes\030\n \001(\r\022\022\n\n"
  "autojoined\030\021 \001(\010\022\024\n\014boost_tokens\030\014 \001(\r\022\032"
  "\n\022boost_tokens_spent\030\016 \001(\r\022\'\n\014buff_histo"
  "ry\030\r \003(\0132\021.ei.CoopBuffState\022\034\n\024chicken_r"
  "un_cooldown\030\024 \001(\001\032>\n\010CoopGift\022\017\n\007user_id"
  "\030\001 \001(\t\022\021\n\tuser_name\030\003 \001(\t\022\016\n\006amount\030\002 \001("
  "\r\032@\n\nChickenRun\022\017\n\007user_id\030\001 \001(\t\022\021\n\tuser"
  "_name\030\003 \001(\t\022\016\n\006amount\030\002 \001(\004\"g\n\014MemberSta"
  "tus\022\t\n\005VALID\020\000\022\023\n\017KICKED_INACTIVE\020\001\022\022\n\016K"
  "ICKED_PRIVATE\020\002\022\021\n\rKICKED_CHEATS\020\003\022\020\n\014KI"
  "CKED_LEECH\020\004\"I\n\006Status\022\013\n\007UNKNOWN\020\000\022\t\n\005L"
  "OBBY\020\001\022\n\n\006ACTIVE\020\002\022\014\n\010COMPLETE\020\003\022\r\n\tFINA"
  "LIZED\020\004\"\323\004\n\rLocalContract\022\036\n\010contract\030\001 "
  "\001(\0132\014.ei.Contract\022\027\n\017coop_identifier\030\002 \001"
  "(\t\022\020\n\010accepted\030\007 \001(\010\022\025\n\rtime_accepted\030\003 "
  "\001(\001\022\021\n\tcancelled\030\004 \001(\010\022\013\n\003new\030\010 \001(\010\022\034\n\024c"
  "oop_shared_end_time\030\005 \001(\001\022\"\n\032coop_grace_"
  "period_end_time\030\t \001(\001\022#\n\033coop_contributi"
  "on_finalized\030\n \001(\010\022\'\n\037coop_last_uploaded"
  "_contribution\030\013 \001(\001\022\024\n\014coop_user_id\030\r \001("
  "\t\022\027\n\017coop_share_farm\030\021 \001(\010\022%\n\035last_amoun"
  "t_when_reward_given\030\006 \001(\001\022\032\n\022num_goals_a"
  "chieved\030\016 \001(\r\022\023\n\013boosts_used\030\014 \001(\r\022\025\n\rpo"
  "ints_replay\030\024 \001(\010\022\016\n\006league\030\017 \001(\r\022\'\n\005gra"
  "de\030\022 \001(\0162\030.ei.Contract.PlayerGrade\022\025\n\rla"
  "st_nag_time\030\020 \001(\001\022*\n\nevaluation\030\023 \001(\0132\026."
  "ei.ContractEvaluation\022\026\n\016reported_uuids\030"
  "\025 \003(\t\"\301\002\n\013MyContracts\022\031\n\021contract_ids_se"
  "en\030\003 \003(\t\022$\n\tcontracts\030\001 \003(\0132\021.ei.LocalCo"
  "ntract\022\"\n\007archive\030\002 \003(\0132\021.ei.LocalContra"
  "ct\022=\n\025current_coop_statuses\030\004 \003(\0132\036.ei.C"
  "ontractCoopStatusResponse\022(\n\010last_cpi\030\005 "
  "\001(\0132\026.ei.ContractPlayerInfo\022\036\n\026initial_g"
  "rade_revealed\030\006 \001(\010\022!\n\031last_grade_progre"
  "ss_shown\030\007 \001(\001\022!\n\031show_advanced_evaluati"
  "ons\030\010 \001(\010\"\276\001\n\020QueryCoopRequest\022#\n\005rinfo\030"
  "\005 \001(\0132\024.ei.BasicRequestInfo\022\033\n\023contract_"
  "identifier\030\001 \001(\t\022\027\n\017coop_identifier\030\002 \001("
  "\t\022\016\n\006league\030\004 \001(\r\022\'\n\005grade\030\006 \001(\0162\030.ei.Co"
  "ntract.PlayerGrade\022\026\n\016client_version\030\003 \001"
  "(\r\"\226\001\n\021QueryCoopResponse\022\016\n\006exists\030\001 \001(\010"
  "\022\014\n\004full\030\002 \001(\010\022\017\n\007expired\030\005 \001(\010\022\030\n\020diffe"
  "rent_league\030\004 \001(\010\022\027\n\017different_grade\030\006 \001"
  "(\010\022\017\n\007cc_only\030\007 \001(\010\022\016\n\006banned\030\003 \001(\010\"\340\002\n\021"
  "CreateCoopRequest\022#\n\005rinfo\030\n \001(\0132\024.ei.Ba"
  "sicRequestInfo\022\033\n\023contract_identifier\030\001 "
  "\001(\t\022\027\n\017coop_identifier\030\002 \001(\t\022\016\n\006public\030\r"
  " \001(\010\022\017\n\007cc_only\030\016 \001(\010\022\031\n\021seconds_remaini"
  "ng\030\003 \001(\001\022\017\n\007user_id\030\004 \001(\t\022\021\n\tuser_name\030\005"
  " \001(\t\022\022\n\nsoul_power\030\010 \001(\001\022\013\n\003eop\030\013 \001(\001\022\016\n"
  "\006league\030\t \001(\r\022\'\n\005grade\030\014 \001(\0162\030.ei.Contra"
  "ct.PlayerGrade\022\036\n\010platform\030\006 \001(\0162\014.ei.Pl"
  "atform\022\026\n\016client_version\030\007 \001(\r\"6\n\022Create"
  "CoopResponse\022\017\n\007success\030\001 \001(\010\022\017\n\007message"
  "\030\002 \001(\t\"\275\002\n\017JoinCoopRequest\022#\n\005rinfo\030\n \001("
  "\0132\024.ei.BasicRequestInfo\022\033\n\023contract_iden"
  "tifier\030\001 \001(\t\022\027\n\017coop_identifier\030\002 \001(\t\022\017\n"
  "\007user_id\030\003 \001(\t\022\021\n\tuser_name\030\004 \001(\t\022\022\n\nsou"
  "l_power\030\010 \001(\001\022\013\n\003eop\030\014 \001(\001\022\016\n\006league\030\t \001"
  "(\r\022\'\n\005grade\030\r \001(\0162\030.ei.Contract.PlayerGr"
  "ade\022\036\n\010platform\030\005 \001(\0162\014.ei.Platform\022\031\n\021s"
  "econds_remaining\030\013 \001(\001\022\026\n\016client_version"
  "\030\007 \001(\r\"\227\002\n\020JoinCoopResponse\022\017\n\007success\030\001"
  " \001(\010\022\017\n\007message\030\002 \001(\t\022\016\n\006banned\030\004 \001(\010\022\027\n"
  "\017coop_identifier\030\005 \001(\t\022\031\n\021seconds_remain"
  "ing\030\003 \001(\001\022\025\n\rmatch_percent\030\006 \001(\001\022\023\n\013num_"
  "members\030\007 \001(\r\0225\n\006status\030\010 \001(\0162%.ei.Contr"
  "actCoopStatusResponse.Status\022\'\n\005grade\030\t "
  "\001(\0162\030.ei.Contract.PlayerGrade\022\021\n\tcan_sta"
  "rt\030\n \001(\010\"\250\002\n\023AutoJoinCoopRequest\022#\n\005rinf"
  "o\030\t \001(\0132\024.ei.BasicRequestInfo\022\033\n\023contrac"
  "t_identifier\030\001 \001(\t\022\017\n\007user_id\030\002 \001(\t\022\021\n\tu"
  "ser_name\030\003 \001(\t\022\022\n\nsoul_power\030\004 \001(\001\022\013\n\003eo"
  "p\030\n \001(\001\022\016\n\006league\030\010 \001(\r\022\'\n\005grade\030\014 \001(\0162\030"
  ".ei.Contract.PlayerGrade\022\031\n\021seconds_rema"
  "ining\030\005 \001(\001\022\036\n\010platform\030\006 \001(\0162\014.ei.Platf"
  "orm\022\026\n\016client_version\030\007 \001(\r\"\275\001\n\034UpdateCo"
  "opPermissionsRequest\022#\n\005rinfo\030\006 \001(\0132\024.ei"
  ".BasicRequestInfo\022\033\n\023contract_identifier"
  "\030\001 \001(\t\022\027\n\017coop_identifier\030\002 \001(\t\022\032\n\022reque"
  "sting_user_id\030\003 \001(\t\022\016\n\006public\030\004 \001(\010\022\026\n\016c"
  "lient_version\030\005 \001(\r\"A\n\035UpdateCoopPermiss"
  "ionsResponse\022\017\n\007success\030\001 \001(\010\022\017\n\007message"
  "\030\002 \001(\t\"\240\001\n\020LeaveCoopRequest\022#\n\005rinfo\030\010 \001"
  "(\0132\024.ei.BasicRequestInfo\022\033\n\023contract_ide"
  "ntifier\030\001 \001(\t\022\027\n\017coop_identifier\030\002 \001(\t\022\031"
  "\n\021player_identifier\030\003 \001(\t\022\026\n\016client_vers"
  "ion\030\007 \001(\r\"\357\001\n\025GiftPlayerCoopRequest\022#\n\005r"
  "info\030\010 \001(\0132\024.ei.BasicRequestInfo\022\033\n\023cont"
  "ract_identifier\030\001 \001(\t\022\027\n\017coop_identifier"
  "\030\002 \001(\t\022\031\n\021player_identifier\030\003 \001(\t\022\032\n\022req"
  "uesting_user_id\030\004 \001(\t\022\034\n\024requesting_user"
  "_name\030\006 \001(\t\022\016\n\006amount\030\005 \001(\r\022\026\n\016client_ve"
  "rsion\030\007 \001(\r\"\365\001\n\031SendChickenRunCoopReques"
  "t\022#\n\005rinfo\030\010 \001(\0132\024.ei.BasicRequestInfo\022\033"
  "\n\023contract_identifier\030\001 \001(\t\022\027\n\017coop_iden"
  "tifier\030\002 \001(\t\022\031\n\021player_identifier\030\003 \001(\t\022"
  "\032\n\022requesting_user_id\030\004 \001(\t\022\034\n\024requestin"
  "g_user_name\030\006 \001(\t\022\020\n\010farm_pop\030\005 \001(\004\022\026\n\016c"
  "lient_version\030\007 \001(\r\"\200\002\n\027ReportPlayerCoop"
  "Request\022#\n\005rinfo\030\001 \001(\0132\024.ei.BasicRequest"
  "Info\022\033\n\023contract_identifier\030\002 \001(\t\022\027\n\017coo"
  "p_identifier\030\003 \001(\t\022\017\n\007user_id\030\004 \001(\t\0222\n\006r"
  "eason\030\005 \001(\0162\".ei.ReportPlayerCoopRequest"
  ".Reason\"E\n\006Reason\022\013\n\007UNKNOWN\020\000\022\022\n\016OFFENS"
  "IVE_NAME\020\001\022\014\n\010CHEATING\020\002\022\014\n\010LEECHING\020\003\"\271"
  "\002\n\025KickPlayerCoopRequest\022#\n\005rinfo\030\010 \001(\0132"
  "\024.ei.BasicRequestInfo\022\033\n\023contract_identi"
  "fier\030\001 \001(\t\022\027\n\017coop_identifier\030\002 \001(\t\022\031\n\021p"
  "layer_identifier\030\003 \001(\t\022\032\n\022requesting_use"
  "r_id\030\004 \001(\t\0220\n\006reason\030\t \001(\0162 .ei.KickPlay"
  "erCoopRequest.Reason\022\026\n\016client_version\030\007"
  " \001(\r\"D\n\006Reason\022\013\n\007INVALID\020\000\022\013\n\007CHEATER\020\001"
  "\022\010\n\004IDLE\020\002\022\t\n\005LEECH\020\003\022\013\n\007PRIVATE\020\004\"\311\003\n\037C"
  "ontractCoopStatusUpdateRequest\022#\n\005rinfo\030"
  "\014 \001(\0132\024.ei.BasicRequestInfo\022\017\n\007user_id\030\001"
  " \001(\t\022\033\n\023contract_identifier\030\002 \001(\t\022\027\n\017coo"
  "p_identifier\030\003 \001(\t\022\024\n\014push_user_id\030\010 \001(\t"
  "\022\016\n\006amount\030\004 \001(\001\022\014\n\004rate\030\005 \001(\001\022\034\n\024time_c"
  "heats_detected\030\006 \001(\r\022\022\n\nsoul_power\030\007 \001(\001"
  "\022\013\n\003eop\030\017 \001(\r\022\024\n\014boost_tokens\030\t \001(\r\022\032\n\022b"
  "oost_tokens_spent\030\r \001(\r\0223\n\021production_pa"
  "rams\030\016 \001(\0132\030.ei.FarmProductionParams\022%\n\t"
  "farm_info\030\020 \001(\0132\022.ei.PlayerFarmInfo\022\037\n\024e"
  "gg_laying_rate_buff\030\n \001(\001:\0011\022\030\n\rearnings"
  "_buff\030\013 \001(\001:\0011\"\202\001\n ContractCoopStatusUpd"
  "ateResponse\022\021\n\tfinalized\030\001 \001(\010\022\016\n\006exists"
  "\030\002 \001(\010\022;\n\006status\030\003 \001(\0162+.ei.ContractCoop"
  "StatusResponse.MemberStatus\"Z\n\rCoopBuffS"
  "tate\022\032\n\017egg_laying_rate\030\001 \001(\001:\0011\022\023\n\010earn"
  "ings\030\002 \001(\001:\0011\022\030\n\020server_timestamp\030\003 \001(\001\""
  "5\n\017CoopBuffHistory\022\"\n\007history\030\001 \003(\0132\021.ei"
  ".CoopBuffState\"@\n\023CoopChickenRunEntry\022\017\n"
  "\007user_id\030\001 \001(\t\022\030\n\020server_timestamp\030\002 \001(\001"
  "\"C\n\027CoopLastChickenRunTimes\022(\n\007entries\030\003"
  " \003(\0132\027.ei.CoopChickenRunEntry\"\375\001\n\023Leader"
  "boardAnalysis\022-\n\006chunks\030\001 \003(\0132\035.ei.Leade"
  "rboardAnalysis.Chunk\022\r\n\005count\030\002 \001(\r\022\022\n\nh"
  "igh_score\030\003 \001(\001\022\021\n\tlow_score\030\004 \001(\001\032\200\001\n\005C"
  "hunk\022\023\n\013start_index\030\001 \001(\r\022\021\n\tend_index\030\002"
  " \001(\r\022\022\n\nhigh_score\030\003 \001(\001\022\021\n\tlow_score\030\004 "
  "\001(\001\022\024\n\014start_cursor\030\005 \001(\t\022\022\n\nend_cursor\030"
  "\006 \001(\t\"}\n\017LeaderboardInfo\022+\n\007seasons\030\001 \003("
  "\0132\032.ei.LeaderboardInfo.Season\022\026\n\016all_tim"
  "e_scope\030\002 \001(\t\032%\n\006Season\022\r\n\005scope\030\001 \001(\t\022\014"
  "\n\004name\030\002 \001(\t\"q\n\022LeaderboardRequest\022#\n\005ri"
  "nfo\030\001 \001(\0132\024.ei.BasicRequestInfo\022\r\n\005scope"
  "\030\002 \001(\t\022\'\n\005grade\030\003 \001(\0162\030.ei.Contract.Play"
  "erGrade\"\342\001\n\023LeaderboardResponse\022\r\n\005scope"
  "\030\001 \001(\t\022\'\n\005grade\030\002 \001(\0162\030.ei.Contract.Play"
  "erGrade\0222\n\013top_entries\030\003 \003(\0132\035.ei.Leader"
  "boardResponse.Entry\022\r\n\005count\030\004 \001(\r\022\014\n\004ra"
  "nk\030\005 \001(\r\022\r\n\005score\030\006 \001(\001\0323\n\005Entry\022\014\n\004rank"
  "\030\001 \001(\r\022\r\n\005alias\030\002 \001(\t\022\r\n\005score\030\003 \001(\001\"6\n\020"
  "ContractsArchive\022\"\n\007archive\030\001 \003(\0132\021.ei.L"
  "ocalContract\"\377\002\n\016ContractAction\022\017\n\007user_"
  "id\030\001 \001(\t\022\023\n\013action_name\030\002 \001(\t\022\023\n\013approx_"
  "time\030\003 \001(\001\022\024\n\014dest_user_id\030\004 \001(\t\022\023\n\013cont"
  "ract_id\030\005 \001(\t\022\017\n\007coop_id\030\006 \001(\t\022\020\n\010autojo"
  "in\030\007 \001(\010\022\r\n\005grade\030\010 \001(\r\022\016\n\006replay\030\t \001(\010\022"
  "\025\n\rpoints_replay\030\n \001(\010\022\023\n\013reward_type\030\013 "
  "\001(\r\022\026\n\016reward_subtype\030\014 \001(\t\022\025\n\rreward_am"
  "ount\030\r \001(\001\022\022\n\ngoal_index\030\016 \001(\r\022\020\n\010boost_"
  "id\030\017 \001(\t\022\016\n\006tokens\030\020 \001(\r\022\023\n\013kick_reason\030"
  "\021 \001(\r\022\016\n\006public\030\022 \001(\010\022\017\n\007cc_only\030\023 \001(\010\"w"
  "\n\023UserDataInfoRequest\022#\n\005rinfo\030\004 \001(\0132\024.e"
  "i.BasicRequestInfo\022\017\n\007user_id\030\001 \001(\t\022\021\n\td"
  "evice_id\030\002 \001(\t\022\027\n\017backup_checksum\030\003 \001(\004\""
  "d\n\024UserDataInfoResponse\022\027\n\017backup_checks"
  "um\030\001 \001(\004\022\031\n\021backup_total_cash\030\002 \001(\001\022\030\n\020c"
  "oop_memberships\030\003 \003(\t\"{\n\027ClearAllUserDat"
  "aRequest\022#\n\005rinfo\030\004 \001(\0132\024.ei.BasicReques"
  "tInfo\022\017\n\007user_id\030\001 \001(\t\022\021\n\tdevice_id\030\002 \001("
  "\t\022\027\n\017backup_checksum\030\003 \001(\004\"r\n\nServerGift"
  "\022\017\n\007user_id\030\001 \001(\t\022#\n\013reward_type\030\003 \001(\0162\016"
  ".ei.RewardType\022\027\n\017reward_sub_type\030\004 \001(\t\022"
  "\025\n\rreward_amount\030\005 \001(\001\"\256\r\n\nLiveConfig\022\021\n"
  "\tconfig_id\030\001 \001(\t\0222\n\rboosts_config\030\002 \001(\0132"
  "\033.ei.LiveConfig.BoostsConfig\022.\n\013gift_con"
  "fig\030\003 \001(\0132\031.ei.LiveConfig.GiftConfig\022.\n\013"
  "misc_config\030\004 \001(\0132\031.ei.LiveConfig.MiscCo"
  "nfig\032\306\001\n\014BoostsConfig\022<\n\014item_configs\030\001 "
  "\003(\0132&.ei.LiveConfig.BoostsConfig.ItemCon"
  "fig\022\037\n\027cash_boost_cooloff_time\030\002 \001(\001\032W\n\n"
  "ItemConfig\022\020\n\010boost_id\030\001 \001(\t\022\r\n\005price\030\002 "
  "\001(\r\022\023\n\013token_price\030\003 \001(\r\022\023\n\013se_required\030"
  "\004 \001(\001\032\336\006\n\nGiftConfig\022\?\n\014gift_configs\030\t \003"
  "(\0132).ei.LiveConfig.GiftConfig.GiftValueC"
  "onfig\022\031\n\021gift_mu_min_spent\030\n \001(\001\022\031\n\021gift"
  "_mu_max_spent\030\013 \001(\001\022\034\n\024gift_mu_overall_m"
  "ult\030\014 \001(\001\022E\n\025random_gift_mu_config\030\017 \001(\013"
  "2&.ei.LiveConfig.GiftConfig.GiftMuConfig"
  "\022D\n\024video_gift_mu_config\030\020 \001(\0132&.ei.Live"
  "Config.GiftConfig.GiftMuConfig\022\030\n\020packag"
  "e_interval\030\001 \001(\001\022\034\n\024video_offer_interval"
  "\030\002 \001(\001\022%\n\035video_offer_interval_contract\030"
  "\003 \001(\001\022\'\n\037video_offer_interval_piggy_full"
  "\030\004 \001(\001\022-\n%video_offer_interval_piggy_ext"
  "ra_full\030\005 \001(\001\022\033\n\023video_reset_on_idle\030\016 \001"
  "(\010\022!\n\031package_interval_contract\030\006 \001(\001\022#\n"
  "\033package_interval_piggy_full\030\007 \001(\001\022)\n!pa"
  "ckage_interval_piggy_extra_full\030\010 \001(\001\022\035\n"
  "\025package_reset_on_idle\030\r \001(\010\032|\n\017GiftValu"
  "eConfig\022\017\n\007gift_id\030\001 \001(\t\022\016\n\006amount\030\004 \001(\001"
  "\022\020\n\010rand_min\030\002 \001(\001\022\020\n\010rand_max\030\003 \001(\001\022\021\n\t"
  "video_min\030\005 \001(\001\022\021\n\tvideo_max\030\006 \001(\001\032J\n\014Gi"
  "ftMuConfig\022\021\n\tmin_spent\030\001 \001(\001\022\021\n\tmax_spe"
  "nt\030\002 \001(\001\022\024\n\014overall_mult\030\003 \001(\001\032\316\003\n\nMiscC"
  "onfig\022\024\n\014ask_to_track\030\001 \001(\010\022\"\n\032ask_to_tr"
  "ack_min_soul_eggs\030\002 \001(\001\022\034\n\024ask_to_track_"
  "message\030\003 \001(\t\022$\n\034ask_to_track_show_pre_d"
  "ialog\030\004 \001(\010\022\"\n\032ask_to_track_after_privac"
  "y\030\005 \001(\010\022$\n\034chicken_run_boost_percentage\030"
  "\006 \001(\001\022\034\n\024shells_intro_tickets\030\007 \001(\r\022\'\n\037s"
  "hells_max_free_chicken_configs\030\010 \001(\r\022$\n\034"
  "shells_intro_alert_threshold\030\t \001(\r\022.\n&co"
  "ntracts_expert_league_min_soul_power\030\n \001"
  "(\001\022!\n\031new_player_event_duration\030\013 \001(\001\022 \n"
  "\030contracts_club_available\030\014 \001(\010\022\026\n\016contr"
  "acts_beta\030\r \001(\010\"\202\002\n\nInGameMail\022\n\n\002id\030\001 \001"
  "(\t\022\r\n\005title\030\002 \001(\t\022\014\n\004date\030\010 \001(\t\022\017\n\007messa"
  "ge\030\003 \001(\t\022\016\n\006action\030\004 \001(\t\022\013\n\003url\030\005 \001(\t\022\020\n"
  "\010platform\030\007 \001(\r\022\016\n\006builds\030\t \003(\t\022\032\n\022min_c"
  "lient_version\030\n \001(\r\022\032\n\022max_client_versio"
  "n\030\014 \001(\r\022\025\n\rmin_soul_eggs\030\013 \001(\001\022\032\n\022min_my"
  "stical_bonus\030\r \001(\001\022\020\n\010gold_tip\030\006 \001(\001\"&\n\006"
  "MailDB\022\034\n\004mail\030\001 \003(\0132\016.ei.InGameMail\"\313\002\n"
  "\023PeriodicalsResponse\022\034\n\005sales\030\001 \001(\0132\r.ei"
  ".SalesInfo\022\'\n\006events\030\002 \001(\0132\027.ei.EggIncCu"
  "rrentEvents\022(\n\tcontracts\030\003 \001(\0132\025.ei.Cont"
  "ractsResponse\022+\n\013evaluations\030\010 \003(\0132\026.ei."
  "ContractEvaluation\022\035\n\005gifts\030\004 \003(\0132\016.ei.S"
  "erverGift\022#\n\013live_config\030\005 \001(\0132\016.ei.Live"
  "Config\022\034\n\010mail_bag\030\006 \001(\0132\n.ei.MailDB\0224\n\024"
  "contract_player_info\030\007 \001(\0132\026.ei.Contract"
  "PlayerInfo\"\371\002\n\025GetPeriodicalsRequest\022#\n\005"
  "rinfo\030\014 \001(\0132\024.ei.BasicRequestInfo\022\017\n\007use"
  "r_id\030\001 \001(\t\022\022\n\npiggy_full\030\002 \001(\010\022\030\n\020piggy_"
  "found_full\030\003 \001(\010\022\035\n\025seconds_full_realtim"
  "e\030\004 \001(\001\022\035\n\025seconds_full_gametime\030\005 \001(\001\022\027"
  "\n\017lost_increments\030\007 \001(\r\022\021\n\tsoul_eggs\030\010 \001"
  "(\001\022\036\n\026mystical_earnings_mult\030\r \001(\001\022\013\n\003eo"
  "p\030\016 \001(\r\022\032\n\022contracts_unlocked\030\017 \001(\010\022\032\n\022a"
  "rtifacts_unlocked\030\020 \001(\010\022\036\n\026current_clien"
  "t_version\030\n \001(\r\022\r\n\005debug\030\013 \001(\010\"~\n\rConfig"
  "Request\022#\n\005rinfo\030\001 \001(\0132\024.ei.BasicRequest"
  "Info\022\021\n\tsoul_eggs\030\002 \001(\001\022\031\n\021artifacts_ena"
  "bled\030\003 \001(\010\022\032\n\022fuel_tank_unlocked\030\004 \001(\010\"x"
  "\n\016ConfigResponse\022#\n\013live_config\030\001 \001(\0132\016."
  "ei.LiveConfig\022\034\n\010mail_bag\030\002 \001(\0132\n.ei.Mai"
  "lDB\022#\n\013dlc_catalog\030\003 \001(\0132\016.ei.DLCCatalog"
  "\"d\n\024AdAttributionRawData\022\024\n\014device_ad_id"
  "\030\001 \001(\t\022\017\n\007user_id\030\004 \001(\t\022\022\n\nad_network\030\002 "
  "\001(\t\022\021\n\tjson_data\030\003 \001(\t\"\270\001\n\020AdAttribution"
  "Row\022\017\n\007user_id\030\001 \001(\t\022\r\n\005ad_id\030\002 \001(\t\022\022\n\na"
  "d_network\030\003 \001(\t\022\020\n\010campaign\030\004 \001(\t\022\017\n\007key"
  "word\030\005 \001(\t\022\r\n\005extra\030\006 \001(\t\022\022\n\nclick_date\030"
  "\007 \001(\002\022\025\n\rdownload_date\030\010 \001(\002\022\023\n\013approx_t"
  "ime\030\t \001(\002\"\215\003\n\021AdAttributionInfo\022\024\n\014devic"
  "e_ad_id\030\001 \001(\t\022\024\n\014network_name\030\002 \001(\t\022\023\n\013a"
  "ttribution\030\003 \001(\010\022\020\n\010org_name\030\004 \001(\t\022\016\n\006or"
  "g_id\030\005 \001(\t\022\025\n\rcampaign_name\030\006 \001(\t\022\023\n\013cam"
  "paign_id\030\007 \001(\t\022\022\n\nclick_date\030\010 \001(\t\022\027\n\017co"
  "nversion_date\030\t \001(\t\022\027\n\017conversion_type\030\n"
  " \001(\t\022\013\n\003geo\030\013 \001(\t\022\024\n\014adgroup_name\030\014 \001(\t\022"
  "\022\n\nadgroup_id\030\r \001(\t\022\017\n\007keyword\030\016 \001(\t\022\022\n\n"
  "keyword_id\030\017 \001(\t\022\025\n\rkeyword_extra\030\020 \001(\t\022"
  "\030\n\020creativeset_name\030\021 \001(\t\022\026\n\016creativeset"
  "_id\030\022 \001(\t\"\227\002\n\023ArtifactsClientInfo\022\035\n\025mis"
  "sion_capacity_mult\030\001 \001(\001\022\035\n\025mission_dura"
  "tion_mult\030\002 \001(\001\022!\n\031mission_ftl_duration_"
  "mult\030\004 \001(\001\022:\n\rlaunch_counts\030\003 \003(\0132#.ei.A"
  "rtifactsClientInfo.LaunchCount\032c\n\013Launch"
  "Count\022\'\n\004ship\030\001 \001(\0162\031.ei.MissionInfo.Spa"
  "ceship\022\024\n\014num_launches\030\002 \001(\r\022\025\n\rlaunch_p"
  "oints\030\003 \001(\001\"\204\006\n\013MissionInfo\022\'\n\004ship\030\001 \001("
  "\0162\031.ei.MissionInfo.Spaceship\022&\n\006status\030\002"
  " \001(\0162\026.ei.MissionInfo.Status\0223\n\rduration"
  "_type\030\003 \001(\0162\034.ei.MissionInfo.DurationTyp"
  "e\022\"\n\004fuel\030\004 \003(\0132\024.ei.MissionInfo.Fuel\022\r\n"
  "\005level\030\014 \001(\r\022\030\n\020duration_seconds\030\005 \001(\001\022\020"
  "\n\010capacity\030\t \001(\r\022\024\n\014quality_bump\030\013 \001(\001\022\031"
  "\n\021seconds_remaining\030\006 \001(\001\022\032\n\022start_time_"
  "derived\030\010 \001(\001\022\023\n\013mission_log\030\n \001(\t\022\022\n\nid"
  "entifier\030\007 \001(\t\032,\n\004Fuel\022\024\n\003egg\030\001 \001(\0162\007.ei"
  ".Egg\022\016\n\006amount\030\002 \001(\001\"\270\001\n\tSpaceship\022\017\n\013CH"
  "ICKEN_ONE\020\000\022\020\n\014CHICKEN_NINE\020\001\022\021\n\rCHICKEN"
  "_HEAVY\020\002\022\007\n\003BCR\020\003\022\025\n\021MILLENIUM_CHICKEN\020\004"
  "\022\027\n\023CORELLIHEN_CORVETTE\020\005\022\016\n\nGALEGGTICA\020"
  "\006\022\016\n\nCHICKFIANT\020\007\022\014\n\010VOYEGGER\020\010\022\016\n\nHENER"
  "PRISE\020\t\"t\n\006Status\022\013\n\007FUELING\020\000\022\025\n\021PREPAR"
  "E_TO_LAUNCH\020\005\022\r\n\tEXPLORING\020\n\022\014\n\010RETURNED"
  "\020\017\022\r\n\tANALYZING\020\020\022\014\n\010COMPLETE\020\024\022\014\n\010ARCHI"
  "VED\020\031\";\n\014DurationType\022\t\n\005SHORT\020\000\022\010\n\004LONG"
  "\020\001\022\010\n\004EPIC\020\002\022\014\n\010TUTORIAL\020\003\"\360\013\n\014ArtifactS"
  "pec\022#\n\004name\030\001 \001(\0162\025.ei.ArtifactSpec.Name"
  "\022%\n\005level\030\002 \001(\0162\026.ei.ArtifactSpec.Level\022"
  "\'\n\006rarity\030\003 \001(\0162\027.ei.ArtifactSpec.Rarity"
  "\022\024\n\003egg\030\004 \001(\0162\007.ei.Egg\"\212\t\n\004Name\022\017\n\013LUNAR"
  "_TOTEM\020\000\022\027\n\023NEODYMIUM_MEDALLION\020\003\022\021\n\rBEA"
  "K_OF_MIDAS\020\004\022\025\n\021LIGHT_OF_EGGENDIL\020\005\022\025\n\021D"
  "EMETERS_NECKLACE\020\006\022\025\n\021VIAL_MARTIAN_DUST\020"
  "\007\022\021\n\rORNATE_GUSSET\020\010\022\017\n\013THE_CHALICE\020\t\022\021\n"
  "\rBOOK_OF_BASAN\020\n\022\023\n\017PHOENIX_FEATHER\020\013\022\021\n"
  "\rTUNGSTEN_ANKH\020\014\022\023\n\017AURELIAN_BROOCH\020\025\022\024\n"
  "\020CARVED_RAINSTICK\020\026\022\017\n\013PUZZLE_CUBE\020\027\022\025\n\021"
  "QUANTUM_METRONOME\020\030\022\024\n\020SHIP_IN_A_BOTTLE\020"
  "\031\022\025\n\021TACHYON_DEFLECTOR\020\032\022\030\n\024INTERSTELLAR"
  "_COMPASS\020\033\022\025\n\021DILITHIUM_MONOCLE\020\034\022\025\n\021TIT"
  "ANIUM_ACTUATOR\020\035\022\021\n\rMERCURYS_LENS\020\036\022\021\n\rT"
  "ACHYON_STONE\020\001\022\023\n\017DILITHIUM_STONE\020\037\022\017\n\013S"
  "HELL_STONE\020 \022\017\n\013LUNAR_STONE\020!\022\016\n\nSOUL_ST"
  "ONE\020\"\022\022\n\016PROPHECY_STONE\020\'\022\021\n\rQUANTUM_STO"
  "NE\020$\022\017\n\013TERRA_STONE\020%\022\016\n\nLIFE_STONE\020&\022\021\n"
  "\rCLARITY_STONE\020(\022\035\n\031EXTRATERRESTRIAL_ALU"
  "MINUM\020\r\022\024\n\020ANCIENT_TUNGSTEN\020\016\022\017\n\013SPACE_R"
  "OCKS\020\017\022\016\n\nALIEN_WOOD\020\020\022\022\n\016GOLD_METEORITE"
  "\020\021\022\022\n\016TAU_CETI_GEODE\020\022\022\024\n\020CENTAURIAN_STE"
  "EL\020\023\022\023\n\017ERIDANI_FEATHER\020\024\022\017\n\013DRONE_PARTS"
  "\020#\022\024\n\020CELESTIAL_BRONZE\020)\022\020\n\014LALANDE_HIDE"
  "\020*\022\022\n\016SOLAR_TITANIUM\020+\022\032\n\026TACHYON_STONE_"
  "FRAGMENT\020\002\022\034\n\030DILITHIUM_STONE_FRAGMENT\020,"
  "\022\030\n\024SHELL_STONE_FRAGMENT\020-\022\030\n\024LUNAR_STON"
  "E_FRAGMENT\020.\022\027\n\023SOUL_STONE_FRAGMENT\020/\022\033\n"
  "\027PROPHECY_STONE_FRAGMENT\0200\022\032\n\026QUANTUM_ST"
  "ONE_FRAGMENT\0201\022\030\n\024TERRA_STONE_FRAGMENT\0202"
  "\022\027\n\023LIFE_STONE_FRAGMENT\0203\022\032\n\026CLARITY_STO"
  "NE_FRAGMENT\0204\022\014\n\007UNKNOWN\020\220N\"H\n\005Level\022\014\n\010"
  "INFERIOR\020\000\022\n\n\006LESSER\020\001\022\n\n\006NORMAL\020\002\022\013\n\007GR"
  "EATER\020\003\022\014\n\010SUPERIOR\020\004\"7\n\006Rarity\022\n\n\006COMMO"
  "N\020\000\022\010\n\004RARE\020\001\022\010\n\004EPIC\020\002\022\r\n\tLEGENDARY\020\003\"E"
  "\n\004Type\022\014\n\010ARTIFACT\020\000\022\t\n\005STONE\020\001\022\016\n\nINGRE"
  "DIENT\020\002\022\024\n\020STONE_INGREDIENT\020\003\"T\n\020Complet"
  "eArtifact\022\036\n\004spec\030\001 \001(\0132\020.ei.ArtifactSpe"
  "c\022 \n\006stones\030\002 \003(\0132\020.ei.ArtifactSpec\"u\n\025A"
  "rtifactInventoryItem\022\017\n\007item_id\030\001 \001(\004\022&\n"
  "\010artifact\030\002 \001(\0132\024.ei.CompleteArtifact\022\020\n"
  "\010quantity\030\003 \001(\001\022\021\n\tserver_id\030\004 \001(\t\"2\n\rIn"
  "ventorySlot\022\020\n\010occupied\030\001 \001(\010\022\017\n\007item_id"
  "\030\002 \001(\r\"\\\n\035ArtifactsConfigurationRequest\022"
  "#\n\005rinfo\030\002 \001(\0132\024.ei.BasicRequestInfo\022\026\n\016"
  "client_version\030\001 \001(\r\"\377\007\n\036ArtifactsConfig"
  "urationResponse\022P\n\022mission_parameters\030\001 "
  "\003(\01324.ei.ArtifactsConfigurationResponse."
  "MissionParameters\022R\n\023artifact_parameters"
  "\030\002 \003(\01325.ei.ArtifactsConfigurationRespon"
  "se.ArtifactParameters\022R\n\024crafting_level_"
  "infos\030\003 \003(\01324.ei.ArtifactsConfigurationR"
  "esponse.CraftingLevelInfo\032\250\003\n\021MissionPar"
  "ameters\022\'\n\004ship\030\001 \001(\0162\031.ei.MissionInfo.S"
  "paceship\022P\n\tdurations\030\003 \003(\0132=.ei.Artifac"
  "tsConfigurationResponse.MissionParameter"
  "s.Duration\022\"\n\032level_mission_requirements"
  "\030\004 \003(\r\022\033\n\023capacity_DEPRECATED\030\002 \001(\r\032\326\001\n\010"
  "Duration\0223\n\rduration_type\030\001 \001(\0162\034.ei.Mis"
  "sionInfo.DurationType\022\017\n\007seconds\030\002 \001(\001\022\017"
  "\n\007quality\030\003 \001(\002\022\023\n\013min_quality\030\004 \001(\002\022\023\n\013"
  "max_quality\030\005 \001(\002\022\020\n\010capacity\030\006 \001(\r\022\033\n\023l"
  "evel_capacity_bump\030\007 \001(\r\022\032\n\022level_qualit"
  "y_bump\030\010 \001(\002\032\370\001\n\022ArtifactParameters\022\036\n\004s"
  "pec\030\001 \001(\0132\020.ei.ArtifactSpec\022\024\n\014base_qual"
  "ity\030\002 \001(\001\022\027\n\017odds_multiplier\030\004 \001(\001\022\r\n\005va"
  "lue\030\003 \001(\001\022\026\n\016crafting_price\030\005 \001(\001\022\032\n\022cra"
  "fting_price_low\030\006 \001(\001\022\035\n\025crafting_price_"
  "domain\030\007 \001(\r\022\034\n\024crafting_price_curve\030\010 \001"
  "(\001\022\023\n\013crafting_xp\030\t \001(\004\032=\n\021CraftingLevel"
  "Info\022\023\n\013xp_required\030\001 \001(\001\022\023\n\013rarity_mult"
  "\030\002 \001(\002\"\256\001\n\016MissionRequest\022#\n\005rinfo\030\004 \001(\013"
  "2\024.ei.BasicRequestInfo\022\026\n\016client_version"
  "\030\001 \001(\r\022\022\n\nei_user_id\030\003 \001(\t\022\035\n\004info\030\002 \001(\013"
  "2\017.ei.MissionInfo\022,\n\013client_info\030\005 \001(\0132\027"
  ".ei.ArtifactsClientInfo\"A\n\017MissionRespon"
  "se\022\017\n\007success\030\001 \001(\010\022\035\n\004info\030\002 \001(\0132\017.ei.M"
  "issionInfo\"\214\002\n\027CompleteMissionResponse\022\017"
  "\n\007success\030\001 \001(\010\022\035\n\004info\030\002 \001(\0132\017.ei.Missi"
  "onInfo\022A\n\tartifacts\030\003 \003(\0132..ei.CompleteM"
  "issionResponse.SecureArtifactSpec\022!\n\roth"
  "er_rewards\030\004 \003(\0132\n.ei.Reward\022\022\n\nei_user_"
  "id\030\005 \001(\t\032G\n\022SecureArtifactSpec\022\036\n\004spec\030\001"
  " \001(\0132\020.ei.ArtifactSpec\022\021\n\tserver_id\030\002 \001("
  "\t\"\344\001\n%CollectContractArtifactRewardsRequ"
  "est\022#\n\005rinfo\030\001 \001(\0132\024.ei.BasicRequestInfo"
  "\022\033\n\023contract_identifier\030\002 \001(\t\022\016\n\006league\030"
  "\005 \001(\r\022\'\n\005grade\030\006 \001(\0162\030.ei.Contract.Playe"
  "rGrade\022\022\n\ngoal_index\030\003 \001(\r\022,\n\tbest_ship\030"
  "\004 \001(\0162\031.ei.MissionInfo.Spaceship\"\366\001\n\024Cra"
  "ftArtifactRequest\022#\n\005rinfo\030\005 \001(\0132\024.ei.Ba"
  "sicRequestInfo\022\022\n\nei_user_id\030\001 \001(\t\022\036\n\004sp"
  "ec\030\002 \001(\0132\020.ei.ArtifactSpec\022\017\n\007item_id\030\003 "
  "\001(\004\022\027\n\017gold_price_paid\030\006 \001(\001\022\026\n\016crafting"
  "_count\030\007 \001(\r\022\023\n\013crafting_xp\030\010 \001(\001\022.\n\013ing"
  "redients\030\004 \003(\0132\031.ei.ArtifactInventoryIte"
  "m\"\211\001\n\025CraftArtifactResponse\022\017\n\007item_id\030\001"
  " \001(\004\022\022\n\nei_user_id\030\005 \001(\t\0228\n\017rarity_achie"
  "ved\030\002 \001(\0162\027.ei.ArtifactSpec.Rarity:\006COMM"
  "ON\022\021\n\tserver_id\030\003 \001(\t\"\365\001\n\026ConsumeArtifac"
  "tRequest\022#\n\005rinfo\030\004 \001(\0132\024.ei.BasicReques"
  "tInfo\022\022\n\nei_user_id\030\003 \001(\t\022\036\n\004spec\030\001 \001(\0132"
  "\020.ei.ArtifactSpec\022\032\n\022artifact_server_id\030"
  "\005 \001(\t\022\030\n\020original_item_id\030\002 \001(\004\022\035\n\025addit"
  "ional_server_ids\030\007 \003(\t\022\033\n\023additional_ite"
  "m_ids\030\010 \003(\004\022\020\n\010quantity\030\006 \001(\r\"\276\001\n\027Consum"
  "eArtifactResponse\022\017\n\007success\030\001 \001(\010\022\030\n\020or"
  "iginal_item_id\030\002 \001(\004\022\033\n\023additional_item_"
  "ids\030\006 \003(\004\022$\n\nbyproducts\030\003 \003(\0132\020.ei.Artif"
  "actSpec\022!\n\rother_rewards\030\004 \003(\0132\n.ei.Rewa"
  "rd\022\022\n\nei_user_id\030\005 \001(\t\"}\n\034AuthenticateAr"
  "tifactResponse\022\017\n\007success\030\001 \001(\010\022\030\n\020origi"
  "nal_item_id\030\002 \001(\004\022\016\n\006demote\030\003 \001(\010\022\016\n\006del"
  "ete\030\004 \001(\010\022\022\n\nei_user_id\030\005 \001(\t\"\241\001\n\022SetArt"
  "ifactRequest\022#\n\005rinfo\030\001 \001(\0132\024.ei.BasicRe"
  "questInfo\022+\n\010artifact\030\002 \001(\0132\031.ei.Artifac"
  "tInventoryItem\022 \n\006stones\030\003 \003(\0132\020.ei.Arti"
  "factSpec\022\027\n\017gold_price_paid\030\004 \001(\001\"T\n\023Set"
  "ArtifactResponse\022\017\n\007success\030\001 \001(\010\022\030\n\020ori"
  "ginal_item_id\030\002 \001(\004\022\022\n\nei_user_id\030\005 \001(\t\""
  "\364\006\n\013ArtifactsDB\0222\n\017inventory_items\030\001 \003(\013"
  "2\031.ei.ArtifactInventoryItem\022\025\n\ritem_sequ"
  "ence\030\002 \001(\004\022*\n\017inventory_slots\030\003 \003(\0132\021.ei"
  ".InventorySlot\022<\n\020active_artifacts\030\007 \003(\013"
  "2\".ei.ArtifactsDB.ActiveArtifactSlot\022\?\n\024"
  "active_artifact_sets\030\013 \003(\0132!.ei.Artifact"
  "sDB.ActiveArtifactSet\022:\n\017artifact_status"
  "\030\014 \003(\0132!.ei.ArtifactsDB.CraftableArtifac"
  "t\022&\n\rmission_infos\030\004 \003(\0132\017.ei.MissionInf"
  "o\022(\n\017mission_archive\030\005 \003(\0132\017.ei.MissionI"
  "nfo\0229\n\037discovered_artifacts_DEPRECATED\030\010"
  " \003(\0132\020.ei.ArtifactSpec\022I\n\036craftable_arti"
  "facts_DEPRECATED\030\t \003(\0132!.ei.ArtifactsDB."
  "CraftableArtifact\022E\n\032crafting_counts_DEP"
  "RECATED\030\n \003(\0132!.ei.ArtifactsDB.Craftable"
  "Artifact\0327\n\022ActiveArtifactSlot\022\020\n\010occupi"
  "ed\030\001 \001(\010\022\017\n\007item_id\030\002 \001(\004\032F\n\021ActiveArtif"
  "actSet\0221\n\005slots\030\001 \003(\0132\".ei.ArtifactsDB.A"
  "ctiveArtifactSlot\032\222\001\n\021CraftableArtifact\022"
  "\036\n\004spec\030\001 \001(\0132\020.ei.ArtifactSpec\022\022\n\ndisco"
  "vered\030\006 \001(\010\022\021\n\tcraftable\030\004 \001(\010\022\031\n\021recipe"
  "_discovered\030\005 \001(\010\022\014\n\004seen\030\002 \001(\010\022\r\n\005count"
  "\030\003 \001(\r\"q\n\024AuthenticatedMessage\022\017\n\007messag"
  "e\030\001 \001(\014\022\017\n\007version\030\003 \001(\r\022\014\n\004code\030\002 \001(\t\022\022"
  "\n\ncompressed\030\004 \001(\010\022\025\n\roriginal_size\030\005 \001("
  "\r\"f\n\031LogCompleteMissionPayload\022\037\n\003req\030\001 "
  "\001(\0132\022.ei.MissionRequest\022(\n\003res\030\002 \001(\0132\033.e"
  "i.CompleteMissionResponse\"h\n\027LogCraftArt"
  "ifactPayload\022%\n\003req\030\001 \001(\0132\030.ei.CraftArti"
  "factRequest\022&\n\003res\030\002 \001(\0132\031.ei.CraftArtif"
  "actResponse\"n\n\031LogConsumeArtifactPayload"
  "\022\'\n\003req\030\001 \001(\0132\032.ei.ConsumeArtifactReques"
  "t\022(\n\003res\030\002 \001(\0132\033.ei.ConsumeArtifactRespo"
  "nse\"b\n\025LogSetArtifactPayload\022#\n\003req\030\001 \001("
  "\0132\026.ei.SetArtifactRequest\022$\n\003res\030\002 \001(\0132\027"
  ".ei.SetArtifactResponse\"@\n\026AccountTransf"
  "erPayload\022\017\n\007from_id\030\001 \001(\t\022\025\n\rto_ei_user"
  "_id\030\002 \001(\t\"\335\001\n\022SaveBackupResponse\022\017\n\007succ"
  "ess\030\001 \001(\010\022\022\n\nerror_code\030\002 \001(\r\022\017\n\007message"
  "\030\003 \001(\t\022#\n\017existing_backup\030\004 \001(\0132\n.ei.Bac"
  "kup\"l\n\nErrorCodes\022\014\n\010NO_ERROR\020\000\022\022\n\016USER_"
  "NOT_FOUND\020\001\022\027\n\023COULD_NOT_OVERWRITE\020\002\022\022\n\016"
  "BACKUP_OFFERED\020\003\022\017\n\013BAD_USER_ID\020\004\"K\n\023Cle"
  "anAccountRequest\022\032\n\022ei_user_id_to_keep\030\001"
  " \001(\t\022\030\n\020game_services_id\030\002 \001(\t\"&\n\020Return"
  "EDTPayload\022\022\n\nei_user_id\030\001 \001(\t\"\201\001\n\007DLCIt"
  "em\022\014\n\004name\030\001 \001(\t\022\021\n\tdirectory\030\002 \001(\t\022\013\n\003e"
  "xt\030\003 \001(\t\022\022\n\ncompressed\030\006 \001(\010\022\025\n\roriginal"
  "_size\030\007 \001(\004\022\013\n\003url\030\004 \001(\t\022\020\n\010checksum\030\005 \001"
  "(\t\"\301\022\n\tShellSpec\022\022\n\nidentifier\030\001 \001(\t\022/\n\r"
  "primary_piece\030\014 \001(\0132\030.ei.ShellSpec.Shell"
  "Piece\022(\n\006pieces\030\013 \003(\0132\030.ei.ShellSpec.She"
  "llPiece\022\037\n\nalt_assets\030\022 \003(\0132\013.ei.DLCItem"
  "\022\014\n\004name\030\003 \001(\t\022\026\n\016set_identifier\030\r \001(\t\022\031"
  "\n\021modified_geometry\030\023 \001(\010\022\r\n\005price\030\004 \001(\r"
  "\022\024\n\014required_eop\030\005 \001(\r\022\032\n\022required_soul_"
  "eggs\030\006 \001(\001\022\035\n\025required_parent_shell\030\024 \001("
  "\t\022\016\n\006is_new\030\016 \001(\010\022\017\n\007expires\030\017 \001(\010\022\037\n\027se"
  "conds_until_available\030\021 \001(\001\022\031\n\021seconds_r"
  "emaining\030\020 \001(\001\022\032\n\022default_appearance\030\010 \001"
  "(\010\032S\n\nShellPiece\022+\n\nasset_type\030\001 \001(\0162\027.e"
  "i.ShellSpec.AssetType\022\030\n\003dlc\030\002 \001(\0132\013.ei."
  "DLCItem\"\264\016\n\tAssetType\022\010\n\004COOP\020\001\022\t\n\005SHACK"
  "\020\002\022\017\n\013SUPER_SHACK\020\003\022\017\n\013SHORT_HOUSE\020\004\022\020\n\014"
  "THE_STANDARD\020\005\022\016\n\nLONG_HOUSE\020\006\022\021\n\rDOUBLE"
  "_DECKER\020\007\022\r\n\tWAREHOUSE\020\010\022\n\n\006CENTER\020\t\022\n\n\006"
  "BUNKER\020\n\022\n\n\006EGGKEA\020\013\022\n\n\006HAB_1K\020\014\022\n\n\006HANG"
  "AR\020\r\022\t\n\005TOWER\020\016\022\013\n\007HAB_10K\020\017\022\014\n\010EGGTOPIA"
  "\020\020\022\014\n\010MONOLITH\020\021\022\021\n\rPLANET_PORTAL\020\022\022\024\n\020C"
  "HICKEN_UNIVERSE\020\023\022\020\n\014SILO_0_SMALL\0202\022\016\n\nS"
  "ILO_0_MED\0203\022\020\n\014SILO_0_LARGE\0204\022\020\n\014SILO_1_"
  "SMALL\0205\022\016\n\nSILO_1_MED\0206\022\020\n\014SILO_1_LARGE\020"
  "7\022\014\n\010SILO_ALL\020;\022\013\n\007MAILBOX\020F\022\017\n\013TROPHY_C"
  "ASE\020G\022\n\n\006GROUND\020H\022\r\n\tHARDSCAPE\020I\022\r\n\tHYPE"
  "RLOOP\020J\022\013\n\007DEPOT_1\020d\022\013\n\007DEPOT_2\020e\022\013\n\007DEP"
  "OT_3\020f\022\013\n\007DEPOT_4\020g\022\013\n\007DEPOT_5\020h\022\013\n\007DEPO"
  "T_6\020i\022\013\n\007DEPOT_7\020j\022\t\n\005LAB_1\020n\022\t\n\005LAB_2\020o"
  "\022\t\n\005LAB_3\020p\022\t\n\005LAB_4\020q\022\t\n\005LAB_5\020r\022\t\n\005LAB"
  "_6\020s\022\023\n\017HATCHERY_EDIBLE\020x\022\026\n\022HATCHERY_SU"
  "PERFOOD\020y\022\024\n\020HATCHERY_MEDICAL\020z\022\030\n\024HATCH"
  "ERY_ROCKET_FUEL\020{\022\032\n\026HATCHERY_SUPERMATER"
  "IAL\020|\022\023\n\017HATCHERY_FUSION\020}\022\024\n\020HATCHERY_Q"
  "UANTUM\020~\022\030\n\024HATCHERY_IMMORTALITY\020\177\022\025\n\020HA"
  "TCHERY_TACHYON\020\200\001\022\026\n\021HATCHERY_GRAVITON\020\201"
  "\001\022\027\n\022HATCHERY_DILITHIUM\020\202\001\022\025\n\020HATCHERY_P"
  "RODIGY\020\203\001\022\027\n\022HATCHERY_TERRAFORM\020\204\001\022\030\n\023HA"
  "TCHERY_ANTIMATTER\020\205\001\022\031\n\024HATCHERY_DARK_MA"
  "TTER\020\206\001\022\020\n\013HATCHERY_AI\020\207\001\022\024\n\017HATCHERY_NE"
  "BULA\020\210\001\022\026\n\021HATCHERY_UNIVERSE\020\211\001\022\033\n\026HATCH"
  "ERY_ENLIGHTENMENT\020\212\001\022\027\n\022HATCHERY_CHOCOLA"
  "TE\020\213\001\022\024\n\017HATCHERY_EASTER\020\214\001\022\032\n\025HATCHERY_"
  "WATERBALLOON\020\215\001\022\026\n\021HATCHERY_FIREWORK\020\216\001\022"
  "\025\n\020HATCHERY_PUMPKIN\020\217\001\022\n\n\005HOA_1\020\252\001\022\n\n\005HO"
  "A_2\020\253\001\022\n\n\005HOA_3\020\254\001\022\026\n\021MISSION_CONTROL_1\020"
  "\264\001\022\026\n\021MISSION_CONTROL_2\020\265\001\022\026\n\021MISSION_CO"
  "NTROL_3\020\266\001\022\020\n\013FUEL_TANK_1\020\310\001\022\020\n\013FUEL_TAN"
  "K_2\020\311\001\022\020\n\013FUEL_TANK_3\020\312\001\022\020\n\013FUEL_TANK_4\020"
  "\313\001\022\032\n\025HATCHERY_GRAVITON_TOP\020\364\003\022\033\n\026HATCHE"
  "RY_NEBULA_MIDDLE\020\365\003\022\030\n\023HATCHERY_NEBULA_T"
  "OP\020\366\003\022 \n\033HATCHERY_DARK_MATTER_RING_1\020\371\003\022"
  " \n\033HATCHERY_DARK_MATTER_RING_2\020\372\003\022 \n\033HAT"
  "CHERY_DARK_MATTER_RING_3\020\373\003\022\026\n\021HATCHERY_"
  "AI_TOP_1\020\376\003\022\026\n\021HATCHERY_AI_TOP_2\020\377\003\022\026\n\021H"
  "ATCHERY_AI_TOP_3\020\200\004\022\026\n\021HATCHERY_AI_TOP_4"
  "\020\201\004\022\034\n\027HATCHERY_UNIVERSE_PROBE\020\203\004\022\033\n\026HAT"
  "CHERY_UNIVERSE_BOLT\020\204\004\022\037\n\032HATCHERY_ENLIG"
  "HTENMENT_ORB\020\210\004\022\024\n\017HYPERLOOP_TRACK\020\272\004\022\021\n"
  "\014MAILBOX_FULL\020\330\004\022\014\n\007CHICKEN\020\350\007\022\010\n\003HAT\020\362\007"
  "\022\014\n\007UNKNOWN\020\217N\"\226\005\n\014ShellSetSpec\022\022\n\nident"
  "ifier\030\001 \001(\t\022\014\n\004name\030\002 \001(\t\022\r\n\005price\030\003 \001(\r"
  "\022 \n\025price_mult_DEPRECATED\030\010 \001(\001:\0011\022\020\n\010di"
  "scount\030\021 \001(\001\022\024\n\014required_eop\030\004 \001(\r\022\032\n\022re"
  "quired_soul_eggs\030\005 \001(\001\022\033\n\023required_paren"
  "t_set\030\024 \001(\t\022\016\n\006is_new\030\t \001(\010\022\017\n\007expires\030\n"
  " \001(\010\022\037\n\027seconds_until_available\030\022 \001(\001\022\031\n"
  "\021seconds_remaining\030\013 \001(\001\022\021\n\tdecorator\030\016 "
  "\001(\010\022\031\n\021modified_geometry\030\r \001(\010\022\023\n\013elemen"
  "t_set\030\007 \001(\010\022\026\n\016hex_base_color\030\020 \001(\t\0222\n\nv"
  "ariations\030\017 \003(\0132\036.ei.ShellSetSpec.Variat"
  "ionSpec\022\031\n\004icon\030\023 \001(\0132\013.ei.DLCItem\022\032\n\022de"
  "fault_appearance\030\006 \001(\010\022\031\n\021custom_appeara"
  "nce\030\014 \001(\010\032\223\001\n\rVariationSpec\022\022\n\nidentifie"
  "r\030\001 \001(\t\022\021\n\thex_color\030\002 \001(\t\022\r\n\005price\030\003 \001("
  "\r\022\025\n\rsort_priority\030\006 \001(\005\022\032\n\022default_appe"
  "arance\030\004 \001(\010\022\031\n\021custom_appearance\030\005 \001(\010\""
  "\301\005\n\017ShellObjectSpec\022\022\n\nidentifier\030\001 \001(\t\022"
  "\014\n\004name\030\002 \001(\t\022+\n\nasset_type\030\003 \001(\0162\027.ei.S"
  "hellSpec.AssetType\022\024\n\014object_class\030\016 \001(\t"
  "\022\023\n\013icon_colors\030\017 \003(\t\022\r\n\005price\030\004 \001(\r\022\024\n\014"
  "required_eop\030\005 \001(\r\022\032\n\022required_soul_eggs"
  "\030\006 \001(\001\022\016\n\006is_new\030\n \001(\010\022\017\n\007expires\030\013 \001(\010\022"
  "\037\n\027seconds_until_available\030\022 \001(\001\022\031\n\021seco"
  "nds_remaining\030\014 \001(\001\022\020\n\010metadata\030\007 \003(\001\022\017\n"
  "\007no_hats\030\r \001(\010\022\?\n\021chicken_animation\030\020 \001("
  "\0162$.ei.ShellObjectSpec.ChickenAnimation\022"
  "\025\n\rsort_priority\030\021 \001(\005\022,\n\006pieces\030\010 \003(\0132\034"
  ".ei.ShellObjectSpec.LODPiece\022\032\n\022default_"
  "appearance\030\t \001(\010\0321\n\010LODPiece\022\030\n\003dlc\030\001 \001("
  "\0132\013.ei.DLCItem\022\013\n\003lod\030\002 \001(\r\"\235\001\n\020ChickenA"
  "nimation\022\020\n\014STANDARD_RUN\020\000\022\n\n\006SLOWMO\020\007\022\n"
  "\n\006WOBBLE\020\001\022\017\n\013WOBBLE_LEAN\020\005\022\n\n\006SMOOTH\020\002\022"
  "\017\n\013SMOOTH_LEAN\020\006\022\t\n\005HOVER\020\003\022\023\n\017SIDEWAYS_"
  "SMOOTH\020\004\022\021\n\rSIDEWAYS_LEAN\020\010\"\222\001\n\016ShellGro"
  "upSpec\022\022\n\nidentifier\030\001 \001(\t\022\014\n\004name\030\002 \001(\t"
  "\022+\n\nasset_type\030\005 \001(\0162\027.ei.ShellSpec.Asse"
  "tType\022\022\n\nmember_ids\030\003 \003(\t\022\035\n\025price_mult_"
  "DEPRECATED\030\004 \001(\001\"\351\001\n\nDLCCatalog\022\032\n\005items"
  "\030\001 \003(\0132\013.ei.DLCItem\022\035\n\006shells\030\002 \003(\0132\r.ei"
  ".ShellSpec\022$\n\nshell_sets\030\003 \003(\0132\020.ei.Shel"
  "lSetSpec\022$\n\ndecorators\030\006 \003(\0132\020.ei.ShellS"
  "etSpec\022*\n\rshell_objects\030\004 \003(\0132\023.ei.Shell"
  "ObjectSpec\022(\n\014shell_groups\030\005 \003(\0132\022.ei.Sh"
  "ellGroupSpec\"\346\r\n\007ShellDB\0220\n\017shell_invent"
  "ory\030\001 \003(\0132\027.ei.ShellDB.ShellStatus\022\?\n\027sh"
  "ell_element_inventory\030\005 \003(\0132\036.ei.ShellDB"
  ".ShellElementStatus\022F\n\031shell_variation_i"
  "nventory\030\010 \003(\0132#.ei.ShellDB.ShellSetVari"
  "ationStatus\0224\n\023shell_set_inventory\030\002 \003(\013"
  "2\027.ei.ShellDB.ShellStatus\0227\n\026shell_objec"
  "t_inventory\030\004 \003(\0132\027.ei.ShellDB.ShellStat"
  "us\0223\n\014farm_configs\030\003 \003(\0132\035.ei.ShellDB.Fa"
  "rmConfiguration\0229\n\rsaved_configs\030\t \003(\0132\""
  ".ei.ShellDB.SavedFarmConfiguration\022\035\n\025ne"
  "w_shells_downloaded\030\006 \003(\t\022\027\n\017new_shells_"
  "seen\030\007 \003(\t\0320\n\013ShellStatus\022\022\n\nidentifier\030"
  "\001 \001(\t\022\r\n\005owned\030\002 \001(\010\032V\n\022ShellElementStat"
  "us\022(\n\007element\030\001 \001(\0162\027.ei.ShellDB.FarmEle"
  "ment\022\026\n\016set_identifier\030\002 \001(\t\032K\n\027ShellSet"
  "VariationStatus\022\026\n\016set_identifier\030\001 \001(\t\022"
  "\030\n\020owned_variations\030\002 \003(\t\032\235\002\n\021FarmConfig"
  "uration\0225\n\rshell_configs\030\001 \003(\0132\036.ei.Shel"
  "lDB.ShellConfiguration\022<\n\021shell_set_conf"
  "igs\030\002 \003(\0132!.ei.ShellDB.ShellSetConfigura"
  "tion\022#\n\033configure_chickens_by_group\030\007 \001("
  "\010\022:\n\rgroup_configs\030\010 \003(\0132#.ei.ShellDB.Sh"
  "ellGroupConfiguration\0222\n\017chicken_configs"
  "\030\t \003(\0132\031.ei.ShellDB.ChickenConfig\032o\n\026Sav"
  "edFarmConfiguration\022\014\n\004name\030\001 \001(\t\022-\n\006con"
  "fig\030\002 \001(\0132\035.ei.ShellDB.FarmConfiguration"
  "\022\030\n\020client_save_time\030\003 \001(\001\032j\n\022ShellConfi"
  "guration\022+\n\nasset_type\030\001 \001(\0162\027.ei.ShellS"
  "pec.AssetType\022\r\n\005index\030\002 \001(\r\022\030\n\020shell_id"
  "entifier\030\003 \001(\t\032\252\001\n\025ShellSetConfiguration"
  "\022(\n\007element\030\001 \001(\0162\027.ei.ShellDB.FarmEleme"
  "nt\022\r\n\005index\030\002 \001(\r\022\034\n\024shell_set_identifie"
  "r\030\003 \001(\t\022\034\n\024variation_identifier\030\004 \001(\t\022\034\n"
  "\024decorator_identifier\030\005 \001(\t\032`\n\027ShellGrou"
  "pConfiguration\022+\n\nasset_type\030\001 \001(\0162\027.ei."
  "ShellSpec.AssetType\022\030\n\020group_identifier\030"
  "\002 \001(\t\032C\n\rChickenConfig\022\032\n\022chicken_identi"
  "fier\030\001 \001(\t\022\026\n\016hat_identifier\030\002 \001(\t\"\340\001\n\013F"
  "armElement\022\r\n\tHEN_HOUSE\020\001\022\010\n\004SILO\020\002\022\013\n\007M"
  "AILBOX\020\003\022\017\n\013TROPHY_CASE\020\004\022\n\n\006GROUND\020\005\022\r\n"
  "\tHARDSCAPE\020\006\022\r\n\tHYPERLOOP\020\007\022\t\n\005DEPOT\020\010\022\007"
  "\n\003LAB\020\t\022\014\n\010HATCHERY\020\n\022\007\n\003HOA\020\013\022\023\n\017MISSIO"
  "N_CONTROL\020\014\022\r\n\tFUEL_TANK\020\r\022\013\n\007CHICKEN\020\016\022"
  "\007\n\003HAT\020\017\022\013\n\007UNKNOWN\020c\"\234\002\n\017ShellsActionLo"
  "g\022#\n\005rinfo\030\010 \001(\0132\024.ei.BasicRequestInfo\022\017"
  "\n\007user_id\030\001 \001(\t\022\016\n\006action\030\002 \001(\t\022\016\n\006sub_i"
  "d\030\003 \001(\t\022-\n\014farm_element\030\t \001(\0162\027.ei.Shell"
  "DB.FarmElement\022\014\n\004cost\030\004 \001(\r\022\023\n\013approx_t"
  "ime\030\005 \001(\001\022\017\n\007version\030\006 \001(\t\022\022\n\nfarm_index"
  "\030\007 \001(\005\022\021\n\tsoul_eggs\030\n \001(\001\022\025\n\rtickets_spe"
  "nt\030\013 \001(\004\022\022\n\ngold_spent\030\014 \001(\004\"\271\010\n\030UserVer"
  "ificationAnalysis\022;\n\016overall_status\030\001 \001("
  "\0162#.ei.UserVerificationAnalysis.Status\022\022"
  "\n\nstart_time\030\002 \001(\001\022\027\n\017completion_time\030\003 "
  "\001(\001\022\025\n\rnum_prestiges\030\016 \001(\001\022\021\n\tsoul_eggs\030"
  "\017 \001(\001\022\030\n\020eggs_of_prophecy\030\033 \001(\r\0227\n\niap_s"
  "tatus\030\022 \001(\0162#.ei.UserVerificationAnalysi"
  "s.Status\022\033\n\023verified_pro_permit\030\004 \001(\010\022\035\n"
  "\025verified_piggy_breaks\030\005 \001(\r\022\032\n\022verified"
  "_other_iap\030\006 \001(\r\022\026\n\016unverified_iap\030\007 \001(\r"
  "\022\023\n\013gold_earned\030\r \001(\001\022\031\n\021regular_iap_buy"
  "er\030\026 \001(\010\022\033\n\023regular_iap_cheater\030\027 \001(\010\022=\n"
  "\020artifacts_status\030\023 \001(\0162#.ei.UserVerific"
  "ationAnalysis.Status\022\032\n\022missions_complet"
  "ed\030\010 \001(\r\022\033\n\023artifacts_collected\030\t \001(\001\022\032\n"
  "\022artifacts_consumed\030\n \001(\001\022\036\n\026artifacts_i"
  "n_inventory\030\013 \001(\001\022\033\n\023gold_spent_crafting"
  "\030\025 \001(\001\022\032\n\022excessive_consumes\030\030 \001(\010\022\033\n\023ex"
  "cessive_inventory\030\031 \001(\010\022\027\n\017excessive_spe"
  "nd\030\032 \001(\010\022=\n\020contracts_status\030\024 \001(\0162#.ei."
  "UserVerificationAnalysis.Status\022\034\n\024num_c"
  "oop_memberships\030\014 \001(\r\022\027\n\017valid_contracts"
  "\030\020 \001(\r\022\031\n\021invalid_contracts\030\021 \003(\t\022\025\n\rexc"
  "essive_eop\030\034 \001(\010\022#\n\033excessive_invalid_co"
  "ntracts\030\035 \001(\010\022\020\n\010verified\030\036 \001(\010\022\035\n\025verif"
  "ication_override\030\037 \001(\010\022#\n\033verification_o"
  "verride_value\030  \001(\010\"3\n\006Status\022\013\n\007UNKNOWN"
  "\020\000\022\016\n\nPROCESSING\020\001\022\014\n\010COMPLETE\020\002\"\365\005\n\024Use"
  "rSubscriptionInfo\022:\n\022subscription_level\030"
  "\r \001(\0162\036.ei.UserSubscriptionInfo.Level\022\?\n"
  "\027next_subscription_level\030\017 \001(\0162\036.ei.User"
  "SubscriptionInfo.Level\022$\n\034lock_next_subs"
  "cription_level\030\022 \001(\010\022\036\n\010platform\030\n \001(\0162\014"
  ".ei.Platform\022\037\n\027original_transaction_id\030"
  "\001 \001(\t\022\035\n\025linked_transaction_id\030\020 \001(\t\022\024\n\014"
  "acknowledged\030\021 \001(\010\022\030\n\020first_subscribed\030\002"
  " \001(\001\022\022\n\nperiod_end\030\004 \001(\001\022/\n\006status\030\005 \001(\016"
  "2\037.ei.UserSubscriptionInfo.Status\022\024\n\014sto"
  "re_status\030\016 \001(\t\022\022\n\nauto_renew\030\006 \001(\010\022\017\n\007s"
  "andbox\030\023 \001(\010\022\024\n\014last_updated\030\007 \001(\001\0226\n\007hi"
  "story\030\t \003(\0132%.ei.UserSubscriptionInfo.Hi"
  "storyEntry\022\025\n\rpast_user_ids\030\013 \003(\t\032F\n\014His"
  "toryEntry\022\021\n\ttimestamp\030\001 \001(\001\022\022\n\nmessage_"
  "id\030\002 \001(\t\022\017\n\007message\030\003 \001(\t\"\036\n\005Level\022\014\n\010ST"
  "ANDARD\020\000\022\007\n\003PRO\020\001\"]\n\006Status\022\013\n\007UNKNOWN\020\000"
  "\022\n\n\006ACTIVE\020\001\022\013\n\007EXPIRED\020\002\022\013\n\007REVOKED\020\003\022\020"
  "\n\014GRACE_PERIOD\020\004\022\016\n\nPAUSE_HOLD\020\005\"\246\001\n\035Sub"
  "scriptionChangeHintRequest\022#\n\005rinfo\030\003 \001("
  "\0132\024.ei.BasicRequestInfo\022\037\n\027original_tran"
  "saction_id\030\001 \001(\t\022\?\n\027next_subscription_le"
  "vel\030\002 \001(\0162\036.ei.UserSubscriptionInfo.Leve"
  "l\">\n\022CXPEvalRolloutInfo\022\022\n\ncurrent_id\030\001 "
  "\001(\t\022\024\n\014basis_points\030\002 \001(\r*\036\n\010Platform\022\007\n"
  "\003IOS\020\001\022\t\n\005DROID\020\002*)\n\020DeviceFormFactor\022\t\n"
  "\005PHONE\020\001\022\n\n\006TABLET\020\002*k\n\tAdNetwork\022\n\n\006VUN"
  "GLE\020\000\022\016\n\nCHARTBOOST\020\001\022\r\n\tAD_COLONY\020\002\022\014\n\010"
  "HYPER_MX\020\003\022\t\n\005UNITY\020\004\022\014\n\010FACEBOOK\020\005\022\014\n\010A"
  "PPLOVIN\020\006*\356\002\n\003Egg\022\n\n\006EDIBLE\020\001\022\r\n\tSUPERFO"
  "OD\020\002\022\013\n\007MEDICAL\020\003\022\017\n\013ROCKET_FUEL\020\004\022\022\n\016SU"
  "PER_MATERIAL\020\005\022\n\n\006FUSION\020\006\022\013\n\007QUANTUM\020\007\022"
  "\017\n\013IMMORTALITY\020\010\022\013\n\007TACHYON\020\t\022\014\n\010GRAVITO"
  "N\020\n\022\r\n\tDILITHIUM\020\013\022\013\n\007PRODIGY\020\014\022\r\n\tTERRA"
  "FORM\020\r\022\016\n\nANTIMATTER\020\016\022\017\n\013DARK_MATTER\020\017\022"
  "\006\n\002AI\020\020\022\n\n\006NEBULA\020\021\022\014\n\010UNIVERSE\020\022\022\021\n\rENL"
  "IGHTENMENT\020\023\022\r\n\tCHOCOLATE\020d\022\n\n\006EASTER\020e\022"
  "\020\n\014WATERBALLOON\020f\022\014\n\010FIREWORK\020g\022\013\n\007PUMPK"
  "IN\020h\022\014\n\007UNKNOWN\020\350\007*-\n\010FarmType\022\t\n\005EMPTY\020"
  "\001\022\010\n\004HOME\020\002\022\014\n\010CONTRACT\020\003*+\n\010GoalType\022\r\n"
  "\tEGGS_LAID\020\001\022\020\n\014UNKNOWN_GOAL\020d*\211\002\n\nRewar"
  "dType\022\010\n\004CASH\020\001\022\010\n\004GOLD\020\002\022\r\n\tSOUL_EGGS\020\003"
  "\022\024\n\020EGGS_OF_PROPHECY\020\004\022\026\n\022EPIC_RESEARCH_"
  "ITEM\020\005\022\016\n\nPIGGY_FILL\020\006\022\024\n\020PIGGY_MULTIPLI"
  "ER\020\007\022\024\n\020PIGGY_LEVEL_BUMP\020\010\022\t\n\005BOOST\020\t\022\017\n"
  "\013BOOST_TOKEN\020\n\022\014\n\010ARTIFACT\020\013\022\021\n\rARTIFACT"
  "_CASE\020\014\022\013\n\007CHICKEN\020\r\022\020\n\014SHELL_SCRIPT\020\016\022\022"
  "\n\016UNKNOWN_REWARD\020d*4\n\020LeaderboardScope\022\014"
  "\n\010ALL_TIME\020\000\022\022\n\016CURRENT_SEASON\020\001"
  ;
static ::_pbi::once_flag descriptor_table_ei_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_ei_2eproto = {
    false, false, 43552, descriptor_table_protodef_ei_2eproto,
    "ei.proto",
    &descriptor_table_ei_2eproto_once, nullptr, 0, 179,
    schemas, file_default_instances, TableStruct_ei_2eproto::offsets,
    file_level_metadata_ei_2eproto, file_level_enum_descriptors_ei_2eproto,
    file_level_service_descriptors_ei_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_ei_2eproto_getter() {
  return &descriptor_table_ei_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_ei_2eproto(&descriptor_table_ei_2eproto);
namespace ei {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EggIncFirstContactResponse_ErrorCodes_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ei_2eproto);
  return file_level_enum_descriptors_ei_2eproto[0];
}
bool EggIncFirstContactResponse_ErrorCodes_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr EggIncFirstContactResponse_ErrorCodes EggIncFirstContactResponse::NO_ERROR;
constexpr EggIncFirstContactResponse_ErrorCodes EggIncFirstContactResponse::EXISTING_USER_W_GAMER_ID;
constexpr EggIncFirstContactResponse_ErrorCodes EggIncFirstContactResponse::USER_NOT_FOUND;
constexpr EggIncFirstContactResponse_ErrorCodes EggIncFirstContactResponse::BACKUP_CONFLICT;
constexpr EggIncFirstContactResponse_ErrorCodes EggIncFirstContactResponse::ErrorCodes_MIN;
constexpr EggIncFirstContactResponse_ErrorCodes EggIncFirstContactResponse::ErrorCodes_MAX;
constexpr int EggIncFirstContactResponse::ErrorCodes_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GameModifier_GameDimension_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ei_2eproto);
  return file_level_enum_descriptors_ei_2eproto[1];
}
bool GameModifier_GameDimension_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr GameModifier_GameDimension GameModifier::EARNINGS;
constexpr GameModifier_GameDimension GameModifier::AWAY_EARNINGS;
constexpr GameModifier_GameDimension GameModifier::INTERNAL_HATCHERY_RATE;
constexpr GameModifier_GameDimension GameModifier::EGG_LAYING_RATE;
constexpr GameModifier_GameDimension GameModifier::SHIPPING_CAPACITY;
constexpr GameModifier_GameDimension GameModifier::HAB_CAPACITY;
constexpr GameModifier_GameDimension GameModifier::VEHICLE_COST;
constexpr GameModifier_GameDimension GameModifier::HAB_COST;
constexpr GameModifier_GameDimension GameModifier::RESEARCH_COST;
constexpr GameModifier_GameDimension GameModifier::GameDimension_MIN;
constexpr GameModifier_GameDimension GameModifier::GameDimension_MAX;
constexpr int GameModifier::GameDimension_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Contract_PlayerGrade_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ei_2eproto);
  return file_level_enum_descriptors_ei_2eproto[2];
}
bool Contract_PlayerGrade_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Contract_PlayerGrade Contract::GRADE_UNSET;
constexpr Contract_PlayerGrade Contract::GRADE_C;
constexpr Contract_PlayerGrade Contract::GRADE_B;
constexpr Contract_PlayerGrade Contract::GRADE_A;
constexpr Contract_PlayerGrade Contract::GRADE_AA;
constexpr Contract_PlayerGrade Contract::GRADE_AAA;
constexpr Contract_PlayerGrade Contract::PlayerGrade_MIN;
constexpr Contract_PlayerGrade Contract::PlayerGrade_MAX;
constexpr int Contract::PlayerGrade_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ContractPlayerInfo_Status_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ei_2eproto);
  return file_level_enum_descriptors_ei_2eproto[3];
}
bool ContractPlayerInfo_Status_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ContractPlayerInfo_Status ContractPlayerInfo::UNKNOWN;
constexpr ContractPlayerInfo_Status ContractPlayerInfo::CALCULATING;
constexpr ContractPlayerInfo_Status ContractPlayerInfo::OUT_OF_DATE;
constexpr ContractPlayerInfo_Status ContractPlayerInfo::INCOMPLETE;
constexpr ContractPlayerInfo_Status ContractPlayerInfo::COMPLETE;
constexpr ContractPlayerInfo_Status ContractPlayerInfo::Status_MIN;
constexpr ContractPlayerInfo_Status ContractPlayerInfo::Status_MAX;
constexpr int ContractPlayerInfo::Status_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ContractEvaluation_PoorBehavior_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ei_2eproto);
  return file_level_enum_descriptors_ei_2eproto[4];
}
bool ContractEvaluation_PoorBehavior_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ContractEvaluation_PoorBehavior ContractEvaluation::NONE;
constexpr ContractEvaluation_PoorBehavior ContractEvaluation::LOW_CONTRIBUTION;
constexpr ContractEvaluation_PoorBehavior ContractEvaluation::BAD_CONTRIBUTION;
constexpr ContractEvaluation_PoorBehavior ContractEvaluation::DISHONORABLY_DISCHARGED;
constexpr ContractEvaluation_PoorBehavior ContractEvaluation::POOR_TEAMWORK;
constexpr ContractEvaluation_PoorBehavior ContractEvaluation::ABANDONED_COOP;
constexpr ContractEvaluation_PoorBehavior ContractEvaluation::TIME_CHEAT;
constexpr ContractEvaluation_PoorBehavior ContractEvaluation::PoorBehavior_MIN;
constexpr ContractEvaluation_PoorBehavior ContractEvaluation::PoorBehavior_MAX;
constexpr int ContractEvaluation::PoorBehavior_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ContractEvaluation_Status_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ei_2eproto);
  return file_level_enum_descriptors_ei_2eproto[5];
}
bool ContractEvaluation_Status_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ContractEvaluation_Status ContractEvaluation::UNKNOWN;
constexpr ContractEvaluation_Status ContractEvaluation::PENDING;
constexpr ContractEvaluation_Status ContractEvaluation::EVALUATING;
constexpr ContractEvaluation_Status ContractEvaluation::COMPLETE;
constexpr ContractEvaluation_Status ContractEvaluation::Status_MIN;
constexpr ContractEvaluation_Status ContractEvaluation::Status_MAX;
constexpr int ContractEvaluation::Status_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ContractCoopStatusResponse_MemberStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ei_2eproto);
  return file_level_enum_descriptors_ei_2eproto[6];
}
bool ContractCoopStatusResponse_MemberStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ContractCoopStatusResponse_MemberStatus ContractCoopStatusResponse::VALID;
constexpr ContractCoopStatusResponse_MemberStatus ContractCoopStatusResponse::KICKED_INACTIVE;
constexpr ContractCoopStatusResponse_MemberStatus ContractCoopStatusResponse::KICKED_PRIVATE;
constexpr ContractCoopStatusResponse_MemberStatus ContractCoopStatusResponse::KICKED_CHEATS;
constexpr ContractCoopStatusResponse_MemberStatus ContractCoopStatusResponse::KICKED_LEECH;
constexpr ContractCoopStatusResponse_MemberStatus ContractCoopStatusResponse::MemberStatus_MIN;
constexpr ContractCoopStatusResponse_MemberStatus ContractCoopStatusResponse::MemberStatus_MAX;
constexpr int ContractCoopStatusResponse::MemberStatus_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ContractCoopStatusResponse_Status_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ei_2eproto);
  return file_level_enum_descriptors_ei_2eproto[7];
}
bool ContractCoopStatusResponse_Status_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ContractCoopStatusResponse_Status ContractCoopStatusResponse::UNKNOWN;
constexpr ContractCoopStatusResponse_Status ContractCoopStatusResponse::LOBBY;
constexpr ContractCoopStatusResponse_Status ContractCoopStatusResponse::ACTIVE;
constexpr ContractCoopStatusResponse_Status ContractCoopStatusResponse::COMPLETE;
constexpr ContractCoopStatusResponse_Status ContractCoopStatusResponse::FINALIZED;
constexpr ContractCoopStatusResponse_Status ContractCoopStatusResponse::Status_MIN;
constexpr ContractCoopStatusResponse_Status ContractCoopStatusResponse::Status_MAX;
constexpr int ContractCoopStatusResponse::Status_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ReportPlayerCoopRequest_Reason_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ei_2eproto);
  return file_level_enum_descriptors_ei_2eproto[8];
}
bool ReportPlayerCoopRequest_Reason_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ReportPlayerCoopRequest_Reason ReportPlayerCoopRequest::UNKNOWN;
constexpr ReportPlayerCoopRequest_Reason ReportPlayerCoopRequest::OFFENSIVE_NAME;
constexpr ReportPlayerCoopRequest_Reason ReportPlayerCoopRequest::CHEATING;
constexpr ReportPlayerCoopRequest_Reason ReportPlayerCoopRequest::LEECHING;
constexpr ReportPlayerCoopRequest_Reason ReportPlayerCoopRequest::Reason_MIN;
constexpr ReportPlayerCoopRequest_Reason ReportPlayerCoopRequest::Reason_MAX;
constexpr int ReportPlayerCoopRequest::Reason_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KickPlayerCoopRequest_Reason_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ei_2eproto);
  return file_level_enum_descriptors_ei_2eproto[9];
}
bool KickPlayerCoopRequest_Reason_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr KickPlayerCoopRequest_Reason KickPlayerCoopRequest::INVALID;
constexpr KickPlayerCoopRequest_Reason KickPlayerCoopRequest::CHEATER;
constexpr KickPlayerCoopRequest_Reason KickPlayerCoopRequest::IDLE;
constexpr KickPlayerCoopRequest_Reason KickPlayerCoopRequest::LEECH;
constexpr KickPlayerCoopRequest_Reason KickPlayerCoopRequest::PRIVATE;
constexpr KickPlayerCoopRequest_Reason KickPlayerCoopRequest::Reason_MIN;
constexpr KickPlayerCoopRequest_Reason KickPlayerCoopRequest::Reason_MAX;
constexpr int KickPlayerCoopRequest::Reason_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MissionInfo_Spaceship_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ei_2eproto);
  return file_level_enum_descriptors_ei_2eproto[10];
}
bool MissionInfo_Spaceship_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr MissionInfo_Spaceship MissionInfo::CHICKEN_ONE;
constexpr MissionInfo_Spaceship MissionInfo::CHICKEN_NINE;
constexpr MissionInfo_Spaceship MissionInfo::CHICKEN_HEAVY;
constexpr MissionInfo_Spaceship MissionInfo::BCR;
constexpr MissionInfo_Spaceship MissionInfo::MILLENIUM_CHICKEN;
constexpr MissionInfo_Spaceship MissionInfo::CORELLIHEN_CORVETTE;
constexpr MissionInfo_Spaceship MissionInfo::GALEGGTICA;
constexpr MissionInfo_Spaceship MissionInfo::CHICKFIANT;
constexpr MissionInfo_Spaceship MissionInfo::VOYEGGER;
constexpr MissionInfo_Spaceship MissionInfo::HENERPRISE;
constexpr MissionInfo_Spaceship MissionInfo::Spaceship_MIN;
constexpr MissionInfo_Spaceship MissionInfo::Spaceship_MAX;
constexpr int MissionInfo::Spaceship_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MissionInfo_Status_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ei_2eproto);
  return file_level_enum_descriptors_ei_2eproto[11];
}
bool MissionInfo_Status_IsValid(int value) {
  switch (value) {
    case 0:
    case 5:
    case 10:
    case 15:
    case 16:
    case 20:
    case 25:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr MissionInfo_Status MissionInfo::FUELING;
constexpr MissionInfo_Status MissionInfo::PREPARE_TO_LAUNCH;
constexpr MissionInfo_Status MissionInfo::EXPLORING;
constexpr MissionInfo_Status MissionInfo::RETURNED;
constexpr MissionInfo_Status MissionInfo::ANALYZING;
constexpr MissionInfo_Status MissionInfo::COMPLETE;
constexpr MissionInfo_Status MissionInfo::ARCHIVED;
constexpr MissionInfo_Status MissionInfo::Status_MIN;
constexpr MissionInfo_Status MissionInfo::Status_MAX;
constexpr int MissionInfo::Status_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MissionInfo_DurationType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ei_2eproto);
  return file_level_enum_descriptors_ei_2eproto[12];
}
bool MissionInfo_DurationType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr MissionInfo_DurationType MissionInfo::SHORT;
constexpr MissionInfo_DurationType MissionInfo::LONG;
constexpr MissionInfo_DurationType MissionInfo::EPIC;
constexpr MissionInfo_DurationType MissionInfo::TUTORIAL;
constexpr MissionInfo_DurationType MissionInfo::DurationType_MIN;
constexpr MissionInfo_DurationType MissionInfo::DurationType_MAX;
constexpr int MissionInfo::DurationType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ArtifactSpec_Name_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ei_2eproto);
  return file_level_enum_descriptors_ei_2eproto[13];
}
bool ArtifactSpec_Name_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 10000:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ArtifactSpec_Name ArtifactSpec::LUNAR_TOTEM;
constexpr ArtifactSpec_Name ArtifactSpec::NEODYMIUM_MEDALLION;
constexpr ArtifactSpec_Name ArtifactSpec::BEAK_OF_MIDAS;
constexpr ArtifactSpec_Name ArtifactSpec::LIGHT_OF_EGGENDIL;
constexpr ArtifactSpec_Name ArtifactSpec::DEMETERS_NECKLACE;
constexpr ArtifactSpec_Name ArtifactSpec::VIAL_MARTIAN_DUST;
constexpr ArtifactSpec_Name ArtifactSpec::ORNATE_GUSSET;
constexpr ArtifactSpec_Name ArtifactSpec::THE_CHALICE;
constexpr ArtifactSpec_Name ArtifactSpec::BOOK_OF_BASAN;
constexpr ArtifactSpec_Name ArtifactSpec::PHOENIX_FEATHER;
constexpr ArtifactSpec_Name ArtifactSpec::TUNGSTEN_ANKH;
constexpr ArtifactSpec_Name ArtifactSpec::AURELIAN_BROOCH;
constexpr ArtifactSpec_Name ArtifactSpec::CARVED_RAINSTICK;
constexpr ArtifactSpec_Name ArtifactSpec::PUZZLE_CUBE;
constexpr ArtifactSpec_Name ArtifactSpec::QUANTUM_METRONOME;
constexpr ArtifactSpec_Name ArtifactSpec::SHIP_IN_A_BOTTLE;
constexpr ArtifactSpec_Name ArtifactSpec::TACHYON_DEFLECTOR;
constexpr ArtifactSpec_Name ArtifactSpec::INTERSTELLAR_COMPASS;
constexpr ArtifactSpec_Name ArtifactSpec::DILITHIUM_MONOCLE;
constexpr ArtifactSpec_Name ArtifactSpec::TITANIUM_ACTUATOR;
constexpr ArtifactSpec_Name ArtifactSpec::MERCURYS_LENS;
constexpr ArtifactSpec_Name ArtifactSpec::TACHYON_STONE;
constexpr ArtifactSpec_Name ArtifactSpec::DILITHIUM_STONE;
constexpr ArtifactSpec_Name ArtifactSpec::SHELL_STONE;
constexpr ArtifactSpec_Name ArtifactSpec::LUNAR_STONE;
constexpr ArtifactSpec_Name ArtifactSpec::SOUL_STONE;
constexpr ArtifactSpec_Name ArtifactSpec::PROPHECY_STONE;
constexpr ArtifactSpec_Name ArtifactSpec::QUANTUM_STONE;
constexpr ArtifactSpec_Name ArtifactSpec::TERRA_STONE;
constexpr ArtifactSpec_Name ArtifactSpec::LIFE_STONE;
constexpr ArtifactSpec_Name ArtifactSpec::CLARITY_STONE;
constexpr ArtifactSpec_Name ArtifactSpec::EXTRATERRESTRIAL_ALUMINUM;
constexpr ArtifactSpec_Name ArtifactSpec::ANCIENT_TUNGSTEN;
constexpr ArtifactSpec_Name ArtifactSpec::SPACE_ROCKS;
constexpr ArtifactSpec_Name ArtifactSpec::ALIEN_WOOD;
constexpr ArtifactSpec_Name ArtifactSpec::GOLD_METEORITE;
constexpr ArtifactSpec_Name ArtifactSpec::TAU_CETI_GEODE;
constexpr ArtifactSpec_Name ArtifactSpec::CENTAURIAN_STEEL;
constexpr ArtifactSpec_Name ArtifactSpec::ERIDANI_FEATHER;
constexpr ArtifactSpec_Name ArtifactSpec::DRONE_PARTS;
constexpr ArtifactSpec_Name ArtifactSpec::CELESTIAL_BRONZE;
constexpr ArtifactSpec_Name ArtifactSpec::LALANDE_HIDE;
constexpr ArtifactSpec_Name ArtifactSpec::SOLAR_TITANIUM;
constexpr ArtifactSpec_Name ArtifactSpec::TACHYON_STONE_FRAGMENT;
constexpr ArtifactSpec_Name ArtifactSpec::DILITHIUM_STONE_FRAGMENT;
constexpr ArtifactSpec_Name ArtifactSpec::SHELL_STONE_FRAGMENT;
constexpr ArtifactSpec_Name ArtifactSpec::LUNAR_STONE_FRAGMENT;
constexpr ArtifactSpec_Name ArtifactSpec::SOUL_STONE_FRAGMENT;
constexpr ArtifactSpec_Name ArtifactSpec::PROPHECY_STONE_FRAGMENT;
constexpr ArtifactSpec_Name ArtifactSpec::QUANTUM_STONE_FRAGMENT;
constexpr ArtifactSpec_Name ArtifactSpec::TERRA_STONE_FRAGMENT;
constexpr ArtifactSpec_Name ArtifactSpec::LIFE_STONE_FRAGMENT;
constexpr ArtifactSpec_Name ArtifactSpec::CLARITY_STONE_FRAGMENT;
constexpr ArtifactSpec_Name ArtifactSpec::UNKNOWN;
constexpr ArtifactSpec_Name ArtifactSpec::Name_MIN;
constexpr ArtifactSpec_Name ArtifactSpec::Name_MAX;
constexpr int ArtifactSpec::Name_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ArtifactSpec_Level_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ei_2eproto);
  return file_level_enum_descriptors_ei_2eproto[14];
}
bool ArtifactSpec_Level_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ArtifactSpec_Level ArtifactSpec::INFERIOR;
constexpr ArtifactSpec_Level ArtifactSpec::LESSER;
constexpr ArtifactSpec_Level ArtifactSpec::NORMAL;
constexpr ArtifactSpec_Level ArtifactSpec::GREATER;
constexpr ArtifactSpec_Level ArtifactSpec::SUPERIOR;
constexpr ArtifactSpec_Level ArtifactSpec::Level_MIN;
constexpr ArtifactSpec_Level ArtifactSpec::Level_MAX;
constexpr int ArtifactSpec::Level_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ArtifactSpec_Rarity_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ei_2eproto);
  return file_level_enum_descriptors_ei_2eproto[15];
}
bool ArtifactSpec_Rarity_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ArtifactSpec_Rarity ArtifactSpec::COMMON;
constexpr ArtifactSpec_Rarity ArtifactSpec::RARE;
constexpr ArtifactSpec_Rarity ArtifactSpec::EPIC;
constexpr ArtifactSpec_Rarity ArtifactSpec::LEGENDARY;
constexpr ArtifactSpec_Rarity ArtifactSpec::Rarity_MIN;
constexpr ArtifactSpec_Rarity ArtifactSpec::Rarity_MAX;
constexpr int ArtifactSpec::Rarity_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ArtifactSpec_Type_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ei_2eproto);
  return file_level_enum_descriptors_ei_2eproto[16];
}
bool ArtifactSpec_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ArtifactSpec_Type ArtifactSpec::ARTIFACT;
constexpr ArtifactSpec_Type ArtifactSpec::STONE;
constexpr ArtifactSpec_Type ArtifactSpec::INGREDIENT;
constexpr ArtifactSpec_Type ArtifactSpec::STONE_INGREDIENT;
constexpr ArtifactSpec_Type ArtifactSpec::Type_MIN;
constexpr ArtifactSpec_Type ArtifactSpec::Type_MAX;
constexpr int ArtifactSpec::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SaveBackupResponse_ErrorCodes_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ei_2eproto);
  return file_level_enum_descriptors_ei_2eproto[17];
}
bool SaveBackupResponse_ErrorCodes_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SaveBackupResponse_ErrorCodes SaveBackupResponse::NO_ERROR;
constexpr SaveBackupResponse_ErrorCodes SaveBackupResponse::USER_NOT_FOUND;
constexpr SaveBackupResponse_ErrorCodes SaveBackupResponse::COULD_NOT_OVERWRITE;
constexpr SaveBackupResponse_ErrorCodes SaveBackupResponse::BACKUP_OFFERED;
constexpr SaveBackupResponse_ErrorCodes SaveBackupResponse::BAD_USER_ID;
constexpr SaveBackupResponse_ErrorCodes SaveBackupResponse::ErrorCodes_MIN;
constexpr SaveBackupResponse_ErrorCodes SaveBackupResponse::ErrorCodes_MAX;
constexpr int SaveBackupResponse::ErrorCodes_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ShellSpec_AssetType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ei_2eproto);
  return file_level_enum_descriptors_ei_2eproto[18];
}
bool ShellSpec_AssetType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 59:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 110:
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 120:
    case 121:
    case 122:
    case 123:
    case 124:
    case 125:
    case 126:
    case 127:
    case 128:
    case 129:
    case 130:
    case 131:
    case 132:
    case 133:
    case 134:
    case 135:
    case 136:
    case 137:
    case 138:
    case 139:
    case 140:
    case 141:
    case 142:
    case 143:
    case 170:
    case 171:
    case 172:
    case 180:
    case 181:
    case 182:
    case 200:
    case 201:
    case 202:
    case 203:
    case 500:
    case 501:
    case 502:
    case 505:
    case 506:
    case 507:
    case 510:
    case 511:
    case 512:
    case 513:
    case 515:
    case 516:
    case 520:
    case 570:
    case 600:
    case 1000:
    case 1010:
    case 9999:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ShellSpec_AssetType ShellSpec::COOP;
constexpr ShellSpec_AssetType ShellSpec::SHACK;
constexpr ShellSpec_AssetType ShellSpec::SUPER_SHACK;
constexpr ShellSpec_AssetType ShellSpec::SHORT_HOUSE;
constexpr ShellSpec_AssetType ShellSpec::THE_STANDARD;
constexpr ShellSpec_AssetType ShellSpec::LONG_HOUSE;
constexpr ShellSpec_AssetType ShellSpec::DOUBLE_DECKER;
constexpr ShellSpec_AssetType ShellSpec::WAREHOUSE;
constexpr ShellSpec_AssetType ShellSpec::CENTER;
constexpr ShellSpec_AssetType ShellSpec::BUNKER;
constexpr ShellSpec_AssetType ShellSpec::EGGKEA;
constexpr ShellSpec_AssetType ShellSpec::HAB_1K;
constexpr ShellSpec_AssetType ShellSpec::HANGAR;
constexpr ShellSpec_AssetType ShellSpec::TOWER;
constexpr ShellSpec_AssetType ShellSpec::HAB_10K;
constexpr ShellSpec_AssetType ShellSpec::EGGTOPIA;
constexpr ShellSpec_AssetType ShellSpec::MONOLITH;
constexpr ShellSpec_AssetType ShellSpec::PLANET_PORTAL;
constexpr ShellSpec_AssetType ShellSpec::CHICKEN_UNIVERSE;
constexpr ShellSpec_AssetType ShellSpec::SILO_0_SMALL;
constexpr ShellSpec_AssetType ShellSpec::SILO_0_MED;
constexpr ShellSpec_AssetType ShellSpec::SILO_0_LARGE;
constexpr ShellSpec_AssetType ShellSpec::SILO_1_SMALL;
constexpr ShellSpec_AssetType ShellSpec::SILO_1_MED;
constexpr ShellSpec_AssetType ShellSpec::SILO_1_LARGE;
constexpr ShellSpec_AssetType ShellSpec::SILO_ALL;
constexpr ShellSpec_AssetType ShellSpec::MAILBOX;
constexpr ShellSpec_AssetType ShellSpec::TROPHY_CASE;
constexpr ShellSpec_AssetType ShellSpec::GROUND;
constexpr ShellSpec_AssetType ShellSpec::HARDSCAPE;
constexpr ShellSpec_AssetType ShellSpec::HYPERLOOP;
constexpr ShellSpec_AssetType ShellSpec::DEPOT_1;
constexpr ShellSpec_AssetType ShellSpec::DEPOT_2;
constexpr ShellSpec_AssetType ShellSpec::DEPOT_3;
constexpr ShellSpec_AssetType ShellSpec::DEPOT_4;
constexpr ShellSpec_AssetType ShellSpec::DEPOT_5;
constexpr ShellSpec_AssetType ShellSpec::DEPOT_6;
constexpr ShellSpec_AssetType ShellSpec::DEPOT_7;
constexpr ShellSpec_AssetType ShellSpec::LAB_1;
constexpr ShellSpec_AssetType ShellSpec::LAB_2;
constexpr ShellSpec_AssetType ShellSpec::LAB_3;
constexpr ShellSpec_AssetType ShellSpec::LAB_4;
constexpr ShellSpec_AssetType ShellSpec::LAB_5;
constexpr ShellSpec_AssetType ShellSpec::LAB_6;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_EDIBLE;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_SUPERFOOD;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_MEDICAL;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_ROCKET_FUEL;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_SUPERMATERIAL;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_FUSION;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_QUANTUM;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_IMMORTALITY;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_TACHYON;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_GRAVITON;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_DILITHIUM;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_PRODIGY;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_TERRAFORM;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_ANTIMATTER;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_DARK_MATTER;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_AI;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_NEBULA;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_UNIVERSE;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_ENLIGHTENMENT;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_CHOCOLATE;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_EASTER;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_WATERBALLOON;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_FIREWORK;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_PUMPKIN;
constexpr ShellSpec_AssetType ShellSpec::HOA_1;
constexpr ShellSpec_AssetType ShellSpec::HOA_2;
constexpr ShellSpec_AssetType ShellSpec::HOA_3;
constexpr ShellSpec_AssetType ShellSpec::MISSION_CONTROL_1;
constexpr ShellSpec_AssetType ShellSpec::MISSION_CONTROL_2;
constexpr ShellSpec_AssetType ShellSpec::MISSION_CONTROL_3;
constexpr ShellSpec_AssetType ShellSpec::FUEL_TANK_1;
constexpr ShellSpec_AssetType ShellSpec::FUEL_TANK_2;
constexpr ShellSpec_AssetType ShellSpec::FUEL_TANK_3;
constexpr ShellSpec_AssetType ShellSpec::FUEL_TANK_4;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_GRAVITON_TOP;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_NEBULA_MIDDLE;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_NEBULA_TOP;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_DARK_MATTER_RING_1;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_DARK_MATTER_RING_2;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_DARK_MATTER_RING_3;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_AI_TOP_1;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_AI_TOP_2;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_AI_TOP_3;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_AI_TOP_4;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_UNIVERSE_PROBE;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_UNIVERSE_BOLT;
constexpr ShellSpec_AssetType ShellSpec::HATCHERY_ENLIGHTENMENT_ORB;
constexpr ShellSpec_AssetType ShellSpec::HYPERLOOP_TRACK;
constexpr ShellSpec_AssetType ShellSpec::MAILBOX_FULL;
constexpr ShellSpec_AssetType ShellSpec::CHICKEN;
constexpr ShellSpec_AssetType ShellSpec::HAT;
constexpr ShellSpec_AssetType ShellSpec::UNKNOWN;
constexpr ShellSpec_AssetType ShellSpec::AssetType_MIN;
constexpr ShellSpec_AssetType ShellSpec::AssetType_MAX;
constexpr int ShellSpec::AssetType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ShellObjectSpec_ChickenAnimation_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ei_2eproto);
  return file_level_enum_descriptors_ei_2eproto[19];
}
bool ShellObjectSpec_ChickenAnimation_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ShellObjectSpec_ChickenAnimation ShellObjectSpec::STANDARD_RUN;
constexpr ShellObjectSpec_ChickenAnimation ShellObjectSpec::SLOWMO;
constexpr ShellObjectSpec_ChickenAnimation ShellObjectSpec::WOBBLE;
constexpr ShellObjectSpec_ChickenAnimation ShellObjectSpec::WOBBLE_LEAN;
constexpr ShellObjectSpec_ChickenAnimation ShellObjectSpec::SMOOTH;
constexpr ShellObjectSpec_ChickenAnimation ShellObjectSpec::SMOOTH_LEAN;
constexpr ShellObjectSpec_ChickenAnimation ShellObjectSpec::HOVER;
constexpr ShellObjectSpec_ChickenAnimation ShellObjectSpec::SIDEWAYS_SMOOTH;
constexpr ShellObjectSpec_ChickenAnimation ShellObjectSpec::SIDEWAYS_LEAN;
constexpr ShellObjectSpec_ChickenAnimation ShellObjectSpec::ChickenAnimation_MIN;
constexpr ShellObjectSpec_ChickenAnimation ShellObjectSpec::ChickenAnimation_MAX;
constexpr int ShellObjectSpec::ChickenAnimation_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ShellDB_FarmElement_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ei_2eproto);
  return file_level_enum_descriptors_ei_2eproto[20];
}
bool ShellDB_FarmElement_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 99:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ShellDB_FarmElement ShellDB::HEN_HOUSE;
constexpr ShellDB_FarmElement ShellDB::SILO;
constexpr ShellDB_FarmElement ShellDB::MAILBOX;
constexpr ShellDB_FarmElement ShellDB::TROPHY_CASE;
constexpr ShellDB_FarmElement ShellDB::GROUND;
constexpr ShellDB_FarmElement ShellDB::HARDSCAPE;
constexpr ShellDB_FarmElement ShellDB::HYPERLOOP;
constexpr ShellDB_FarmElement ShellDB::DEPOT;
constexpr ShellDB_FarmElement ShellDB::LAB;
constexpr ShellDB_FarmElement ShellDB::HATCHERY;
constexpr ShellDB_FarmElement ShellDB::HOA;
constexpr ShellDB_FarmElement ShellDB::MISSION_CONTROL;
constexpr ShellDB_FarmElement ShellDB::FUEL_TANK;
constexpr ShellDB_FarmElement ShellDB::CHICKEN;
constexpr ShellDB_FarmElement ShellDB::HAT;
constexpr ShellDB_FarmElement ShellDB::UNKNOWN;
constexpr ShellDB_FarmElement ShellDB::FarmElement_MIN;
constexpr ShellDB_FarmElement ShellDB::FarmElement_MAX;
constexpr int ShellDB::FarmElement_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UserVerificationAnalysis_Status_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ei_2eproto);
  return file_level_enum_descriptors_ei_2eproto[21];
}
bool UserVerificationAnalysis_Status_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr UserVerificationAnalysis_Status UserVerificationAnalysis::UNKNOWN;
constexpr UserVerificationAnalysis_Status UserVerificationAnalysis::PROCESSING;
constexpr UserVerificationAnalysis_Status UserVerificationAnalysis::COMPLETE;
constexpr UserVerificationAnalysis_Status UserVerificationAnalysis::Status_MIN;
constexpr UserVerificationAnalysis_Status UserVerificationAnalysis::Status_MAX;
constexpr int UserVerificationAnalysis::Status_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UserSubscriptionInfo_Level_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ei_2eproto);
  return file_level_enum_descriptors_ei_2eproto[22];
}
bool UserSubscriptionInfo_Level_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr UserSubscriptionInfo_Level UserSubscriptionInfo::STANDARD;
constexpr UserSubscriptionInfo_Level UserSubscriptionInfo::PRO;
constexpr UserSubscriptionInfo_Level UserSubscriptionInfo::Level_MIN;
constexpr UserSubscriptionInfo_Level UserSubscriptionInfo::Level_MAX;
constexpr int UserSubscriptionInfo::Level_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UserSubscriptionInfo_Status_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ei_2eproto);
  return file_level_enum_descriptors_ei_2eproto[23];
}
bool UserSubscriptionInfo_Status_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr UserSubscriptionInfo_Status UserSubscriptionInfo::UNKNOWN;
constexpr UserSubscriptionInfo_Status UserSubscriptionInfo::ACTIVE;
constexpr UserSubscriptionInfo_Status UserSubscriptionInfo::EXPIRED;
constexpr UserSubscriptionInfo_Status UserSubscriptionInfo::REVOKED;
constexpr UserSubscriptionInfo_Status UserSubscriptionInfo::GRACE_PERIOD;
constexpr UserSubscriptionInfo_Status UserSubscriptionInfo::PAUSE_HOLD;
constexpr UserSubscriptionInfo_Status UserSubscriptionInfo::Status_MIN;
constexpr UserSubscriptionInfo_Status UserSubscriptionInfo::Status_MAX;
constexpr int UserSubscriptionInfo::Status_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Platform_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ei_2eproto);
  return file_level_enum_descriptors_ei_2eproto[24];
}
bool Platform_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DeviceFormFactor_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ei_2eproto);
  return file_level_enum_descriptors_ei_2eproto[25];
}
bool DeviceFormFactor_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AdNetwork_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ei_2eproto);
  return file_level_enum_descriptors_ei_2eproto[26];
}
bool AdNetwork_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Egg_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ei_2eproto);
  return file_level_enum_descriptors_ei_2eproto[27];
}
bool Egg_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 1000:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FarmType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ei_2eproto);
  return file_level_enum_descriptors_ei_2eproto[28];
}
bool FarmType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GoalType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ei_2eproto);
  return file_level_enum_descriptors_ei_2eproto[29];
}
bool GoalType_IsValid(int value) {
  switch (value) {
    case 1:
    case 100:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RewardType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ei_2eproto);
  return file_level_enum_descriptors_ei_2eproto[30];
}
bool RewardType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 100:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LeaderboardScope_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ei_2eproto);
  return file_level_enum_descriptors_ei_2eproto[31];
}
bool LeaderboardScope_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class Backup_Settings::_Internal {
 public:
  using HasBits = decltype(std::declval<Backup_Settings>()._has_bits_);
  static void set_has_sfx(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_music(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_low_battery_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_low_performance_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_force_touch_chicken_btn(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_notifications_queried(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_notifications_on(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_notify_daily_gift(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_coppa_queried(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_coppa_restricted(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_gdpr_consent_queried(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_gdpr_age_restricted(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_gdpr_consent_given(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_age_queried(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_age_restricted(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_data_collection_consent_queried(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_data_collection_consent_given(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_last_day_age_queried(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_user_ads_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_user_cloud_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_user_analytics_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_user_personalized_ads_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_low_performance(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_auto_stop_fueling(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_last_backup_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
};

Backup_Settings::Backup_Settings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.Backup.Settings)
}
Backup_Settings::Backup_Settings(const Backup_Settings& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&sfx_, &from.sfx_,
    static_cast<size_t>(reinterpret_cast<char*>(&user_personalized_ads_enabled_) -
    reinterpret_cast<char*>(&sfx_)) + sizeof(user_personalized_ads_enabled_));
  // @@protoc_insertion_point(copy_constructor:ei.Backup.Settings)
}

inline void Backup_Settings::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sfx_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&last_backup_time_) -
    reinterpret_cast<char*>(&sfx_)) + sizeof(last_backup_time_));
user_ads_enabled_ = true;
user_cloud_enabled_ = true;
user_analytics_enabled_ = true;
user_personalized_ads_enabled_ = true;
}

Backup_Settings::~Backup_Settings() {
  // @@protoc_insertion_point(destructor:ei.Backup.Settings)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Backup_Settings::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Backup_Settings::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Backup_Settings::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.Backup.Settings)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&sfx_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&notify_daily_gift_) -
        reinterpret_cast<char*>(&sfx_)) + sizeof(notify_daily_gift_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&coppa_queried_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&age_restricted_) -
        reinterpret_cast<char*>(&coppa_queried_)) + sizeof(age_restricted_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&data_collection_consent_queried_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&last_backup_time_) -
        reinterpret_cast<char*>(&data_collection_consent_queried_)) + sizeof(last_backup_time_));
    user_ads_enabled_ = true;
    user_cloud_enabled_ = true;
    user_analytics_enabled_ = true;
  }
  user_personalized_ads_enabled_ = true;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Backup_Settings::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool sfx = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_sfx(&has_bits);
          sfx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool music = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_music(&has_bits);
          music_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool low_battery_mode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_low_battery_mode(&has_bits);
          low_battery_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool low_performance_mode = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_low_performance_mode(&has_bits);
          low_performance_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool notifications_queried = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_notifications_queried(&has_bits);
          notifications_queried_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool notifications_on = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_notifications_on(&has_bits);
          notifications_on_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool coppa_queried = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_coppa_queried(&has_bits);
          coppa_queried_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool coppa_restricted = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_coppa_restricted(&has_bits);
          coppa_restricted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool force_touch_chicken_btn = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_force_touch_chicken_btn(&has_bits);
          force_touch_chicken_btn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool low_performance = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_low_performance(&has_bits);
          low_performance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool notify_daily_gift = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_notify_daily_gift(&has_bits);
          notify_daily_gift_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool gdpr_consent_queried = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_gdpr_consent_queried(&has_bits);
          gdpr_consent_queried_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool gdpr_consent_given = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_gdpr_consent_given(&has_bits);
          gdpr_consent_given_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool user_ads_enabled = 14 [default = true];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_user_ads_enabled(&has_bits);
          user_ads_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool user_cloud_enabled = 15 [default = true];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_user_cloud_enabled(&has_bits);
          user_cloud_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool gdpr_age_restricted = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_gdpr_age_restricted(&has_bits);
          gdpr_age_restricted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 last_day_age_queried = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_last_day_age_queried(&has_bits);
          last_day_age_queried_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool age_queried = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_age_queried(&has_bits);
          age_queried_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool age_restricted = 19 [default = false];
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_age_restricted(&has_bits);
          age_restricted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool data_collection_consent_queried = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_data_collection_consent_queried(&has_bits);
          data_collection_consent_queried_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool data_collection_consent_given = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_data_collection_consent_given(&has_bits);
          data_collection_consent_given_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool user_analytics_enabled = 22 [default = true];
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_user_analytics_enabled(&has_bits);
          user_analytics_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool user_personalized_ads_enabled = 23 [default = true];
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_user_personalized_ads_enabled(&has_bits);
          user_personalized_ads_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double last_backup_time = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 193)) {
          _Internal::set_has_last_backup_time(&has_bits);
          last_backup_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool auto_stop_fueling = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_auto_stop_fueling(&has_bits);
          auto_stop_fueling_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Backup_Settings::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.Backup.Settings)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool sfx = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_sfx(), target);
  }

  // optional bool music = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_music(), target);
  }

  // optional bool low_battery_mode = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_low_battery_mode(), target);
  }

  // optional bool low_performance_mode = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_low_performance_mode(), target);
  }

  // optional bool notifications_queried = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_notifications_queried(), target);
  }

  // optional bool notifications_on = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_notifications_on(), target);
  }

  // optional bool coppa_queried = 7;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_coppa_queried(), target);
  }

  // optional bool coppa_restricted = 8;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_coppa_restricted(), target);
  }

  // optional bool force_touch_chicken_btn = 9;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_force_touch_chicken_btn(), target);
  }

  // optional bool low_performance = 10;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_low_performance(), target);
  }

  // optional bool notify_daily_gift = 11;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_notify_daily_gift(), target);
  }

  // optional bool gdpr_consent_queried = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_gdpr_consent_queried(), target);
  }

  // optional bool gdpr_consent_given = 13;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_gdpr_consent_given(), target);
  }

  // optional bool user_ads_enabled = 14 [default = true];
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_user_ads_enabled(), target);
  }

  // optional bool user_cloud_enabled = 15 [default = true];
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_user_cloud_enabled(), target);
  }

  // optional bool gdpr_age_restricted = 16;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_gdpr_age_restricted(), target);
  }

  // optional uint32 last_day_age_queried = 17;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(17, this->_internal_last_day_age_queried(), target);
  }

  // optional bool age_queried = 18;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(18, this->_internal_age_queried(), target);
  }

  // optional bool age_restricted = 19 [default = false];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(19, this->_internal_age_restricted(), target);
  }

  // optional bool data_collection_consent_queried = 20;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(20, this->_internal_data_collection_consent_queried(), target);
  }

  // optional bool data_collection_consent_given = 21;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(21, this->_internal_data_collection_consent_given(), target);
  }

  // optional bool user_analytics_enabled = 22 [default = true];
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(22, this->_internal_user_analytics_enabled(), target);
  }

  // optional bool user_personalized_ads_enabled = 23 [default = true];
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(23, this->_internal_user_personalized_ads_enabled(), target);
  }

  // optional double last_backup_time = 24;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(24, this->_internal_last_backup_time(), target);
  }

  // optional bool auto_stop_fueling = 25;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(25, this->_internal_auto_stop_fueling(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.Backup.Settings)
  return target;
}

size_t Backup_Settings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.Backup.Settings)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bool sfx = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool music = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool low_battery_mode = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool low_performance_mode = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool force_touch_chicken_btn = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool notifications_queried = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool notifications_on = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool notify_daily_gift = 11;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool coppa_queried = 7;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool coppa_restricted = 8;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool gdpr_consent_queried = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool gdpr_age_restricted = 16;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 + 1;
    }

    // optional uint32 last_day_age_queried = 17;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_last_day_age_queried());
    }

    // optional bool gdpr_consent_given = 13;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional bool age_queried = 18;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 1;
    }

    // optional bool age_restricted = 19 [default = false];
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional bool data_collection_consent_queried = 20;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 1;
    }

    // optional bool data_collection_consent_given = 21;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 1;
    }

    // optional bool low_performance = 10;
    if (cached_has_bits & 0x00040000u) {
      total_size += 1 + 1;
    }

    // optional bool auto_stop_fueling = 25;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 1;
    }

    // optional double last_backup_time = 24;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 8;
    }

    // optional bool user_ads_enabled = 14 [default = true];
    if (cached_has_bits & 0x00200000u) {
      total_size += 1 + 1;
    }

    // optional bool user_cloud_enabled = 15 [default = true];
    if (cached_has_bits & 0x00400000u) {
      total_size += 1 + 1;
    }

    // optional bool user_analytics_enabled = 22 [default = true];
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 1;
    }

  }
  // optional bool user_personalized_ads_enabled = 23 [default = true];
  if (cached_has_bits & 0x01000000u) {
    total_size += 2 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Backup_Settings::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Backup_Settings::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Backup_Settings::GetClassData() const { return &_class_data_; }

void Backup_Settings::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Backup_Settings *>(to)->MergeFrom(
      static_cast<const Backup_Settings &>(from));
}


void Backup_Settings::MergeFrom(const Backup_Settings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.Backup.Settings)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      sfx_ = from.sfx_;
    }
    if (cached_has_bits & 0x00000002u) {
      music_ = from.music_;
    }
    if (cached_has_bits & 0x00000004u) {
      low_battery_mode_ = from.low_battery_mode_;
    }
    if (cached_has_bits & 0x00000008u) {
      low_performance_mode_ = from.low_performance_mode_;
    }
    if (cached_has_bits & 0x00000010u) {
      force_touch_chicken_btn_ = from.force_touch_chicken_btn_;
    }
    if (cached_has_bits & 0x00000020u) {
      notifications_queried_ = from.notifications_queried_;
    }
    if (cached_has_bits & 0x00000040u) {
      notifications_on_ = from.notifications_on_;
    }
    if (cached_has_bits & 0x00000080u) {
      notify_daily_gift_ = from.notify_daily_gift_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      coppa_queried_ = from.coppa_queried_;
    }
    if (cached_has_bits & 0x00000200u) {
      coppa_restricted_ = from.coppa_restricted_;
    }
    if (cached_has_bits & 0x00000400u) {
      gdpr_consent_queried_ = from.gdpr_consent_queried_;
    }
    if (cached_has_bits & 0x00000800u) {
      gdpr_age_restricted_ = from.gdpr_age_restricted_;
    }
    if (cached_has_bits & 0x00001000u) {
      last_day_age_queried_ = from.last_day_age_queried_;
    }
    if (cached_has_bits & 0x00002000u) {
      gdpr_consent_given_ = from.gdpr_consent_given_;
    }
    if (cached_has_bits & 0x00004000u) {
      age_queried_ = from.age_queried_;
    }
    if (cached_has_bits & 0x00008000u) {
      age_restricted_ = from.age_restricted_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      data_collection_consent_queried_ = from.data_collection_consent_queried_;
    }
    if (cached_has_bits & 0x00020000u) {
      data_collection_consent_given_ = from.data_collection_consent_given_;
    }
    if (cached_has_bits & 0x00040000u) {
      low_performance_ = from.low_performance_;
    }
    if (cached_has_bits & 0x00080000u) {
      auto_stop_fueling_ = from.auto_stop_fueling_;
    }
    if (cached_has_bits & 0x00100000u) {
      last_backup_time_ = from.last_backup_time_;
    }
    if (cached_has_bits & 0x00200000u) {
      user_ads_enabled_ = from.user_ads_enabled_;
    }
    if (cached_has_bits & 0x00400000u) {
      user_cloud_enabled_ = from.user_cloud_enabled_;
    }
    if (cached_has_bits & 0x00800000u) {
      user_analytics_enabled_ = from.user_analytics_enabled_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x01000000u) {
    _internal_set_user_personalized_ads_enabled(from._internal_user_personalized_ads_enabled());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Backup_Settings::CopyFrom(const Backup_Settings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.Backup.Settings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Backup_Settings::IsInitialized() const {
  return true;
}

void Backup_Settings::InternalSwap(Backup_Settings* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Backup_Settings, last_backup_time_)
      + sizeof(Backup_Settings::last_backup_time_)
      - PROTOBUF_FIELD_OFFSET(Backup_Settings, sfx_)>(
          reinterpret_cast<char*>(&sfx_),
          reinterpret_cast<char*>(&other->sfx_));
  swap(user_ads_enabled_, other->user_ads_enabled_);
  swap(user_cloud_enabled_, other->user_cloud_enabled_);
  swap(user_analytics_enabled_, other->user_analytics_enabled_);
  swap(user_personalized_ads_enabled_, other->user_personalized_ads_enabled_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Backup_Settings::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[0]);
}

// ===================================================================

class Backup_Tutorial::_Internal {
 public:
  using HasBits = decltype(std::declval<Backup_Tutorial>()._has_bits_);
  static void set_has_intro_shown(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_click_tutorial_shown(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_buy_hab_shown(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_hire_vehicle_shown(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_q_num_shown(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_s_num_shown(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_contracts_tab_shown(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_contract_info_shown(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_join_coop_shown(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_switch_farm_shown(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

Backup_Tutorial::Backup_Tutorial(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  tutorial_shown_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.Backup.Tutorial)
}
Backup_Tutorial::Backup_Tutorial(const Backup_Tutorial& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      tutorial_shown_(from.tutorial_shown_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&intro_shown_, &from.intro_shown_,
    static_cast<size_t>(reinterpret_cast<char*>(&switch_farm_shown_) -
    reinterpret_cast<char*>(&intro_shown_)) + sizeof(switch_farm_shown_));
  // @@protoc_insertion_point(copy_constructor:ei.Backup.Tutorial)
}

inline void Backup_Tutorial::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&intro_shown_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&switch_farm_shown_) -
    reinterpret_cast<char*>(&intro_shown_)) + sizeof(switch_farm_shown_));
}

Backup_Tutorial::~Backup_Tutorial() {
  // @@protoc_insertion_point(destructor:ei.Backup.Tutorial)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Backup_Tutorial::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Backup_Tutorial::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Backup_Tutorial::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.Backup.Tutorial)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  tutorial_shown_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&intro_shown_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&contract_info_shown_) -
        reinterpret_cast<char*>(&intro_shown_)) + sizeof(contract_info_shown_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&join_coop_shown_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&switch_farm_shown_) -
        reinterpret_cast<char*>(&join_coop_shown_)) + sizeof(switch_farm_shown_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Backup_Tutorial::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool intro_shown = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_intro_shown(&has_bits);
          intro_shown_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool click_tutorial_shown = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_click_tutorial_shown(&has_bits);
          click_tutorial_shown_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool buy_hab_shown = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_buy_hab_shown(&has_bits);
          buy_hab_shown_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool hire_vehicle_shown = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_hire_vehicle_shown(&has_bits);
          hire_vehicle_shown_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool q_num_shown = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_q_num_shown(&has_bits);
          q_num_shown_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool s_num_shown = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_s_num_shown(&has_bits);
          s_num_shown_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool contracts_tab_shown = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_contracts_tab_shown(&has_bits);
          contracts_tab_shown_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool contract_info_shown = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_contract_info_shown(&has_bits);
          contract_info_shown_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool join_coop_shown = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_join_coop_shown(&has_bits);
          join_coop_shown_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool switch_farm_shown = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_switch_farm_shown(&has_bits);
          switch_farm_shown_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bool tutorial_shown = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_tutorial_shown(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<88>(ptr));
        } else if (static_cast<uint8_t>(tag) == 90) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(_internal_mutable_tutorial_shown(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Backup_Tutorial::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.Backup.Tutorial)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool intro_shown = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_intro_shown(), target);
  }

  // optional bool click_tutorial_shown = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_click_tutorial_shown(), target);
  }

  // optional bool buy_hab_shown = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_buy_hab_shown(), target);
  }

  // optional bool hire_vehicle_shown = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_hire_vehicle_shown(), target);
  }

  // optional bool q_num_shown = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_q_num_shown(), target);
  }

  // optional bool s_num_shown = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_s_num_shown(), target);
  }

  // optional bool contracts_tab_shown = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_contracts_tab_shown(), target);
  }

  // optional bool contract_info_shown = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_contract_info_shown(), target);
  }

  // optional bool join_coop_shown = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_join_coop_shown(), target);
  }

  // optional bool switch_farm_shown = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_switch_farm_shown(), target);
  }

  // repeated bool tutorial_shown = 11;
  for (int i = 0, n = this->_internal_tutorial_shown_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_tutorial_shown(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.Backup.Tutorial)
  return target;
}

size_t Backup_Tutorial::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.Backup.Tutorial)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bool tutorial_shown = 11;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_tutorial_shown_size());
    size_t data_size = 1UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_tutorial_shown_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bool intro_shown = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool click_tutorial_shown = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool buy_hab_shown = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool hire_vehicle_shown = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool q_num_shown = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool s_num_shown = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool contracts_tab_shown = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool contract_info_shown = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional bool join_coop_shown = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool switch_farm_shown = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Backup_Tutorial::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Backup_Tutorial::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Backup_Tutorial::GetClassData() const { return &_class_data_; }

void Backup_Tutorial::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Backup_Tutorial *>(to)->MergeFrom(
      static_cast<const Backup_Tutorial &>(from));
}


void Backup_Tutorial::MergeFrom(const Backup_Tutorial& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.Backup.Tutorial)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  tutorial_shown_.MergeFrom(from.tutorial_shown_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      intro_shown_ = from.intro_shown_;
    }
    if (cached_has_bits & 0x00000002u) {
      click_tutorial_shown_ = from.click_tutorial_shown_;
    }
    if (cached_has_bits & 0x00000004u) {
      buy_hab_shown_ = from.buy_hab_shown_;
    }
    if (cached_has_bits & 0x00000008u) {
      hire_vehicle_shown_ = from.hire_vehicle_shown_;
    }
    if (cached_has_bits & 0x00000010u) {
      q_num_shown_ = from.q_num_shown_;
    }
    if (cached_has_bits & 0x00000020u) {
      s_num_shown_ = from.s_num_shown_;
    }
    if (cached_has_bits & 0x00000040u) {
      contracts_tab_shown_ = from.contracts_tab_shown_;
    }
    if (cached_has_bits & 0x00000080u) {
      contract_info_shown_ = from.contract_info_shown_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      join_coop_shown_ = from.join_coop_shown_;
    }
    if (cached_has_bits & 0x00000200u) {
      switch_farm_shown_ = from.switch_farm_shown_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Backup_Tutorial::CopyFrom(const Backup_Tutorial& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.Backup.Tutorial)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Backup_Tutorial::IsInitialized() const {
  return true;
}

void Backup_Tutorial::InternalSwap(Backup_Tutorial* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  tutorial_shown_.InternalSwap(&other->tutorial_shown_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Backup_Tutorial, switch_farm_shown_)
      + sizeof(Backup_Tutorial::switch_farm_shown_)
      - PROTOBUF_FIELD_OFFSET(Backup_Tutorial, intro_shown_)>(
          reinterpret_cast<char*>(&intro_shown_),
          reinterpret_cast<char*>(&other->intro_shown_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Backup_Tutorial::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[1]);
}

// ===================================================================

class Backup_Stats::_Internal {
 public:
  using HasBits = decltype(std::declval<Backup_Stats>()._has_bits_);
  static void set_has_unlimited_chickens_uses(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_refill_uses(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_warp_1_uses(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_warp_8_uses(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_boosts_used(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_video_doubler_uses(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_drone_takedowns(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_drone_takedowns_elite(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_num_prestiges(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_num_piggy_breaks(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_iap_packs_purchased(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_piggy_full(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_piggy_found_full(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_time_piggy_filled_realtime(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_time_piggy_full_gametime(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_lost_piggy_increments(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
};

Backup_Stats::Backup_Stats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  egg_totals_old_(arena),
  egg_totals_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.Backup.Stats)
}
Backup_Stats::Backup_Stats(const Backup_Stats& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      egg_totals_old_(from.egg_totals_old_),
      egg_totals_(from.egg_totals_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&refill_uses_, &from.refill_uses_,
    static_cast<size_t>(reinterpret_cast<char*>(&piggy_found_full_) -
    reinterpret_cast<char*>(&refill_uses_)) + sizeof(piggy_found_full_));
  // @@protoc_insertion_point(copy_constructor:ei.Backup.Stats)
}

inline void Backup_Stats::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&refill_uses_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&piggy_found_full_) -
    reinterpret_cast<char*>(&refill_uses_)) + sizeof(piggy_found_full_));
}

Backup_Stats::~Backup_Stats() {
  // @@protoc_insertion_point(destructor:ei.Backup.Stats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Backup_Stats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Backup_Stats::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Backup_Stats::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.Backup.Stats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  egg_totals_old_.Clear();
  egg_totals_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&refill_uses_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&drone_takedowns_elite_) -
        reinterpret_cast<char*>(&refill_uses_)) + sizeof(drone_takedowns_elite_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&num_piggy_breaks_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&piggy_found_full_) -
        reinterpret_cast<char*>(&num_piggy_breaks_)) + sizeof(piggy_found_full_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Backup_Stats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 egg_totals_OLD = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_egg_totals_old(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_egg_totals_old(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 refill_uses = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_refill_uses(&has_bits);
          refill_uses_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 video_doubler_uses = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_video_doubler_uses(&has_bits);
          video_doubler_uses_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 warp_1_uses = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_warp_1_uses(&has_bits);
          warp_1_uses_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 warp_8_uses = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_warp_8_uses(&has_bits);
          warp_8_uses_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 drone_takedowns = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_drone_takedowns(&has_bits);
          drone_takedowns_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 unlimited_chickens_uses = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_unlimited_chickens_uses(&has_bits);
          unlimited_chickens_uses_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated double egg_totals = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_egg_totals(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<65>(ptr));
        } else if (static_cast<uint8_t>(tag) == 66) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_egg_totals(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 num_prestiges = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_num_prestiges(&has_bits);
          num_prestiges_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 drone_takedowns_elite = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_drone_takedowns_elite(&has_bits);
          drone_takedowns_elite_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 num_piggy_breaks = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_num_piggy_breaks(&has_bits);
          num_piggy_breaks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 iap_packs_purchased = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_iap_packs_purchased(&has_bits);
          iap_packs_purchased_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 boosts_used = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_boosts_used(&has_bits);
          boosts_used_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool piggy_full = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_piggy_full(&has_bits);
          piggy_full_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool piggy_found_full = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_piggy_found_full(&has_bits);
          piggy_found_full_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double time_piggy_filled_realtime = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 129)) {
          _Internal::set_has_time_piggy_filled_realtime(&has_bits);
          time_piggy_filled_realtime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double time_piggy_full_gametime = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 137)) {
          _Internal::set_has_time_piggy_full_gametime(&has_bits);
          time_piggy_full_gametime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 lost_piggy_increments = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_lost_piggy_increments(&has_bits);
          lost_piggy_increments_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Backup_Stats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.Backup.Stats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 egg_totals_OLD = 1;
  for (int i = 0, n = this->_internal_egg_totals_old_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_egg_totals_old(i), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional uint64 refill_uses = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_refill_uses(), target);
  }

  // optional uint64 video_doubler_uses = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_video_doubler_uses(), target);
  }

  // optional uint64 warp_1_uses = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_warp_1_uses(), target);
  }

  // optional uint64 warp_8_uses = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_warp_8_uses(), target);
  }

  // optional uint64 drone_takedowns = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_drone_takedowns(), target);
  }

  // optional uint64 unlimited_chickens_uses = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_unlimited_chickens_uses(), target);
  }

  // repeated double egg_totals = 8;
  for (int i = 0, n = this->_internal_egg_totals_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_egg_totals(i), target);
  }

  // optional uint64 num_prestiges = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(9, this->_internal_num_prestiges(), target);
  }

  // optional uint64 drone_takedowns_elite = 10;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(10, this->_internal_drone_takedowns_elite(), target);
  }

  // optional uint64 num_piggy_breaks = 11;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(11, this->_internal_num_piggy_breaks(), target);
  }

  // optional uint64 iap_packs_purchased = 12;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(12, this->_internal_iap_packs_purchased(), target);
  }

  // optional uint64 boosts_used = 13;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(13, this->_internal_boosts_used(), target);
  }

  // optional bool piggy_full = 14;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_piggy_full(), target);
  }

  // optional bool piggy_found_full = 15;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_piggy_found_full(), target);
  }

  // optional double time_piggy_filled_realtime = 16;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(16, this->_internal_time_piggy_filled_realtime(), target);
  }

  // optional double time_piggy_full_gametime = 17;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(17, this->_internal_time_piggy_full_gametime(), target);
  }

  // optional uint64 lost_piggy_increments = 18;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(18, this->_internal_lost_piggy_increments(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.Backup.Stats)
  return target;
}

size_t Backup_Stats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.Backup.Stats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 egg_totals_OLD = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->egg_totals_old_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_egg_totals_old_size());
    total_size += data_size;
  }

  // repeated double egg_totals = 8;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_egg_totals_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_egg_totals_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 refill_uses = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_refill_uses());
    }

    // optional uint64 video_doubler_uses = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_video_doubler_uses());
    }

    // optional uint64 warp_1_uses = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_warp_1_uses());
    }

    // optional uint64 warp_8_uses = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_warp_8_uses());
    }

    // optional uint64 drone_takedowns = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_drone_takedowns());
    }

    // optional uint64 unlimited_chickens_uses = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_unlimited_chickens_uses());
    }

    // optional uint64 num_prestiges = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_num_prestiges());
    }

    // optional uint64 drone_takedowns_elite = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_drone_takedowns_elite());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint64 num_piggy_breaks = 11;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_num_piggy_breaks());
    }

    // optional uint64 iap_packs_purchased = 12;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_iap_packs_purchased());
    }

    // optional uint64 boosts_used = 13;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_boosts_used());
    }

    // optional double time_piggy_filled_realtime = 16;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 + 8;
    }

    // optional double time_piggy_full_gametime = 17;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + 8;
    }

    // optional uint64 lost_piggy_increments = 18;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_lost_piggy_increments());
    }

    // optional bool piggy_full = 14;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

    // optional bool piggy_found_full = 15;
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Backup_Stats::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Backup_Stats::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Backup_Stats::GetClassData() const { return &_class_data_; }

void Backup_Stats::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Backup_Stats *>(to)->MergeFrom(
      static_cast<const Backup_Stats &>(from));
}


void Backup_Stats::MergeFrom(const Backup_Stats& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.Backup.Stats)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  egg_totals_old_.MergeFrom(from.egg_totals_old_);
  egg_totals_.MergeFrom(from.egg_totals_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      refill_uses_ = from.refill_uses_;
    }
    if (cached_has_bits & 0x00000002u) {
      video_doubler_uses_ = from.video_doubler_uses_;
    }
    if (cached_has_bits & 0x00000004u) {
      warp_1_uses_ = from.warp_1_uses_;
    }
    if (cached_has_bits & 0x00000008u) {
      warp_8_uses_ = from.warp_8_uses_;
    }
    if (cached_has_bits & 0x00000010u) {
      drone_takedowns_ = from.drone_takedowns_;
    }
    if (cached_has_bits & 0x00000020u) {
      unlimited_chickens_uses_ = from.unlimited_chickens_uses_;
    }
    if (cached_has_bits & 0x00000040u) {
      num_prestiges_ = from.num_prestiges_;
    }
    if (cached_has_bits & 0x00000080u) {
      drone_takedowns_elite_ = from.drone_takedowns_elite_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      num_piggy_breaks_ = from.num_piggy_breaks_;
    }
    if (cached_has_bits & 0x00000200u) {
      iap_packs_purchased_ = from.iap_packs_purchased_;
    }
    if (cached_has_bits & 0x00000400u) {
      boosts_used_ = from.boosts_used_;
    }
    if (cached_has_bits & 0x00000800u) {
      time_piggy_filled_realtime_ = from.time_piggy_filled_realtime_;
    }
    if (cached_has_bits & 0x00001000u) {
      time_piggy_full_gametime_ = from.time_piggy_full_gametime_;
    }
    if (cached_has_bits & 0x00002000u) {
      lost_piggy_increments_ = from.lost_piggy_increments_;
    }
    if (cached_has_bits & 0x00004000u) {
      piggy_full_ = from.piggy_full_;
    }
    if (cached_has_bits & 0x00008000u) {
      piggy_found_full_ = from.piggy_found_full_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Backup_Stats::CopyFrom(const Backup_Stats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.Backup.Stats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Backup_Stats::IsInitialized() const {
  return true;
}

void Backup_Stats::InternalSwap(Backup_Stats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  egg_totals_old_.InternalSwap(&other->egg_totals_old_);
  egg_totals_.InternalSwap(&other->egg_totals_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Backup_Stats, piggy_found_full_)
      + sizeof(Backup_Stats::piggy_found_full_)
      - PROTOBUF_FIELD_OFFSET(Backup_Stats, refill_uses_)>(
          reinterpret_cast<char*>(&refill_uses_),
          reinterpret_cast<char*>(&other->refill_uses_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Backup_Stats::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[2]);
}

// ===================================================================

class Backup_Game::_Internal {
 public:
  using HasBits = decltype(std::declval<Backup_Game>()._has_bits_);
  static void set_has_current_farm(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_max_egg_reached(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static void set_has_golden_eggs_earned(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_golden_eggs_spent(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_uncliamed_golden_eggs(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_soul_eggs(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_unclaimed_soul_eggs(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_soul_eggs_d(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_unclaimed_soul_eggs_d(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_eggs_of_prophecy(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_unclaimed_eggs_of_prophecy(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_shell_scripts_earned(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_shell_scripts_spent(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_unclaimed_shell_scripts(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_prestige_cash_earned(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_prestige_soul_boost_cash(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_lifetime_cash_earned(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_piggy_bank(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_piggy_full_alert_shown(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_permit_level(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_hyperloop_station(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_next_daily_gift_time(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_last_daily_gift_collected_day(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_num_daily_gifts_collected(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_last_news_time(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_current_multiplier(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_current_multiplier_expiration(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_long_idle_notification_set(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_long_idle_notification_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_long_idle_reward(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_total_time_cheats_detected(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_force_elite_contracts(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_new_player_event_end_time(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
};

Backup_Game::Backup_Game(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  epic_research_(arena),
  news_(arena),
  achievements_(arena),
  max_farm_size_reached_(arena),
  egg_medal_level_(arena),
  boosts_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.Backup.Game)
}
Backup_Game::Backup_Game(const Backup_Game& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      epic_research_(from.epic_research_),
      news_(from.news_),
      achievements_(from.achievements_),
      max_farm_size_reached_(from.max_farm_size_reached_),
      egg_medal_level_(from.egg_medal_level_),
      boosts_(from.boosts_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&golden_eggs_earned_, &from.golden_eggs_earned_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_egg_reached_) -
    reinterpret_cast<char*>(&golden_eggs_earned_)) + sizeof(max_egg_reached_));
  // @@protoc_insertion_point(copy_constructor:ei.Backup.Game)
}

inline void Backup_Game::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&golden_eggs_earned_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&unclaimed_shell_scripts_) -
    reinterpret_cast<char*>(&golden_eggs_earned_)) + sizeof(unclaimed_shell_scripts_));
max_egg_reached_ = 1;
}

Backup_Game::~Backup_Game() {
  // @@protoc_insertion_point(destructor:ei.Backup.Game)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Backup_Game::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Backup_Game::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Backup_Game::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.Backup.Game)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  epic_research_.Clear();
  news_.Clear();
  achievements_.Clear();
  max_farm_size_reached_.Clear();
  egg_medal_level_.Clear();
  boosts_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&golden_eggs_earned_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&last_news_time_) -
        reinterpret_cast<char*>(&golden_eggs_earned_)) + sizeof(last_news_time_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&current_multiplier_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&unclaimed_eggs_of_prophecy_) -
        reinterpret_cast<char*>(&current_multiplier_)) + sizeof(unclaimed_eggs_of_prophecy_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&current_farm_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&force_elite_contracts_) -
        reinterpret_cast<char*>(&current_farm_)) + sizeof(force_elite_contracts_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&total_time_cheats_detected_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&unclaimed_shell_scripts_) -
        reinterpret_cast<char*>(&total_time_cheats_detected_)) + sizeof(unclaimed_shell_scripts_));
  }
  max_egg_reached_ = 1;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Backup_Game::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.Egg max_egg_reached = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::Egg_IsValid(val))) {
            _internal_set_max_egg_reached(static_cast<::ei::Egg>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint64 golden_eggs_earned = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_golden_eggs_earned(&_has_bits_);
          golden_eggs_earned_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 golden_eggs_spent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_golden_eggs_spent(&_has_bits_);
          golden_eggs_spent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 soul_eggs = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_soul_eggs(&_has_bits_);
          soul_eggs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double prestige_cash_earned = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_prestige_cash_earned(&_has_bits_);
          prestige_cash_earned_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double lifetime_cash_earned = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_lifetime_cash_earned(&_has_bits_);
          lifetime_cash_earned_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 piggy_bank = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_piggy_bank(&_has_bits_);
          piggy_bank_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 permit_level = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_permit_level(&_has_bits_);
          permit_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.Backup.ResearchItem epic_research = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_epic_research(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional double next_daily_gift_time = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _Internal::set_has_next_daily_gift_time(&_has_bits_);
          next_daily_gift_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.Backup.NewsHeadline news = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_news(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional double last_news_time = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 97)) {
          _Internal::set_has_last_news_time(&_has_bits_);
          last_news_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double current_multiplier = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 105)) {
          _Internal::set_has_current_multiplier(&_has_bits_);
          current_multiplier_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double current_multiplier_expiration = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 113)) {
          _Internal::set_has_current_multiplier_expiration(&_has_bits_);
          current_multiplier_expiration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.Backup.AchievementInfo achievements = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_achievements(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<122>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 uncliamed_golden_eggs = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_uncliamed_golden_eggs(&_has_bits_);
          uncliamed_golden_eggs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 unclaimed_soul_eggs = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_unclaimed_soul_eggs(&_has_bits_);
          unclaimed_soul_eggs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 max_farm_size_reached = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_max_farm_size_reached(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<144>(ptr));
        } else if (static_cast<uint8_t>(tag) == 146) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_max_farm_size_reached(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 egg_medal_level = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_egg_medal_level(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<152>(ptr));
        } else if (static_cast<uint8_t>(tag) == 154) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_egg_medal_level(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 last_daily_gift_collected_day = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_last_daily_gift_collected_day(&_has_bits_);
          last_daily_gift_collected_day_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 current_farm = 22 [default = 0];
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_current_farm(&_has_bits_);
          current_farm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 eggs_of_prophecy = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_eggs_of_prophecy(&_has_bits_);
          eggs_of_prophecy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 unclaimed_eggs_of_prophecy = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_unclaimed_eggs_of_prophecy(&_has_bits_);
          unclaimed_eggs_of_prophecy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool long_idle_notification_set = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_long_idle_notification_set(&_has_bits_);
          long_idle_notification_set_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double long_idle_notification_threshold = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 209)) {
          _Internal::set_has_long_idle_notification_threshold(&_has_bits_);
          long_idle_notification_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double long_idle_reward = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 217)) {
          _Internal::set_has_long_idle_reward(&_has_bits_);
          long_idle_reward_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 num_daily_gifts_collected = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_num_daily_gifts_collected(&_has_bits_);
          num_daily_gifts_collected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool hyperloop_station = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_hyperloop_station(&_has_bits_);
          hyperloop_station_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.Backup.OwnedBoost boosts = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_boosts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<242>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool piggy_full_alert_shown = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _Internal::set_has_piggy_full_alert_shown(&_has_bits_);
          piggy_full_alert_shown_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 total_time_cheats_detected = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          _Internal::set_has_total_time_cheats_detected(&_has_bits_);
          total_time_cheats_detected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double prestige_soul_boost_cash = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_prestige_soul_boost_cash(&_has_bits_);
          prestige_soul_boost_cash_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double soul_eggs_d = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_soul_eggs_d(&_has_bits_);
          soul_eggs_d_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double unclaimed_soul_eggs_d = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_unclaimed_soul_eggs_d(&_has_bits_);
          unclaimed_soul_eggs_d_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool force_elite_contracts = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_force_elite_contracts(&_has_bits_);
          force_elite_contracts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double new_player_event_end_time = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_new_player_event_end_time(&_has_bits_);
          new_player_event_end_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 shell_scripts_earned = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_shell_scripts_earned(&_has_bits_);
          shell_scripts_earned_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 shell_scripts_spent = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_shell_scripts_spent(&_has_bits_);
          shell_scripts_spent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 unclaimed_shell_scripts = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_unclaimed_shell_scripts(&_has_bits_);
          unclaimed_shell_scripts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Backup_Game::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.Backup.Game)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[1];
  // optional .ei.Egg max_egg_reached = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_max_egg_reached(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional uint64 golden_eggs_earned = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_golden_eggs_earned(), target);
  }

  // optional uint64 golden_eggs_spent = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_golden_eggs_spent(), target);
  }

  // optional uint64 soul_eggs = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_soul_eggs(), target);
  }

  // optional double prestige_cash_earned = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_prestige_cash_earned(), target);
  }

  // optional double lifetime_cash_earned = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_lifetime_cash_earned(), target);
  }

  // optional uint64 piggy_bank = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_piggy_bank(), target);
  }

  // optional uint32 permit_level = 8;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_permit_level(), target);
  }

  // repeated .ei.Backup.ResearchItem epic_research = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_epic_research_size()); i < n; i++) {
    const auto& repfield = this->_internal_epic_research(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional double next_daily_gift_time = 10;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(10, this->_internal_next_daily_gift_time(), target);
  }

  // repeated .ei.Backup.NewsHeadline news = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_news_size()); i < n; i++) {
    const auto& repfield = this->_internal_news(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional double last_news_time = 12;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(12, this->_internal_last_news_time(), target);
  }

  // optional double current_multiplier = 13;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(13, this->_internal_current_multiplier(), target);
  }

  // optional double current_multiplier_expiration = 14;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(14, this->_internal_current_multiplier_expiration(), target);
  }

  // repeated .ei.Backup.AchievementInfo achievements = 15;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_achievements_size()); i < n; i++) {
    const auto& repfield = this->_internal_achievements(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(15, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint64 uncliamed_golden_eggs = 16;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(16, this->_internal_uncliamed_golden_eggs(), target);
  }

  // optional uint64 unclaimed_soul_eggs = 17;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(17, this->_internal_unclaimed_soul_eggs(), target);
  }

  // repeated uint64 max_farm_size_reached = 18;
  for (int i = 0, n = this->_internal_max_farm_size_reached_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(18, this->_internal_max_farm_size_reached(i), target);
  }

  // repeated uint32 egg_medal_level = 19;
  for (int i = 0, n = this->_internal_egg_medal_level_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(19, this->_internal_egg_medal_level(i), target);
  }

  // optional uint32 last_daily_gift_collected_day = 20;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(20, this->_internal_last_daily_gift_collected_day(), target);
  }

  // optional uint32 current_farm = 22 [default = 0];
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(22, this->_internal_current_farm(), target);
  }

  // optional uint64 eggs_of_prophecy = 23;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(23, this->_internal_eggs_of_prophecy(), target);
  }

  // optional uint64 unclaimed_eggs_of_prophecy = 24;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(24, this->_internal_unclaimed_eggs_of_prophecy(), target);
  }

  // optional bool long_idle_notification_set = 25;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(25, this->_internal_long_idle_notification_set(), target);
  }

  // optional double long_idle_notification_threshold = 26;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(26, this->_internal_long_idle_notification_threshold(), target);
  }

  // optional double long_idle_reward = 27;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(27, this->_internal_long_idle_reward(), target);
  }

  // optional uint32 num_daily_gifts_collected = 28;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(28, this->_internal_num_daily_gifts_collected(), target);
  }

  // optional bool hyperloop_station = 29;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(29, this->_internal_hyperloop_station(), target);
  }

  // repeated .ei.Backup.OwnedBoost boosts = 30;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_boosts_size()); i < n; i++) {
    const auto& repfield = this->_internal_boosts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(30, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool piggy_full_alert_shown = 31;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(31, this->_internal_piggy_full_alert_shown(), target);
  }

  // optional uint32 total_time_cheats_detected = 32;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(32, this->_internal_total_time_cheats_detected(), target);
  }

  // optional double prestige_soul_boost_cash = 33;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(33, this->_internal_prestige_soul_boost_cash(), target);
  }

  // optional double soul_eggs_d = 34;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(34, this->_internal_soul_eggs_d(), target);
  }

  // optional double unclaimed_soul_eggs_d = 35;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(35, this->_internal_unclaimed_soul_eggs_d(), target);
  }

  // optional bool force_elite_contracts = 36;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(36, this->_internal_force_elite_contracts(), target);
  }

  // optional double new_player_event_end_time = 37;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(37, this->_internal_new_player_event_end_time(), target);
  }

  // optional uint64 shell_scripts_earned = 38;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(38, this->_internal_shell_scripts_earned(), target);
  }

  // optional uint64 shell_scripts_spent = 39;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(39, this->_internal_shell_scripts_spent(), target);
  }

  // optional uint64 unclaimed_shell_scripts = 40;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(40, this->_internal_unclaimed_shell_scripts(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.Backup.Game)
  return target;
}

size_t Backup_Game::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.Backup.Game)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.Backup.ResearchItem epic_research = 9;
  total_size += 1UL * this->_internal_epic_research_size();
  for (const auto& msg : this->epic_research_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.Backup.NewsHeadline news = 11;
  total_size += 1UL * this->_internal_news_size();
  for (const auto& msg : this->news_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.Backup.AchievementInfo achievements = 15;
  total_size += 1UL * this->_internal_achievements_size();
  for (const auto& msg : this->achievements_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint64 max_farm_size_reached = 18;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->max_farm_size_reached_);
    total_size += 2 *
                  ::_pbi::FromIntSize(this->_internal_max_farm_size_reached_size());
    total_size += data_size;
  }

  // repeated uint32 egg_medal_level = 19;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->egg_medal_level_);
    total_size += 2 *
                  ::_pbi::FromIntSize(this->_internal_egg_medal_level_size());
    total_size += data_size;
  }

  // repeated .ei.Backup.OwnedBoost boosts = 30;
  total_size += 2UL * this->_internal_boosts_size();
  for (const auto& msg : this->boosts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 golden_eggs_earned = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_golden_eggs_earned());
    }

    // optional uint64 golden_eggs_spent = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_golden_eggs_spent());
    }

    // optional uint64 soul_eggs = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_soul_eggs());
    }

    // optional double prestige_cash_earned = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double lifetime_cash_earned = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional uint64 piggy_bank = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_piggy_bank());
    }

    // optional double next_daily_gift_time = 10;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional double last_news_time = 12;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional double current_multiplier = 13;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 8;
    }

    // optional double current_multiplier_expiration = 14;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional uint32 permit_level = 8;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_permit_level());
    }

    // optional uint32 last_daily_gift_collected_day = 20;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_last_daily_gift_collected_day());
    }

    // optional uint64 uncliamed_golden_eggs = 16;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_uncliamed_golden_eggs());
    }

    // optional uint64 unclaimed_soul_eggs = 17;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_unclaimed_soul_eggs());
    }

    // optional uint64 eggs_of_prophecy = 23;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_eggs_of_prophecy());
    }

    // optional uint64 unclaimed_eggs_of_prophecy = 24;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_unclaimed_eggs_of_prophecy());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional uint32 current_farm = 22 [default = 0];
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_current_farm());
    }

    // optional uint32 num_daily_gifts_collected = 28;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_num_daily_gifts_collected());
    }

    // optional double long_idle_notification_threshold = 26;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 8;
    }

    // optional double long_idle_reward = 27;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 8;
    }

    // optional bool piggy_full_alert_shown = 31;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 1;
    }

    // optional bool hyperloop_station = 29;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 + 1;
    }

    // optional bool long_idle_notification_set = 25;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 1;
    }

    // optional bool force_elite_contracts = 36;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional uint32 total_time_cheats_detected = 32;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_total_time_cheats_detected());
    }

    // optional double prestige_soul_boost_cash = 33;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + 8;
    }

    // optional double soul_eggs_d = 34;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 + 8;
    }

    // optional double unclaimed_soul_eggs_d = 35;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 + 8;
    }

    // optional double new_player_event_end_time = 37;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 + 8;
    }

    // optional uint64 shell_scripts_earned = 38;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_shell_scripts_earned());
    }

    // optional uint64 shell_scripts_spent = 39;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_shell_scripts_spent());
    }

    // optional uint64 unclaimed_shell_scripts = 40;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_unclaimed_shell_scripts());
    }

  }
  // optional .ei.Egg max_egg_reached = 1;
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_max_egg_reached());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Backup_Game::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Backup_Game::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Backup_Game::GetClassData() const { return &_class_data_; }

void Backup_Game::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Backup_Game *>(to)->MergeFrom(
      static_cast<const Backup_Game &>(from));
}


void Backup_Game::MergeFrom(const Backup_Game& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.Backup.Game)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  epic_research_.MergeFrom(from.epic_research_);
  news_.MergeFrom(from.news_);
  achievements_.MergeFrom(from.achievements_);
  max_farm_size_reached_.MergeFrom(from.max_farm_size_reached_);
  egg_medal_level_.MergeFrom(from.egg_medal_level_);
  boosts_.MergeFrom(from.boosts_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      golden_eggs_earned_ = from.golden_eggs_earned_;
    }
    if (cached_has_bits & 0x00000002u) {
      golden_eggs_spent_ = from.golden_eggs_spent_;
    }
    if (cached_has_bits & 0x00000004u) {
      soul_eggs_ = from.soul_eggs_;
    }
    if (cached_has_bits & 0x00000008u) {
      prestige_cash_earned_ = from.prestige_cash_earned_;
    }
    if (cached_has_bits & 0x00000010u) {
      lifetime_cash_earned_ = from.lifetime_cash_earned_;
    }
    if (cached_has_bits & 0x00000020u) {
      piggy_bank_ = from.piggy_bank_;
    }
    if (cached_has_bits & 0x00000040u) {
      next_daily_gift_time_ = from.next_daily_gift_time_;
    }
    if (cached_has_bits & 0x00000080u) {
      last_news_time_ = from.last_news_time_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      current_multiplier_ = from.current_multiplier_;
    }
    if (cached_has_bits & 0x00000200u) {
      current_multiplier_expiration_ = from.current_multiplier_expiration_;
    }
    if (cached_has_bits & 0x00000400u) {
      permit_level_ = from.permit_level_;
    }
    if (cached_has_bits & 0x00000800u) {
      last_daily_gift_collected_day_ = from.last_daily_gift_collected_day_;
    }
    if (cached_has_bits & 0x00001000u) {
      uncliamed_golden_eggs_ = from.uncliamed_golden_eggs_;
    }
    if (cached_has_bits & 0x00002000u) {
      unclaimed_soul_eggs_ = from.unclaimed_soul_eggs_;
    }
    if (cached_has_bits & 0x00004000u) {
      eggs_of_prophecy_ = from.eggs_of_prophecy_;
    }
    if (cached_has_bits & 0x00008000u) {
      unclaimed_eggs_of_prophecy_ = from.unclaimed_eggs_of_prophecy_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      current_farm_ = from.current_farm_;
    }
    if (cached_has_bits & 0x00020000u) {
      num_daily_gifts_collected_ = from.num_daily_gifts_collected_;
    }
    if (cached_has_bits & 0x00040000u) {
      long_idle_notification_threshold_ = from.long_idle_notification_threshold_;
    }
    if (cached_has_bits & 0x00080000u) {
      long_idle_reward_ = from.long_idle_reward_;
    }
    if (cached_has_bits & 0x00100000u) {
      piggy_full_alert_shown_ = from.piggy_full_alert_shown_;
    }
    if (cached_has_bits & 0x00200000u) {
      hyperloop_station_ = from.hyperloop_station_;
    }
    if (cached_has_bits & 0x00400000u) {
      long_idle_notification_set_ = from.long_idle_notification_set_;
    }
    if (cached_has_bits & 0x00800000u) {
      force_elite_contracts_ = from.force_elite_contracts_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      total_time_cheats_detected_ = from.total_time_cheats_detected_;
    }
    if (cached_has_bits & 0x02000000u) {
      prestige_soul_boost_cash_ = from.prestige_soul_boost_cash_;
    }
    if (cached_has_bits & 0x04000000u) {
      soul_eggs_d_ = from.soul_eggs_d_;
    }
    if (cached_has_bits & 0x08000000u) {
      unclaimed_soul_eggs_d_ = from.unclaimed_soul_eggs_d_;
    }
    if (cached_has_bits & 0x10000000u) {
      new_player_event_end_time_ = from.new_player_event_end_time_;
    }
    if (cached_has_bits & 0x20000000u) {
      shell_scripts_earned_ = from.shell_scripts_earned_;
    }
    if (cached_has_bits & 0x40000000u) {
      shell_scripts_spent_ = from.shell_scripts_spent_;
    }
    if (cached_has_bits & 0x80000000u) {
      unclaimed_shell_scripts_ = from.unclaimed_shell_scripts_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (from._internal_has_max_egg_reached()) {
    _internal_set_max_egg_reached(from._internal_max_egg_reached());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Backup_Game::CopyFrom(const Backup_Game& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.Backup.Game)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Backup_Game::IsInitialized() const {
  return true;
}

void Backup_Game::InternalSwap(Backup_Game* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(_has_bits_[1], other->_has_bits_[1]);
  epic_research_.InternalSwap(&other->epic_research_);
  news_.InternalSwap(&other->news_);
  achievements_.InternalSwap(&other->achievements_);
  max_farm_size_reached_.InternalSwap(&other->max_farm_size_reached_);
  egg_medal_level_.InternalSwap(&other->egg_medal_level_);
  boosts_.InternalSwap(&other->boosts_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Backup_Game, unclaimed_shell_scripts_)
      + sizeof(Backup_Game::unclaimed_shell_scripts_)
      - PROTOBUF_FIELD_OFFSET(Backup_Game, golden_eggs_earned_)>(
          reinterpret_cast<char*>(&golden_eggs_earned_),
          reinterpret_cast<char*>(&other->golden_eggs_earned_));
  swap(max_egg_reached_, other->max_egg_reached_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Backup_Game::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[3]);
}

// ===================================================================

class Backup_Artifacts::_Internal {
 public:
  using HasBits = decltype(std::declval<Backup_Artifacts>()._has_bits_);
  static void set_has_infusing(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::ei::ArtifactInventoryItem& item_being_infused(const Backup_Artifacts* msg);
  static void set_has_item_being_infused(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ei::ArtifactSpec& spec_being_infused(const Backup_Artifacts* msg);
  static void set_has_spec_being_infused(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_egg_type_infusing(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_infusing_eggs_required(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_eggs_infused(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_flow_percentage_artifacts(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_fueling_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_tank_filling_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_tank_level(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_last_fueled_ship(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_inventory_score(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_crafting_xp(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_intro_shown(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_infusing_enabled_deprecated(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
};

const ::ei::ArtifactInventoryItem&
Backup_Artifacts::_Internal::item_being_infused(const Backup_Artifacts* msg) {
  return *msg->item_being_infused_;
}
const ::ei::ArtifactSpec&
Backup_Artifacts::_Internal::spec_being_infused(const Backup_Artifacts* msg) {
  return *msg->spec_being_infused_;
}
Backup_Artifacts::Backup_Artifacts(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  tank_fuels_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.Backup.Artifacts)
}
Backup_Artifacts::Backup_Artifacts(const Backup_Artifacts& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      tank_fuels_(from.tank_fuels_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_item_being_infused()) {
    item_being_infused_ = new ::ei::ArtifactInventoryItem(*from.item_being_infused_);
  } else {
    item_being_infused_ = nullptr;
  }
  if (from._internal_has_spec_being_infused()) {
    spec_being_infused_ = new ::ei::ArtifactSpec(*from.spec_being_infused_);
  } else {
    spec_being_infused_ = nullptr;
  }
  ::memcpy(&infusing_eggs_required_, &from.infusing_eggs_required_,
    static_cast<size_t>(reinterpret_cast<char*>(&infusing_enabled_deprecated_) -
    reinterpret_cast<char*>(&infusing_eggs_required_)) + sizeof(infusing_enabled_deprecated_));
  // @@protoc_insertion_point(copy_constructor:ei.Backup.Artifacts)
}

inline void Backup_Artifacts::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&item_being_infused_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&tank_level_) -
    reinterpret_cast<char*>(&item_being_infused_)) + sizeof(tank_level_));
flow_percentage_artifacts_ = 0.5;
egg_type_infusing_ = 1;
fueling_enabled_ = true;
infusing_enabled_deprecated_ = true;
}

Backup_Artifacts::~Backup_Artifacts() {
  // @@protoc_insertion_point(destructor:ei.Backup.Artifacts)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Backup_Artifacts::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete item_being_infused_;
  if (this != internal_default_instance()) delete spec_being_infused_;
}

void Backup_Artifacts::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Backup_Artifacts::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.Backup.Artifacts)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  tank_fuels_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(item_being_infused_ != nullptr);
      item_being_infused_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(spec_being_infused_ != nullptr);
      spec_being_infused_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&infusing_eggs_required_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&enabled_) -
        reinterpret_cast<char*>(&infusing_eggs_required_)) + sizeof(enabled_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&intro_shown_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&tank_level_) -
        reinterpret_cast<char*>(&intro_shown_)) + sizeof(tank_level_));
    flow_percentage_artifacts_ = 0.5;
    egg_type_infusing_ = 1;
    fueling_enabled_ = true;
    infusing_enabled_deprecated_ = true;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Backup_Artifacts::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool infusing = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_infusing(&has_bits);
          infusing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.ArtifactInventoryItem item_being_infused = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_item_being_infused(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.Egg egg_type_infusing = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::Egg_IsValid(val))) {
            _internal_set_egg_type_infusing(static_cast<::ei::Egg>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional double infusing_eggs_required = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_infusing_eggs_required(&has_bits);
          infusing_eggs_required_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double eggs_infused = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_eggs_infused(&has_bits);
          eggs_infused_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double flow_percentage_artifacts = 6 [default = 0.5];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_flow_percentage_artifacts(&has_bits);
          flow_percentage_artifacts_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool fueling_enabled = 7 [default = true];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_fueling_enabled(&has_bits);
          fueling_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool infusing_enabled_DEPRECATED = 8 [default = true];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_infusing_enabled_deprecated(&has_bits);
          infusing_enabled_deprecated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.MissionInfo.Spaceship last_fueled_ship = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::MissionInfo_Spaceship_IsValid(val))) {
            _internal_set_last_fueled_ship(static_cast<::ei::MissionInfo_Spaceship>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional double inventory_score = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _Internal::set_has_inventory_score(&has_bits);
          inventory_score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool enabled = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_enabled(&has_bits);
          enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool intro_shown = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_intro_shown(&has_bits);
          intro_shown_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.ArtifactSpec spec_being_infused = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec_being_infused(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool tank_filling_enabled = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_tank_filling_enabled(&has_bits);
          tank_filling_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tank_level = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_tank_level(&has_bits);
          tank_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated double tank_fuels = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 129)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_tank_fuels(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<129>(ptr));
        } else if (static_cast<uint8_t>(tag) == 130) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_tank_fuels(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double crafting_xp = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 137)) {
          _Internal::set_has_crafting_xp(&has_bits);
          crafting_xp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Backup_Artifacts::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.Backup.Artifacts)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool infusing = 1;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_infusing(), target);
  }

  // optional .ei.ArtifactInventoryItem item_being_infused = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::item_being_infused(this),
        _Internal::item_being_infused(this).GetCachedSize(), target, stream);
  }

  // optional .ei.Egg egg_type_infusing = 3;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_egg_type_infusing(), target);
  }

  // optional double infusing_eggs_required = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_infusing_eggs_required(), target);
  }

  // optional double eggs_infused = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_eggs_infused(), target);
  }

  // optional double flow_percentage_artifacts = 6 [default = 0.5];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_flow_percentage_artifacts(), target);
  }

  // optional bool fueling_enabled = 7 [default = true];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_fueling_enabled(), target);
  }

  // optional bool infusing_enabled_DEPRECATED = 8 [default = true];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_infusing_enabled_deprecated(), target);
  }

  // optional .ei.MissionInfo.Spaceship last_fueled_ship = 9;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_last_fueled_ship(), target);
  }

  // optional double inventory_score = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(10, this->_internal_inventory_score(), target);
  }

  // optional bool enabled = 11;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_enabled(), target);
  }

  // optional bool intro_shown = 12;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_intro_shown(), target);
  }

  // optional .ei.ArtifactSpec spec_being_infused = 13;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::spec_being_infused(this),
        _Internal::spec_being_infused(this).GetCachedSize(), target, stream);
  }

  // optional bool tank_filling_enabled = 14;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_tank_filling_enabled(), target);
  }

  // optional uint32 tank_level = 15;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_tank_level(), target);
  }

  // repeated double tank_fuels = 16;
  for (int i = 0, n = this->_internal_tank_fuels_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(16, this->_internal_tank_fuels(i), target);
  }

  // optional double crafting_xp = 17;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(17, this->_internal_crafting_xp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.Backup.Artifacts)
  return target;
}

size_t Backup_Artifacts::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.Backup.Artifacts)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double tank_fuels = 16;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_tank_fuels_size());
    size_t data_size = 8UL * count;
    total_size += 2 *
                  ::_pbi::FromIntSize(this->_internal_tank_fuels_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .ei.ArtifactInventoryItem item_being_infused = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *item_being_infused_);
    }

    // optional .ei.ArtifactSpec spec_being_infused = 13;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *spec_being_infused_);
    }

    // optional double infusing_eggs_required = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double eggs_infused = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional .ei.MissionInfo.Spaceship last_fueled_ship = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_last_fueled_ship());
    }

    // optional bool infusing = 1;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool tank_filling_enabled = 14;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool enabled = 11;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool intro_shown = 12;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional double inventory_score = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional double crafting_xp = 17;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 + 8;
    }

    // optional uint32 tank_level = 15;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tank_level());
    }

    // optional double flow_percentage_artifacts = 6 [default = 0.5];
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 8;
    }

    // optional .ei.Egg egg_type_infusing = 3;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_egg_type_infusing());
    }

    // optional bool fueling_enabled = 7 [default = true];
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

    // optional bool infusing_enabled_DEPRECATED = 8 [default = true];
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Backup_Artifacts::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Backup_Artifacts::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Backup_Artifacts::GetClassData() const { return &_class_data_; }

void Backup_Artifacts::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Backup_Artifacts *>(to)->MergeFrom(
      static_cast<const Backup_Artifacts &>(from));
}


void Backup_Artifacts::MergeFrom(const Backup_Artifacts& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.Backup.Artifacts)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  tank_fuels_.MergeFrom(from.tank_fuels_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_item_being_infused()->::ei::ArtifactInventoryItem::MergeFrom(from._internal_item_being_infused());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_spec_being_infused()->::ei::ArtifactSpec::MergeFrom(from._internal_spec_being_infused());
    }
    if (cached_has_bits & 0x00000004u) {
      infusing_eggs_required_ = from.infusing_eggs_required_;
    }
    if (cached_has_bits & 0x00000008u) {
      eggs_infused_ = from.eggs_infused_;
    }
    if (cached_has_bits & 0x00000010u) {
      last_fueled_ship_ = from.last_fueled_ship_;
    }
    if (cached_has_bits & 0x00000020u) {
      infusing_ = from.infusing_;
    }
    if (cached_has_bits & 0x00000040u) {
      tank_filling_enabled_ = from.tank_filling_enabled_;
    }
    if (cached_has_bits & 0x00000080u) {
      enabled_ = from.enabled_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      intro_shown_ = from.intro_shown_;
    }
    if (cached_has_bits & 0x00000200u) {
      inventory_score_ = from.inventory_score_;
    }
    if (cached_has_bits & 0x00000400u) {
      crafting_xp_ = from.crafting_xp_;
    }
    if (cached_has_bits & 0x00000800u) {
      tank_level_ = from.tank_level_;
    }
    if (cached_has_bits & 0x00001000u) {
      flow_percentage_artifacts_ = from.flow_percentage_artifacts_;
    }
    if (cached_has_bits & 0x00002000u) {
      egg_type_infusing_ = from.egg_type_infusing_;
    }
    if (cached_has_bits & 0x00004000u) {
      fueling_enabled_ = from.fueling_enabled_;
    }
    if (cached_has_bits & 0x00008000u) {
      infusing_enabled_deprecated_ = from.infusing_enabled_deprecated_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Backup_Artifacts::CopyFrom(const Backup_Artifacts& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.Backup.Artifacts)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Backup_Artifacts::IsInitialized() const {
  return true;
}

void Backup_Artifacts::InternalSwap(Backup_Artifacts* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  tank_fuels_.InternalSwap(&other->tank_fuels_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Backup_Artifacts, tank_level_)
      + sizeof(Backup_Artifacts::tank_level_)
      - PROTOBUF_FIELD_OFFSET(Backup_Artifacts, item_being_infused_)>(
          reinterpret_cast<char*>(&item_being_infused_),
          reinterpret_cast<char*>(&other->item_being_infused_));
  swap(flow_percentage_artifacts_, other->flow_percentage_artifacts_);
  swap(egg_type_infusing_, other->egg_type_infusing_);
  swap(fueling_enabled_, other->fueling_enabled_);
  swap(infusing_enabled_deprecated_, other->infusing_enabled_deprecated_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Backup_Artifacts::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[4]);
}

// ===================================================================

class Backup_Shells::_Internal {
 public:
  using HasBits = decltype(std::declval<Backup_Shells>()._has_bits_);
  static void set_has_intro_alert(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_contracts_intro_alert(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Backup_Shells::Backup_Shells(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  num_new_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.Backup.Shells)
}
Backup_Shells::Backup_Shells(const Backup_Shells& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      num_new_(from.num_new_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&intro_alert_, &from.intro_alert_,
    static_cast<size_t>(reinterpret_cast<char*>(&contracts_intro_alert_) -
    reinterpret_cast<char*>(&intro_alert_)) + sizeof(contracts_intro_alert_));
  // @@protoc_insertion_point(copy_constructor:ei.Backup.Shells)
}

inline void Backup_Shells::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&intro_alert_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&contracts_intro_alert_) -
    reinterpret_cast<char*>(&intro_alert_)) + sizeof(contracts_intro_alert_));
}

Backup_Shells::~Backup_Shells() {
  // @@protoc_insertion_point(destructor:ei.Backup.Shells)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Backup_Shells::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Backup_Shells::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Backup_Shells::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.Backup.Shells)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  num_new_.Clear();
  ::memset(&intro_alert_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&contracts_intro_alert_) -
      reinterpret_cast<char*>(&intro_alert_)) + sizeof(contracts_intro_alert_));
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Backup_Shells::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool intro_alert = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_intro_alert(&has_bits);
          intro_alert_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool contracts_intro_alert = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_contracts_intro_alert(&has_bits);
          contracts_intro_alert_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 num_new = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_num_new(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_num_new(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Backup_Shells::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.Backup.Shells)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool intro_alert = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_intro_alert(), target);
  }

  // optional bool contracts_intro_alert = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_contracts_intro_alert(), target);
  }

  // repeated int32 num_new = 3;
  for (int i = 0, n = this->_internal_num_new_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_num_new(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.Backup.Shells)
  return target;
}

size_t Backup_Shells::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.Backup.Shells)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 num_new = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->num_new_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_num_new_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool intro_alert = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool contracts_intro_alert = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Backup_Shells::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Backup_Shells::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Backup_Shells::GetClassData() const { return &_class_data_; }

void Backup_Shells::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Backup_Shells *>(to)->MergeFrom(
      static_cast<const Backup_Shells &>(from));
}


void Backup_Shells::MergeFrom(const Backup_Shells& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.Backup.Shells)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  num_new_.MergeFrom(from.num_new_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      intro_alert_ = from.intro_alert_;
    }
    if (cached_has_bits & 0x00000002u) {
      contracts_intro_alert_ = from.contracts_intro_alert_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Backup_Shells::CopyFrom(const Backup_Shells& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.Backup.Shells)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Backup_Shells::IsInitialized() const {
  return true;
}

void Backup_Shells::InternalSwap(Backup_Shells* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  num_new_.InternalSwap(&other->num_new_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Backup_Shells, contracts_intro_alert_)
      + sizeof(Backup_Shells::contracts_intro_alert_)
      - PROTOBUF_FIELD_OFFSET(Backup_Shells, intro_alert_)>(
          reinterpret_cast<char*>(&intro_alert_),
          reinterpret_cast<char*>(&other->intro_alert_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Backup_Shells::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[5]);
}

// ===================================================================

class Backup_Simulation::_Internal {
 public:
  using HasBits = decltype(std::declval<Backup_Simulation>()._has_bits_);
  static void set_has_egg_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_farm_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_contract_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cash_earned(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cash_spent(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_unclaimed_cash(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_last_step_time(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_num_chickens(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_num_chickens_unsettled(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_num_chickens_running(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_eggs_laid(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_eggs_shipped(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_eggs_paid_for(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_silos_owned(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_hatchery_population(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_last_cash_boost_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_time_cheats_detected(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_time_cheat_debt(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_boost_tokens_received(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_boost_tokens_spent(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_boost_tokens_given(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_unclaimed_boost_tokens(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_gametime_until_next_boost_token(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
};

Backup_Simulation::Backup_Simulation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  habs_(arena),
  hab_population_(arena),
  hab_population_indound_(arena),
  hab_incubator_popuplation_(arena),
  vehicles_(arena),
  common_research_(arena),
  train_length_(arena),
  active_boosts_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.Backup.Simulation)
}
Backup_Simulation::Backup_Simulation(const Backup_Simulation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      habs_(from.habs_),
      hab_population_(from.hab_population_),
      hab_population_indound_(from.hab_population_indound_),
      hab_incubator_popuplation_(from.hab_incubator_popuplation_),
      vehicles_(from.vehicles_),
      common_research_(from.common_research_),
      train_length_(from.train_length_),
      active_boosts_(from.active_boosts_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contract_id()) {
    contract_id_.Set(from._internal_contract_id(), 
      GetArenaForAllocation());
  }
  ::memcpy(&cash_earned_, &from.cash_earned_,
    static_cast<size_t>(reinterpret_cast<char*>(&farm_type_) -
    reinterpret_cast<char*>(&cash_earned_)) + sizeof(farm_type_));
  // @@protoc_insertion_point(copy_constructor:ei.Backup.Simulation)
}

inline void Backup_Simulation::SharedCtor() {
contract_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  contract_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&cash_earned_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&last_cash_boost_time_) -
    reinterpret_cast<char*>(&cash_earned_)) + sizeof(last_cash_boost_time_));
egg_type_ = 1;
farm_type_ = 1;
}

Backup_Simulation::~Backup_Simulation() {
  // @@protoc_insertion_point(destructor:ei.Backup.Simulation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Backup_Simulation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  contract_id_.Destroy();
}

void Backup_Simulation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Backup_Simulation::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.Backup.Simulation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  habs_.Clear();
  hab_population_.Clear();
  hab_population_indound_.Clear();
  hab_incubator_popuplation_.Clear();
  vehicles_.Clear();
  common_research_.Clear();
  train_length_.Clear();
  active_boosts_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    contract_id_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&cash_earned_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&num_chickens_running_) -
        reinterpret_cast<char*>(&cash_earned_)) + sizeof(num_chickens_running_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&eggs_laid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&boost_tokens_spent_) -
        reinterpret_cast<char*>(&eggs_laid_)) + sizeof(boost_tokens_spent_));
  }
  if (cached_has_bits & 0x007f0000u) {
    ::memset(&unclaimed_boost_tokens_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&last_cash_boost_time_) -
        reinterpret_cast<char*>(&unclaimed_boost_tokens_)) + sizeof(last_cash_boost_time_));
    egg_type_ = 1;
    farm_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Backup_Simulation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.Egg egg_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::Egg_IsValid(val))) {
            _internal_set_egg_type(static_cast<::ei::Egg>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional double cash_earned = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_cash_earned(&has_bits);
          cash_earned_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double cash_spent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_cash_spent(&has_bits);
          cash_spent_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double unclaimed_cash = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_unclaimed_cash(&has_bits);
          unclaimed_cash_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double last_step_time = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_last_step_time(&has_bits);
          last_step_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 num_chickens = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_num_chickens(&has_bits);
          num_chickens_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 num_chickens_unsettled = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_num_chickens_unsettled(&has_bits);
          num_chickens_unsettled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 num_chickens_running = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_num_chickens_running(&has_bits);
          num_chickens_running_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double eggs_laid = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          _Internal::set_has_eggs_laid(&has_bits);
          eggs_laid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double eggs_paid_for = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _Internal::set_has_eggs_paid_for(&has_bits);
          eggs_paid_for_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 silos_owned = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_silos_owned(&has_bits);
          silos_owned_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 habs = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_habs(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<96>(ptr));
        } else if (static_cast<uint8_t>(tag) == 98) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_habs(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 hab_population = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_hab_population(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<104>(ptr));
        } else if (static_cast<uint8_t>(tag) == 106) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_hab_population(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 hab_population_indound = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_hab_population_indound(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<112>(ptr));
        } else if (static_cast<uint8_t>(tag) == 114) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_hab_population_indound(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated double hab_incubator_popuplation = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 121)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_hab_incubator_popuplation(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<121>(ptr));
        } else if (static_cast<uint8_t>(tag) == 122) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_hab_incubator_popuplation(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double hatchery_population = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 129)) {
          _Internal::set_has_hatchery_population(&has_bits);
          hatchery_population_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 vehicles = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_vehicles(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<136>(ptr));
        } else if (static_cast<uint8_t>(tag) == 138) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_vehicles(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.Backup.ResearchItem common_research = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_common_research(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<146>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .ei.FarmType farm_type = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::FarmType_IsValid(val))) {
            _internal_set_farm_type(static_cast<::ei::FarmType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(19, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string contract_id = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.Backup.Simulation.contract_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 train_length = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_train_length(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<168>(ptr));
        } else if (static_cast<uint8_t>(tag) == 170) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_train_length(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.Backup.ActiveBoost active_boosts = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_active_boosts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<178>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 time_cheats_detected = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_time_cheats_detected(&has_bits);
          time_cheats_detected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double time_cheat_debt = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 193)) {
          _Internal::set_has_time_cheat_debt(&has_bits);
          time_cheat_debt_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 boost_tokens_received = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_boost_tokens_received(&has_bits);
          boost_tokens_received_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 boost_tokens_spent = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_boost_tokens_spent(&has_bits);
          boost_tokens_spent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 unclaimed_boost_tokens = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_unclaimed_boost_tokens(&has_bits);
          unclaimed_boost_tokens_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 boost_tokens_given = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_boost_tokens_given(&has_bits);
          boost_tokens_given_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double gametime_until_next_boost_token = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 233)) {
          _Internal::set_has_gametime_until_next_boost_token(&has_bits);
          gametime_until_next_boost_token_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double eggs_shipped = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 241)) {
          _Internal::set_has_eggs_shipped(&has_bits);
          eggs_shipped_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double last_cash_boost_time = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 249)) {
          _Internal::set_has_last_cash_boost_time(&has_bits);
          last_cash_boost_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Backup_Simulation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.Backup.Simulation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.Egg egg_type = 1;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_egg_type(), target);
  }

  // optional double cash_earned = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_cash_earned(), target);
  }

  // optional double cash_spent = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_cash_spent(), target);
  }

  // optional double unclaimed_cash = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_unclaimed_cash(), target);
  }

  // optional double last_step_time = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_last_step_time(), target);
  }

  // optional uint64 num_chickens = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_num_chickens(), target);
  }

  // optional uint64 num_chickens_unsettled = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_num_chickens_unsettled(), target);
  }

  // optional uint64 num_chickens_running = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_num_chickens_running(), target);
  }

  // optional double eggs_laid = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(9, this->_internal_eggs_laid(), target);
  }

  // optional double eggs_paid_for = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(10, this->_internal_eggs_paid_for(), target);
  }

  // optional uint32 silos_owned = 11;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_silos_owned(), target);
  }

  // repeated uint32 habs = 12;
  for (int i = 0, n = this->_internal_habs_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_habs(i), target);
  }

  // repeated uint64 hab_population = 13;
  for (int i = 0, n = this->_internal_hab_population_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(13, this->_internal_hab_population(i), target);
  }

  // repeated uint64 hab_population_indound = 14;
  for (int i = 0, n = this->_internal_hab_population_indound_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(14, this->_internal_hab_population_indound(i), target);
  }

  // repeated double hab_incubator_popuplation = 15;
  for (int i = 0, n = this->_internal_hab_incubator_popuplation_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(15, this->_internal_hab_incubator_popuplation(i), target);
  }

  // optional double hatchery_population = 16;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(16, this->_internal_hatchery_population(), target);
  }

  // repeated uint32 vehicles = 17;
  for (int i = 0, n = this->_internal_vehicles_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(17, this->_internal_vehicles(i), target);
  }

  // repeated .ei.Backup.ResearchItem common_research = 18;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_common_research_size()); i < n; i++) {
    const auto& repfield = this->_internal_common_research(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(18, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .ei.FarmType farm_type = 19;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      19, this->_internal_farm_type(), target);
  }

  // optional string contract_id = 20;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_contract_id().data(), static_cast<int>(this->_internal_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.Backup.Simulation.contract_id");
    target = stream->WriteStringMaybeAliased(
        20, this->_internal_contract_id(), target);
  }

  // repeated uint32 train_length = 21;
  for (int i = 0, n = this->_internal_train_length_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_train_length(i), target);
  }

  // repeated .ei.Backup.ActiveBoost active_boosts = 22;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_active_boosts_size()); i < n; i++) {
    const auto& repfield = this->_internal_active_boosts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(22, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 time_cheats_detected = 23;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(23, this->_internal_time_cheats_detected(), target);
  }

  // optional double time_cheat_debt = 24;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(24, this->_internal_time_cheat_debt(), target);
  }

  // optional uint32 boost_tokens_received = 25;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(25, this->_internal_boost_tokens_received(), target);
  }

  // optional uint32 boost_tokens_spent = 26;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(26, this->_internal_boost_tokens_spent(), target);
  }

  // optional uint32 unclaimed_boost_tokens = 27;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(27, this->_internal_unclaimed_boost_tokens(), target);
  }

  // optional uint32 boost_tokens_given = 28;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(28, this->_internal_boost_tokens_given(), target);
  }

  // optional double gametime_until_next_boost_token = 29;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(29, this->_internal_gametime_until_next_boost_token(), target);
  }

  // optional double eggs_shipped = 30;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(30, this->_internal_eggs_shipped(), target);
  }

  // optional double last_cash_boost_time = 31;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(31, this->_internal_last_cash_boost_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.Backup.Simulation)
  return target;
}

size_t Backup_Simulation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.Backup.Simulation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 habs = 12;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->habs_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_habs_size());
    total_size += data_size;
  }

  // repeated uint64 hab_population = 13;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->hab_population_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_hab_population_size());
    total_size += data_size;
  }

  // repeated uint64 hab_population_indound = 14;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->hab_population_indound_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_hab_population_indound_size());
    total_size += data_size;
  }

  // repeated double hab_incubator_popuplation = 15;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_hab_incubator_popuplation_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_hab_incubator_popuplation_size());
    total_size += data_size;
  }

  // repeated uint32 vehicles = 17;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->vehicles_);
    total_size += 2 *
                  ::_pbi::FromIntSize(this->_internal_vehicles_size());
    total_size += data_size;
  }

  // repeated .ei.Backup.ResearchItem common_research = 18;
  total_size += 2UL * this->_internal_common_research_size();
  for (const auto& msg : this->common_research_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint32 train_length = 21;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->train_length_);
    total_size += 2 *
                  ::_pbi::FromIntSize(this->_internal_train_length_size());
    total_size += data_size;
  }

  // repeated .ei.Backup.ActiveBoost active_boosts = 22;
  total_size += 2UL * this->_internal_active_boosts_size();
  for (const auto& msg : this->active_boosts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string contract_id = 20;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contract_id());
    }

    // optional double cash_earned = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double cash_spent = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double unclaimed_cash = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double last_step_time = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional uint64 num_chickens = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_num_chickens());
    }

    // optional uint64 num_chickens_unsettled = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_num_chickens_unsettled());
    }

    // optional uint64 num_chickens_running = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_num_chickens_running());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional double eggs_laid = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 8;
    }

    // optional double eggs_paid_for = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional double hatchery_population = 16;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 + 8;
    }

    // optional uint32 silos_owned = 11;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_silos_owned());
    }

    // optional uint32 time_cheats_detected = 23;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_time_cheats_detected());
    }

    // optional double time_cheat_debt = 24;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 8;
    }

    // optional uint32 boost_tokens_received = 25;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_boost_tokens_received());
    }

    // optional uint32 boost_tokens_spent = 26;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_boost_tokens_spent());
    }

  }
  if (cached_has_bits & 0x007f0000u) {
    // optional uint32 unclaimed_boost_tokens = 27;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_unclaimed_boost_tokens());
    }

    // optional uint32 boost_tokens_given = 28;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_boost_tokens_given());
    }

    // optional double gametime_until_next_boost_token = 29;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 8;
    }

    // optional double eggs_shipped = 30;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 8;
    }

    // optional double last_cash_boost_time = 31;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 8;
    }

    // optional .ei.Egg egg_type = 1;
    if (cached_has_bits & 0x00200000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_egg_type());
    }

    // optional .ei.FarmType farm_type = 19;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_farm_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Backup_Simulation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Backup_Simulation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Backup_Simulation::GetClassData() const { return &_class_data_; }

void Backup_Simulation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Backup_Simulation *>(to)->MergeFrom(
      static_cast<const Backup_Simulation &>(from));
}


void Backup_Simulation::MergeFrom(const Backup_Simulation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.Backup.Simulation)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  habs_.MergeFrom(from.habs_);
  hab_population_.MergeFrom(from.hab_population_);
  hab_population_indound_.MergeFrom(from.hab_population_indound_);
  hab_incubator_popuplation_.MergeFrom(from.hab_incubator_popuplation_);
  vehicles_.MergeFrom(from.vehicles_);
  common_research_.MergeFrom(from.common_research_);
  train_length_.MergeFrom(from.train_length_);
  active_boosts_.MergeFrom(from.active_boosts_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_contract_id(from._internal_contract_id());
    }
    if (cached_has_bits & 0x00000002u) {
      cash_earned_ = from.cash_earned_;
    }
    if (cached_has_bits & 0x00000004u) {
      cash_spent_ = from.cash_spent_;
    }
    if (cached_has_bits & 0x00000008u) {
      unclaimed_cash_ = from.unclaimed_cash_;
    }
    if (cached_has_bits & 0x00000010u) {
      last_step_time_ = from.last_step_time_;
    }
    if (cached_has_bits & 0x00000020u) {
      num_chickens_ = from.num_chickens_;
    }
    if (cached_has_bits & 0x00000040u) {
      num_chickens_unsettled_ = from.num_chickens_unsettled_;
    }
    if (cached_has_bits & 0x00000080u) {
      num_chickens_running_ = from.num_chickens_running_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      eggs_laid_ = from.eggs_laid_;
    }
    if (cached_has_bits & 0x00000200u) {
      eggs_paid_for_ = from.eggs_paid_for_;
    }
    if (cached_has_bits & 0x00000400u) {
      hatchery_population_ = from.hatchery_population_;
    }
    if (cached_has_bits & 0x00000800u) {
      silos_owned_ = from.silos_owned_;
    }
    if (cached_has_bits & 0x00001000u) {
      time_cheats_detected_ = from.time_cheats_detected_;
    }
    if (cached_has_bits & 0x00002000u) {
      time_cheat_debt_ = from.time_cheat_debt_;
    }
    if (cached_has_bits & 0x00004000u) {
      boost_tokens_received_ = from.boost_tokens_received_;
    }
    if (cached_has_bits & 0x00008000u) {
      boost_tokens_spent_ = from.boost_tokens_spent_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x007f0000u) {
    if (cached_has_bits & 0x00010000u) {
      unclaimed_boost_tokens_ = from.unclaimed_boost_tokens_;
    }
    if (cached_has_bits & 0x00020000u) {
      boost_tokens_given_ = from.boost_tokens_given_;
    }
    if (cached_has_bits & 0x00040000u) {
      gametime_until_next_boost_token_ = from.gametime_until_next_boost_token_;
    }
    if (cached_has_bits & 0x00080000u) {
      eggs_shipped_ = from.eggs_shipped_;
    }
    if (cached_has_bits & 0x00100000u) {
      last_cash_boost_time_ = from.last_cash_boost_time_;
    }
    if (cached_has_bits & 0x00200000u) {
      egg_type_ = from.egg_type_;
    }
    if (cached_has_bits & 0x00400000u) {
      farm_type_ = from.farm_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Backup_Simulation::CopyFrom(const Backup_Simulation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.Backup.Simulation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Backup_Simulation::IsInitialized() const {
  return true;
}

void Backup_Simulation::InternalSwap(Backup_Simulation* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  habs_.InternalSwap(&other->habs_);
  hab_population_.InternalSwap(&other->hab_population_);
  hab_population_indound_.InternalSwap(&other->hab_population_indound_);
  hab_incubator_popuplation_.InternalSwap(&other->hab_incubator_popuplation_);
  vehicles_.InternalSwap(&other->vehicles_);
  common_research_.InternalSwap(&other->common_research_);
  train_length_.InternalSwap(&other->train_length_);
  active_boosts_.InternalSwap(&other->active_boosts_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &contract_id_, lhs_arena,
      &other->contract_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Backup_Simulation, last_cash_boost_time_)
      + sizeof(Backup_Simulation::last_cash_boost_time_)
      - PROTOBUF_FIELD_OFFSET(Backup_Simulation, cash_earned_)>(
          reinterpret_cast<char*>(&cash_earned_),
          reinterpret_cast<char*>(&other->cash_earned_));
  swap(egg_type_, other->egg_type_);
  swap(farm_type_, other->farm_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Backup_Simulation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[6]);
}

// ===================================================================

class Backup_Mission::_Internal {
 public:
  using HasBits = decltype(std::declval<Backup_Mission>()._has_bits_);
  static void set_has_current_mission(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_reference_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Backup_Mission::Backup_Mission(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  missions_(arena),
  current_missions_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.Backup.Mission)
}
Backup_Mission::Backup_Mission(const Backup_Mission& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      missions_(from.missions_),
      current_missions_(from.current_missions_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  current_mission_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    current_mission_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_current_mission()) {
    current_mission_.Set(from._internal_current_mission(), 
      GetArenaForAllocation());
  }
  reference_value_ = from.reference_value_;
  // @@protoc_insertion_point(copy_constructor:ei.Backup.Mission)
}

inline void Backup_Mission::SharedCtor() {
current_mission_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  current_mission_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
reference_value_ = 0;
}

Backup_Mission::~Backup_Mission() {
  // @@protoc_insertion_point(destructor:ei.Backup.Mission)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Backup_Mission::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  current_mission_.Destroy();
}

void Backup_Mission::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Backup_Mission::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.Backup.Mission)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  missions_.Clear();
  current_missions_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    current_mission_.ClearNonDefaultToEmpty();
  }
  reference_value_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Backup_Mission::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string current_mission = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_current_mission();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.Backup.Mission.current_mission");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double reference_value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_reference_value(&has_bits);
          reference_value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.Backup.MissionInfo missions = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_missions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string current_missions = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_current_missions();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "ei.Backup.Mission.current_missions");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Backup_Mission::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.Backup.Mission)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string current_mission = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_current_mission().data(), static_cast<int>(this->_internal_current_mission().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.Backup.Mission.current_mission");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_current_mission(), target);
  }

  // optional double reference_value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_reference_value(), target);
  }

  // repeated .ei.Backup.MissionInfo missions = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_missions_size()); i < n; i++) {
    const auto& repfield = this->_internal_missions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string current_missions = 4;
  for (int i = 0, n = this->_internal_current_missions_size(); i < n; i++) {
    const auto& s = this->_internal_current_missions(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.Backup.Mission.current_missions");
    target = stream->WriteString(4, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.Backup.Mission)
  return target;
}

size_t Backup_Mission::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.Backup.Mission)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.Backup.MissionInfo missions = 3;
  total_size += 1UL * this->_internal_missions_size();
  for (const auto& msg : this->missions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string current_missions = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(current_missions_.size());
  for (int i = 0, n = current_missions_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      current_missions_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string current_mission = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_current_mission());
    }

    // optional double reference_value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Backup_Mission::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Backup_Mission::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Backup_Mission::GetClassData() const { return &_class_data_; }

void Backup_Mission::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Backup_Mission *>(to)->MergeFrom(
      static_cast<const Backup_Mission &>(from));
}


void Backup_Mission::MergeFrom(const Backup_Mission& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.Backup.Mission)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  missions_.MergeFrom(from.missions_);
  current_missions_.MergeFrom(from.current_missions_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_current_mission(from._internal_current_mission());
    }
    if (cached_has_bits & 0x00000002u) {
      reference_value_ = from.reference_value_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Backup_Mission::CopyFrom(const Backup_Mission& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.Backup.Mission)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Backup_Mission::IsInitialized() const {
  return true;
}

void Backup_Mission::InternalSwap(Backup_Mission* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  missions_.InternalSwap(&other->missions_);
  current_missions_.InternalSwap(&other->current_missions_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &current_mission_, lhs_arena,
      &other->current_mission_, rhs_arena
  );
  swap(reference_value_, other->reference_value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Backup_Mission::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[7]);
}

// ===================================================================

class Backup_Misc::_Internal {
 public:
  using HasBits = decltype(std::declval<Backup_Misc>()._has_bits_);
  static void set_has_chicken_btn_pref_big(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_free_hatchery_refill_given(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_last_share_farm_value(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_last_share_swarm_farm_value(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_last_share_swarm_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_last_prestige_alert_soul_eggs_deprecated(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_friend_rank(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_friend_rank_pop(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_global_rank(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_global_rank_pop(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_challenges_alert(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_trophy_alert(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_ar_alert(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_contracts_alert(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_contracts_alert_v2(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_coop_alert(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_coop_alert_v2(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_switch_alert(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_egg_of_prophecy_alert(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_boost_token_alert(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_soul_egg_alert(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_backup_reminder_alert(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
};

Backup_Misc::Backup_Misc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.Backup.Misc)
}
Backup_Misc::Backup_Misc(const Backup_Misc& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&friend_rank_, &from.friend_rank_,
    static_cast<size_t>(reinterpret_cast<char*>(&last_prestige_alert_soul_eggs_deprecated_) -
    reinterpret_cast<char*>(&friend_rank_)) + sizeof(last_prestige_alert_soul_eggs_deprecated_));
  // @@protoc_insertion_point(copy_constructor:ei.Backup.Misc)
}

inline void Backup_Misc::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&friend_rank_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&backup_reminder_alert_) -
    reinterpret_cast<char*>(&friend_rank_)) + sizeof(backup_reminder_alert_));
last_share_farm_value_ = 10000000;
last_share_swarm_farm_value_ = 10000000;
last_share_swarm_size_ = 140;
last_prestige_alert_soul_eggs_deprecated_ = uint64_t{45u};
}

Backup_Misc::~Backup_Misc() {
  // @@protoc_insertion_point(destructor:ei.Backup.Misc)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Backup_Misc::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Backup_Misc::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Backup_Misc::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.Backup.Misc)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&friend_rank_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&trophy_alert_) -
        reinterpret_cast<char*>(&friend_rank_)) + sizeof(trophy_alert_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&ar_alert_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&boost_token_alert_) -
        reinterpret_cast<char*>(&ar_alert_)) + sizeof(boost_token_alert_));
  }
  if (cached_has_bits & 0x003f0000u) {
    ::memset(&soul_egg_alert_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&backup_reminder_alert_) -
        reinterpret_cast<char*>(&soul_egg_alert_)) + sizeof(backup_reminder_alert_));
    last_share_farm_value_ = 10000000;
    last_share_swarm_farm_value_ = 10000000;
    last_share_swarm_size_ = 140;
    last_prestige_alert_soul_eggs_deprecated_ = uint64_t{45u};
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Backup_Misc::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool chicken_btn_pref_big = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_chicken_btn_pref_big(&has_bits);
          chicken_btn_pref_big_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool free_hatchery_refill_given = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_free_hatchery_refill_given(&has_bits);
          free_hatchery_refill_given_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double last_share_farm_value = 3 [default = 10000000];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_last_share_farm_value(&has_bits);
          last_share_farm_value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double last_share_swarm_farm_value = 4 [default = 10000000];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_last_share_swarm_farm_value(&has_bits);
          last_share_swarm_farm_value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double last_share_swarm_size = 5 [default = 140];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_last_share_swarm_size(&has_bits);
          last_share_swarm_size_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 friend_rank = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_friend_rank(&has_bits);
          friend_rank_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 friend_rank_pop = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_friend_rank_pop(&has_bits);
          friend_rank_pop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 global_rank = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_global_rank(&has_bits);
          global_rank_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 global_rank_pop = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_global_rank_pop(&has_bits);
          global_rank_pop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 last_prestige_alert_soul_eggs_DEPRECATED = 10 [default = 45];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_last_prestige_alert_soul_eggs_deprecated(&has_bits);
          last_prestige_alert_soul_eggs_deprecated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool trophy_alert = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_trophy_alert(&has_bits);
          trophy_alert_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ar_alert = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_ar_alert(&has_bits);
          ar_alert_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool contracts_alert = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_contracts_alert(&has_bits);
          contracts_alert_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool coop_alert = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_coop_alert(&has_bits);
          coop_alert_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool switch_alert = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_switch_alert(&has_bits);
          switch_alert_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool egg_of_prophecy_alert = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_egg_of_prophecy_alert(&has_bits);
          egg_of_prophecy_alert_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool boost_token_alert = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_boost_token_alert(&has_bits);
          boost_token_alert_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool soul_egg_alert = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_soul_egg_alert(&has_bits);
          soul_egg_alert_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool backup_reminder_alert = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_backup_reminder_alert(&has_bits);
          backup_reminder_alert_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool challenges_alert = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_challenges_alert(&has_bits);
          challenges_alert_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool contracts_alert_v2 = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_contracts_alert_v2(&has_bits);
          contracts_alert_v2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool coop_alert_v2 = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_coop_alert_v2(&has_bits);
          coop_alert_v2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Backup_Misc::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.Backup.Misc)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool chicken_btn_pref_big = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_chicken_btn_pref_big(), target);
  }

  // optional bool free_hatchery_refill_given = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_free_hatchery_refill_given(), target);
  }

  // optional double last_share_farm_value = 3 [default = 10000000];
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_last_share_farm_value(), target);
  }

  // optional double last_share_swarm_farm_value = 4 [default = 10000000];
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_last_share_swarm_farm_value(), target);
  }

  // optional double last_share_swarm_size = 5 [default = 140];
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_last_share_swarm_size(), target);
  }

  // optional uint64 friend_rank = 6;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_friend_rank(), target);
  }

  // optional uint64 friend_rank_pop = 7;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_friend_rank_pop(), target);
  }

  // optional uint64 global_rank = 8;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_global_rank(), target);
  }

  // optional uint64 global_rank_pop = 9;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(9, this->_internal_global_rank_pop(), target);
  }

  // optional uint64 last_prestige_alert_soul_eggs_DEPRECATED = 10 [default = 45];
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(10, this->_internal_last_prestige_alert_soul_eggs_deprecated(), target);
  }

  // optional bool trophy_alert = 11;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_trophy_alert(), target);
  }

  // optional bool ar_alert = 12;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_ar_alert(), target);
  }

  // optional bool contracts_alert = 13;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_contracts_alert(), target);
  }

  // optional bool coop_alert = 14;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_coop_alert(), target);
  }

  // optional bool switch_alert = 15;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_switch_alert(), target);
  }

  // optional bool egg_of_prophecy_alert = 16;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_egg_of_prophecy_alert(), target);
  }

  // optional bool boost_token_alert = 17;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(17, this->_internal_boost_token_alert(), target);
  }

  // optional bool soul_egg_alert = 18;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(18, this->_internal_soul_egg_alert(), target);
  }

  // optional bool backup_reminder_alert = 19;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(19, this->_internal_backup_reminder_alert(), target);
  }

  // optional bool challenges_alert = 20;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(20, this->_internal_challenges_alert(), target);
  }

  // optional bool contracts_alert_v2 = 21;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(21, this->_internal_contracts_alert_v2(), target);
  }

  // optional bool coop_alert_v2 = 22;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(22, this->_internal_coop_alert_v2(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.Backup.Misc)
  return target;
}

size_t Backup_Misc::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.Backup.Misc)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 friend_rank = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_friend_rank());
    }

    // optional uint64 friend_rank_pop = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_friend_rank_pop());
    }

    // optional uint64 global_rank = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_global_rank());
    }

    // optional uint64 global_rank_pop = 9;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_global_rank_pop());
    }

    // optional bool chicken_btn_pref_big = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool free_hatchery_refill_given = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool challenges_alert = 20;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 + 1;
    }

    // optional bool trophy_alert = 11;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool ar_alert = 12;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool contracts_alert = 13;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool contracts_alert_v2 = 21;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 + 1;
    }

    // optional bool coop_alert = 14;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool coop_alert_v2 = 22;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + 1;
    }

    // optional bool switch_alert = 15;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional bool egg_of_prophecy_alert = 16;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 1;
    }

    // optional bool boost_token_alert = 17;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x003f0000u) {
    // optional bool soul_egg_alert = 18;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 1;
    }

    // optional bool backup_reminder_alert = 19;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 1;
    }

    // optional double last_share_farm_value = 3 [default = 10000000];
    if (cached_has_bits & 0x00040000u) {
      total_size += 1 + 8;
    }

    // optional double last_share_swarm_farm_value = 4 [default = 10000000];
    if (cached_has_bits & 0x00080000u) {
      total_size += 1 + 8;
    }

    // optional double last_share_swarm_size = 5 [default = 140];
    if (cached_has_bits & 0x00100000u) {
      total_size += 1 + 8;
    }

    // optional uint64 last_prestige_alert_soul_eggs_DEPRECATED = 10 [default = 45];
    if (cached_has_bits & 0x00200000u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_last_prestige_alert_soul_eggs_deprecated());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Backup_Misc::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Backup_Misc::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Backup_Misc::GetClassData() const { return &_class_data_; }

void Backup_Misc::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Backup_Misc *>(to)->MergeFrom(
      static_cast<const Backup_Misc &>(from));
}


void Backup_Misc::MergeFrom(const Backup_Misc& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.Backup.Misc)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      friend_rank_ = from.friend_rank_;
    }
    if (cached_has_bits & 0x00000002u) {
      friend_rank_pop_ = from.friend_rank_pop_;
    }
    if (cached_has_bits & 0x00000004u) {
      global_rank_ = from.global_rank_;
    }
    if (cached_has_bits & 0x00000008u) {
      global_rank_pop_ = from.global_rank_pop_;
    }
    if (cached_has_bits & 0x00000010u) {
      chicken_btn_pref_big_ = from.chicken_btn_pref_big_;
    }
    if (cached_has_bits & 0x00000020u) {
      free_hatchery_refill_given_ = from.free_hatchery_refill_given_;
    }
    if (cached_has_bits & 0x00000040u) {
      challenges_alert_ = from.challenges_alert_;
    }
    if (cached_has_bits & 0x00000080u) {
      trophy_alert_ = from.trophy_alert_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      ar_alert_ = from.ar_alert_;
    }
    if (cached_has_bits & 0x00000200u) {
      contracts_alert_ = from.contracts_alert_;
    }
    if (cached_has_bits & 0x00000400u) {
      contracts_alert_v2_ = from.contracts_alert_v2_;
    }
    if (cached_has_bits & 0x00000800u) {
      coop_alert_ = from.coop_alert_;
    }
    if (cached_has_bits & 0x00001000u) {
      coop_alert_v2_ = from.coop_alert_v2_;
    }
    if (cached_has_bits & 0x00002000u) {
      switch_alert_ = from.switch_alert_;
    }
    if (cached_has_bits & 0x00004000u) {
      egg_of_prophecy_alert_ = from.egg_of_prophecy_alert_;
    }
    if (cached_has_bits & 0x00008000u) {
      boost_token_alert_ = from.boost_token_alert_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x003f0000u) {
    if (cached_has_bits & 0x00010000u) {
      soul_egg_alert_ = from.soul_egg_alert_;
    }
    if (cached_has_bits & 0x00020000u) {
      backup_reminder_alert_ = from.backup_reminder_alert_;
    }
    if (cached_has_bits & 0x00040000u) {
      last_share_farm_value_ = from.last_share_farm_value_;
    }
    if (cached_has_bits & 0x00080000u) {
      last_share_swarm_farm_value_ = from.last_share_swarm_farm_value_;
    }
    if (cached_has_bits & 0x00100000u) {
      last_share_swarm_size_ = from.last_share_swarm_size_;
    }
    if (cached_has_bits & 0x00200000u) {
      last_prestige_alert_soul_eggs_deprecated_ = from.last_prestige_alert_soul_eggs_deprecated_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Backup_Misc::CopyFrom(const Backup_Misc& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.Backup.Misc)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Backup_Misc::IsInitialized() const {
  return true;
}

void Backup_Misc::InternalSwap(Backup_Misc* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Backup_Misc, backup_reminder_alert_)
      + sizeof(Backup_Misc::backup_reminder_alert_)
      - PROTOBUF_FIELD_OFFSET(Backup_Misc, friend_rank_)>(
          reinterpret_cast<char*>(&friend_rank_),
          reinterpret_cast<char*>(&other->friend_rank_));
  swap(last_share_farm_value_, other->last_share_farm_value_);
  swap(last_share_swarm_farm_value_, other->last_share_swarm_farm_value_);
  swap(last_share_swarm_size_, other->last_share_swarm_size_);
  swap(last_prestige_alert_soul_eggs_deprecated_, other->last_prestige_alert_soul_eggs_deprecated_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Backup_Misc::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[8]);
}

// ===================================================================

class Backup_ResearchItem::_Internal {
 public:
  using HasBits = decltype(std::declval<Backup_ResearchItem>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_level(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Backup_ResearchItem::Backup_ResearchItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.Backup.ResearchItem)
}
Backup_ResearchItem::Backup_ResearchItem(const Backup_ResearchItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_id()) {
    id_.Set(from._internal_id(), 
      GetArenaForAllocation());
  }
  level_ = from.level_;
  // @@protoc_insertion_point(copy_constructor:ei.Backup.ResearchItem)
}

inline void Backup_ResearchItem::SharedCtor() {
id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
level_ = 0u;
}

Backup_ResearchItem::~Backup_ResearchItem() {
  // @@protoc_insertion_point(destructor:ei.Backup.ResearchItem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Backup_ResearchItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  id_.Destroy();
}

void Backup_ResearchItem::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Backup_ResearchItem::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.Backup.ResearchItem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    id_.ClearNonDefaultToEmpty();
  }
  level_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Backup_ResearchItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.Backup.ResearchItem.id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 level = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_level(&has_bits);
          level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Backup_ResearchItem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.Backup.ResearchItem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.Backup.ResearchItem.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // optional uint32 level = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_level(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.Backup.ResearchItem)
  return target;
}

size_t Backup_ResearchItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.Backup.ResearchItem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_id());
    }

    // optional uint32 level = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_level());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Backup_ResearchItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Backup_ResearchItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Backup_ResearchItem::GetClassData() const { return &_class_data_; }

void Backup_ResearchItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Backup_ResearchItem *>(to)->MergeFrom(
      static_cast<const Backup_ResearchItem &>(from));
}


void Backup_ResearchItem::MergeFrom(const Backup_ResearchItem& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.Backup.ResearchItem)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      level_ = from.level_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Backup_ResearchItem::CopyFrom(const Backup_ResearchItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.Backup.ResearchItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Backup_ResearchItem::IsInitialized() const {
  return true;
}

void Backup_ResearchItem::InternalSwap(Backup_ResearchItem* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &id_, lhs_arena,
      &other->id_, rhs_arena
  );
  swap(level_, other->level_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Backup_ResearchItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[9]);
}

// ===================================================================

class Backup_NewsHeadline::_Internal {
 public:
  using HasBits = decltype(std::declval<Backup_NewsHeadline>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_read(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Backup_NewsHeadline::Backup_NewsHeadline(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.Backup.NewsHeadline)
}
Backup_NewsHeadline::Backup_NewsHeadline(const Backup_NewsHeadline& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_id()) {
    id_.Set(from._internal_id(), 
      GetArenaForAllocation());
  }
  read_ = from.read_;
  // @@protoc_insertion_point(copy_constructor:ei.Backup.NewsHeadline)
}

inline void Backup_NewsHeadline::SharedCtor() {
id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
read_ = false;
}

Backup_NewsHeadline::~Backup_NewsHeadline() {
  // @@protoc_insertion_point(destructor:ei.Backup.NewsHeadline)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Backup_NewsHeadline::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  id_.Destroy();
}

void Backup_NewsHeadline::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Backup_NewsHeadline::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.Backup.NewsHeadline)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    id_.ClearNonDefaultToEmpty();
  }
  read_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Backup_NewsHeadline::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.Backup.NewsHeadline.id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool read = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_read(&has_bits);
          read_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Backup_NewsHeadline::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.Backup.NewsHeadline)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.Backup.NewsHeadline.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // optional bool read = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_read(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.Backup.NewsHeadline)
  return target;
}

size_t Backup_NewsHeadline::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.Backup.NewsHeadline)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_id());
    }

    // optional bool read = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Backup_NewsHeadline::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Backup_NewsHeadline::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Backup_NewsHeadline::GetClassData() const { return &_class_data_; }

void Backup_NewsHeadline::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Backup_NewsHeadline *>(to)->MergeFrom(
      static_cast<const Backup_NewsHeadline &>(from));
}


void Backup_NewsHeadline::MergeFrom(const Backup_NewsHeadline& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.Backup.NewsHeadline)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      read_ = from.read_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Backup_NewsHeadline::CopyFrom(const Backup_NewsHeadline& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.Backup.NewsHeadline)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Backup_NewsHeadline::IsInitialized() const {
  return true;
}

void Backup_NewsHeadline::InternalSwap(Backup_NewsHeadline* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &id_, lhs_arena,
      &other->id_, rhs_arena
  );
  swap(read_, other->read_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Backup_NewsHeadline::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[10]);
}

// ===================================================================

class Backup_AchievementInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<Backup_AchievementInfo>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_achieved(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Backup_AchievementInfo::Backup_AchievementInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.Backup.AchievementInfo)
}
Backup_AchievementInfo::Backup_AchievementInfo(const Backup_AchievementInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_id()) {
    id_.Set(from._internal_id(), 
      GetArenaForAllocation());
  }
  achieved_ = from.achieved_;
  // @@protoc_insertion_point(copy_constructor:ei.Backup.AchievementInfo)
}

inline void Backup_AchievementInfo::SharedCtor() {
id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
achieved_ = false;
}

Backup_AchievementInfo::~Backup_AchievementInfo() {
  // @@protoc_insertion_point(destructor:ei.Backup.AchievementInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Backup_AchievementInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  id_.Destroy();
}

void Backup_AchievementInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Backup_AchievementInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.Backup.AchievementInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    id_.ClearNonDefaultToEmpty();
  }
  achieved_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Backup_AchievementInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.Backup.AchievementInfo.id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool achieved = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_achieved(&has_bits);
          achieved_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Backup_AchievementInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.Backup.AchievementInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.Backup.AchievementInfo.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // optional bool achieved = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_achieved(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.Backup.AchievementInfo)
  return target;
}

size_t Backup_AchievementInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.Backup.AchievementInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_id());
    }

    // optional bool achieved = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Backup_AchievementInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Backup_AchievementInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Backup_AchievementInfo::GetClassData() const { return &_class_data_; }

void Backup_AchievementInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Backup_AchievementInfo *>(to)->MergeFrom(
      static_cast<const Backup_AchievementInfo &>(from));
}


void Backup_AchievementInfo::MergeFrom(const Backup_AchievementInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.Backup.AchievementInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      achieved_ = from.achieved_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Backup_AchievementInfo::CopyFrom(const Backup_AchievementInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.Backup.AchievementInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Backup_AchievementInfo::IsInitialized() const {
  return true;
}

void Backup_AchievementInfo::InternalSwap(Backup_AchievementInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &id_, lhs_arena,
      &other->id_, rhs_arena
  );
  swap(achieved_, other->achieved_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Backup_AchievementInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[11]);
}

// ===================================================================

class Backup_ActiveBoost::_Internal {
 public:
  using HasBits = decltype(std::declval<Backup_ActiveBoost>()._has_bits_);
  static void set_has_boost_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_time_remaining(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_reference_value(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Backup_ActiveBoost::Backup_ActiveBoost(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.Backup.ActiveBoost)
}
Backup_ActiveBoost::Backup_ActiveBoost(const Backup_ActiveBoost& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  boost_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    boost_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_boost_id()) {
    boost_id_.Set(from._internal_boost_id(), 
      GetArenaForAllocation());
  }
  ::memcpy(&time_remaining_, &from.time_remaining_,
    static_cast<size_t>(reinterpret_cast<char*>(&reference_value_) -
    reinterpret_cast<char*>(&time_remaining_)) + sizeof(reference_value_));
  // @@protoc_insertion_point(copy_constructor:ei.Backup.ActiveBoost)
}

inline void Backup_ActiveBoost::SharedCtor() {
boost_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  boost_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&time_remaining_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&reference_value_) -
    reinterpret_cast<char*>(&time_remaining_)) + sizeof(reference_value_));
}

Backup_ActiveBoost::~Backup_ActiveBoost() {
  // @@protoc_insertion_point(destructor:ei.Backup.ActiveBoost)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Backup_ActiveBoost::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  boost_id_.Destroy();
}

void Backup_ActiveBoost::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Backup_ActiveBoost::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.Backup.ActiveBoost)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    boost_id_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&time_remaining_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&reference_value_) -
        reinterpret_cast<char*>(&time_remaining_)) + sizeof(reference_value_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Backup_ActiveBoost::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string boost_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_boost_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.Backup.ActiveBoost.boost_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double time_remaining = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_time_remaining(&has_bits);
          time_remaining_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double reference_value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_reference_value(&has_bits);
          reference_value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Backup_ActiveBoost::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.Backup.ActiveBoost)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string boost_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_boost_id().data(), static_cast<int>(this->_internal_boost_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.Backup.ActiveBoost.boost_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_boost_id(), target);
  }

  // optional double time_remaining = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_time_remaining(), target);
  }

  // optional double reference_value = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_reference_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.Backup.ActiveBoost)
  return target;
}

size_t Backup_ActiveBoost::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.Backup.ActiveBoost)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string boost_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_boost_id());
    }

    // optional double time_remaining = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double reference_value = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Backup_ActiveBoost::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Backup_ActiveBoost::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Backup_ActiveBoost::GetClassData() const { return &_class_data_; }

void Backup_ActiveBoost::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Backup_ActiveBoost *>(to)->MergeFrom(
      static_cast<const Backup_ActiveBoost &>(from));
}


void Backup_ActiveBoost::MergeFrom(const Backup_ActiveBoost& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.Backup.ActiveBoost)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_boost_id(from._internal_boost_id());
    }
    if (cached_has_bits & 0x00000002u) {
      time_remaining_ = from.time_remaining_;
    }
    if (cached_has_bits & 0x00000004u) {
      reference_value_ = from.reference_value_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Backup_ActiveBoost::CopyFrom(const Backup_ActiveBoost& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.Backup.ActiveBoost)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Backup_ActiveBoost::IsInitialized() const {
  return true;
}

void Backup_ActiveBoost::InternalSwap(Backup_ActiveBoost* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &boost_id_, lhs_arena,
      &other->boost_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Backup_ActiveBoost, reference_value_)
      + sizeof(Backup_ActiveBoost::reference_value_)
      - PROTOBUF_FIELD_OFFSET(Backup_ActiveBoost, time_remaining_)>(
          reinterpret_cast<char*>(&time_remaining_),
          reinterpret_cast<char*>(&other->time_remaining_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Backup_ActiveBoost::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[12]);
}

// ===================================================================

class Backup_OwnedBoost::_Internal {
 public:
  using HasBits = decltype(std::declval<Backup_OwnedBoost>()._has_bits_);
  static void set_has_boost_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Backup_OwnedBoost::Backup_OwnedBoost(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.Backup.OwnedBoost)
}
Backup_OwnedBoost::Backup_OwnedBoost(const Backup_OwnedBoost& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  boost_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    boost_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_boost_id()) {
    boost_id_.Set(from._internal_boost_id(), 
      GetArenaForAllocation());
  }
  count_ = from.count_;
  // @@protoc_insertion_point(copy_constructor:ei.Backup.OwnedBoost)
}

inline void Backup_OwnedBoost::SharedCtor() {
boost_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  boost_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
count_ = 0u;
}

Backup_OwnedBoost::~Backup_OwnedBoost() {
  // @@protoc_insertion_point(destructor:ei.Backup.OwnedBoost)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Backup_OwnedBoost::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  boost_id_.Destroy();
}

void Backup_OwnedBoost::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Backup_OwnedBoost::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.Backup.OwnedBoost)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    boost_id_.ClearNonDefaultToEmpty();
  }
  count_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Backup_OwnedBoost::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string boost_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_boost_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.Backup.OwnedBoost.boost_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_count(&has_bits);
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Backup_OwnedBoost::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.Backup.OwnedBoost)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string boost_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_boost_id().data(), static_cast<int>(this->_internal_boost_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.Backup.OwnedBoost.boost_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_boost_id(), target);
  }

  // optional uint32 count = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.Backup.OwnedBoost)
  return target;
}

size_t Backup_OwnedBoost::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.Backup.OwnedBoost)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string boost_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_boost_id());
    }

    // optional uint32 count = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Backup_OwnedBoost::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Backup_OwnedBoost::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Backup_OwnedBoost::GetClassData() const { return &_class_data_; }

void Backup_OwnedBoost::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Backup_OwnedBoost *>(to)->MergeFrom(
      static_cast<const Backup_OwnedBoost &>(from));
}


void Backup_OwnedBoost::MergeFrom(const Backup_OwnedBoost& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.Backup.OwnedBoost)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_boost_id(from._internal_boost_id());
    }
    if (cached_has_bits & 0x00000002u) {
      count_ = from.count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Backup_OwnedBoost::CopyFrom(const Backup_OwnedBoost& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.Backup.OwnedBoost)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Backup_OwnedBoost::IsInitialized() const {
  return true;
}

void Backup_OwnedBoost::InternalSwap(Backup_OwnedBoost* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &boost_id_, lhs_arena,
      &other->boost_id_, rhs_arena
  );
  swap(count_, other->count_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Backup_OwnedBoost::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[13]);
}

// ===================================================================

class Backup_MissionInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<Backup_MissionInfo>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_completed(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_reference_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Backup_MissionInfo::Backup_MissionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.Backup.MissionInfo)
}
Backup_MissionInfo::Backup_MissionInfo(const Backup_MissionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_id()) {
    id_.Set(from._internal_id(), 
      GetArenaForAllocation());
  }
  ::memcpy(&reference_value_, &from.reference_value_,
    static_cast<size_t>(reinterpret_cast<char*>(&completed_) -
    reinterpret_cast<char*>(&reference_value_)) + sizeof(completed_));
  // @@protoc_insertion_point(copy_constructor:ei.Backup.MissionInfo)
}

inline void Backup_MissionInfo::SharedCtor() {
id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&reference_value_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&completed_) -
    reinterpret_cast<char*>(&reference_value_)) + sizeof(completed_));
}

Backup_MissionInfo::~Backup_MissionInfo() {
  // @@protoc_insertion_point(destructor:ei.Backup.MissionInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Backup_MissionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  id_.Destroy();
}

void Backup_MissionInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Backup_MissionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.Backup.MissionInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    id_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&reference_value_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&completed_) -
        reinterpret_cast<char*>(&reference_value_)) + sizeof(completed_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Backup_MissionInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.Backup.MissionInfo.id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool completed = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_completed(&has_bits);
          completed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double reference_value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_reference_value(&has_bits);
          reference_value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Backup_MissionInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.Backup.MissionInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.Backup.MissionInfo.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // optional bool completed = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_completed(), target);
  }

  // optional double reference_value = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_reference_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.Backup.MissionInfo)
  return target;
}

size_t Backup_MissionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.Backup.MissionInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_id());
    }

    // optional double reference_value = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional bool completed = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Backup_MissionInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Backup_MissionInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Backup_MissionInfo::GetClassData() const { return &_class_data_; }

void Backup_MissionInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Backup_MissionInfo *>(to)->MergeFrom(
      static_cast<const Backup_MissionInfo &>(from));
}


void Backup_MissionInfo::MergeFrom(const Backup_MissionInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.Backup.MissionInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      reference_value_ = from.reference_value_;
    }
    if (cached_has_bits & 0x00000004u) {
      completed_ = from.completed_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Backup_MissionInfo::CopyFrom(const Backup_MissionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.Backup.MissionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Backup_MissionInfo::IsInitialized() const {
  return true;
}

void Backup_MissionInfo::InternalSwap(Backup_MissionInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &id_, lhs_arena,
      &other->id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Backup_MissionInfo, completed_)
      + sizeof(Backup_MissionInfo::completed_)
      - PROTOBUF_FIELD_OFFSET(Backup_MissionInfo, reference_value_)>(
          reinterpret_cast<char*>(&reference_value_),
          reinterpret_cast<char*>(&other->reference_value_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Backup_MissionInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[14]);
}

// ===================================================================

class Backup::_Internal {
 public:
  using HasBits = decltype(std::declval<Backup>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ei_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_game_services_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_device_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_user_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_approx_time(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_force_offer_backup(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_force_backup(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static const ::ei::Backup_Settings& settings(const Backup* msg);
  static void set_has_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::ei::Backup_Tutorial& tutorial(const Backup* msg);
  static void set_has_tutorial(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::ei::Backup_Stats& stats(const Backup* msg);
  static void set_has_stats(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::ei::Backup_Game& game(const Backup* msg);
  static void set_has_game(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::ei::Backup_Artifacts& artifacts(const Backup* msg);
  static void set_has_artifacts(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::ei::Backup_Shells& shells(const Backup* msg);
  static void set_has_shells(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static const ::ei::Backup_Simulation& sim(const Backup* msg);
  static void set_has_sim(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::ei::Backup_Mission& mission(const Backup* msg);
  static void set_has_mission(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::ei::Backup_Misc& misc(const Backup* msg);
  static void set_has_misc(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::ei::MyContracts& contracts(const Backup* msg);
  static void set_has_contracts(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::ei::ArtifactsDB& artifacts_db(const Backup* msg);
  static void set_has_artifacts_db(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static const ::ei::ShellDB& shell_db(const Backup* msg);
  static void set_has_shell_db(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_checksum(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::ei::Backup_Settings&
Backup::_Internal::settings(const Backup* msg) {
  return *msg->settings_;
}
const ::ei::Backup_Tutorial&
Backup::_Internal::tutorial(const Backup* msg) {
  return *msg->tutorial_;
}
const ::ei::Backup_Stats&
Backup::_Internal::stats(const Backup* msg) {
  return *msg->stats_;
}
const ::ei::Backup_Game&
Backup::_Internal::game(const Backup* msg) {
  return *msg->game_;
}
const ::ei::Backup_Artifacts&
Backup::_Internal::artifacts(const Backup* msg) {
  return *msg->artifacts_;
}
const ::ei::Backup_Shells&
Backup::_Internal::shells(const Backup* msg) {
  return *msg->shells_;
}
const ::ei::Backup_Simulation&
Backup::_Internal::sim(const Backup* msg) {
  return *msg->sim_;
}
const ::ei::Backup_Mission&
Backup::_Internal::mission(const Backup* msg) {
  return *msg->mission_;
}
const ::ei::Backup_Misc&
Backup::_Internal::misc(const Backup* msg) {
  return *msg->misc_;
}
const ::ei::MyContracts&
Backup::_Internal::contracts(const Backup* msg) {
  return *msg->contracts_;
}
const ::ei::ArtifactsDB&
Backup::_Internal::artifacts_db(const Backup* msg) {
  return *msg->artifacts_db_;
}
const ::ei::ShellDB&
Backup::_Internal::shell_db(const Backup* msg) {
  return *msg->shell_db_;
}
Backup::Backup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  farms_(arena),
  read_mail_ids_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.Backup)
}
Backup::Backup(const Backup& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      farms_(from.farms_),
      read_mail_ids_(from.read_mail_ids_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_id()) {
    user_id_.Set(from._internal_user_id(), 
      GetArenaForAllocation());
  }
  user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_name()) {
    user_name_.Set(from._internal_user_name(), 
      GetArenaForAllocation());
  }
  game_services_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    game_services_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_game_services_id()) {
    game_services_id_.Set(from._internal_game_services_id(), 
      GetArenaForAllocation());
  }
  device_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    device_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_id()) {
    device_id_.Set(from._internal_device_id(), 
      GetArenaForAllocation());
  }
  ei_user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ei_user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ei_user_id()) {
    ei_user_id_.Set(from._internal_ei_user_id(), 
      GetArenaForAllocation());
  }
  signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signature()) {
    signature_.Set(from._internal_signature(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_settings()) {
    settings_ = new ::ei::Backup_Settings(*from.settings_);
  } else {
    settings_ = nullptr;
  }
  if (from._internal_has_tutorial()) {
    tutorial_ = new ::ei::Backup_Tutorial(*from.tutorial_);
  } else {
    tutorial_ = nullptr;
  }
  if (from._internal_has_stats()) {
    stats_ = new ::ei::Backup_Stats(*from.stats_);
  } else {
    stats_ = nullptr;
  }
  if (from._internal_has_game()) {
    game_ = new ::ei::Backup_Game(*from.game_);
  } else {
    game_ = nullptr;
  }
  if (from._internal_has_sim()) {
    sim_ = new ::ei::Backup_Simulation(*from.sim_);
  } else {
    sim_ = nullptr;
  }
  if (from._internal_has_mission()) {
    mission_ = new ::ei::Backup_Mission(*from.mission_);
  } else {
    mission_ = nullptr;
  }
  if (from._internal_has_misc()) {
    misc_ = new ::ei::Backup_Misc(*from.misc_);
  } else {
    misc_ = nullptr;
  }
  if (from._internal_has_contracts()) {
    contracts_ = new ::ei::MyContracts(*from.contracts_);
  } else {
    contracts_ = nullptr;
  }
  if (from._internal_has_artifacts()) {
    artifacts_ = new ::ei::Backup_Artifacts(*from.artifacts_);
  } else {
    artifacts_ = nullptr;
  }
  if (from._internal_has_artifacts_db()) {
    artifacts_db_ = new ::ei::ArtifactsDB(*from.artifacts_db_);
  } else {
    artifacts_db_ = nullptr;
  }
  if (from._internal_has_shell_db()) {
    shell_db_ = new ::ei::ShellDB(*from.shell_db_);
  } else {
    shell_db_ = nullptr;
  }
  if (from._internal_has_shells()) {
    shells_ = new ::ei::Backup_Shells(*from.shells_);
  } else {
    shells_ = nullptr;
  }
  ::memcpy(&approx_time_, &from.approx_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&checksum_) -
    reinterpret_cast<char*>(&approx_time_)) + sizeof(checksum_));
  // @@protoc_insertion_point(copy_constructor:ei.Backup)
}

inline void Backup::SharedCtor() {
user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
user_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
game_services_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  game_services_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
device_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  device_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
ei_user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ei_user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
signature_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  signature_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&settings_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&checksum_) -
    reinterpret_cast<char*>(&settings_)) + sizeof(checksum_));
}

Backup::~Backup() {
  // @@protoc_insertion_point(destructor:ei.Backup)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Backup::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_id_.Destroy();
  user_name_.Destroy();
  game_services_id_.Destroy();
  device_id_.Destroy();
  ei_user_id_.Destroy();
  signature_.Destroy();
  if (this != internal_default_instance()) delete settings_;
  if (this != internal_default_instance()) delete tutorial_;
  if (this != internal_default_instance()) delete stats_;
  if (this != internal_default_instance()) delete game_;
  if (this != internal_default_instance()) delete sim_;
  if (this != internal_default_instance()) delete mission_;
  if (this != internal_default_instance()) delete misc_;
  if (this != internal_default_instance()) delete contracts_;
  if (this != internal_default_instance()) delete artifacts_;
  if (this != internal_default_instance()) delete artifacts_db_;
  if (this != internal_default_instance()) delete shell_db_;
  if (this != internal_default_instance()) delete shells_;
}

void Backup::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Backup::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.Backup)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  farms_.Clear();
  read_mail_ids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      user_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      game_services_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      device_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      ei_user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      signature_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(settings_ != nullptr);
      settings_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(tutorial_ != nullptr);
      tutorial_->Clear();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(stats_ != nullptr);
      stats_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(game_ != nullptr);
      game_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(sim_ != nullptr);
      sim_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(mission_ != nullptr);
      mission_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(misc_ != nullptr);
      misc_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(contracts_ != nullptr);
      contracts_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(artifacts_ != nullptr);
      artifacts_->Clear();
    }
    if (cached_has_bits & 0x00008000u) {
      GOOGLE_DCHECK(artifacts_db_ != nullptr);
      artifacts_db_->Clear();
    }
  }
  if (cached_has_bits & 0x00030000u) {
    if (cached_has_bits & 0x00010000u) {
      GOOGLE_DCHECK(shell_db_ != nullptr);
      shell_db_->Clear();
    }
    if (cached_has_bits & 0x00020000u) {
      GOOGLE_DCHECK(shells_ != nullptr);
      shells_->Clear();
    }
  }
  if (cached_has_bits & 0x007c0000u) {
    ::memset(&approx_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&checksum_) -
        reinterpret_cast<char*>(&approx_time_)) + sizeof(checksum_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Backup::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.Backup.user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string user_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_user_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.Backup.user_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double approx_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_approx_time(&has_bits);
          approx_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.Backup.Settings settings = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.Backup.Tutorial tutorial = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_tutorial(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.Backup.Stats stats = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_stats(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.Backup.Game game = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_game(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.Backup.Simulation sim = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_sim(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.Backup.Mission mission = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_mission(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.Backup.Misc misc = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_misc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.Backup.Simulation farms = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_farms(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .ei.MyContracts contracts = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_contracts(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.Backup.Artifacts artifacts = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_artifacts(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.ArtifactsDB artifacts_db = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_artifacts_db(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string game_services_id = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          auto str = _internal_mutable_game_services_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.Backup.game_services_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string device_id = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          auto str = _internal_mutable_device_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.Backup.device_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string ei_user_id = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          auto str = _internal_mutable_ei_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.Backup.ei_user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool force_offer_backup = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_force_offer_backup(&has_bits);
          force_offer_backup_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 version = 21 [default = 0];
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool force_backup = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_force_backup(&has_bits);
          force_backup_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string read_mail_ids = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_read_mail_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "ei.Backup.read_mail_ids");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<186>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .ei.ShellDB shell_db = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_shell_db(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.Backup.Shells shells = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_shells(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 checksum = 100;
      case 100:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_checksum(&has_bits);
          checksum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string signature = 101;
      case 101:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_signature();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.Backup.signature");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Backup::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.Backup)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.Backup.user_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_id(), target);
  }

  // optional string user_name = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_name().data(), static_cast<int>(this->_internal_user_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.Backup.user_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_user_name(), target);
  }

  // optional double approx_time = 3;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_approx_time(), target);
  }

  // optional .ei.Backup.Settings settings = 4;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::settings(this),
        _Internal::settings(this).GetCachedSize(), target, stream);
  }

  // optional .ei.Backup.Tutorial tutorial = 5;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::tutorial(this),
        _Internal::tutorial(this).GetCachedSize(), target, stream);
  }

  // optional .ei.Backup.Stats stats = 6;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::stats(this),
        _Internal::stats(this).GetCachedSize(), target, stream);
  }

  // optional .ei.Backup.Game game = 7;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::game(this),
        _Internal::game(this).GetCachedSize(), target, stream);
  }

  // optional .ei.Backup.Simulation sim = 8;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::sim(this),
        _Internal::sim(this).GetCachedSize(), target, stream);
  }

  // optional .ei.Backup.Mission mission = 9;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::mission(this),
        _Internal::mission(this).GetCachedSize(), target, stream);
  }

  // optional .ei.Backup.Misc misc = 10;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::misc(this),
        _Internal::misc(this).GetCachedSize(), target, stream);
  }

  // repeated .ei.Backup.Simulation farms = 12;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_farms_size()); i < n; i++) {
    const auto& repfield = this->_internal_farms(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .ei.MyContracts contracts = 13;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::contracts(this),
        _Internal::contracts(this).GetCachedSize(), target, stream);
  }

  // optional .ei.Backup.Artifacts artifacts = 14;
  if (cached_has_bits & 0x00004000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::artifacts(this),
        _Internal::artifacts(this).GetCachedSize(), target, stream);
  }

  // optional .ei.ArtifactsDB artifacts_db = 15;
  if (cached_has_bits & 0x00008000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::artifacts_db(this),
        _Internal::artifacts_db(this).GetCachedSize(), target, stream);
  }

  // optional string game_services_id = 16;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_game_services_id().data(), static_cast<int>(this->_internal_game_services_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.Backup.game_services_id");
    target = stream->WriteStringMaybeAliased(
        16, this->_internal_game_services_id(), target);
  }

  // optional string device_id = 17;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_device_id().data(), static_cast<int>(this->_internal_device_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.Backup.device_id");
    target = stream->WriteStringMaybeAliased(
        17, this->_internal_device_id(), target);
  }

  // optional string ei_user_id = 18;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ei_user_id().data(), static_cast<int>(this->_internal_ei_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.Backup.ei_user_id");
    target = stream->WriteStringMaybeAliased(
        18, this->_internal_ei_user_id(), target);
  }

  // optional bool force_offer_backup = 20;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(20, this->_internal_force_offer_backup(), target);
  }

  // optional uint32 version = 21 [default = 0];
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_version(), target);
  }

  // optional bool force_backup = 22;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(22, this->_internal_force_backup(), target);
  }

  // repeated string read_mail_ids = 23;
  for (int i = 0, n = this->_internal_read_mail_ids_size(); i < n; i++) {
    const auto& s = this->_internal_read_mail_ids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.Backup.read_mail_ids");
    target = stream->WriteString(23, s, target);
  }

  // optional .ei.ShellDB shell_db = 24;
  if (cached_has_bits & 0x00010000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(24, _Internal::shell_db(this),
        _Internal::shell_db(this).GetCachedSize(), target, stream);
  }

  // optional .ei.Backup.Shells shells = 25;
  if (cached_has_bits & 0x00020000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(25, _Internal::shells(this),
        _Internal::shells(this).GetCachedSize(), target, stream);
  }

  // optional uint64 checksum = 100;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(100, this->_internal_checksum(), target);
  }

  // optional string signature = 101;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_signature().data(), static_cast<int>(this->_internal_signature().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.Backup.signature");
    target = stream->WriteStringMaybeAliased(
        101, this->_internal_signature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.Backup)
  return target;
}

size_t Backup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.Backup)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.Backup.Simulation farms = 12;
  total_size += 1UL * this->_internal_farms_size();
  for (const auto& msg : this->farms_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string read_mail_ids = 23;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(read_mail_ids_.size());
  for (int i = 0, n = read_mail_ids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      read_mail_ids_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string user_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_id());
    }

    // optional string user_name = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_name());
    }

    // optional string game_services_id = 16;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_game_services_id());
    }

    // optional string device_id = 17;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_id());
    }

    // optional string ei_user_id = 18;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ei_user_id());
    }

    // optional string signature = 101;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_signature());
    }

    // optional .ei.Backup.Settings settings = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *settings_);
    }

    // optional .ei.Backup.Tutorial tutorial = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *tutorial_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .ei.Backup.Stats stats = 6;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *stats_);
    }

    // optional .ei.Backup.Game game = 7;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *game_);
    }

    // optional .ei.Backup.Simulation sim = 8;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *sim_);
    }

    // optional .ei.Backup.Mission mission = 9;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *mission_);
    }

    // optional .ei.Backup.Misc misc = 10;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *misc_);
    }

    // optional .ei.MyContracts contracts = 13;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *contracts_);
    }

    // optional .ei.Backup.Artifacts artifacts = 14;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *artifacts_);
    }

    // optional .ei.ArtifactsDB artifacts_db = 15;
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *artifacts_db_);
    }

  }
  if (cached_has_bits & 0x007f0000u) {
    // optional .ei.ShellDB shell_db = 24;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *shell_db_);
    }

    // optional .ei.Backup.Shells shells = 25;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *shells_);
    }

    // optional double approx_time = 3;
    if (cached_has_bits & 0x00040000u) {
      total_size += 1 + 8;
    }

    // optional uint32 version = 21 [default = 0];
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_version());
    }

    // optional bool force_offer_backup = 20;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 1;
    }

    // optional bool force_backup = 22;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 + 1;
    }

    // optional uint64 checksum = 100;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_checksum());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Backup::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Backup::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Backup::GetClassData() const { return &_class_data_; }

void Backup::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Backup *>(to)->MergeFrom(
      static_cast<const Backup &>(from));
}


void Backup::MergeFrom(const Backup& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.Backup)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  farms_.MergeFrom(from.farms_);
  read_mail_ids_.MergeFrom(from.read_mail_ids_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_id(from._internal_user_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_user_name(from._internal_user_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_game_services_id(from._internal_game_services_id());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_device_id(from._internal_device_id());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_ei_user_id(from._internal_ei_user_id());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_signature(from._internal_signature());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_settings()->::ei::Backup_Settings::MergeFrom(from._internal_settings());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_tutorial()->::ei::Backup_Tutorial::MergeFrom(from._internal_tutorial());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_mutable_stats()->::ei::Backup_Stats::MergeFrom(from._internal_stats());
    }
    if (cached_has_bits & 0x00000200u) {
      _internal_mutable_game()->::ei::Backup_Game::MergeFrom(from._internal_game());
    }
    if (cached_has_bits & 0x00000400u) {
      _internal_mutable_sim()->::ei::Backup_Simulation::MergeFrom(from._internal_sim());
    }
    if (cached_has_bits & 0x00000800u) {
      _internal_mutable_mission()->::ei::Backup_Mission::MergeFrom(from._internal_mission());
    }
    if (cached_has_bits & 0x00001000u) {
      _internal_mutable_misc()->::ei::Backup_Misc::MergeFrom(from._internal_misc());
    }
    if (cached_has_bits & 0x00002000u) {
      _internal_mutable_contracts()->::ei::MyContracts::MergeFrom(from._internal_contracts());
    }
    if (cached_has_bits & 0x00004000u) {
      _internal_mutable_artifacts()->::ei::Backup_Artifacts::MergeFrom(from._internal_artifacts());
    }
    if (cached_has_bits & 0x00008000u) {
      _internal_mutable_artifacts_db()->::ei::ArtifactsDB::MergeFrom(from._internal_artifacts_db());
    }
  }
  if (cached_has_bits & 0x007f0000u) {
    if (cached_has_bits & 0x00010000u) {
      _internal_mutable_shell_db()->::ei::ShellDB::MergeFrom(from._internal_shell_db());
    }
    if (cached_has_bits & 0x00020000u) {
      _internal_mutable_shells()->::ei::Backup_Shells::MergeFrom(from._internal_shells());
    }
    if (cached_has_bits & 0x00040000u) {
      approx_time_ = from.approx_time_;
    }
    if (cached_has_bits & 0x00080000u) {
      version_ = from.version_;
    }
    if (cached_has_bits & 0x00100000u) {
      force_offer_backup_ = from.force_offer_backup_;
    }
    if (cached_has_bits & 0x00200000u) {
      force_backup_ = from.force_backup_;
    }
    if (cached_has_bits & 0x00400000u) {
      checksum_ = from.checksum_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Backup::CopyFrom(const Backup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.Backup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Backup::IsInitialized() const {
  return true;
}

void Backup::InternalSwap(Backup* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  farms_.InternalSwap(&other->farms_);
  read_mail_ids_.InternalSwap(&other->read_mail_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_name_, lhs_arena,
      &other->user_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &game_services_id_, lhs_arena,
      &other->game_services_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &device_id_, lhs_arena,
      &other->device_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ei_user_id_, lhs_arena,
      &other->ei_user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &signature_, lhs_arena,
      &other->signature_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Backup, checksum_)
      + sizeof(Backup::checksum_)
      - PROTOBUF_FIELD_OFFSET(Backup, settings_)>(
          reinterpret_cast<char*>(&settings_),
          reinterpret_cast<char*>(&other->settings_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Backup::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[15]);
}

// ===================================================================

class EggIncFirstContactRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<EggIncFirstContactRequest>()._has_bits_);
  static const ::ei::BasicRequestInfo& rinfo(const EggIncFirstContactRequest* msg);
  static void set_has_rinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_ei_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_game_services_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_device_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_username(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_platform(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::ei::BasicRequestInfo&
EggIncFirstContactRequest::_Internal::rinfo(const EggIncFirstContactRequest* msg) {
  return *msg->rinfo_;
}
EggIncFirstContactRequest::EggIncFirstContactRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.EggIncFirstContactRequest)
}
EggIncFirstContactRequest::EggIncFirstContactRequest(const EggIncFirstContactRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_id()) {
    user_id_.Set(from._internal_user_id(), 
      GetArenaForAllocation());
  }
  ei_user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ei_user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ei_user_id()) {
    ei_user_id_.Set(from._internal_ei_user_id(), 
      GetArenaForAllocation());
  }
  device_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    device_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_id()) {
    device_id_.Set(from._internal_device_id(), 
      GetArenaForAllocation());
  }
  username_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    username_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_username()) {
    username_.Set(from._internal_username(), 
      GetArenaForAllocation());
  }
  game_services_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    game_services_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_game_services_id()) {
    game_services_id_.Set(from._internal_game_services_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_rinfo()) {
    rinfo_ = new ::ei::BasicRequestInfo(*from.rinfo_);
  } else {
    rinfo_ = nullptr;
  }
  ::memcpy(&client_version_, &from.client_version_,
    static_cast<size_t>(reinterpret_cast<char*>(&platform_) -
    reinterpret_cast<char*>(&client_version_)) + sizeof(platform_));
  // @@protoc_insertion_point(copy_constructor:ei.EggIncFirstContactRequest)
}

inline void EggIncFirstContactRequest::SharedCtor() {
user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
ei_user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ei_user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
device_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  device_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
username_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  username_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
game_services_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  game_services_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rinfo_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&client_version_) -
    reinterpret_cast<char*>(&rinfo_)) + sizeof(client_version_));
platform_ = 1;
}

EggIncFirstContactRequest::~EggIncFirstContactRequest() {
  // @@protoc_insertion_point(destructor:ei.EggIncFirstContactRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EggIncFirstContactRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_id_.Destroy();
  ei_user_id_.Destroy();
  device_id_.Destroy();
  username_.Destroy();
  game_services_id_.Destroy();
  if (this != internal_default_instance()) delete rinfo_;
}

void EggIncFirstContactRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EggIncFirstContactRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.EggIncFirstContactRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ei_user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      device_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      username_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      game_services_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(rinfo_ != nullptr);
      rinfo_->Clear();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    client_version_ = 0u;
    platform_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EggIncFirstContactRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.EggIncFirstContactRequest.user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 client_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_client_version(&has_bits);
          client_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.Platform platform = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::Platform_IsValid(val))) {
            _internal_set_platform(static_cast<::ei::Platform>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string ei_user_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_ei_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.EggIncFirstContactRequest.ei_user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string device_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_device_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.EggIncFirstContactRequest.device_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string username = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_username();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.EggIncFirstContactRequest.username");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string game_services_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_game_services_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.EggIncFirstContactRequest.game_services_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .ei.BasicRequestInfo rinfo = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_rinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EggIncFirstContactRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.EggIncFirstContactRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.EggIncFirstContactRequest.user_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_id(), target);
  }

  // optional uint32 client_version = 2;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_client_version(), target);
  }

  // optional .ei.Platform platform = 3;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_platform(), target);
  }

  // optional string ei_user_id = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ei_user_id().data(), static_cast<int>(this->_internal_ei_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.EggIncFirstContactRequest.ei_user_id");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_ei_user_id(), target);
  }

  // optional string device_id = 5;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_device_id().data(), static_cast<int>(this->_internal_device_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.EggIncFirstContactRequest.device_id");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_device_id(), target);
  }

  // optional string username = 6;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_username().data(), static_cast<int>(this->_internal_username().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.EggIncFirstContactRequest.username");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_username(), target);
  }

  // optional string game_services_id = 7;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_game_services_id().data(), static_cast<int>(this->_internal_game_services_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.EggIncFirstContactRequest.game_services_id");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_game_services_id(), target);
  }

  // optional .ei.BasicRequestInfo rinfo = 8;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::rinfo(this),
        _Internal::rinfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.EggIncFirstContactRequest)
  return target;
}

size_t EggIncFirstContactRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.EggIncFirstContactRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string user_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_id());
    }

    // optional string ei_user_id = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ei_user_id());
    }

    // optional string device_id = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_id());
    }

    // optional string username = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_username());
    }

    // optional string game_services_id = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_game_services_id());
    }

    // optional .ei.BasicRequestInfo rinfo = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rinfo_);
    }

    // optional uint32 client_version = 2;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_client_version());
    }

    // optional .ei.Platform platform = 3;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_platform());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EggIncFirstContactRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    EggIncFirstContactRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EggIncFirstContactRequest::GetClassData() const { return &_class_data_; }

void EggIncFirstContactRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<EggIncFirstContactRequest *>(to)->MergeFrom(
      static_cast<const EggIncFirstContactRequest &>(from));
}


void EggIncFirstContactRequest::MergeFrom(const EggIncFirstContactRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.EggIncFirstContactRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_id(from._internal_user_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_ei_user_id(from._internal_ei_user_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_device_id(from._internal_device_id());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_username(from._internal_username());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_game_services_id(from._internal_game_services_id());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_rinfo()->::ei::BasicRequestInfo::MergeFrom(from._internal_rinfo());
    }
    if (cached_has_bits & 0x00000040u) {
      client_version_ = from.client_version_;
    }
    if (cached_has_bits & 0x00000080u) {
      platform_ = from.platform_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EggIncFirstContactRequest::CopyFrom(const EggIncFirstContactRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.EggIncFirstContactRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EggIncFirstContactRequest::IsInitialized() const {
  return true;
}

void EggIncFirstContactRequest::InternalSwap(EggIncFirstContactRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ei_user_id_, lhs_arena,
      &other->ei_user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &device_id_, lhs_arena,
      &other->device_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &username_, lhs_arena,
      &other->username_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &game_services_id_, lhs_arena,
      &other->game_services_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EggIncFirstContactRequest, client_version_)
      + sizeof(EggIncFirstContactRequest::client_version_)
      - PROTOBUF_FIELD_OFFSET(EggIncFirstContactRequest, rinfo_)>(
          reinterpret_cast<char*>(&rinfo_),
          reinterpret_cast<char*>(&other->rinfo_));
  swap(platform_, other->platform_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EggIncFirstContactRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[16]);
}

// ===================================================================

class EggIncFirstContactResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<EggIncFirstContactResponse>()._has_bits_);
  static void set_has_ei_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_error_code(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_error_message(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::ei::Backup& backup(const EggIncFirstContactResponse* msg);
  static void set_has_backup(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::ei::Backup&
EggIncFirstContactResponse::_Internal::backup(const EggIncFirstContactResponse* msg) {
  return *msg->backup_;
}
EggIncFirstContactResponse::EggIncFirstContactResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  ids_transferred_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.EggIncFirstContactResponse)
}
EggIncFirstContactResponse::EggIncFirstContactResponse(const EggIncFirstContactResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      ids_transferred_(from.ids_transferred_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ei_user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ei_user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ei_user_id()) {
    ei_user_id_.Set(from._internal_ei_user_id(), 
      GetArenaForAllocation());
  }
  error_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    error_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_error_message()) {
    error_message_.Set(from._internal_error_message(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_backup()) {
    backup_ = new ::ei::Backup(*from.backup_);
  } else {
    backup_ = nullptr;
  }
  error_code_ = from.error_code_;
  // @@protoc_insertion_point(copy_constructor:ei.EggIncFirstContactResponse)
}

inline void EggIncFirstContactResponse::SharedCtor() {
ei_user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ei_user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
error_message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  error_message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&backup_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&error_code_) -
    reinterpret_cast<char*>(&backup_)) + sizeof(error_code_));
}

EggIncFirstContactResponse::~EggIncFirstContactResponse() {
  // @@protoc_insertion_point(destructor:ei.EggIncFirstContactResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EggIncFirstContactResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ei_user_id_.Destroy();
  error_message_.Destroy();
  if (this != internal_default_instance()) delete backup_;
}

void EggIncFirstContactResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EggIncFirstContactResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.EggIncFirstContactResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ids_transferred_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ei_user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      error_message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(backup_ != nullptr);
      backup_->Clear();
    }
  }
  error_code_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EggIncFirstContactResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.Backup backup = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_backup(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string ei_user_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_ei_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.EggIncFirstContactResponse.ei_user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated string ids_transferred = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_ids_transferred();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "ei.EggIncFirstContactResponse.ids_transferred");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 error_code = 4 [default = 0];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_error_code(&has_bits);
          error_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string error_message = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_error_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.EggIncFirstContactResponse.error_message");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EggIncFirstContactResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.EggIncFirstContactResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.Backup backup = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::backup(this),
        _Internal::backup(this).GetCachedSize(), target, stream);
  }

  // optional string ei_user_id = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ei_user_id().data(), static_cast<int>(this->_internal_ei_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.EggIncFirstContactResponse.ei_user_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_ei_user_id(), target);
  }

  // repeated string ids_transferred = 3;
  for (int i = 0, n = this->_internal_ids_transferred_size(); i < n; i++) {
    const auto& s = this->_internal_ids_transferred(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.EggIncFirstContactResponse.ids_transferred");
    target = stream->WriteString(3, s, target);
  }

  // optional uint32 error_code = 4 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_error_code(), target);
  }

  // optional string error_message = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_error_message().data(), static_cast<int>(this->_internal_error_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.EggIncFirstContactResponse.error_message");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_error_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.EggIncFirstContactResponse)
  return target;
}

size_t EggIncFirstContactResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.EggIncFirstContactResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string ids_transferred = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(ids_transferred_.size());
  for (int i = 0, n = ids_transferred_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      ids_transferred_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string ei_user_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ei_user_id());
    }

    // optional string error_message = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_error_message());
    }

    // optional .ei.Backup backup = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *backup_);
    }

    // optional uint32 error_code = 4 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_error_code());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EggIncFirstContactResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    EggIncFirstContactResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EggIncFirstContactResponse::GetClassData() const { return &_class_data_; }

void EggIncFirstContactResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<EggIncFirstContactResponse *>(to)->MergeFrom(
      static_cast<const EggIncFirstContactResponse &>(from));
}


void EggIncFirstContactResponse::MergeFrom(const EggIncFirstContactResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.EggIncFirstContactResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  ids_transferred_.MergeFrom(from.ids_transferred_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ei_user_id(from._internal_ei_user_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_error_message(from._internal_error_message());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_backup()->::ei::Backup::MergeFrom(from._internal_backup());
    }
    if (cached_has_bits & 0x00000008u) {
      error_code_ = from.error_code_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EggIncFirstContactResponse::CopyFrom(const EggIncFirstContactResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.EggIncFirstContactResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EggIncFirstContactResponse::IsInitialized() const {
  return true;
}

void EggIncFirstContactResponse::InternalSwap(EggIncFirstContactResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ids_transferred_.InternalSwap(&other->ids_transferred_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ei_user_id_, lhs_arena,
      &other->ei_user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &error_message_, lhs_arena,
      &other->error_message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EggIncFirstContactResponse, error_code_)
      + sizeof(EggIncFirstContactResponse::error_code_)
      - PROTOBUF_FIELD_OFFSET(EggIncFirstContactResponse, backup_)>(
          reinterpret_cast<char*>(&backup_),
          reinterpret_cast<char*>(&other->backup_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EggIncFirstContactResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[17]);
}

// ===================================================================

class EggIncAdConfig::_Internal {
 public:
};

EggIncAdConfig::EggIncAdConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  network_priority_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.EggIncAdConfig)
}
EggIncAdConfig::EggIncAdConfig(const EggIncAdConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      network_priority_(from.network_priority_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ei.EggIncAdConfig)
}

inline void EggIncAdConfig::SharedCtor() {
}

EggIncAdConfig::~EggIncAdConfig() {
  // @@protoc_insertion_point(destructor:ei.EggIncAdConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EggIncAdConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EggIncAdConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EggIncAdConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.EggIncAdConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  network_priority_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EggIncAdConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .ei.AdNetwork network_priority = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::ei::AdNetwork_IsValid(val))) {
              _internal_add_network_priority(static_cast<::ei::AdNetwork>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(_internal_mutable_network_priority(), ptr, ctx, ::ei::AdNetwork_IsValid, &_internal_metadata_, 1);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EggIncAdConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.EggIncAdConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ei.AdNetwork network_priority = 1;
  for (int i = 0, n = this->_internal_network_priority_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_network_priority(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.EggIncAdConfig)
  return target;
}

size_t EggIncAdConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.EggIncAdConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.AdNetwork network_priority = 1;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_network_priority_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_network_priority(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EggIncAdConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    EggIncAdConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EggIncAdConfig::GetClassData() const { return &_class_data_; }

void EggIncAdConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<EggIncAdConfig *>(to)->MergeFrom(
      static_cast<const EggIncAdConfig &>(from));
}


void EggIncAdConfig::MergeFrom(const EggIncAdConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.EggIncAdConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  network_priority_.MergeFrom(from.network_priority_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EggIncAdConfig::CopyFrom(const EggIncAdConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.EggIncAdConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EggIncAdConfig::IsInitialized() const {
  return true;
}

void EggIncAdConfig::InternalSwap(EggIncAdConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  network_priority_.InternalSwap(&other->network_priority_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EggIncAdConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[18]);
}

// ===================================================================

class DailyGiftInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<DailyGiftInfo>()._has_bits_);
  static void set_has_current_day(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_seconds_to_next_day(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DailyGiftInfo::DailyGiftInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.DailyGiftInfo)
}
DailyGiftInfo::DailyGiftInfo(const DailyGiftInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&seconds_to_next_day_, &from.seconds_to_next_day_,
    static_cast<size_t>(reinterpret_cast<char*>(&current_day_) -
    reinterpret_cast<char*>(&seconds_to_next_day_)) + sizeof(current_day_));
  // @@protoc_insertion_point(copy_constructor:ei.DailyGiftInfo)
}

inline void DailyGiftInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&seconds_to_next_day_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&current_day_) -
    reinterpret_cast<char*>(&seconds_to_next_day_)) + sizeof(current_day_));
}

DailyGiftInfo::~DailyGiftInfo() {
  // @@protoc_insertion_point(destructor:ei.DailyGiftInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DailyGiftInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DailyGiftInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DailyGiftInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.DailyGiftInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&seconds_to_next_day_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&current_day_) -
        reinterpret_cast<char*>(&seconds_to_next_day_)) + sizeof(current_day_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DailyGiftInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 current_day = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_current_day(&has_bits);
          current_day_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double seconds_to_next_day = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_seconds_to_next_day(&has_bits);
          seconds_to_next_day_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DailyGiftInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.DailyGiftInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 current_day = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_current_day(), target);
  }

  // optional double seconds_to_next_day = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_seconds_to_next_day(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.DailyGiftInfo)
  return target;
}

size_t DailyGiftInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.DailyGiftInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional double seconds_to_next_day = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional uint32 current_day = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_current_day());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DailyGiftInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DailyGiftInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DailyGiftInfo::GetClassData() const { return &_class_data_; }

void DailyGiftInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DailyGiftInfo *>(to)->MergeFrom(
      static_cast<const DailyGiftInfo &>(from));
}


void DailyGiftInfo::MergeFrom(const DailyGiftInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.DailyGiftInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      seconds_to_next_day_ = from.seconds_to_next_day_;
    }
    if (cached_has_bits & 0x00000002u) {
      current_day_ = from.current_day_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DailyGiftInfo::CopyFrom(const DailyGiftInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.DailyGiftInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DailyGiftInfo::IsInitialized() const {
  return true;
}

void DailyGiftInfo::InternalSwap(DailyGiftInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DailyGiftInfo, current_day_)
      + sizeof(DailyGiftInfo::current_day_)
      - PROTOBUF_FIELD_OFFSET(DailyGiftInfo, seconds_to_next_day_)>(
          reinterpret_cast<char*>(&seconds_to_next_day_),
          reinterpret_cast<char*>(&other->seconds_to_next_day_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DailyGiftInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[19]);
}

// ===================================================================

class SalesInfoRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<SalesInfoRequest>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_piggy_full(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_piggy_found_full(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_seconds_full_realtime(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_seconds_full_gametime(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_lost_increments(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_current_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

SalesInfoRequest::SalesInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.SalesInfoRequest)
}
SalesInfoRequest::SalesInfoRequest(const SalesInfoRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_id()) {
    user_id_.Set(from._internal_user_id(), 
      GetArenaForAllocation());
  }
  ::memcpy(&seconds_full_realtime_, &from.seconds_full_realtime_,
    static_cast<size_t>(reinterpret_cast<char*>(&current_client_version_) -
    reinterpret_cast<char*>(&seconds_full_realtime_)) + sizeof(current_client_version_));
  // @@protoc_insertion_point(copy_constructor:ei.SalesInfoRequest)
}

inline void SalesInfoRequest::SharedCtor() {
user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&seconds_full_realtime_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&current_client_version_) -
    reinterpret_cast<char*>(&seconds_full_realtime_)) + sizeof(current_client_version_));
}

SalesInfoRequest::~SalesInfoRequest() {
  // @@protoc_insertion_point(destructor:ei.SalesInfoRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SalesInfoRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_id_.Destroy();
}

void SalesInfoRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SalesInfoRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.SalesInfoRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    user_id_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000007eu) {
    ::memset(&seconds_full_realtime_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&current_client_version_) -
        reinterpret_cast<char*>(&seconds_full_realtime_)) + sizeof(current_client_version_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SalesInfoRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.SalesInfoRequest.user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool piggy_full = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_piggy_full(&has_bits);
          piggy_full_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool piggy_found_full = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_piggy_found_full(&has_bits);
          piggy_found_full_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double seconds_full_realtime = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_seconds_full_realtime(&has_bits);
          seconds_full_realtime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double seconds_full_gametime = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_seconds_full_gametime(&has_bits);
          seconds_full_gametime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lost_increments = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_lost_increments(&has_bits);
          lost_increments_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 current_client_version = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_current_client_version(&has_bits);
          current_client_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SalesInfoRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.SalesInfoRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.SalesInfoRequest.user_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_id(), target);
  }

  // optional bool piggy_full = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_piggy_full(), target);
  }

  // optional bool piggy_found_full = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_piggy_found_full(), target);
  }

  // optional double seconds_full_realtime = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_seconds_full_realtime(), target);
  }

  // optional double seconds_full_gametime = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_seconds_full_gametime(), target);
  }

  // optional uint32 lost_increments = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_lost_increments(), target);
  }

  // optional uint32 current_client_version = 10;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_current_client_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.SalesInfoRequest)
  return target;
}

size_t SalesInfoRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.SalesInfoRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string user_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_id());
    }

    // optional double seconds_full_realtime = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional bool piggy_full = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool piggy_found_full = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional uint32 lost_increments = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lost_increments());
    }

    // optional double seconds_full_gametime = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional uint32 current_client_version = 10;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_current_client_version());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SalesInfoRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SalesInfoRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SalesInfoRequest::GetClassData() const { return &_class_data_; }

void SalesInfoRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SalesInfoRequest *>(to)->MergeFrom(
      static_cast<const SalesInfoRequest &>(from));
}


void SalesInfoRequest::MergeFrom(const SalesInfoRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.SalesInfoRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_id(from._internal_user_id());
    }
    if (cached_has_bits & 0x00000002u) {
      seconds_full_realtime_ = from.seconds_full_realtime_;
    }
    if (cached_has_bits & 0x00000004u) {
      piggy_full_ = from.piggy_full_;
    }
    if (cached_has_bits & 0x00000008u) {
      piggy_found_full_ = from.piggy_found_full_;
    }
    if (cached_has_bits & 0x00000010u) {
      lost_increments_ = from.lost_increments_;
    }
    if (cached_has_bits & 0x00000020u) {
      seconds_full_gametime_ = from.seconds_full_gametime_;
    }
    if (cached_has_bits & 0x00000040u) {
      current_client_version_ = from.current_client_version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SalesInfoRequest::CopyFrom(const SalesInfoRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.SalesInfoRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SalesInfoRequest::IsInitialized() const {
  return true;
}

void SalesInfoRequest::InternalSwap(SalesInfoRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SalesInfoRequest, current_client_version_)
      + sizeof(SalesInfoRequest::current_client_version_)
      - PROTOBUF_FIELD_OFFSET(SalesInfoRequest, seconds_full_realtime_)>(
          reinterpret_cast<char*>(&seconds_full_realtime_),
          reinterpret_cast<char*>(&other->seconds_full_realtime_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SalesInfoRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[20]);
}

// ===================================================================

class IAPSaleEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<IAPSaleEntry>()._has_bits_);
  static void set_has_product_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_seconds_remaining(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_discount_string(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sale_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

IAPSaleEntry::IAPSaleEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.IAPSaleEntry)
}
IAPSaleEntry::IAPSaleEntry(const IAPSaleEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  product_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    product_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_product_id()) {
    product_id_.Set(from._internal_product_id(), 
      GetArenaForAllocation());
  }
  discount_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    discount_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_discount_string()) {
    discount_string_.Set(from._internal_discount_string(), 
      GetArenaForAllocation());
  }
  sale_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sale_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sale_id()) {
    sale_id_.Set(from._internal_sale_id(), 
      GetArenaForAllocation());
  }
  seconds_remaining_ = from.seconds_remaining_;
  // @@protoc_insertion_point(copy_constructor:ei.IAPSaleEntry)
}

inline void IAPSaleEntry::SharedCtor() {
product_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  product_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
discount_string_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  discount_string_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
sale_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sale_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
seconds_remaining_ = 0;
}

IAPSaleEntry::~IAPSaleEntry() {
  // @@protoc_insertion_point(destructor:ei.IAPSaleEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IAPSaleEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  product_id_.Destroy();
  discount_string_.Destroy();
  sale_id_.Destroy();
}

void IAPSaleEntry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IAPSaleEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.IAPSaleEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      product_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      discount_string_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      sale_id_.ClearNonDefaultToEmpty();
    }
  }
  seconds_remaining_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IAPSaleEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string product_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_product_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.IAPSaleEntry.product_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double seconds_remaining = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_seconds_remaining(&has_bits);
          seconds_remaining_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional string discount_string = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_discount_string();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.IAPSaleEntry.discount_string");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string sale_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_sale_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.IAPSaleEntry.sale_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IAPSaleEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.IAPSaleEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string product_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_product_id().data(), static_cast<int>(this->_internal_product_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.IAPSaleEntry.product_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_product_id(), target);
  }

  // optional double seconds_remaining = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_seconds_remaining(), target);
  }

  // optional string discount_string = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_discount_string().data(), static_cast<int>(this->_internal_discount_string().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.IAPSaleEntry.discount_string");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_discount_string(), target);
  }

  // optional string sale_id = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sale_id().data(), static_cast<int>(this->_internal_sale_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.IAPSaleEntry.sale_id");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_sale_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.IAPSaleEntry)
  return target;
}

size_t IAPSaleEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.IAPSaleEntry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string product_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_product_id());
    }

    // optional string discount_string = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_discount_string());
    }

    // optional string sale_id = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_sale_id());
    }

    // optional double seconds_remaining = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IAPSaleEntry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    IAPSaleEntry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IAPSaleEntry::GetClassData() const { return &_class_data_; }

void IAPSaleEntry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<IAPSaleEntry *>(to)->MergeFrom(
      static_cast<const IAPSaleEntry &>(from));
}


void IAPSaleEntry::MergeFrom(const IAPSaleEntry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.IAPSaleEntry)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_product_id(from._internal_product_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_discount_string(from._internal_discount_string());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_sale_id(from._internal_sale_id());
    }
    if (cached_has_bits & 0x00000008u) {
      seconds_remaining_ = from.seconds_remaining_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IAPSaleEntry::CopyFrom(const IAPSaleEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.IAPSaleEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IAPSaleEntry::IsInitialized() const {
  return true;
}

void IAPSaleEntry::InternalSwap(IAPSaleEntry* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &product_id_, lhs_arena,
      &other->product_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &discount_string_, lhs_arena,
      &other->discount_string_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sale_id_, lhs_arena,
      &other->sale_id_, rhs_arena
  );
  swap(seconds_remaining_, other->seconds_remaining_);
}

::PROTOBUF_NAMESPACE_ID::Metadata IAPSaleEntry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[21]);
}

// ===================================================================

class SalesInfo::_Internal {
 public:
};

SalesInfo::SalesInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  sales_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.SalesInfo)
}
SalesInfo::SalesInfo(const SalesInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      sales_(from.sales_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ei.SalesInfo)
}

inline void SalesInfo::SharedCtor() {
}

SalesInfo::~SalesInfo() {
  // @@protoc_insertion_point(destructor:ei.SalesInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SalesInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SalesInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SalesInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.SalesInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  sales_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SalesInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .ei.IAPSaleEntry sales = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sales(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SalesInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.SalesInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ei.IAPSaleEntry sales = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_sales_size()); i < n; i++) {
    const auto& repfield = this->_internal_sales(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.SalesInfo)
  return target;
}

size_t SalesInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.SalesInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.IAPSaleEntry sales = 1;
  total_size += 1UL * this->_internal_sales_size();
  for (const auto& msg : this->sales_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SalesInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SalesInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SalesInfo::GetClassData() const { return &_class_data_; }

void SalesInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SalesInfo *>(to)->MergeFrom(
      static_cast<const SalesInfo &>(from));
}


void SalesInfo::MergeFrom(const SalesInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.SalesInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  sales_.MergeFrom(from.sales_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SalesInfo::CopyFrom(const SalesInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.SalesInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SalesInfo::IsInitialized() const {
  return true;
}

void SalesInfo::InternalSwap(SalesInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  sales_.InternalSwap(&other->sales_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SalesInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[22]);
}

// ===================================================================

class EggIncEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<EggIncEvent>()._has_bits_);
  static void set_has_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_seconds_remaining(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_multiplier(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_subtitle(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_start_time(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_cc_only(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

EggIncEvent::EggIncEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.EggIncEvent)
}
EggIncEvent::EggIncEvent(const EggIncEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_identifier()) {
    identifier_.Set(from._internal_identifier(), 
      GetArenaForAllocation());
  }
  type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_type()) {
    type_.Set(from._internal_type(), 
      GetArenaForAllocation());
  }
  subtitle_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    subtitle_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_subtitle()) {
    subtitle_.Set(from._internal_subtitle(), 
      GetArenaForAllocation());
  }
  ::memcpy(&seconds_remaining_, &from.seconds_remaining_,
    static_cast<size_t>(reinterpret_cast<char*>(&cc_only_) -
    reinterpret_cast<char*>(&seconds_remaining_)) + sizeof(cc_only_));
  // @@protoc_insertion_point(copy_constructor:ei.EggIncEvent)
}

inline void EggIncEvent::SharedCtor() {
identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
subtitle_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  subtitle_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&seconds_remaining_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&cc_only_) -
    reinterpret_cast<char*>(&seconds_remaining_)) + sizeof(cc_only_));
}

EggIncEvent::~EggIncEvent() {
  // @@protoc_insertion_point(destructor:ei.EggIncEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EggIncEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  identifier_.Destroy();
  type_.Destroy();
  subtitle_.Destroy();
}

void EggIncEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EggIncEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.EggIncEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      subtitle_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&seconds_remaining_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&cc_only_) -
        reinterpret_cast<char*>(&seconds_remaining_)) + sizeof(cc_only_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EggIncEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.EggIncEvent.identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double seconds_remaining = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_seconds_remaining(&has_bits);
          seconds_remaining_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional string type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.EggIncEvent.type");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double multiplier = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_multiplier(&has_bits);
          multiplier_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional string subtitle = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_subtitle();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.EggIncEvent.subtitle");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double start_time = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_start_time(&has_bits);
          start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double duration = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _Internal::set_has_duration(&has_bits);
          duration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool cc_only = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_cc_only(&has_bits);
          cc_only_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EggIncEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.EggIncEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_identifier().data(), static_cast<int>(this->_internal_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.EggIncEvent.identifier");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_identifier(), target);
  }

  // optional double seconds_remaining = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_seconds_remaining(), target);
  }

  // optional string type = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.EggIncEvent.type");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_type(), target);
  }

  // optional double multiplier = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_multiplier(), target);
  }

  // optional string subtitle = 5;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_subtitle().data(), static_cast<int>(this->_internal_subtitle().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.EggIncEvent.subtitle");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_subtitle(), target);
  }

  // optional double start_time = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_start_time(), target);
  }

  // optional double duration = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_duration(), target);
  }

  // optional bool cc_only = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_cc_only(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.EggIncEvent)
  return target;
}

size_t EggIncEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.EggIncEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string identifier = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_identifier());
    }

    // optional string type = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_type());
    }

    // optional string subtitle = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_subtitle());
    }

    // optional double seconds_remaining = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double multiplier = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double start_time = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional double duration = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional bool cc_only = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EggIncEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    EggIncEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EggIncEvent::GetClassData() const { return &_class_data_; }

void EggIncEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<EggIncEvent *>(to)->MergeFrom(
      static_cast<const EggIncEvent &>(from));
}


void EggIncEvent::MergeFrom(const EggIncEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.EggIncEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_identifier(from._internal_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_subtitle(from._internal_subtitle());
    }
    if (cached_has_bits & 0x00000008u) {
      seconds_remaining_ = from.seconds_remaining_;
    }
    if (cached_has_bits & 0x00000010u) {
      multiplier_ = from.multiplier_;
    }
    if (cached_has_bits & 0x00000020u) {
      start_time_ = from.start_time_;
    }
    if (cached_has_bits & 0x00000040u) {
      duration_ = from.duration_;
    }
    if (cached_has_bits & 0x00000080u) {
      cc_only_ = from.cc_only_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EggIncEvent::CopyFrom(const EggIncEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.EggIncEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EggIncEvent::IsInitialized() const {
  return true;
}

void EggIncEvent::InternalSwap(EggIncEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &identifier_, lhs_arena,
      &other->identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &type_, lhs_arena,
      &other->type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &subtitle_, lhs_arena,
      &other->subtitle_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EggIncEvent, cc_only_)
      + sizeof(EggIncEvent::cc_only_)
      - PROTOBUF_FIELD_OFFSET(EggIncEvent, seconds_remaining_)>(
          reinterpret_cast<char*>(&seconds_remaining_),
          reinterpret_cast<char*>(&other->seconds_remaining_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EggIncEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[23]);
}

// ===================================================================

class EggIncCurrentEvents::_Internal {
 public:
};

EggIncCurrentEvents::EggIncCurrentEvents(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  events_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.EggIncCurrentEvents)
}
EggIncCurrentEvents::EggIncCurrentEvents(const EggIncCurrentEvents& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      events_(from.events_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ei.EggIncCurrentEvents)
}

inline void EggIncCurrentEvents::SharedCtor() {
}

EggIncCurrentEvents::~EggIncCurrentEvents() {
  // @@protoc_insertion_point(destructor:ei.EggIncCurrentEvents)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EggIncCurrentEvents::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EggIncCurrentEvents::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EggIncCurrentEvents::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.EggIncCurrentEvents)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  events_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EggIncCurrentEvents::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .ei.EggIncEvent events = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_events(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EggIncCurrentEvents::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.EggIncCurrentEvents)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ei.EggIncEvent events = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_events_size()); i < n; i++) {
    const auto& repfield = this->_internal_events(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.EggIncCurrentEvents)
  return target;
}

size_t EggIncCurrentEvents::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.EggIncCurrentEvents)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.EggIncEvent events = 1;
  total_size += 1UL * this->_internal_events_size();
  for (const auto& msg : this->events_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EggIncCurrentEvents::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    EggIncCurrentEvents::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EggIncCurrentEvents::GetClassData() const { return &_class_data_; }

void EggIncCurrentEvents::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<EggIncCurrentEvents *>(to)->MergeFrom(
      static_cast<const EggIncCurrentEvents &>(from));
}


void EggIncCurrentEvents::MergeFrom(const EggIncCurrentEvents& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.EggIncCurrentEvents)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  events_.MergeFrom(from.events_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EggIncCurrentEvents::CopyFrom(const EggIncCurrentEvents& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.EggIncCurrentEvents)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EggIncCurrentEvents::IsInitialized() const {
  return true;
}

void EggIncCurrentEvents::InternalSwap(EggIncCurrentEvents* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  events_.InternalSwap(&other->events_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EggIncCurrentEvents::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[24]);
}

// ===================================================================

class DeviceInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceInfo>()._has_bits_);
  static void set_has_device_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_advertising_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_platform(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_form_factor(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_device_name(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_platform_version(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_locale_country(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_locale_language(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_gpu_vendor(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_gpu_model(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_device_bucket(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_screen_width(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_screen_height(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
};

DeviceInfo::DeviceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.DeviceInfo)
}
DeviceInfo::DeviceInfo(const DeviceInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  device_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    device_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_id()) {
    device_id_.Set(from._internal_device_id(), 
      GetArenaForAllocation());
  }
  platform_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    platform_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_platform()) {
    platform_.Set(from._internal_platform(), 
      GetArenaForAllocation());
  }
  form_factor_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    form_factor_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_form_factor()) {
    form_factor_.Set(from._internal_form_factor(), 
      GetArenaForAllocation());
  }
  device_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    device_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_name()) {
    device_name_.Set(from._internal_device_name(), 
      GetArenaForAllocation());
  }
  platform_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    platform_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_platform_version()) {
    platform_version_.Set(from._internal_platform_version(), 
      GetArenaForAllocation());
  }
  locale_country_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    locale_country_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_locale_country()) {
    locale_country_.Set(from._internal_locale_country(), 
      GetArenaForAllocation());
  }
  locale_language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    locale_language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_locale_language()) {
    locale_language_.Set(from._internal_locale_language(), 
      GetArenaForAllocation());
  }
  gpu_vendor_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    gpu_vendor_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_gpu_vendor()) {
    gpu_vendor_.Set(from._internal_gpu_vendor(), 
      GetArenaForAllocation());
  }
  gpu_model_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    gpu_model_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_gpu_model()) {
    gpu_model_.Set(from._internal_gpu_model(), 
      GetArenaForAllocation());
  }
  device_bucket_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    device_bucket_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_bucket()) {
    device_bucket_.Set(from._internal_device_bucket(), 
      GetArenaForAllocation());
  }
  advertising_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    advertising_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_advertising_id()) {
    advertising_id_.Set(from._internal_advertising_id(), 
      GetArenaForAllocation());
  }
  ::memcpy(&screen_width_, &from.screen_width_,
    static_cast<size_t>(reinterpret_cast<char*>(&screen_height_) -
    reinterpret_cast<char*>(&screen_width_)) + sizeof(screen_height_));
  // @@protoc_insertion_point(copy_constructor:ei.DeviceInfo)
}

inline void DeviceInfo::SharedCtor() {
device_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  device_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
platform_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  platform_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
form_factor_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  form_factor_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
device_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  device_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
platform_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  platform_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
locale_country_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  locale_country_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
locale_language_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  locale_language_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
gpu_vendor_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  gpu_vendor_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
gpu_model_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  gpu_model_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
device_bucket_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  device_bucket_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
advertising_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  advertising_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&screen_width_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&screen_height_) -
    reinterpret_cast<char*>(&screen_width_)) + sizeof(screen_height_));
}

DeviceInfo::~DeviceInfo() {
  // @@protoc_insertion_point(destructor:ei.DeviceInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  device_id_.Destroy();
  platform_.Destroy();
  form_factor_.Destroy();
  device_name_.Destroy();
  platform_version_.Destroy();
  locale_country_.Destroy();
  locale_language_.Destroy();
  gpu_vendor_.Destroy();
  gpu_model_.Destroy();
  device_bucket_.Destroy();
  advertising_id_.Destroy();
}

void DeviceInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DeviceInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.DeviceInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      device_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      platform_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      form_factor_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      device_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      platform_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      locale_country_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      locale_language_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      gpu_vendor_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      gpu_model_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000200u) {
      device_bucket_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000400u) {
      advertising_id_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00001800u) {
    ::memset(&screen_width_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&screen_height_) -
        reinterpret_cast<char*>(&screen_width_)) + sizeof(screen_height_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeviceInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string device_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_device_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.DeviceInfo.device_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string platform = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_platform();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.DeviceInfo.platform");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string form_factor = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_form_factor();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.DeviceInfo.form_factor");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string device_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_device_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.DeviceInfo.device_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string platform_version = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_platform_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.DeviceInfo.platform_version");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string locale_country = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_locale_country();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.DeviceInfo.locale_country");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string locale_language = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_locale_language();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.DeviceInfo.locale_language");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string gpu_vendor = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_gpu_vendor();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.DeviceInfo.gpu_vendor");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string gpu_model = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_gpu_model();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.DeviceInfo.gpu_model");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string device_bucket = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_device_bucket();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.DeviceInfo.device_bucket");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 screen_width = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_screen_width(&has_bits);
          screen_width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 screen_height = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_screen_height(&has_bits);
          screen_height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string advertising_id = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_advertising_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.DeviceInfo.advertising_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.DeviceInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string device_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_device_id().data(), static_cast<int>(this->_internal_device_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.DeviceInfo.device_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_device_id(), target);
  }

  // optional string platform = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_platform().data(), static_cast<int>(this->_internal_platform().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.DeviceInfo.platform");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_platform(), target);
  }

  // optional string form_factor = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_form_factor().data(), static_cast<int>(this->_internal_form_factor().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.DeviceInfo.form_factor");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_form_factor(), target);
  }

  // optional string device_name = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_device_name().data(), static_cast<int>(this->_internal_device_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.DeviceInfo.device_name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_device_name(), target);
  }

  // optional string platform_version = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_platform_version().data(), static_cast<int>(this->_internal_platform_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.DeviceInfo.platform_version");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_platform_version(), target);
  }

  // optional string locale_country = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_locale_country().data(), static_cast<int>(this->_internal_locale_country().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.DeviceInfo.locale_country");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_locale_country(), target);
  }

  // optional string locale_language = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_locale_language().data(), static_cast<int>(this->_internal_locale_language().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.DeviceInfo.locale_language");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_locale_language(), target);
  }

  // optional string gpu_vendor = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_gpu_vendor().data(), static_cast<int>(this->_internal_gpu_vendor().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.DeviceInfo.gpu_vendor");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_gpu_vendor(), target);
  }

  // optional string gpu_model = 9;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_gpu_model().data(), static_cast<int>(this->_internal_gpu_model().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.DeviceInfo.gpu_model");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_gpu_model(), target);
  }

  // optional string device_bucket = 10;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_device_bucket().data(), static_cast<int>(this->_internal_device_bucket().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.DeviceInfo.device_bucket");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_device_bucket(), target);
  }

  // optional uint32 screen_width = 11;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_screen_width(), target);
  }

  // optional uint32 screen_height = 12;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_screen_height(), target);
  }

  // optional string advertising_id = 13;
  if (cached_has_bits & 0x00000400u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_advertising_id().data(), static_cast<int>(this->_internal_advertising_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.DeviceInfo.advertising_id");
    target = stream->WriteStringMaybeAliased(
        13, this->_internal_advertising_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.DeviceInfo)
  return target;
}

size_t DeviceInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.DeviceInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string device_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_id());
    }

    // optional string platform = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_platform());
    }

    // optional string form_factor = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_form_factor());
    }

    // optional string device_name = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_name());
    }

    // optional string platform_version = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_platform_version());
    }

    // optional string locale_country = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_locale_country());
    }

    // optional string locale_language = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_locale_language());
    }

    // optional string gpu_vendor = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_gpu_vendor());
    }

  }
  if (cached_has_bits & 0x00001f00u) {
    // optional string gpu_model = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_gpu_model());
    }

    // optional string device_bucket = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_bucket());
    }

    // optional string advertising_id = 13;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_advertising_id());
    }

    // optional uint32 screen_width = 11;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_screen_width());
    }

    // optional uint32 screen_height = 12;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_screen_height());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeviceInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DeviceInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeviceInfo::GetClassData() const { return &_class_data_; }

void DeviceInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DeviceInfo *>(to)->MergeFrom(
      static_cast<const DeviceInfo &>(from));
}


void DeviceInfo::MergeFrom(const DeviceInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.DeviceInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_device_id(from._internal_device_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_platform(from._internal_platform());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_form_factor(from._internal_form_factor());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_device_name(from._internal_device_name());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_platform_version(from._internal_platform_version());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_locale_country(from._internal_locale_country());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_set_locale_language(from._internal_locale_language());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_set_gpu_vendor(from._internal_gpu_vendor());
    }
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_set_gpu_model(from._internal_gpu_model());
    }
    if (cached_has_bits & 0x00000200u) {
      _internal_set_device_bucket(from._internal_device_bucket());
    }
    if (cached_has_bits & 0x00000400u) {
      _internal_set_advertising_id(from._internal_advertising_id());
    }
    if (cached_has_bits & 0x00000800u) {
      screen_width_ = from.screen_width_;
    }
    if (cached_has_bits & 0x00001000u) {
      screen_height_ = from.screen_height_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeviceInfo::CopyFrom(const DeviceInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.DeviceInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceInfo::IsInitialized() const {
  return true;
}

void DeviceInfo::InternalSwap(DeviceInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &device_id_, lhs_arena,
      &other->device_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &platform_, lhs_arena,
      &other->platform_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &form_factor_, lhs_arena,
      &other->form_factor_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &device_name_, lhs_arena,
      &other->device_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &platform_version_, lhs_arena,
      &other->platform_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &locale_country_, lhs_arena,
      &other->locale_country_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &locale_language_, lhs_arena,
      &other->locale_language_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &gpu_vendor_, lhs_arena,
      &other->gpu_vendor_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &gpu_model_, lhs_arena,
      &other->gpu_model_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &device_bucket_, lhs_arena,
      &other->device_bucket_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &advertising_id_, lhs_arena,
      &other->advertising_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DeviceInfo, screen_height_)
      + sizeof(DeviceInfo::screen_height_)
      - PROTOBUF_FIELD_OFFSET(DeviceInfo, screen_width_)>(
          reinterpret_cast<char*>(&screen_width_),
          reinterpret_cast<char*>(&other->screen_width_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DeviceInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[25]);
}

// ===================================================================

class AppInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<AppInfo>()._has_bits_);
  static void set_has_version_str(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sessions(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_num_prestiges(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_soul_eggs(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_current_egg(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_gold_earned(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_gold_spent(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_current_mission(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_piggy_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_num_piggy_breaks(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_verified_piggy_breaks(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_iap_packs_purchased(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_permit_level(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_video_doubler_uses(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_drone_takedowns(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_drone_takedowns_elite(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_trophies_unlocked(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_egg_level(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_struggle_factor(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_piggy_full(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_piggy_found_full(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_time_piggy_full_realtime(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_time_piggy_full_gametime(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_lost_piggy_increments(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_sale_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_unlimited_chickens_uses(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_refill_uses(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_short_warp_uses(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_long_warp_uses(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
};

AppInfo::AppInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.AppInfo)
}
AppInfo::AppInfo(const AppInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  version_str_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    version_str_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_version_str()) {
    version_str_.Set(from._internal_version_str(), 
      GetArenaForAllocation());
  }
  sale_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sale_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sale_id()) {
    sale_id_.Set(from._internal_sale_id(), 
      GetArenaForAllocation());
  }
  ::memcpy(&sessions_, &from.sessions_,
    static_cast<size_t>(reinterpret_cast<char*>(&piggy_found_full_) -
    reinterpret_cast<char*>(&sessions_)) + sizeof(piggy_found_full_));
  // @@protoc_insertion_point(copy_constructor:ei.AppInfo)
}

inline void AppInfo::SharedCtor() {
version_str_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  version_str_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
sale_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sale_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sessions_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&piggy_found_full_) -
    reinterpret_cast<char*>(&sessions_)) + sizeof(piggy_found_full_));
}

AppInfo::~AppInfo() {
  // @@protoc_insertion_point(destructor:ei.AppInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AppInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  version_str_.Destroy();
  sale_id_.Destroy();
}

void AppInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AppInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.AppInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      version_str_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      sale_id_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&sessions_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&current_mission_) -
        reinterpret_cast<char*>(&sessions_)) + sizeof(current_mission_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&gold_spent_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&video_doubler_uses_) -
        reinterpret_cast<char*>(&gold_spent_)) + sizeof(video_doubler_uses_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&short_warp_uses_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&time_piggy_full_gametime_) -
        reinterpret_cast<char*>(&short_warp_uses_)) + sizeof(time_piggy_full_gametime_));
  }
  if (cached_has_bits & 0x1f000000u) {
    ::memset(&lost_piggy_increments_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&piggy_found_full_) -
        reinterpret_cast<char*>(&lost_piggy_increments_)) + sizeof(piggy_found_full_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AppInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string version_str = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_version_str();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AppInfo.version_str");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 sessions = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_sessions(&has_bits);
          sessions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 num_prestiges = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_num_prestiges(&has_bits);
          num_prestiges_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 soul_eggs = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_soul_eggs(&has_bits);
          soul_eggs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 current_egg = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_current_egg(&has_bits);
          current_egg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 gold_earned = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_gold_earned(&has_bits);
          gold_earned_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 gold_spent = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_gold_spent(&has_bits);
          gold_spent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 current_mission = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_current_mission(&has_bits);
          current_mission_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 piggy_size = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_piggy_size(&has_bits);
          piggy_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 num_piggy_breaks = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_num_piggy_breaks(&has_bits);
          num_piggy_breaks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 iap_packs_purchased = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_iap_packs_purchased(&has_bits);
          iap_packs_purchased_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 permit_level = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_permit_level(&has_bits);
          permit_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 unlimited_chickens_uses = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_unlimited_chickens_uses(&has_bits);
          unlimited_chickens_uses_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 refill_uses = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_refill_uses(&has_bits);
          refill_uses_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 video_doubler_uses = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_video_doubler_uses(&has_bits);
          video_doubler_uses_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 short_warp_uses = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_short_warp_uses(&has_bits);
          short_warp_uses_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 long_warp_uses = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_long_warp_uses(&has_bits);
          long_warp_uses_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 drone_takedowns = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_drone_takedowns(&has_bits);
          drone_takedowns_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 drone_takedowns_elite = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_drone_takedowns_elite(&has_bits);
          drone_takedowns_elite_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool trophies_unlocked = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_trophies_unlocked(&has_bits);
          trophies_unlocked_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float egg_level = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 173)) {
          _Internal::set_has_egg_level(&has_bits);
          egg_level_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float struggle_factor = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 181)) {
          _Internal::set_has_struggle_factor(&has_bits);
          struggle_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool piggy_full = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_piggy_full(&has_bits);
          piggy_full_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool piggy_found_full = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_piggy_found_full(&has_bits);
          piggy_found_full_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double time_piggy_full_realtime = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 201)) {
          _Internal::set_has_time_piggy_full_realtime(&has_bits);
          time_piggy_full_realtime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double time_piggy_full_gametime = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 209)) {
          _Internal::set_has_time_piggy_full_gametime(&has_bits);
          time_piggy_full_gametime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 lost_piggy_increments = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_lost_piggy_increments(&has_bits);
          lost_piggy_increments_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string sale_id = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          auto str = _internal_mutable_sale_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AppInfo.sale_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint64 verified_piggy_breaks = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_verified_piggy_breaks(&has_bits);
          verified_piggy_breaks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AppInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.AppInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string version_str = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_version_str().data(), static_cast<int>(this->_internal_version_str().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AppInfo.version_str");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_version_str(), target);
  }

  // optional uint32 sessions = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_sessions(), target);
  }

  // optional uint32 num_prestiges = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_num_prestiges(), target);
  }

  // optional uint64 soul_eggs = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_soul_eggs(), target);
  }

  // optional uint32 current_egg = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_current_egg(), target);
  }

  // optional uint64 gold_earned = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_gold_earned(), target);
  }

  // optional uint64 gold_spent = 7;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_gold_spent(), target);
  }

  // optional uint32 current_mission = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_current_mission(), target);
  }

  // optional uint32 piggy_size = 9;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_piggy_size(), target);
  }

  // optional uint64 num_piggy_breaks = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(10, this->_internal_num_piggy_breaks(), target);
  }

  // optional uint64 iap_packs_purchased = 11;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(11, this->_internal_iap_packs_purchased(), target);
  }

  // optional uint32 permit_level = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_permit_level(), target);
  }

  // optional uint64 unlimited_chickens_uses = 13;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(13, this->_internal_unlimited_chickens_uses(), target);
  }

  // optional uint64 refill_uses = 14;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(14, this->_internal_refill_uses(), target);
  }

  // optional uint64 video_doubler_uses = 15;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(15, this->_internal_video_doubler_uses(), target);
  }

  // optional uint64 short_warp_uses = 16;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(16, this->_internal_short_warp_uses(), target);
  }

  // optional uint64 long_warp_uses = 17;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(17, this->_internal_long_warp_uses(), target);
  }

  // optional uint64 drone_takedowns = 18;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(18, this->_internal_drone_takedowns(), target);
  }

  // optional uint64 drone_takedowns_elite = 19;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(19, this->_internal_drone_takedowns_elite(), target);
  }

  // optional bool trophies_unlocked = 20;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(20, this->_internal_trophies_unlocked(), target);
  }

  // optional float egg_level = 21;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(21, this->_internal_egg_level(), target);
  }

  // optional float struggle_factor = 22;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(22, this->_internal_struggle_factor(), target);
  }

  // optional bool piggy_full = 23;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(23, this->_internal_piggy_full(), target);
  }

  // optional bool piggy_found_full = 24;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(24, this->_internal_piggy_found_full(), target);
  }

  // optional double time_piggy_full_realtime = 25;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(25, this->_internal_time_piggy_full_realtime(), target);
  }

  // optional double time_piggy_full_gametime = 26;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(26, this->_internal_time_piggy_full_gametime(), target);
  }

  // optional uint64 lost_piggy_increments = 27;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(27, this->_internal_lost_piggy_increments(), target);
  }

  // optional string sale_id = 28;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sale_id().data(), static_cast<int>(this->_internal_sale_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AppInfo.sale_id");
    target = stream->WriteStringMaybeAliased(
        28, this->_internal_sale_id(), target);
  }

  // optional uint64 verified_piggy_breaks = 29;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(29, this->_internal_verified_piggy_breaks(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.AppInfo)
  return target;
}

size_t AppInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.AppInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string version_str = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_version_str());
    }

    // optional string sale_id = 28;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_sale_id());
    }

    // optional uint32 sessions = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sessions());
    }

    // optional uint32 num_prestiges = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_prestiges());
    }

    // optional uint64 soul_eggs = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_soul_eggs());
    }

    // optional uint64 gold_earned = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_gold_earned());
    }

    // optional uint32 current_egg = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_current_egg());
    }

    // optional uint32 current_mission = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_current_mission());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint64 gold_spent = 7;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_gold_spent());
    }

    // optional uint64 num_piggy_breaks = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_num_piggy_breaks());
    }

    // optional uint32 piggy_size = 9;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_piggy_size());
    }

    // optional uint32 permit_level = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_permit_level());
    }

    // optional uint64 iap_packs_purchased = 11;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_iap_packs_purchased());
    }

    // optional uint64 unlimited_chickens_uses = 13;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_unlimited_chickens_uses());
    }

    // optional uint64 refill_uses = 14;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_refill_uses());
    }

    // optional uint64 video_doubler_uses = 15;
    if (cached_has_bits & 0x00008000u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_video_doubler_uses());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional uint64 short_warp_uses = 16;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_short_warp_uses());
    }

    // optional uint64 long_warp_uses = 17;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_long_warp_uses());
    }

    // optional uint64 drone_takedowns = 18;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_drone_takedowns());
    }

    // optional uint64 drone_takedowns_elite = 19;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_drone_takedowns_elite());
    }

    // optional float egg_level = 21;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 4;
    }

    // optional float struggle_factor = 22;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 + 4;
    }

    // optional double time_piggy_full_realtime = 25;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 8;
    }

    // optional double time_piggy_full_gametime = 26;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 8;
    }

  }
  if (cached_has_bits & 0x1f000000u) {
    // optional uint64 lost_piggy_increments = 27;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_lost_piggy_increments());
    }

    // optional uint64 verified_piggy_breaks = 29;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_verified_piggy_breaks());
    }

    // optional bool trophies_unlocked = 20;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 + 1;
    }

    // optional bool piggy_full = 23;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 + 1;
    }

    // optional bool piggy_found_full = 24;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AppInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AppInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AppInfo::GetClassData() const { return &_class_data_; }

void AppInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AppInfo *>(to)->MergeFrom(
      static_cast<const AppInfo &>(from));
}


void AppInfo::MergeFrom(const AppInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.AppInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_version_str(from._internal_version_str());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_sale_id(from._internal_sale_id());
    }
    if (cached_has_bits & 0x00000004u) {
      sessions_ = from.sessions_;
    }
    if (cached_has_bits & 0x00000008u) {
      num_prestiges_ = from.num_prestiges_;
    }
    if (cached_has_bits & 0x00000010u) {
      soul_eggs_ = from.soul_eggs_;
    }
    if (cached_has_bits & 0x00000020u) {
      gold_earned_ = from.gold_earned_;
    }
    if (cached_has_bits & 0x00000040u) {
      current_egg_ = from.current_egg_;
    }
    if (cached_has_bits & 0x00000080u) {
      current_mission_ = from.current_mission_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      gold_spent_ = from.gold_spent_;
    }
    if (cached_has_bits & 0x00000200u) {
      num_piggy_breaks_ = from.num_piggy_breaks_;
    }
    if (cached_has_bits & 0x00000400u) {
      piggy_size_ = from.piggy_size_;
    }
    if (cached_has_bits & 0x00000800u) {
      permit_level_ = from.permit_level_;
    }
    if (cached_has_bits & 0x00001000u) {
      iap_packs_purchased_ = from.iap_packs_purchased_;
    }
    if (cached_has_bits & 0x00002000u) {
      unlimited_chickens_uses_ = from.unlimited_chickens_uses_;
    }
    if (cached_has_bits & 0x00004000u) {
      refill_uses_ = from.refill_uses_;
    }
    if (cached_has_bits & 0x00008000u) {
      video_doubler_uses_ = from.video_doubler_uses_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      short_warp_uses_ = from.short_warp_uses_;
    }
    if (cached_has_bits & 0x00020000u) {
      long_warp_uses_ = from.long_warp_uses_;
    }
    if (cached_has_bits & 0x00040000u) {
      drone_takedowns_ = from.drone_takedowns_;
    }
    if (cached_has_bits & 0x00080000u) {
      drone_takedowns_elite_ = from.drone_takedowns_elite_;
    }
    if (cached_has_bits & 0x00100000u) {
      egg_level_ = from.egg_level_;
    }
    if (cached_has_bits & 0x00200000u) {
      struggle_factor_ = from.struggle_factor_;
    }
    if (cached_has_bits & 0x00400000u) {
      time_piggy_full_realtime_ = from.time_piggy_full_realtime_;
    }
    if (cached_has_bits & 0x00800000u) {
      time_piggy_full_gametime_ = from.time_piggy_full_gametime_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x1f000000u) {
    if (cached_has_bits & 0x01000000u) {
      lost_piggy_increments_ = from.lost_piggy_increments_;
    }
    if (cached_has_bits & 0x02000000u) {
      verified_piggy_breaks_ = from.verified_piggy_breaks_;
    }
    if (cached_has_bits & 0x04000000u) {
      trophies_unlocked_ = from.trophies_unlocked_;
    }
    if (cached_has_bits & 0x08000000u) {
      piggy_full_ = from.piggy_full_;
    }
    if (cached_has_bits & 0x10000000u) {
      piggy_found_full_ = from.piggy_found_full_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AppInfo::CopyFrom(const AppInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.AppInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AppInfo::IsInitialized() const {
  return true;
}

void AppInfo::InternalSwap(AppInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &version_str_, lhs_arena,
      &other->version_str_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sale_id_, lhs_arena,
      &other->sale_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AppInfo, piggy_found_full_)
      + sizeof(AppInfo::piggy_found_full_)
      - PROTOBUF_FIELD_OFFSET(AppInfo, sessions_)>(
          reinterpret_cast<char*>(&sessions_),
          reinterpret_cast<char*>(&other->sessions_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AppInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[26]);
}

// ===================================================================

class ActionKeyValuePair::_Internal {
 public:
  using HasBits = decltype(std::declval<ActionKeyValuePair>()._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

ActionKeyValuePair::ActionKeyValuePair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ActionKeyValuePair)
}
ActionKeyValuePair::ActionKeyValuePair(const ActionKeyValuePair& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key()) {
    key_.Set(from._internal_key(), 
      GetArenaForAllocation());
  }
  value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    value_.Set(from._internal_value(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:ei.ActionKeyValuePair)
}

inline void ActionKeyValuePair::SharedCtor() {
key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ActionKeyValuePair::~ActionKeyValuePair() {
  // @@protoc_insertion_point(destructor:ei.ActionKeyValuePair)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ActionKeyValuePair::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  key_.Destroy();
  value_.Destroy();
}

void ActionKeyValuePair::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ActionKeyValuePair::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ActionKeyValuePair)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      value_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ActionKeyValuePair::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ActionKeyValuePair.key");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ActionKeyValuePair.value");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActionKeyValuePair::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ActionKeyValuePair)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string key = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ActionKeyValuePair.key");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  // required string value = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ActionKeyValuePair.value");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ActionKeyValuePair)
  return target;
}

size_t ActionKeyValuePair::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ei.ActionKeyValuePair)
  size_t total_size = 0;

  if (_internal_has_key()) {
    // required string key = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  if (_internal_has_value()) {
    // required string value = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());
  }

  return total_size;
}
size_t ActionKeyValuePair::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ActionKeyValuePair)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string key = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());

    // required string value = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ActionKeyValuePair::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ActionKeyValuePair::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ActionKeyValuePair::GetClassData() const { return &_class_data_; }

void ActionKeyValuePair::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ActionKeyValuePair *>(to)->MergeFrom(
      static_cast<const ActionKeyValuePair &>(from));
}


void ActionKeyValuePair::MergeFrom(const ActionKeyValuePair& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ActionKeyValuePair)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_value(from._internal_value());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ActionKeyValuePair::CopyFrom(const ActionKeyValuePair& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ActionKeyValuePair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActionKeyValuePair::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void ActionKeyValuePair::InternalSwap(ActionKeyValuePair* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &key_, lhs_arena,
      &other->key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &value_, lhs_arena,
      &other->value_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ActionKeyValuePair::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[27]);
}

// ===================================================================

class GenericAction::_Internal {
 public:
  using HasBits = decltype(std::declval<GenericAction>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_advertising_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_approx_time_dep(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_approx_time(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_action_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::ei::AppInfo& app(const GenericAction* msg);
  static void set_has_app(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::ei::DeviceInfo& device(const GenericAction* msg);
  static void set_has_device(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::ei::AppInfo&
GenericAction::_Internal::app(const GenericAction* msg) {
  return *msg->app_;
}
const ::ei::DeviceInfo&
GenericAction::_Internal::device(const GenericAction* msg) {
  return *msg->device_;
}
GenericAction::GenericAction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  data_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.GenericAction)
}
GenericAction::GenericAction(const GenericAction& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      data_(from.data_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_id()) {
    user_id_.Set(from._internal_user_id(), 
      GetArenaForAllocation());
  }
  action_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    action_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_action_name()) {
    action_name_.Set(from._internal_action_name(), 
      GetArenaForAllocation());
  }
  advertising_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    advertising_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_advertising_id()) {
    advertising_id_.Set(from._internal_advertising_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_app()) {
    app_ = new ::ei::AppInfo(*from.app_);
  } else {
    app_ = nullptr;
  }
  if (from._internal_has_device()) {
    device_ = new ::ei::DeviceInfo(*from.device_);
  } else {
    device_ = nullptr;
  }
  ::memcpy(&approx_time_, &from.approx_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&approx_time_dep_) -
    reinterpret_cast<char*>(&approx_time_)) + sizeof(approx_time_dep_));
  // @@protoc_insertion_point(copy_constructor:ei.GenericAction)
}

inline void GenericAction::SharedCtor() {
user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
action_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  action_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
advertising_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  advertising_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&app_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&approx_time_dep_) -
    reinterpret_cast<char*>(&app_)) + sizeof(approx_time_dep_));
}

GenericAction::~GenericAction() {
  // @@protoc_insertion_point(destructor:ei.GenericAction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GenericAction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_id_.Destroy();
  action_name_.Destroy();
  advertising_id_.Destroy();
  if (this != internal_default_instance()) delete app_;
  if (this != internal_default_instance()) delete device_;
}

void GenericAction::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GenericAction::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.GenericAction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  data_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      action_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      advertising_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(app_ != nullptr);
      app_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(device_ != nullptr);
      device_->Clear();
    }
  }
  if (cached_has_bits & 0x00000060u) {
    ::memset(&approx_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&approx_time_dep_) -
        reinterpret_cast<char*>(&approx_time_)) + sizeof(approx_time_dep_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GenericAction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.GenericAction.user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional float approx_time_DEP = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_approx_time_dep(&has_bits);
          approx_time_dep_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional string action_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_action_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.GenericAction.action_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ActionKeyValuePair data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_data(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .ei.AppInfo app = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_app(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.DeviceInfo device = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_device(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string advertising_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_advertising_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.GenericAction.advertising_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double approx_time = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _Internal::set_has_approx_time(&has_bits);
          approx_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GenericAction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.GenericAction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.GenericAction.user_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_id(), target);
  }

  // optional float approx_time_DEP = 2;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_approx_time_dep(), target);
  }

  // optional string action_name = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_action_name().data(), static_cast<int>(this->_internal_action_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.GenericAction.action_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_action_name(), target);
  }

  // repeated .ei.ActionKeyValuePair data = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_data_size()); i < n; i++) {
    const auto& repfield = this->_internal_data(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .ei.AppInfo app = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::app(this),
        _Internal::app(this).GetCachedSize(), target, stream);
  }

  // optional .ei.DeviceInfo device = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::device(this),
        _Internal::device(this).GetCachedSize(), target, stream);
  }

  // optional string advertising_id = 7;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_advertising_id().data(), static_cast<int>(this->_internal_advertising_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.GenericAction.advertising_id");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_advertising_id(), target);
  }

  // optional double approx_time = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_approx_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.GenericAction)
  return target;
}

size_t GenericAction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.GenericAction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.ActionKeyValuePair data = 4;
  total_size += 1UL * this->_internal_data_size();
  for (const auto& msg : this->data_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string user_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_id());
    }

    // optional string action_name = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_action_name());
    }

    // optional string advertising_id = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_advertising_id());
    }

    // optional .ei.AppInfo app = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *app_);
    }

    // optional .ei.DeviceInfo device = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *device_);
    }

    // optional double approx_time = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional float approx_time_DEP = 2;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GenericAction::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GenericAction::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GenericAction::GetClassData() const { return &_class_data_; }

void GenericAction::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GenericAction *>(to)->MergeFrom(
      static_cast<const GenericAction &>(from));
}


void GenericAction::MergeFrom(const GenericAction& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.GenericAction)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  data_.MergeFrom(from.data_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_id(from._internal_user_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_action_name(from._internal_action_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_advertising_id(from._internal_advertising_id());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_app()->::ei::AppInfo::MergeFrom(from._internal_app());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_device()->::ei::DeviceInfo::MergeFrom(from._internal_device());
    }
    if (cached_has_bits & 0x00000020u) {
      approx_time_ = from.approx_time_;
    }
    if (cached_has_bits & 0x00000040u) {
      approx_time_dep_ = from.approx_time_dep_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GenericAction::CopyFrom(const GenericAction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.GenericAction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GenericAction::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(data_))
    return false;
  return true;
}

void GenericAction::InternalSwap(GenericAction* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  data_.InternalSwap(&other->data_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &action_name_, lhs_arena,
      &other->action_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &advertising_id_, lhs_arena,
      &other->advertising_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GenericAction, approx_time_dep_)
      + sizeof(GenericAction::approx_time_dep_)
      - PROTOBUF_FIELD_OFFSET(GenericAction, app_)>(
          reinterpret_cast<char*>(&app_),
          reinterpret_cast<char*>(&other->app_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GenericAction::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[28]);
}

// ===================================================================

class GenericActionBatchRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<GenericActionBatchRequest>()._has_bits_);
  static const ::ei::BasicRequestInfo& rinfo(const GenericActionBatchRequest* msg);
  static void set_has_rinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::ei::BasicRequestInfo&
GenericActionBatchRequest::_Internal::rinfo(const GenericActionBatchRequest* msg) {
  return *msg->rinfo_;
}
GenericActionBatchRequest::GenericActionBatchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  actions_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.GenericActionBatchRequest)
}
GenericActionBatchRequest::GenericActionBatchRequest(const GenericActionBatchRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      actions_(from.actions_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_rinfo()) {
    rinfo_ = new ::ei::BasicRequestInfo(*from.rinfo_);
  } else {
    rinfo_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:ei.GenericActionBatchRequest)
}

inline void GenericActionBatchRequest::SharedCtor() {
rinfo_ = nullptr;
}

GenericActionBatchRequest::~GenericActionBatchRequest() {
  // @@protoc_insertion_point(destructor:ei.GenericActionBatchRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GenericActionBatchRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete rinfo_;
}

void GenericActionBatchRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GenericActionBatchRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.GenericActionBatchRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  actions_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(rinfo_ != nullptr);
    rinfo_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GenericActionBatchRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.BasicRequestInfo rinfo = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_rinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.GenericAction actions = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_actions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GenericActionBatchRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.GenericActionBatchRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.BasicRequestInfo rinfo = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::rinfo(this),
        _Internal::rinfo(this).GetCachedSize(), target, stream);
  }

  // repeated .ei.GenericAction actions = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_actions_size()); i < n; i++) {
    const auto& repfield = this->_internal_actions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.GenericActionBatchRequest)
  return target;
}

size_t GenericActionBatchRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.GenericActionBatchRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.GenericAction actions = 2;
  total_size += 1UL * this->_internal_actions_size();
  for (const auto& msg : this->actions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .ei.BasicRequestInfo rinfo = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *rinfo_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GenericActionBatchRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GenericActionBatchRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GenericActionBatchRequest::GetClassData() const { return &_class_data_; }

void GenericActionBatchRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GenericActionBatchRequest *>(to)->MergeFrom(
      static_cast<const GenericActionBatchRequest &>(from));
}


void GenericActionBatchRequest::MergeFrom(const GenericActionBatchRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.GenericActionBatchRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  actions_.MergeFrom(from.actions_);
  if (from._internal_has_rinfo()) {
    _internal_mutable_rinfo()->::ei::BasicRequestInfo::MergeFrom(from._internal_rinfo());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GenericActionBatchRequest::CopyFrom(const GenericActionBatchRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.GenericActionBatchRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GenericActionBatchRequest::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(actions_))
    return false;
  return true;
}

void GenericActionBatchRequest::InternalSwap(GenericActionBatchRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  actions_.InternalSwap(&other->actions_);
  swap(rinfo_, other->rinfo_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GenericActionBatchRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[29]);
}

// ===================================================================

class VerifyPurchaseRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<VerifyPurchaseRequest>()._has_bits_);
  static const ::ei::BasicRequestInfo& rinfo(const VerifyPurchaseRequest* msg);
  static void set_has_rinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_sku(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_transaction_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_original_transaction_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_receipt(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_platform(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_sandbox(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::ei::GenericAction& log(const VerifyPurchaseRequest* msg);
  static void set_has_log(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::ei::BasicRequestInfo&
VerifyPurchaseRequest::_Internal::rinfo(const VerifyPurchaseRequest* msg) {
  return *msg->rinfo_;
}
const ::ei::GenericAction&
VerifyPurchaseRequest::_Internal::log(const VerifyPurchaseRequest* msg) {
  return *msg->log_;
}
VerifyPurchaseRequest::VerifyPurchaseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.VerifyPurchaseRequest)
}
VerifyPurchaseRequest::VerifyPurchaseRequest(const VerifyPurchaseRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  sku_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sku_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sku()) {
    sku_.Set(from._internal_sku(), 
      GetArenaForAllocation());
  }
  transaction_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    transaction_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_transaction_id()) {
    transaction_id_.Set(from._internal_transaction_id(), 
      GetArenaForAllocation());
  }
  receipt_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    receipt_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_receipt()) {
    receipt_.Set(from._internal_receipt(), 
      GetArenaForAllocation());
  }
  platform_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    platform_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_platform()) {
    platform_.Set(from._internal_platform(), 
      GetArenaForAllocation());
  }
  original_transaction_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    original_transaction_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_original_transaction_id()) {
    original_transaction_id_.Set(from._internal_original_transaction_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_log()) {
    log_ = new ::ei::GenericAction(*from.log_);
  } else {
    log_ = nullptr;
  }
  if (from._internal_has_rinfo()) {
    rinfo_ = new ::ei::BasicRequestInfo(*from.rinfo_);
  } else {
    rinfo_ = nullptr;
  }
  sandbox_ = from.sandbox_;
  // @@protoc_insertion_point(copy_constructor:ei.VerifyPurchaseRequest)
}

inline void VerifyPurchaseRequest::SharedCtor() {
sku_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sku_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
transaction_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  transaction_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
receipt_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  receipt_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
platform_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  platform_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
original_transaction_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  original_transaction_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&log_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&sandbox_) -
    reinterpret_cast<char*>(&log_)) + sizeof(sandbox_));
}

VerifyPurchaseRequest::~VerifyPurchaseRequest() {
  // @@protoc_insertion_point(destructor:ei.VerifyPurchaseRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VerifyPurchaseRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  sku_.Destroy();
  transaction_id_.Destroy();
  receipt_.Destroy();
  platform_.Destroy();
  original_transaction_id_.Destroy();
  if (this != internal_default_instance()) delete log_;
  if (this != internal_default_instance()) delete rinfo_;
}

void VerifyPurchaseRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VerifyPurchaseRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.VerifyPurchaseRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      sku_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      transaction_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      receipt_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      platform_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      original_transaction_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(log_ != nullptr);
      log_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(rinfo_ != nullptr);
      rinfo_->Clear();
    }
  }
  sandbox_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VerifyPurchaseRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string sku = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_sku();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.VerifyPurchaseRequest.sku");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string transaction_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_transaction_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.VerifyPurchaseRequest.transaction_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string receipt = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_receipt();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.VerifyPurchaseRequest.receipt");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string platform = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_platform();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.VerifyPurchaseRequest.platform");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .ei.GenericAction log = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_log(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.BasicRequestInfo rinfo = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_rinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool sandbox = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_sandbox(&has_bits);
          sandbox_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string original_transaction_id = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_original_transaction_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.VerifyPurchaseRequest.original_transaction_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VerifyPurchaseRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.VerifyPurchaseRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string sku = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sku().data(), static_cast<int>(this->_internal_sku().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.VerifyPurchaseRequest.sku");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_sku(), target);
  }

  // optional string transaction_id = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_transaction_id().data(), static_cast<int>(this->_internal_transaction_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.VerifyPurchaseRequest.transaction_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_transaction_id(), target);
  }

  // optional string receipt = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_receipt().data(), static_cast<int>(this->_internal_receipt().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.VerifyPurchaseRequest.receipt");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_receipt(), target);
  }

  // optional string platform = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_platform().data(), static_cast<int>(this->_internal_platform().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.VerifyPurchaseRequest.platform");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_platform(), target);
  }

  // optional .ei.GenericAction log = 5;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::log(this),
        _Internal::log(this).GetCachedSize(), target, stream);
  }

  // optional .ei.BasicRequestInfo rinfo = 6;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::rinfo(this),
        _Internal::rinfo(this).GetCachedSize(), target, stream);
  }

  // optional bool sandbox = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_sandbox(), target);
  }

  // optional string original_transaction_id = 8;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_original_transaction_id().data(), static_cast<int>(this->_internal_original_transaction_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.VerifyPurchaseRequest.original_transaction_id");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_original_transaction_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.VerifyPurchaseRequest)
  return target;
}

size_t VerifyPurchaseRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.VerifyPurchaseRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string sku = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_sku());
    }

    // optional string transaction_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_transaction_id());
    }

    // optional string receipt = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_receipt());
    }

    // optional string platform = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_platform());
    }

    // optional string original_transaction_id = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_original_transaction_id());
    }

    // optional .ei.GenericAction log = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *log_);
    }

    // optional .ei.BasicRequestInfo rinfo = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rinfo_);
    }

    // optional bool sandbox = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VerifyPurchaseRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    VerifyPurchaseRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VerifyPurchaseRequest::GetClassData() const { return &_class_data_; }

void VerifyPurchaseRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<VerifyPurchaseRequest *>(to)->MergeFrom(
      static_cast<const VerifyPurchaseRequest &>(from));
}


void VerifyPurchaseRequest::MergeFrom(const VerifyPurchaseRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.VerifyPurchaseRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_sku(from._internal_sku());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_transaction_id(from._internal_transaction_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_receipt(from._internal_receipt());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_platform(from._internal_platform());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_original_transaction_id(from._internal_original_transaction_id());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_log()->::ei::GenericAction::MergeFrom(from._internal_log());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_rinfo()->::ei::BasicRequestInfo::MergeFrom(from._internal_rinfo());
    }
    if (cached_has_bits & 0x00000080u) {
      sandbox_ = from.sandbox_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VerifyPurchaseRequest::CopyFrom(const VerifyPurchaseRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.VerifyPurchaseRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerifyPurchaseRequest::IsInitialized() const {
  if (_internal_has_log()) {
    if (!log_->IsInitialized()) return false;
  }
  return true;
}

void VerifyPurchaseRequest::InternalSwap(VerifyPurchaseRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sku_, lhs_arena,
      &other->sku_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &transaction_id_, lhs_arena,
      &other->transaction_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &receipt_, lhs_arena,
      &other->receipt_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &platform_, lhs_arena,
      &other->platform_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &original_transaction_id_, lhs_arena,
      &other->original_transaction_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VerifyPurchaseRequest, sandbox_)
      + sizeof(VerifyPurchaseRequest::sandbox_)
      - PROTOBUF_FIELD_OFFSET(VerifyPurchaseRequest, log_)>(
          reinterpret_cast<char*>(&log_),
          reinterpret_cast<char*>(&other->log_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VerifyPurchaseRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[30]);
}

// ===================================================================

class VerifyPurchaseResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<VerifyPurchaseResponse>()._has_bits_);
  static void set_has_verified(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

VerifyPurchaseResponse::VerifyPurchaseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.VerifyPurchaseResponse)
}
VerifyPurchaseResponse::VerifyPurchaseResponse(const VerifyPurchaseResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    message_.Set(from._internal_message(), 
      GetArenaForAllocation());
  }
  verified_ = from.verified_;
  // @@protoc_insertion_point(copy_constructor:ei.VerifyPurchaseResponse)
}

inline void VerifyPurchaseResponse::SharedCtor() {
message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
verified_ = false;
}

VerifyPurchaseResponse::~VerifyPurchaseResponse() {
  // @@protoc_insertion_point(destructor:ei.VerifyPurchaseResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VerifyPurchaseResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  message_.Destroy();
}

void VerifyPurchaseResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VerifyPurchaseResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.VerifyPurchaseResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    message_.ClearNonDefaultToEmpty();
  }
  verified_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VerifyPurchaseResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool verified = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_verified(&has_bits);
          verified_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.VerifyPurchaseResponse.message");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VerifyPurchaseResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.VerifyPurchaseResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool verified = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_verified(), target);
  }

  // optional string message = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_message().data(), static_cast<int>(this->_internal_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.VerifyPurchaseResponse.message");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.VerifyPurchaseResponse)
  return target;
}

size_t VerifyPurchaseResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.VerifyPurchaseResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string message = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_message());
    }

    // optional bool verified = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VerifyPurchaseResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    VerifyPurchaseResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VerifyPurchaseResponse::GetClassData() const { return &_class_data_; }

void VerifyPurchaseResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<VerifyPurchaseResponse *>(to)->MergeFrom(
      static_cast<const VerifyPurchaseResponse &>(from));
}


void VerifyPurchaseResponse::MergeFrom(const VerifyPurchaseResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.VerifyPurchaseResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      verified_ = from.verified_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VerifyPurchaseResponse::CopyFrom(const VerifyPurchaseResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.VerifyPurchaseResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerifyPurchaseResponse::IsInitialized() const {
  return true;
}

void VerifyPurchaseResponse::InternalSwap(VerifyPurchaseResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &message_, lhs_arena,
      &other->message_, rhs_arena
  );
  swap(verified_, other->verified_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VerifyPurchaseResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[31]);
}

// ===================================================================

class CurrencyFlowLog::_Internal {
 public:
  using HasBits = decltype(std::declval<CurrencyFlowLog>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_approx_time(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_currency(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_location(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_platform(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_soul_eggs(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_tickets_spent(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_gold_spent(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

CurrencyFlowLog::CurrencyFlowLog(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.CurrencyFlowLog)
}
CurrencyFlowLog::CurrencyFlowLog(const CurrencyFlowLog& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_id()) {
    user_id_.Set(from._internal_user_id(), 
      GetArenaForAllocation());
  }
  location_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    location_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_location()) {
    location_.Set(from._internal_location(), 
      GetArenaForAllocation());
  }
  version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_version()) {
    version_.Set(from._internal_version(), 
      GetArenaForAllocation());
  }
  platform_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    platform_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_platform()) {
    platform_.Set(from._internal_platform(), 
      GetArenaForAllocation());
  }
  ::memcpy(&approx_time_, &from.approx_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&currency_) -
    reinterpret_cast<char*>(&approx_time_)) + sizeof(currency_));
  // @@protoc_insertion_point(copy_constructor:ei.CurrencyFlowLog)
}

inline void CurrencyFlowLog::SharedCtor() {
user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
location_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  location_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
platform_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  platform_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&approx_time_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&gold_spent_) -
    reinterpret_cast<char*>(&approx_time_)) + sizeof(gold_spent_));
currency_ = 1;
}

CurrencyFlowLog::~CurrencyFlowLog() {
  // @@protoc_insertion_point(destructor:ei.CurrencyFlowLog)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CurrencyFlowLog::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_id_.Destroy();
  location_.Destroy();
  version_.Destroy();
  platform_.Destroy();
}

void CurrencyFlowLog::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CurrencyFlowLog::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.CurrencyFlowLog)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      location_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      platform_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&approx_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&tickets_spent_) -
        reinterpret_cast<char*>(&approx_time_)) + sizeof(tickets_spent_));
  }
  if (cached_has_bits & 0x00000300u) {
    gold_spent_ = uint64_t{0u};
    currency_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CurrencyFlowLog::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.CurrencyFlowLog.user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double approx_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_approx_time(&has_bits);
          approx_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.RewardType currency = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::RewardType_IsValid(val))) {
            _internal_set_currency(static_cast<::ei::RewardType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int64 amount = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_amount(&has_bits);
          amount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string location = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_location();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.CurrencyFlowLog.location");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string version = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.CurrencyFlowLog.version");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string platform = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_platform();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.CurrencyFlowLog.platform");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double soul_eggs = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _Internal::set_has_soul_eggs(&has_bits);
          soul_eggs_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 tickets_spent = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_tickets_spent(&has_bits);
          tickets_spent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 gold_spent = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_gold_spent(&has_bits);
          gold_spent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CurrencyFlowLog::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.CurrencyFlowLog)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.CurrencyFlowLog.user_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_id(), target);
  }

  // optional double approx_time = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_approx_time(), target);
  }

  // optional .ei.RewardType currency = 3;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_currency(), target);
  }

  // optional int64 amount = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_amount(), target);
  }

  // optional string location = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_location().data(), static_cast<int>(this->_internal_location().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.CurrencyFlowLog.location");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_location(), target);
  }

  // optional string version = 6;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_version().data(), static_cast<int>(this->_internal_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.CurrencyFlowLog.version");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_version(), target);
  }

  // optional string platform = 7;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_platform().data(), static_cast<int>(this->_internal_platform().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.CurrencyFlowLog.platform");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_platform(), target);
  }

  // optional double soul_eggs = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_soul_eggs(), target);
  }

  // optional uint64 tickets_spent = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(9, this->_internal_tickets_spent(), target);
  }

  // optional uint64 gold_spent = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(10, this->_internal_gold_spent(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.CurrencyFlowLog)
  return target;
}

size_t CurrencyFlowLog::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.CurrencyFlowLog)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string user_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_id());
    }

    // optional string location = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_location());
    }

    // optional string version = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_version());
    }

    // optional string platform = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_platform());
    }

    // optional double approx_time = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional int64 amount = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_amount());
    }

    // optional double soul_eggs = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional uint64 tickets_spent = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_tickets_spent());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint64 gold_spent = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_gold_spent());
    }

    // optional .ei.RewardType currency = 3;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_currency());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CurrencyFlowLog::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CurrencyFlowLog::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CurrencyFlowLog::GetClassData() const { return &_class_data_; }

void CurrencyFlowLog::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CurrencyFlowLog *>(to)->MergeFrom(
      static_cast<const CurrencyFlowLog &>(from));
}


void CurrencyFlowLog::MergeFrom(const CurrencyFlowLog& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.CurrencyFlowLog)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_id(from._internal_user_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_location(from._internal_location());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_version(from._internal_version());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_platform(from._internal_platform());
    }
    if (cached_has_bits & 0x00000010u) {
      approx_time_ = from.approx_time_;
    }
    if (cached_has_bits & 0x00000020u) {
      amount_ = from.amount_;
    }
    if (cached_has_bits & 0x00000040u) {
      soul_eggs_ = from.soul_eggs_;
    }
    if (cached_has_bits & 0x00000080u) {
      tickets_spent_ = from.tickets_spent_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      gold_spent_ = from.gold_spent_;
    }
    if (cached_has_bits & 0x00000200u) {
      currency_ = from.currency_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CurrencyFlowLog::CopyFrom(const CurrencyFlowLog& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.CurrencyFlowLog)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CurrencyFlowLog::IsInitialized() const {
  return true;
}

void CurrencyFlowLog::InternalSwap(CurrencyFlowLog* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &location_, lhs_arena,
      &other->location_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &version_, lhs_arena,
      &other->version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &platform_, lhs_arena,
      &other->platform_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CurrencyFlowLog, gold_spent_)
      + sizeof(CurrencyFlowLog::gold_spent_)
      - PROTOBUF_FIELD_OFFSET(CurrencyFlowLog, approx_time_)>(
          reinterpret_cast<char*>(&approx_time_),
          reinterpret_cast<char*>(&other->approx_time_));
  swap(currency_, other->currency_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CurrencyFlowLog::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[32]);
}

// ===================================================================

class CurrencyFlowBatchRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CurrencyFlowBatchRequest>()._has_bits_);
  static const ::ei::BasicRequestInfo& rinfo(const CurrencyFlowBatchRequest* msg);
  static void set_has_rinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::ei::BasicRequestInfo&
CurrencyFlowBatchRequest::_Internal::rinfo(const CurrencyFlowBatchRequest* msg) {
  return *msg->rinfo_;
}
CurrencyFlowBatchRequest::CurrencyFlowBatchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  logs_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.CurrencyFlowBatchRequest)
}
CurrencyFlowBatchRequest::CurrencyFlowBatchRequest(const CurrencyFlowBatchRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      logs_(from.logs_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_rinfo()) {
    rinfo_ = new ::ei::BasicRequestInfo(*from.rinfo_);
  } else {
    rinfo_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:ei.CurrencyFlowBatchRequest)
}

inline void CurrencyFlowBatchRequest::SharedCtor() {
rinfo_ = nullptr;
}

CurrencyFlowBatchRequest::~CurrencyFlowBatchRequest() {
  // @@protoc_insertion_point(destructor:ei.CurrencyFlowBatchRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CurrencyFlowBatchRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete rinfo_;
}

void CurrencyFlowBatchRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CurrencyFlowBatchRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.CurrencyFlowBatchRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  logs_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(rinfo_ != nullptr);
    rinfo_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CurrencyFlowBatchRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .ei.CurrencyFlowLog logs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_logs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .ei.BasicRequestInfo rinfo = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_rinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CurrencyFlowBatchRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.CurrencyFlowBatchRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ei.CurrencyFlowLog logs = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_logs_size()); i < n; i++) {
    const auto& repfield = this->_internal_logs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional .ei.BasicRequestInfo rinfo = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::rinfo(this),
        _Internal::rinfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.CurrencyFlowBatchRequest)
  return target;
}

size_t CurrencyFlowBatchRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.CurrencyFlowBatchRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.CurrencyFlowLog logs = 1;
  total_size += 1UL * this->_internal_logs_size();
  for (const auto& msg : this->logs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .ei.BasicRequestInfo rinfo = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *rinfo_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CurrencyFlowBatchRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CurrencyFlowBatchRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CurrencyFlowBatchRequest::GetClassData() const { return &_class_data_; }

void CurrencyFlowBatchRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CurrencyFlowBatchRequest *>(to)->MergeFrom(
      static_cast<const CurrencyFlowBatchRequest &>(from));
}


void CurrencyFlowBatchRequest::MergeFrom(const CurrencyFlowBatchRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.CurrencyFlowBatchRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  logs_.MergeFrom(from.logs_);
  if (from._internal_has_rinfo()) {
    _internal_mutable_rinfo()->::ei::BasicRequestInfo::MergeFrom(from._internal_rinfo());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CurrencyFlowBatchRequest::CopyFrom(const CurrencyFlowBatchRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.CurrencyFlowBatchRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CurrencyFlowBatchRequest::IsInitialized() const {
  return true;
}

void CurrencyFlowBatchRequest::InternalSwap(CurrencyFlowBatchRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  logs_.InternalSwap(&other->logs_);
  swap(rinfo_, other->rinfo_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CurrencyFlowBatchRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[33]);
}

// ===================================================================

class Reward::_Internal {
 public:
  using HasBits = decltype(std::declval<Reward>()._has_bits_);
  static void set_has_reward_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_reward_sub_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_reward_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Reward::Reward(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.Reward)
}
Reward::Reward(const Reward& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  reward_sub_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    reward_sub_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_reward_sub_type()) {
    reward_sub_type_.Set(from._internal_reward_sub_type(), 
      GetArenaForAllocation());
  }
  ::memcpy(&reward_amount_, &from.reward_amount_,
    static_cast<size_t>(reinterpret_cast<char*>(&reward_type_) -
    reinterpret_cast<char*>(&reward_amount_)) + sizeof(reward_type_));
  // @@protoc_insertion_point(copy_constructor:ei.Reward)
}

inline void Reward::SharedCtor() {
reward_sub_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  reward_sub_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
reward_amount_ = 0;
reward_type_ = 1;
}

Reward::~Reward() {
  // @@protoc_insertion_point(destructor:ei.Reward)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Reward::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  reward_sub_type_.Destroy();
}

void Reward::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Reward::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.Reward)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    reward_sub_type_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    reward_amount_ = 0;
    reward_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Reward::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.RewardType reward_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::RewardType_IsValid(val))) {
            _internal_set_reward_type(static_cast<::ei::RewardType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string reward_sub_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_reward_sub_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.Reward.reward_sub_type");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double reward_amount = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_reward_amount(&has_bits);
          reward_amount_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Reward::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.Reward)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.RewardType reward_type = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_reward_type(), target);
  }

  // optional string reward_sub_type = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_reward_sub_type().data(), static_cast<int>(this->_internal_reward_sub_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.Reward.reward_sub_type");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_reward_sub_type(), target);
  }

  // optional double reward_amount = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_reward_amount(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.Reward)
  return target;
}

size_t Reward::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.Reward)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string reward_sub_type = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_reward_sub_type());
    }

    // optional double reward_amount = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional .ei.RewardType reward_type = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_reward_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Reward::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Reward::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Reward::GetClassData() const { return &_class_data_; }

void Reward::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Reward *>(to)->MergeFrom(
      static_cast<const Reward &>(from));
}


void Reward::MergeFrom(const Reward& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.Reward)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_reward_sub_type(from._internal_reward_sub_type());
    }
    if (cached_has_bits & 0x00000002u) {
      reward_amount_ = from.reward_amount_;
    }
    if (cached_has_bits & 0x00000004u) {
      reward_type_ = from.reward_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Reward::CopyFrom(const Reward& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.Reward)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Reward::IsInitialized() const {
  return true;
}

void Reward::InternalSwap(Reward* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &reward_sub_type_, lhs_arena,
      &other->reward_sub_type_, rhs_arena
  );
  swap(reward_amount_, other->reward_amount_);
  swap(reward_type_, other->reward_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Reward::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[34]);
}

// ===================================================================

class GameModifier::_Internal {
 public:
  using HasBits = decltype(std::declval<GameModifier>()._has_bits_);
  static void set_has_dimension(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

GameModifier::GameModifier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.GameModifier)
}
GameModifier::GameModifier(const GameModifier& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description()) {
    description_.Set(from._internal_description(), 
      GetArenaForAllocation());
  }
  ::memcpy(&value_, &from.value_,
    static_cast<size_t>(reinterpret_cast<char*>(&dimension_) -
    reinterpret_cast<char*>(&value_)) + sizeof(dimension_));
  // @@protoc_insertion_point(copy_constructor:ei.GameModifier)
}

inline void GameModifier::SharedCtor() {
description_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  description_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
value_ = 0;
dimension_ = 1;
}

GameModifier::~GameModifier() {
  // @@protoc_insertion_point(destructor:ei.GameModifier)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GameModifier::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  description_.Destroy();
}

void GameModifier::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GameModifier::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.GameModifier)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    description_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    value_ = 0;
    dimension_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GameModifier::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.GameModifier.GameDimension dimension = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::GameModifier_GameDimension_IsValid(val))) {
            _internal_set_dimension(static_cast<::ei::GameModifier_GameDimension>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional double value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_value(&has_bits);
          value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional string description = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.GameModifier.description");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameModifier::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.GameModifier)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.GameModifier.GameDimension dimension = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_dimension(), target);
  }

  // optional double value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_value(), target);
  }

  // optional string description = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.GameModifier.description");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_description(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.GameModifier)
  return target;
}

size_t GameModifier::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.GameModifier)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string description = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_description());
    }

    // optional double value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional .ei.GameModifier.GameDimension dimension = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_dimension());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GameModifier::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GameModifier::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GameModifier::GetClassData() const { return &_class_data_; }

void GameModifier::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GameModifier *>(to)->MergeFrom(
      static_cast<const GameModifier &>(from));
}


void GameModifier::MergeFrom(const GameModifier& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.GameModifier)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_description(from._internal_description());
    }
    if (cached_has_bits & 0x00000002u) {
      value_ = from.value_;
    }
    if (cached_has_bits & 0x00000004u) {
      dimension_ = from.dimension_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GameModifier::CopyFrom(const GameModifier& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.GameModifier)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameModifier::IsInitialized() const {
  return true;
}

void GameModifier::InternalSwap(GameModifier* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &description_, lhs_arena,
      &other->description_, rhs_arena
  );
  swap(value_, other->value_);
  swap(dimension_, other->dimension_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GameModifier::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[35]);
}

// ===================================================================

class Contract_Goal::_Internal {
 public:
  using HasBits = decltype(std::declval<Contract_Goal>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_target_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_reward_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_reward_sub_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_reward_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_target_soul_eggs(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Contract_Goal::Contract_Goal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.Contract.Goal)
}
Contract_Goal::Contract_Goal(const Contract_Goal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  reward_sub_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    reward_sub_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_reward_sub_type()) {
    reward_sub_type_.Set(from._internal_reward_sub_type(), 
      GetArenaForAllocation());
  }
  ::memcpy(&target_amount_, &from.target_amount_,
    static_cast<size_t>(reinterpret_cast<char*>(&reward_type_) -
    reinterpret_cast<char*>(&target_amount_)) + sizeof(reward_type_));
  // @@protoc_insertion_point(copy_constructor:ei.Contract.Goal)
}

inline void Contract_Goal::SharedCtor() {
reward_sub_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  reward_sub_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&target_amount_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&target_soul_eggs_) -
    reinterpret_cast<char*>(&target_amount_)) + sizeof(target_soul_eggs_));
type_ = 1;
reward_type_ = 1;
}

Contract_Goal::~Contract_Goal() {
  // @@protoc_insertion_point(destructor:ei.Contract.Goal)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Contract_Goal::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  reward_sub_type_.Destroy();
}

void Contract_Goal::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Contract_Goal::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.Contract.Goal)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    reward_sub_type_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&target_amount_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&target_soul_eggs_) -
        reinterpret_cast<char*>(&target_amount_)) + sizeof(target_soul_eggs_));
    type_ = 1;
    reward_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Contract_Goal::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.GoalType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::GoalType_IsValid(val))) {
            _internal_set_type(static_cast<::ei::GoalType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional double target_amount = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_target_amount(&has_bits);
          target_amount_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.RewardType reward_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::RewardType_IsValid(val))) {
            _internal_set_reward_type(static_cast<::ei::RewardType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string reward_sub_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_reward_sub_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.Contract.Goal.reward_sub_type");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double reward_amount = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_reward_amount(&has_bits);
          reward_amount_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double target_soul_eggs = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_target_soul_eggs(&has_bits);
          target_soul_eggs_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Contract_Goal::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.Contract.Goal)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.GoalType type = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional double target_amount = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_target_amount(), target);
  }

  // optional .ei.RewardType reward_type = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_reward_type(), target);
  }

  // optional string reward_sub_type = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_reward_sub_type().data(), static_cast<int>(this->_internal_reward_sub_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.Contract.Goal.reward_sub_type");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_reward_sub_type(), target);
  }

  // optional double reward_amount = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_reward_amount(), target);
  }

  // optional double target_soul_eggs = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_target_soul_eggs(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.Contract.Goal)
  return target;
}

size_t Contract_Goal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.Contract.Goal)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string reward_sub_type = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_reward_sub_type());
    }

    // optional double target_amount = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double reward_amount = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double target_soul_eggs = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional .ei.GoalType type = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional .ei.RewardType reward_type = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_reward_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Contract_Goal::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Contract_Goal::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Contract_Goal::GetClassData() const { return &_class_data_; }

void Contract_Goal::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Contract_Goal *>(to)->MergeFrom(
      static_cast<const Contract_Goal &>(from));
}


void Contract_Goal::MergeFrom(const Contract_Goal& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.Contract.Goal)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_reward_sub_type(from._internal_reward_sub_type());
    }
    if (cached_has_bits & 0x00000002u) {
      target_amount_ = from.target_amount_;
    }
    if (cached_has_bits & 0x00000004u) {
      reward_amount_ = from.reward_amount_;
    }
    if (cached_has_bits & 0x00000008u) {
      target_soul_eggs_ = from.target_soul_eggs_;
    }
    if (cached_has_bits & 0x00000010u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000020u) {
      reward_type_ = from.reward_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Contract_Goal::CopyFrom(const Contract_Goal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.Contract.Goal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Contract_Goal::IsInitialized() const {
  return true;
}

void Contract_Goal::InternalSwap(Contract_Goal* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &reward_sub_type_, lhs_arena,
      &other->reward_sub_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Contract_Goal, target_soul_eggs_)
      + sizeof(Contract_Goal::target_soul_eggs_)
      - PROTOBUF_FIELD_OFFSET(Contract_Goal, target_amount_)>(
          reinterpret_cast<char*>(&target_amount_),
          reinterpret_cast<char*>(&other->target_amount_));
  swap(type_, other->type_);
  swap(reward_type_, other->reward_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Contract_Goal::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[36]);
}

// ===================================================================

class Contract_GoalSet::_Internal {
 public:
};

Contract_GoalSet::Contract_GoalSet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  goals_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.Contract.GoalSet)
}
Contract_GoalSet::Contract_GoalSet(const Contract_GoalSet& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      goals_(from.goals_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ei.Contract.GoalSet)
}

inline void Contract_GoalSet::SharedCtor() {
}

Contract_GoalSet::~Contract_GoalSet() {
  // @@protoc_insertion_point(destructor:ei.Contract.GoalSet)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Contract_GoalSet::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Contract_GoalSet::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Contract_GoalSet::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.Contract.GoalSet)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  goals_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Contract_GoalSet::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .ei.Contract.Goal goals = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_goals(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Contract_GoalSet::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.Contract.GoalSet)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ei.Contract.Goal goals = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_goals_size()); i < n; i++) {
    const auto& repfield = this->_internal_goals(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.Contract.GoalSet)
  return target;
}

size_t Contract_GoalSet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.Contract.GoalSet)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.Contract.Goal goals = 1;
  total_size += 1UL * this->_internal_goals_size();
  for (const auto& msg : this->goals_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Contract_GoalSet::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Contract_GoalSet::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Contract_GoalSet::GetClassData() const { return &_class_data_; }

void Contract_GoalSet::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Contract_GoalSet *>(to)->MergeFrom(
      static_cast<const Contract_GoalSet &>(from));
}


void Contract_GoalSet::MergeFrom(const Contract_GoalSet& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.Contract.GoalSet)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  goals_.MergeFrom(from.goals_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Contract_GoalSet::CopyFrom(const Contract_GoalSet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.Contract.GoalSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Contract_GoalSet::IsInitialized() const {
  return true;
}

void Contract_GoalSet::InternalSwap(Contract_GoalSet* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  goals_.InternalSwap(&other->goals_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Contract_GoalSet::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[37]);
}

// ===================================================================

class Contract_GradeSpec::_Internal {
 public:
  using HasBits = decltype(std::declval<Contract_GradeSpec>()._has_bits_);
  static void set_has_grade(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_length_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Contract_GradeSpec::Contract_GradeSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  goals_(arena),
  modifiers_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.Contract.GradeSpec)
}
Contract_GradeSpec::Contract_GradeSpec(const Contract_GradeSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      goals_(from.goals_),
      modifiers_(from.modifiers_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&length_seconds_, &from.length_seconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&grade_) -
    reinterpret_cast<char*>(&length_seconds_)) + sizeof(grade_));
  // @@protoc_insertion_point(copy_constructor:ei.Contract.GradeSpec)
}

inline void Contract_GradeSpec::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&length_seconds_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&grade_) -
    reinterpret_cast<char*>(&length_seconds_)) + sizeof(grade_));
}

Contract_GradeSpec::~Contract_GradeSpec() {
  // @@protoc_insertion_point(destructor:ei.Contract.GradeSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Contract_GradeSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Contract_GradeSpec::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Contract_GradeSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.Contract.GradeSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  goals_.Clear();
  modifiers_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&length_seconds_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&grade_) -
        reinterpret_cast<char*>(&length_seconds_)) + sizeof(grade_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Contract_GradeSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.Contract.PlayerGrade grade = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::Contract_PlayerGrade_IsValid(val))) {
            _internal_set_grade(static_cast<::ei::Contract_PlayerGrade>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.Contract.Goal goals = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_goals(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.GameModifier modifiers = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_modifiers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional double length_seconds = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_length_seconds(&has_bits);
          length_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Contract_GradeSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.Contract.GradeSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.Contract.PlayerGrade grade = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_grade(), target);
  }

  // repeated .ei.Contract.Goal goals = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_goals_size()); i < n; i++) {
    const auto& repfield = this->_internal_goals(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .ei.GameModifier modifiers = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_modifiers_size()); i < n; i++) {
    const auto& repfield = this->_internal_modifiers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional double length_seconds = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_length_seconds(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.Contract.GradeSpec)
  return target;
}

size_t Contract_GradeSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.Contract.GradeSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.Contract.Goal goals = 2;
  total_size += 1UL * this->_internal_goals_size();
  for (const auto& msg : this->goals_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.GameModifier modifiers = 3;
  total_size += 1UL * this->_internal_modifiers_size();
  for (const auto& msg : this->modifiers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional double length_seconds = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional .ei.Contract.PlayerGrade grade = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_grade());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Contract_GradeSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Contract_GradeSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Contract_GradeSpec::GetClassData() const { return &_class_data_; }

void Contract_GradeSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Contract_GradeSpec *>(to)->MergeFrom(
      static_cast<const Contract_GradeSpec &>(from));
}


void Contract_GradeSpec::MergeFrom(const Contract_GradeSpec& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.Contract.GradeSpec)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  goals_.MergeFrom(from.goals_);
  modifiers_.MergeFrom(from.modifiers_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      length_seconds_ = from.length_seconds_;
    }
    if (cached_has_bits & 0x00000002u) {
      grade_ = from.grade_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Contract_GradeSpec::CopyFrom(const Contract_GradeSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.Contract.GradeSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Contract_GradeSpec::IsInitialized() const {
  return true;
}

void Contract_GradeSpec::InternalSwap(Contract_GradeSpec* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  goals_.InternalSwap(&other->goals_);
  modifiers_.InternalSwap(&other->modifiers_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Contract_GradeSpec, grade_)
      + sizeof(Contract_GradeSpec::grade_)
      - PROTOBUF_FIELD_OFFSET(Contract_GradeSpec, length_seconds_)>(
          reinterpret_cast<char*>(&length_seconds_),
          reinterpret_cast<char*>(&other->length_seconds_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Contract_GradeSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[38]);
}

// ===================================================================

class Contract::_Internal {
 public:
  using HasBits = decltype(std::declval<Contract>()._has_bits_);
  static void set_has_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_egg(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_season_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_coop_allowed(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_max_coop_size(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_max_boosts(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_minutes_per_token(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_chicken_run_cooldown_minutes(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_start_time(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_expiration_time(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_length_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_max_soul_eggs(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_min_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_leggacy(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_cc_only(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_debug(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Contract::Contract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  goals_(arena),
  goal_sets_(arena),
  grade_specs_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.Contract)
}
Contract::Contract(const Contract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      goals_(from.goals_),
      goal_sets_(from.goal_sets_),
      grade_specs_(from.grade_specs_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_identifier()) {
    identifier_.Set(from._internal_identifier(), 
      GetArenaForAllocation());
  }
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description()) {
    description_.Set(from._internal_description(), 
      GetArenaForAllocation());
  }
  key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key()) {
    key_.Set(from._internal_key(), 
      GetArenaForAllocation());
  }
  season_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    season_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_season_id()) {
    season_id_.Set(from._internal_season_id(), 
      GetArenaForAllocation());
  }
  ::memcpy(&expiration_time_, &from.expiration_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&chicken_run_cooldown_minutes_) -
    reinterpret_cast<char*>(&expiration_time_)) + sizeof(chicken_run_cooldown_minutes_));
  // @@protoc_insertion_point(copy_constructor:ei.Contract)
}

inline void Contract::SharedCtor() {
identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
description_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  description_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
season_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  season_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&expiration_time_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&start_time_) -
    reinterpret_cast<char*>(&expiration_time_)) + sizeof(start_time_));
egg_ = 1;
minutes_per_token_ = 60;
chicken_run_cooldown_minutes_ = 180;
}

Contract::~Contract() {
  // @@protoc_insertion_point(destructor:ei.Contract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Contract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  identifier_.Destroy();
  name_.Destroy();
  description_.Destroy();
  key_.Destroy();
  season_id_.Destroy();
}

void Contract::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Contract::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.Contract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  goals_.Clear();
  goal_sets_.Clear();
  grade_specs_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      description_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      season_id_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&expiration_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&max_coop_size_) -
        reinterpret_cast<char*>(&expiration_time_)) + sizeof(max_coop_size_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&max_boosts_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&start_time_) -
        reinterpret_cast<char*>(&max_boosts_)) + sizeof(start_time_));
  }
  if (cached_has_bits & 0x00070000u) {
    egg_ = 1;
    minutes_per_token_ = 60;
    chicken_run_cooldown_minutes_ = 180;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Contract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.Contract.identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .ei.Egg egg = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::Egg_IsValid(val))) {
            _internal_set_egg(static_cast<::ei::Egg>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.Contract.Goal goals = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_goals(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool coop_allowed = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_coop_allowed(&has_bits);
          coop_allowed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 max_coop_size = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_max_coop_size(&has_bits);
          max_coop_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double expiration_time = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_expiration_time(&has_bits);
          expiration_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double length_seconds = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _Internal::set_has_length_seconds(&has_bits);
          length_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.Contract.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string description = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.Contract.description");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool debug = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_debug(&has_bits);
          debug_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 max_boosts = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_max_boosts(&has_bits);
          max_boosts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double max_soul_eggs = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 105)) {
          _Internal::set_has_max_soul_eggs(&has_bits);
          max_soul_eggs_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 min_client_version = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_min_client_version(&has_bits);
          min_client_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double minutes_per_token = 15 [default = 60];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 121)) {
          _Internal::set_has_minutes_per_token(&has_bits);
          minutes_per_token_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.Contract.GoalSet goal_sets = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_goal_sets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<130>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional double start_time = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 137)) {
          _Internal::set_has_start_time(&has_bits);
          start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double chicken_run_cooldown_minutes = 18 [default = 180];
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 145)) {
          _Internal::set_has_chicken_run_cooldown_minutes(&has_bits);
          chicken_run_cooldown_minutes_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool leggacy = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_leggacy(&has_bits);
          leggacy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.Contract.GradeSpec grade_specs = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_grade_specs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<162>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string key = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.Contract.key");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool cc_only = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_cc_only(&has_bits);
          cc_only_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string season_id = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          auto str = _internal_mutable_season_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.Contract.season_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Contract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.Contract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_identifier().data(), static_cast<int>(this->_internal_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.Contract.identifier");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_identifier(), target);
  }

  // optional .ei.Egg egg = 2;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_egg(), target);
  }

  // repeated .ei.Contract.Goal goals = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_goals_size()); i < n; i++) {
    const auto& repfield = this->_internal_goals(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool coop_allowed = 4;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_coop_allowed(), target);
  }

  // optional uint32 max_coop_size = 5;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_max_coop_size(), target);
  }

  // optional double expiration_time = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_expiration_time(), target);
  }

  // optional double length_seconds = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_length_seconds(), target);
  }

  // optional string name = 9;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.Contract.name");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_name(), target);
  }

  // optional string description = 10;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.Contract.description");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_description(), target);
  }

  // optional bool debug = 11;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_debug(), target);
  }

  // optional uint32 max_boosts = 12;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_max_boosts(), target);
  }

  // optional double max_soul_eggs = 13;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(13, this->_internal_max_soul_eggs(), target);
  }

  // optional uint32 min_client_version = 14;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_min_client_version(), target);
  }

  // optional double minutes_per_token = 15 [default = 60];
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(15, this->_internal_minutes_per_token(), target);
  }

  // repeated .ei.Contract.GoalSet goal_sets = 16;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_goal_sets_size()); i < n; i++) {
    const auto& repfield = this->_internal_goal_sets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(16, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional double start_time = 17;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(17, this->_internal_start_time(), target);
  }

  // optional double chicken_run_cooldown_minutes = 18 [default = 180];
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(18, this->_internal_chicken_run_cooldown_minutes(), target);
  }

  // optional bool leggacy = 19;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(19, this->_internal_leggacy(), target);
  }

  // repeated .ei.Contract.GradeSpec grade_specs = 20;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_grade_specs_size()); i < n; i++) {
    const auto& repfield = this->_internal_grade_specs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(20, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string key = 21;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.Contract.key");
    target = stream->WriteStringMaybeAliased(
        21, this->_internal_key(), target);
  }

  // optional bool cc_only = 22;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(22, this->_internal_cc_only(), target);
  }

  // optional string season_id = 23;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_season_id().data(), static_cast<int>(this->_internal_season_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.Contract.season_id");
    target = stream->WriteStringMaybeAliased(
        23, this->_internal_season_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.Contract)
  return target;
}

size_t Contract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.Contract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.Contract.Goal goals = 3;
  total_size += 1UL * this->_internal_goals_size();
  for (const auto& msg : this->goals_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.Contract.GoalSet goal_sets = 16;
  total_size += 2UL * this->_internal_goal_sets_size();
  for (const auto& msg : this->goal_sets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.Contract.GradeSpec grade_specs = 20;
  total_size += 2UL * this->_internal_grade_specs_size();
  for (const auto& msg : this->grade_specs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string identifier = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_identifier());
    }

    // optional string name = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string description = 10;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_description());
    }

    // optional string key = 21;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_key());
    }

    // optional string season_id = 23;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_season_id());
    }

    // optional double expiration_time = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional double length_seconds = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional uint32 max_coop_size = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_max_coop_size());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 max_boosts = 12;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_max_boosts());
    }

    // optional double max_soul_eggs = 13;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional uint32 min_client_version = 14;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_min_client_version());
    }

    // optional bool coop_allowed = 4;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool leggacy = 19;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + 1;
    }

    // optional bool cc_only = 22;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 1;
    }

    // optional bool debug = 11;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

    // optional double start_time = 17;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 8;
    }

  }
  if (cached_has_bits & 0x00070000u) {
    // optional .ei.Egg egg = 2;
    if (cached_has_bits & 0x00010000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_egg());
    }

    // optional double minutes_per_token = 15 [default = 60];
    if (cached_has_bits & 0x00020000u) {
      total_size += 1 + 8;
    }

    // optional double chicken_run_cooldown_minutes = 18 [default = 180];
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Contract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Contract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Contract::GetClassData() const { return &_class_data_; }

void Contract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Contract *>(to)->MergeFrom(
      static_cast<const Contract &>(from));
}


void Contract::MergeFrom(const Contract& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.Contract)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  goals_.MergeFrom(from.goals_);
  goal_sets_.MergeFrom(from.goal_sets_);
  grade_specs_.MergeFrom(from.grade_specs_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_identifier(from._internal_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_description(from._internal_description());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_season_id(from._internal_season_id());
    }
    if (cached_has_bits & 0x00000020u) {
      expiration_time_ = from.expiration_time_;
    }
    if (cached_has_bits & 0x00000040u) {
      length_seconds_ = from.length_seconds_;
    }
    if (cached_has_bits & 0x00000080u) {
      max_coop_size_ = from.max_coop_size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      max_boosts_ = from.max_boosts_;
    }
    if (cached_has_bits & 0x00000200u) {
      max_soul_eggs_ = from.max_soul_eggs_;
    }
    if (cached_has_bits & 0x00000400u) {
      min_client_version_ = from.min_client_version_;
    }
    if (cached_has_bits & 0x00000800u) {
      coop_allowed_ = from.coop_allowed_;
    }
    if (cached_has_bits & 0x00001000u) {
      leggacy_ = from.leggacy_;
    }
    if (cached_has_bits & 0x00002000u) {
      cc_only_ = from.cc_only_;
    }
    if (cached_has_bits & 0x00004000u) {
      debug_ = from.debug_;
    }
    if (cached_has_bits & 0x00008000u) {
      start_time_ = from.start_time_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00070000u) {
    if (cached_has_bits & 0x00010000u) {
      egg_ = from.egg_;
    }
    if (cached_has_bits & 0x00020000u) {
      minutes_per_token_ = from.minutes_per_token_;
    }
    if (cached_has_bits & 0x00040000u) {
      chicken_run_cooldown_minutes_ = from.chicken_run_cooldown_minutes_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Contract::CopyFrom(const Contract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.Contract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Contract::IsInitialized() const {
  return true;
}

void Contract::InternalSwap(Contract* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  goals_.InternalSwap(&other->goals_);
  goal_sets_.InternalSwap(&other->goal_sets_);
  grade_specs_.InternalSwap(&other->grade_specs_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &identifier_, lhs_arena,
      &other->identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &description_, lhs_arena,
      &other->description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &key_, lhs_arena,
      &other->key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &season_id_, lhs_arena,
      &other->season_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Contract, start_time_)
      + sizeof(Contract::start_time_)
      - PROTOBUF_FIELD_OFFSET(Contract, expiration_time_)>(
          reinterpret_cast<char*>(&expiration_time_),
          reinterpret_cast<char*>(&other->expiration_time_));
  swap(egg_, other->egg_);
  swap(minutes_per_token_, other->minutes_per_token_);
  swap(chicken_run_cooldown_minutes_, other->chicken_run_cooldown_minutes_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Contract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[39]);
}

// ===================================================================

class ContractPlayerInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ContractPlayerInfo>()._has_bits_);
  static void set_has_grade(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_total_cxp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_season_cxp(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_grade_score(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_target_grade_score(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_soul_power(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_target_soul_power(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_grade_progress(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_issue_score(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_last_evaluation_time(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_last_evaluation_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ContractPlayerInfo::ContractPlayerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  unread_evaluations_(arena),
  issues_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ContractPlayerInfo)
}
ContractPlayerInfo::ContractPlayerInfo(const ContractPlayerInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      unread_evaluations_(from.unread_evaluations_),
      issues_(from.issues_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  last_evaluation_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    last_evaluation_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_last_evaluation_version()) {
    last_evaluation_version_.Set(from._internal_last_evaluation_version(), 
      GetArenaForAllocation());
  }
  ::memcpy(&total_cxp_, &from.total_cxp_,
    static_cast<size_t>(reinterpret_cast<char*>(&issue_score_) -
    reinterpret_cast<char*>(&total_cxp_)) + sizeof(issue_score_));
  // @@protoc_insertion_point(copy_constructor:ei.ContractPlayerInfo)
}

inline void ContractPlayerInfo::SharedCtor() {
last_evaluation_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  last_evaluation_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&total_cxp_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&issue_score_) -
    reinterpret_cast<char*>(&total_cxp_)) + sizeof(issue_score_));
}

ContractPlayerInfo::~ContractPlayerInfo() {
  // @@protoc_insertion_point(destructor:ei.ContractPlayerInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContractPlayerInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  last_evaluation_version_.Destroy();
}

void ContractPlayerInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContractPlayerInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ContractPlayerInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  unread_evaluations_.Clear();
  issues_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    last_evaluation_version_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&total_cxp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&target_grade_score_) -
        reinterpret_cast<char*>(&total_cxp_)) + sizeof(target_grade_score_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&soul_power_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&issue_score_) -
        reinterpret_cast<char*>(&soul_power_)) + sizeof(issue_score_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContractPlayerInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.Contract.PlayerGrade grade = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::Contract_PlayerGrade_IsValid(val))) {
            _internal_set_grade(static_cast<::ei::Contract_PlayerGrade>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional double total_cxp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_total_cxp(&has_bits);
          total_cxp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.ContractPlayerInfo.Status status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::ContractPlayerInfo_Status_IsValid(val))) {
            _internal_set_status(static_cast<::ei::ContractPlayerInfo_Status>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional double last_evaluation_time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_last_evaluation_time(&has_bits);
          last_evaluation_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional string last_evaluation_version = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_last_evaluation_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractPlayerInfo.last_evaluation_version");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ContractEvaluation unread_evaluations = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_unread_evaluations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional double grade_score = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _Internal::set_has_grade_score(&has_bits);
          grade_score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double target_soul_power = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _Internal::set_has_target_soul_power(&has_bits);
          target_soul_power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double target_grade_score = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          _Internal::set_has_target_grade_score(&has_bits);
          target_grade_score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double soul_power = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _Internal::set_has_soul_power(&has_bits);
          soul_power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ContractEvaluation.PoorBehavior issues = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::ei::ContractEvaluation_PoorBehavior_IsValid(val))) {
              _internal_add_issues(static_cast<::ei::ContractEvaluation_PoorBehavior>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(11, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<88>(ptr));
        } else if (static_cast<uint8_t>(tag) == 90) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(_internal_mutable_issues(), ptr, ctx, ::ei::ContractEvaluation_PoorBehavior_IsValid, &_internal_metadata_, 11);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double grade_progress = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 97)) {
          _Internal::set_has_grade_progress(&has_bits);
          grade_progress_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double season_cxp = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 105)) {
          _Internal::set_has_season_cxp(&has_bits);
          season_cxp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double issue_score = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 113)) {
          _Internal::set_has_issue_score(&has_bits);
          issue_score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContractPlayerInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ContractPlayerInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.Contract.PlayerGrade grade = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_grade(), target);
  }

  // optional double total_cxp = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_total_cxp(), target);
  }

  // optional .ei.ContractPlayerInfo.Status status = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_status(), target);
  }

  // optional double last_evaluation_time = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_last_evaluation_time(), target);
  }

  // optional string last_evaluation_version = 5;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_last_evaluation_version().data(), static_cast<int>(this->_internal_last_evaluation_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractPlayerInfo.last_evaluation_version");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_last_evaluation_version(), target);
  }

  // repeated .ei.ContractEvaluation unread_evaluations = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_unread_evaluations_size()); i < n; i++) {
    const auto& repfield = this->_internal_unread_evaluations(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional double grade_score = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_grade_score(), target);
  }

  // optional double target_soul_power = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_target_soul_power(), target);
  }

  // optional double target_grade_score = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(9, this->_internal_target_grade_score(), target);
  }

  // optional double soul_power = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(10, this->_internal_soul_power(), target);
  }

  // repeated .ei.ContractEvaluation.PoorBehavior issues = 11;
  for (int i = 0, n = this->_internal_issues_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        11, this->_internal_issues(i), target);
  }

  // optional double grade_progress = 12;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(12, this->_internal_grade_progress(), target);
  }

  // optional double season_cxp = 13;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(13, this->_internal_season_cxp(), target);
  }

  // optional double issue_score = 14;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(14, this->_internal_issue_score(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ContractPlayerInfo)
  return target;
}

size_t ContractPlayerInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ContractPlayerInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.ContractEvaluation unread_evaluations = 6;
  total_size += 1UL * this->_internal_unread_evaluations_size();
  for (const auto& msg : this->unread_evaluations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.ContractEvaluation.PoorBehavior issues = 11;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_issues_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_issues(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string last_evaluation_version = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_last_evaluation_version());
    }

    // optional double total_cxp = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional .ei.Contract.PlayerGrade grade = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_grade());
    }

    // optional .ei.ContractPlayerInfo.Status status = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
    }

    // optional double last_evaluation_time = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double grade_score = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional double target_soul_power = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional double target_grade_score = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional double soul_power = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 8;
    }

    // optional double grade_progress = 12;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional double season_cxp = 13;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 8;
    }

    // optional double issue_score = 14;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContractPlayerInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ContractPlayerInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContractPlayerInfo::GetClassData() const { return &_class_data_; }

void ContractPlayerInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ContractPlayerInfo *>(to)->MergeFrom(
      static_cast<const ContractPlayerInfo &>(from));
}


void ContractPlayerInfo::MergeFrom(const ContractPlayerInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ContractPlayerInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  unread_evaluations_.MergeFrom(from.unread_evaluations_);
  issues_.MergeFrom(from.issues_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_last_evaluation_version(from._internal_last_evaluation_version());
    }
    if (cached_has_bits & 0x00000002u) {
      total_cxp_ = from.total_cxp_;
    }
    if (cached_has_bits & 0x00000004u) {
      grade_ = from.grade_;
    }
    if (cached_has_bits & 0x00000008u) {
      status_ = from.status_;
    }
    if (cached_has_bits & 0x00000010u) {
      last_evaluation_time_ = from.last_evaluation_time_;
    }
    if (cached_has_bits & 0x00000020u) {
      grade_score_ = from.grade_score_;
    }
    if (cached_has_bits & 0x00000040u) {
      target_soul_power_ = from.target_soul_power_;
    }
    if (cached_has_bits & 0x00000080u) {
      target_grade_score_ = from.target_grade_score_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      soul_power_ = from.soul_power_;
    }
    if (cached_has_bits & 0x00000200u) {
      grade_progress_ = from.grade_progress_;
    }
    if (cached_has_bits & 0x00000400u) {
      season_cxp_ = from.season_cxp_;
    }
    if (cached_has_bits & 0x00000800u) {
      issue_score_ = from.issue_score_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContractPlayerInfo::CopyFrom(const ContractPlayerInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ContractPlayerInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContractPlayerInfo::IsInitialized() const {
  return true;
}

void ContractPlayerInfo::InternalSwap(ContractPlayerInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  unread_evaluations_.InternalSwap(&other->unread_evaluations_);
  issues_.InternalSwap(&other->issues_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &last_evaluation_version_, lhs_arena,
      &other->last_evaluation_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContractPlayerInfo, issue_score_)
      + sizeof(ContractPlayerInfo::issue_score_)
      - PROTOBUF_FIELD_OFFSET(ContractPlayerInfo, total_cxp_)>(
          reinterpret_cast<char*>(&total_cxp_),
          reinterpret_cast<char*>(&other->total_cxp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ContractPlayerInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[40]);
}

// ===================================================================

class ContractEvaluation::_Internal {
 public:
  using HasBits = decltype(std::declval<ContractEvaluation>()._has_bits_);
  static void set_has_contract_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_coop_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_cxp(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_replay(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_cxp_change(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_grade_performance(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_old_league(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_old_goals(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_grade(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_contribution_ratio(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_completion_percent(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_original_length(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_coop_size(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_solo(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_soul_power(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_last_contribution_time(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_completion_time(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_chicken_runs_sent(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_gift_tokens_sent(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_gift_tokens_received(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_boost_token_allotment(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_buff_time_value(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_teamwork_score(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_other_bonuses(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_counted_in_season(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_season_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_time_cheats(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_evaluation_start_time(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
};

ContractEvaluation::ContractEvaluation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  notes_(arena),
  issues_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ContractEvaluation)
}
ContractEvaluation::ContractEvaluation(const ContractEvaluation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      notes_(from.notes_),
      issues_(from.issues_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  season_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    season_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_season_id()) {
    season_id_.Set(from._internal_season_id(), 
      GetArenaForAllocation());
  }
  contract_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    contract_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contract_identifier()) {
    contract_identifier_.Set(from._internal_contract_identifier(), 
      GetArenaForAllocation());
  }
  coop_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    coop_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_coop_identifier()) {
    coop_identifier_.Set(from._internal_coop_identifier(), 
      GetArenaForAllocation());
  }
  version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_version()) {
    version_.Set(from._internal_version(), 
      GetArenaForAllocation());
  }
  ::memcpy(&cxp_, &from.cxp_,
    static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&cxp_)) + sizeof(status_));
  // @@protoc_insertion_point(copy_constructor:ei.ContractEvaluation)
}

inline void ContractEvaluation::SharedCtor() {
season_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  season_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
contract_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  contract_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
coop_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  coop_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&cxp_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&cxp_)) + sizeof(status_));
}

ContractEvaluation::~ContractEvaluation() {
  // @@protoc_insertion_point(destructor:ei.ContractEvaluation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContractEvaluation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  season_id_.Destroy();
  contract_identifier_.Destroy();
  coop_identifier_.Destroy();
  version_.Destroy();
}

void ContractEvaluation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContractEvaluation::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ContractEvaluation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  notes_.Clear();
  issues_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      season_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      contract_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      coop_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      version_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&cxp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&contribution_ratio_) -
        reinterpret_cast<char*>(&cxp_)) + sizeof(contribution_ratio_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&completion_percent_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&teamwork_score_) -
        reinterpret_cast<char*>(&completion_percent_)) + sizeof(teamwork_score_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&other_bonuses_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&counted_in_season_) -
        reinterpret_cast<char*>(&other_bonuses_)) + sizeof(counted_in_season_));
  }
  if (cached_has_bits & 0x3f000000u) {
    ::memset(&time_cheats_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&status_) -
        reinterpret_cast<char*>(&time_cheats_)) + sizeof(status_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContractEvaluation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double cxp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_cxp(&has_bits);
          cxp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int32 grade_performance = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_grade_performance(&has_bits);
          grade_performance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.Contract.PlayerGrade grade = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::Contract_PlayerGrade_IsValid(val))) {
            _internal_set_grade(static_cast<::ei::Contract_PlayerGrade>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional double contribution_ratio = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_contribution_ratio(&has_bits);
          contribution_ratio_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double completion_percent = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_completion_percent(&has_bits);
          completion_percent_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double completion_time = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_completion_time(&has_bits);
          completion_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 chicken_runs_sent = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_chicken_runs_sent(&has_bits);
          chicken_runs_sent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gift_tokens_sent = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_gift_tokens_sent(&has_bits);
          gift_tokens_sent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 old_league = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_old_league(&has_bits);
          old_league_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool old_goals = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_old_goals(&has_bits);
          old_goals_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double original_length = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _Internal::set_has_original_length(&has_bits);
          original_length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated string notes = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_notes();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "ei.ContractEvaluation.notes");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional double teamwork_score = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 105)) {
          _Internal::set_has_teamwork_score(&has_bits);
          teamwork_score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double other_bonuses = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 113)) {
          _Internal::set_has_other_bonuses(&has_bits);
          other_bonuses_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gift_tokens_received = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_gift_tokens_received(&has_bits);
          gift_tokens_received_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 boost_token_allotment = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_boost_token_allotment(&has_bits);
          boost_token_allotment_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double buff_time_value = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 137)) {
          _Internal::set_has_buff_time_value(&has_bits);
          buff_time_value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 coop_size = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_coop_size(&has_bits);
          coop_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ContractEvaluation.PoorBehavior issues = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          ptr -= 2;
          do {
            ptr += 2;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::ei::ContractEvaluation_PoorBehavior_IsValid(val))) {
              _internal_add_issues(static_cast<::ei::ContractEvaluation_PoorBehavior>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(19, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<152>(ptr));
        } else if (static_cast<uint8_t>(tag) == 154) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(_internal_mutable_issues(), ptr, ctx, ::ei::ContractEvaluation_PoorBehavior_IsValid, &_internal_metadata_, 19);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool counted_in_season = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_counted_in_season(&has_bits);
          counted_in_season_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string season_id = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          auto str = _internal_mutable_season_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractEvaluation.season_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double last_contribution_time = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 177)) {
          _Internal::set_has_last_contribution_time(&has_bits);
          last_contribution_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double soul_power = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 185)) {
          _Internal::set_has_soul_power(&has_bits);
          soul_power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool replay = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_replay(&has_bits);
          replay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double cxp_change = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 201)) {
          _Internal::set_has_cxp_change(&has_bits);
          cxp_change_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool solo = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_solo(&has_bits);
          solo_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 time_cheats = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_time_cheats(&has_bits);
          time_cheats_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string contract_identifier = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_contract_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractEvaluation.contract_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string coop_identifier = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_coop_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractEvaluation.coop_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string version = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractEvaluation.version");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double evaluation_start_time = 51;
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 153)) {
          _Internal::set_has_evaluation_start_time(&has_bits);
          evaluation_start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.ContractEvaluation.Status status = 52;
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::ContractEvaluation_Status_IsValid(val))) {
            _internal_set_status(static_cast<::ei::ContractEvaluation_Status>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(52, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContractEvaluation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ContractEvaluation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double cxp = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_cxp(), target);
  }

  // optional int32 grade_performance = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_grade_performance(), target);
  }

  // optional .ei.Contract.PlayerGrade grade = 3;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_grade(), target);
  }

  // optional double contribution_ratio = 4;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_contribution_ratio(), target);
  }

  // optional double completion_percent = 5;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_completion_percent(), target);
  }

  // optional double completion_time = 6;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_completion_time(), target);
  }

  // optional uint32 chicken_runs_sent = 7;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_chicken_runs_sent(), target);
  }

  // optional uint32 gift_tokens_sent = 8;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_gift_tokens_sent(), target);
  }

  // optional int32 old_league = 9;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_old_league(), target);
  }

  // optional bool old_goals = 10;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_old_goals(), target);
  }

  // optional double original_length = 11;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(11, this->_internal_original_length(), target);
  }

  // repeated string notes = 12;
  for (int i = 0, n = this->_internal_notes_size(); i < n; i++) {
    const auto& s = this->_internal_notes(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractEvaluation.notes");
    target = stream->WriteString(12, s, target);
  }

  // optional double teamwork_score = 13;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(13, this->_internal_teamwork_score(), target);
  }

  // optional double other_bonuses = 14;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(14, this->_internal_other_bonuses(), target);
  }

  // optional uint32 gift_tokens_received = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_gift_tokens_received(), target);
  }

  // optional uint32 boost_token_allotment = 16;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_boost_token_allotment(), target);
  }

  // optional double buff_time_value = 17;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(17, this->_internal_buff_time_value(), target);
  }

  // optional uint32 coop_size = 18;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(18, this->_internal_coop_size(), target);
  }

  // repeated .ei.ContractEvaluation.PoorBehavior issues = 19;
  for (int i = 0, n = this->_internal_issues_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        19, this->_internal_issues(i), target);
  }

  // optional bool counted_in_season = 20;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(20, this->_internal_counted_in_season(), target);
  }

  // optional string season_id = 21;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_season_id().data(), static_cast<int>(this->_internal_season_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractEvaluation.season_id");
    target = stream->WriteStringMaybeAliased(
        21, this->_internal_season_id(), target);
  }

  // optional double last_contribution_time = 22;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(22, this->_internal_last_contribution_time(), target);
  }

  // optional double soul_power = 23;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(23, this->_internal_soul_power(), target);
  }

  // optional bool replay = 24;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(24, this->_internal_replay(), target);
  }

  // optional double cxp_change = 25;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(25, this->_internal_cxp_change(), target);
  }

  // optional bool solo = 26;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(26, this->_internal_solo(), target);
  }

  // optional uint32 time_cheats = 27;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(27, this->_internal_time_cheats(), target);
  }

  // optional string contract_identifier = 40;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_contract_identifier().data(), static_cast<int>(this->_internal_contract_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractEvaluation.contract_identifier");
    target = stream->WriteStringMaybeAliased(
        40, this->_internal_contract_identifier(), target);
  }

  // optional string coop_identifier = 41;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_coop_identifier().data(), static_cast<int>(this->_internal_coop_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractEvaluation.coop_identifier");
    target = stream->WriteStringMaybeAliased(
        41, this->_internal_coop_identifier(), target);
  }

  // optional string version = 50;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_version().data(), static_cast<int>(this->_internal_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractEvaluation.version");
    target = stream->WriteStringMaybeAliased(
        50, this->_internal_version(), target);
  }

  // optional double evaluation_start_time = 51;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(51, this->_internal_evaluation_start_time(), target);
  }

  // optional .ei.ContractEvaluation.Status status = 52;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      52, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ContractEvaluation)
  return target;
}

size_t ContractEvaluation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ContractEvaluation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string notes = 12;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(notes_.size());
  for (int i = 0, n = notes_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      notes_.Get(i));
  }

  // repeated .ei.ContractEvaluation.PoorBehavior issues = 19;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_issues_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_issues(static_cast<int>(i)));
    }
    total_size += (2UL * count) + data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string season_id = 21;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_season_id());
    }

    // optional string contract_identifier = 40;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contract_identifier());
    }

    // optional string coop_identifier = 41;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_coop_identifier());
    }

    // optional string version = 50;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_version());
    }

    // optional double cxp = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional int32 grade_performance = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_grade_performance());
    }

    // optional .ei.Contract.PlayerGrade grade = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_grade());
    }

    // optional double contribution_ratio = 4;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional double completion_percent = 5;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 8;
    }

    // optional double completion_time = 6;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional uint32 chicken_runs_sent = 7;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_chicken_runs_sent());
    }

    // optional uint32 gift_tokens_sent = 8;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gift_tokens_sent());
    }

    // optional double original_length = 11;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 8;
    }

    // optional int32 old_league = 9;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_old_league());
    }

    // optional uint32 gift_tokens_received = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gift_tokens_received());
    }

    // optional double teamwork_score = 13;
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional double other_bonuses = 14;
    if (cached_has_bits & 0x00010000u) {
      total_size += 1 + 8;
    }

    // optional double buff_time_value = 17;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 8;
    }

    // optional uint32 boost_token_allotment = 16;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_boost_token_allotment());
    }

    // optional uint32 coop_size = 18;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_coop_size());
    }

    // optional bool replay = 24;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 1;
    }

    // optional bool old_goals = 10;
    if (cached_has_bits & 0x00200000u) {
      total_size += 1 + 1;
    }

    // optional bool solo = 26;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 1;
    }

    // optional bool counted_in_season = 20;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x3f000000u) {
    // optional uint32 time_cheats = 27;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_time_cheats());
    }

    // optional double last_contribution_time = 22;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + 8;
    }

    // optional double soul_power = 23;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 + 8;
    }

    // optional double cxp_change = 25;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 + 8;
    }

    // optional double evaluation_start_time = 51;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 + 8;
    }

    // optional .ei.ContractEvaluation.Status status = 52;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContractEvaluation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ContractEvaluation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContractEvaluation::GetClassData() const { return &_class_data_; }

void ContractEvaluation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ContractEvaluation *>(to)->MergeFrom(
      static_cast<const ContractEvaluation &>(from));
}


void ContractEvaluation::MergeFrom(const ContractEvaluation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ContractEvaluation)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  notes_.MergeFrom(from.notes_);
  issues_.MergeFrom(from.issues_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_season_id(from._internal_season_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_contract_identifier(from._internal_contract_identifier());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_coop_identifier(from._internal_coop_identifier());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_version(from._internal_version());
    }
    if (cached_has_bits & 0x00000010u) {
      cxp_ = from.cxp_;
    }
    if (cached_has_bits & 0x00000020u) {
      grade_performance_ = from.grade_performance_;
    }
    if (cached_has_bits & 0x00000040u) {
      grade_ = from.grade_;
    }
    if (cached_has_bits & 0x00000080u) {
      contribution_ratio_ = from.contribution_ratio_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      completion_percent_ = from.completion_percent_;
    }
    if (cached_has_bits & 0x00000200u) {
      completion_time_ = from.completion_time_;
    }
    if (cached_has_bits & 0x00000400u) {
      chicken_runs_sent_ = from.chicken_runs_sent_;
    }
    if (cached_has_bits & 0x00000800u) {
      gift_tokens_sent_ = from.gift_tokens_sent_;
    }
    if (cached_has_bits & 0x00001000u) {
      original_length_ = from.original_length_;
    }
    if (cached_has_bits & 0x00002000u) {
      old_league_ = from.old_league_;
    }
    if (cached_has_bits & 0x00004000u) {
      gift_tokens_received_ = from.gift_tokens_received_;
    }
    if (cached_has_bits & 0x00008000u) {
      teamwork_score_ = from.teamwork_score_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      other_bonuses_ = from.other_bonuses_;
    }
    if (cached_has_bits & 0x00020000u) {
      buff_time_value_ = from.buff_time_value_;
    }
    if (cached_has_bits & 0x00040000u) {
      boost_token_allotment_ = from.boost_token_allotment_;
    }
    if (cached_has_bits & 0x00080000u) {
      coop_size_ = from.coop_size_;
    }
    if (cached_has_bits & 0x00100000u) {
      replay_ = from.replay_;
    }
    if (cached_has_bits & 0x00200000u) {
      old_goals_ = from.old_goals_;
    }
    if (cached_has_bits & 0x00400000u) {
      solo_ = from.solo_;
    }
    if (cached_has_bits & 0x00800000u) {
      counted_in_season_ = from.counted_in_season_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x3f000000u) {
    if (cached_has_bits & 0x01000000u) {
      time_cheats_ = from.time_cheats_;
    }
    if (cached_has_bits & 0x02000000u) {
      last_contribution_time_ = from.last_contribution_time_;
    }
    if (cached_has_bits & 0x04000000u) {
      soul_power_ = from.soul_power_;
    }
    if (cached_has_bits & 0x08000000u) {
      cxp_change_ = from.cxp_change_;
    }
    if (cached_has_bits & 0x10000000u) {
      evaluation_start_time_ = from.evaluation_start_time_;
    }
    if (cached_has_bits & 0x20000000u) {
      status_ = from.status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContractEvaluation::CopyFrom(const ContractEvaluation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ContractEvaluation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContractEvaluation::IsInitialized() const {
  return true;
}

void ContractEvaluation::InternalSwap(ContractEvaluation* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  notes_.InternalSwap(&other->notes_);
  issues_.InternalSwap(&other->issues_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &season_id_, lhs_arena,
      &other->season_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &contract_identifier_, lhs_arena,
      &other->contract_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &coop_identifier_, lhs_arena,
      &other->coop_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &version_, lhs_arena,
      &other->version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContractEvaluation, status_)
      + sizeof(ContractEvaluation::status_)
      - PROTOBUF_FIELD_OFFSET(ContractEvaluation, cxp_)>(
          reinterpret_cast<char*>(&cxp_),
          reinterpret_cast<char*>(&other->cxp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ContractEvaluation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[41]);
}

// ===================================================================

class ContractCitation::_Internal {
 public:
  using HasBits = decltype(std::declval<ContractCitation>()._has_bits_);
  static void set_has_issue(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_grade(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ContractCitation::ContractCitation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ContractCitation)
}
ContractCitation::ContractCitation(const ContractCitation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&timestamp_, &from.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&grade_) -
    reinterpret_cast<char*>(&timestamp_)) + sizeof(grade_));
  // @@protoc_insertion_point(copy_constructor:ei.ContractCitation)
}

inline void ContractCitation::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&grade_) -
    reinterpret_cast<char*>(&timestamp_)) + sizeof(grade_));
}

ContractCitation::~ContractCitation() {
  // @@protoc_insertion_point(destructor:ei.ContractCitation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContractCitation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ContractCitation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContractCitation::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ContractCitation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&grade_) -
        reinterpret_cast<char*>(&timestamp_)) + sizeof(grade_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContractCitation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.ContractEvaluation.PoorBehavior issue = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::ContractEvaluation_PoorBehavior_IsValid(val))) {
            _internal_set_issue(static_cast<::ei::ContractEvaluation_PoorBehavior>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional double timestamp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_timestamp(&has_bits);
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.Contract.PlayerGrade grade = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::Contract_PlayerGrade_IsValid(val))) {
            _internal_set_grade(static_cast<::ei::Contract_PlayerGrade>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContractCitation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ContractCitation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.ContractEvaluation.PoorBehavior issue = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_issue(), target);
  }

  // optional double timestamp = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_timestamp(), target);
  }

  // optional .ei.Contract.PlayerGrade grade = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_grade(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ContractCitation)
  return target;
}

size_t ContractCitation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ContractCitation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double timestamp = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional .ei.ContractEvaluation.PoorBehavior issue = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_issue());
    }

    // optional .ei.Contract.PlayerGrade grade = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_grade());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContractCitation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ContractCitation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContractCitation::GetClassData() const { return &_class_data_; }

void ContractCitation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ContractCitation *>(to)->MergeFrom(
      static_cast<const ContractCitation &>(from));
}


void ContractCitation::MergeFrom(const ContractCitation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ContractCitation)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ = from.timestamp_;
    }
    if (cached_has_bits & 0x00000002u) {
      issue_ = from.issue_;
    }
    if (cached_has_bits & 0x00000004u) {
      grade_ = from.grade_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContractCitation::CopyFrom(const ContractCitation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ContractCitation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContractCitation::IsInitialized() const {
  return true;
}

void ContractCitation::InternalSwap(ContractCitation* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContractCitation, grade_)
      + sizeof(ContractCitation::grade_)
      - PROTOBUF_FIELD_OFFSET(ContractCitation, timestamp_)>(
          reinterpret_cast<char*>(&timestamp_),
          reinterpret_cast<char*>(&other->timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ContractCitation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[42]);
}

// ===================================================================

class ContractEvaluationBatch_Pair::_Internal {
 public:
  using HasBits = decltype(std::declval<ContractEvaluationBatch_Pair>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ei::ContractEvaluation& cev(const ContractEvaluationBatch_Pair* msg);
  static void set_has_cev(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::ei::ContractEvaluation&
ContractEvaluationBatch_Pair::_Internal::cev(const ContractEvaluationBatch_Pair* msg) {
  return *msg->cev_;
}
ContractEvaluationBatch_Pair::ContractEvaluationBatch_Pair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ContractEvaluationBatch.Pair)
}
ContractEvaluationBatch_Pair::ContractEvaluationBatch_Pair(const ContractEvaluationBatch_Pair& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_id()) {
    user_id_.Set(from._internal_user_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_cev()) {
    cev_ = new ::ei::ContractEvaluation(*from.cev_);
  } else {
    cev_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:ei.ContractEvaluationBatch.Pair)
}

inline void ContractEvaluationBatch_Pair::SharedCtor() {
user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
cev_ = nullptr;
}

ContractEvaluationBatch_Pair::~ContractEvaluationBatch_Pair() {
  // @@protoc_insertion_point(destructor:ei.ContractEvaluationBatch.Pair)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContractEvaluationBatch_Pair::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_id_.Destroy();
  if (this != internal_default_instance()) delete cev_;
}

void ContractEvaluationBatch_Pair::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContractEvaluationBatch_Pair::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ContractEvaluationBatch.Pair)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(cev_ != nullptr);
      cev_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContractEvaluationBatch_Pair::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractEvaluationBatch.Pair.user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .ei.ContractEvaluation cev = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_cev(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContractEvaluationBatch_Pair::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ContractEvaluationBatch.Pair)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractEvaluationBatch.Pair.user_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_id(), target);
  }

  // optional .ei.ContractEvaluation cev = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::cev(this),
        _Internal::cev(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ContractEvaluationBatch.Pair)
  return target;
}

size_t ContractEvaluationBatch_Pair::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ContractEvaluationBatch.Pair)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string user_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_id());
    }

    // optional .ei.ContractEvaluation cev = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *cev_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContractEvaluationBatch_Pair::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ContractEvaluationBatch_Pair::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContractEvaluationBatch_Pair::GetClassData() const { return &_class_data_; }

void ContractEvaluationBatch_Pair::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ContractEvaluationBatch_Pair *>(to)->MergeFrom(
      static_cast<const ContractEvaluationBatch_Pair &>(from));
}


void ContractEvaluationBatch_Pair::MergeFrom(const ContractEvaluationBatch_Pair& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ContractEvaluationBatch.Pair)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_id(from._internal_user_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_cev()->::ei::ContractEvaluation::MergeFrom(from._internal_cev());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContractEvaluationBatch_Pair::CopyFrom(const ContractEvaluationBatch_Pair& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ContractEvaluationBatch.Pair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContractEvaluationBatch_Pair::IsInitialized() const {
  return true;
}

void ContractEvaluationBatch_Pair::InternalSwap(ContractEvaluationBatch_Pair* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  swap(cev_, other->cev_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ContractEvaluationBatch_Pair::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[43]);
}

// ===================================================================

class ContractEvaluationBatch::_Internal {
 public:
};

ContractEvaluationBatch::ContractEvaluationBatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  evals_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ContractEvaluationBatch)
}
ContractEvaluationBatch::ContractEvaluationBatch(const ContractEvaluationBatch& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      evals_(from.evals_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ei.ContractEvaluationBatch)
}

inline void ContractEvaluationBatch::SharedCtor() {
}

ContractEvaluationBatch::~ContractEvaluationBatch() {
  // @@protoc_insertion_point(destructor:ei.ContractEvaluationBatch)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContractEvaluationBatch::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ContractEvaluationBatch::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContractEvaluationBatch::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ContractEvaluationBatch)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  evals_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContractEvaluationBatch::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .ei.ContractEvaluationBatch.Pair evals = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_evals(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContractEvaluationBatch::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ContractEvaluationBatch)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ei.ContractEvaluationBatch.Pair evals = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_evals_size()); i < n; i++) {
    const auto& repfield = this->_internal_evals(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ContractEvaluationBatch)
  return target;
}

size_t ContractEvaluationBatch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ContractEvaluationBatch)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.ContractEvaluationBatch.Pair evals = 1;
  total_size += 1UL * this->_internal_evals_size();
  for (const auto& msg : this->evals_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContractEvaluationBatch::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ContractEvaluationBatch::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContractEvaluationBatch::GetClassData() const { return &_class_data_; }

void ContractEvaluationBatch::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ContractEvaluationBatch *>(to)->MergeFrom(
      static_cast<const ContractEvaluationBatch &>(from));
}


void ContractEvaluationBatch::MergeFrom(const ContractEvaluationBatch& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ContractEvaluationBatch)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  evals_.MergeFrom(from.evals_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContractEvaluationBatch::CopyFrom(const ContractEvaluationBatch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ContractEvaluationBatch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContractEvaluationBatch::IsInitialized() const {
  return true;
}

void ContractEvaluationBatch::InternalSwap(ContractEvaluationBatch* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  evals_.InternalSwap(&other->evals_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ContractEvaluationBatch::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[44]);
}

// ===================================================================

class CoopCompletionSnapshot_ContributorSnapshot::_Internal {
 public:
  using HasBits = decltype(std::declval<CoopCompletionSnapshot_ContributorSnapshot>()._has_bits_);
  static void set_has_contribution(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_last_contribution_time(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_soul_power(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tokens(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_tokens_spent(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CoopCompletionSnapshot_ContributorSnapshot::CoopCompletionSnapshot_ContributorSnapshot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.CoopCompletionSnapshot.ContributorSnapshot)
}
CoopCompletionSnapshot_ContributorSnapshot::CoopCompletionSnapshot_ContributorSnapshot(const CoopCompletionSnapshot_ContributorSnapshot& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_id()) {
    user_id_.Set(from._internal_user_id(), 
      GetArenaForAllocation());
  }
  ::memcpy(&contribution_, &from.contribution_,
    static_cast<size_t>(reinterpret_cast<char*>(&last_contribution_time_) -
    reinterpret_cast<char*>(&contribution_)) + sizeof(last_contribution_time_));
  // @@protoc_insertion_point(copy_constructor:ei.CoopCompletionSnapshot.ContributorSnapshot)
}

inline void CoopCompletionSnapshot_ContributorSnapshot::SharedCtor() {
user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&contribution_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&last_contribution_time_) -
    reinterpret_cast<char*>(&contribution_)) + sizeof(last_contribution_time_));
}

CoopCompletionSnapshot_ContributorSnapshot::~CoopCompletionSnapshot_ContributorSnapshot() {
  // @@protoc_insertion_point(destructor:ei.CoopCompletionSnapshot.ContributorSnapshot)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CoopCompletionSnapshot_ContributorSnapshot::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_id_.Destroy();
}

void CoopCompletionSnapshot_ContributorSnapshot::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CoopCompletionSnapshot_ContributorSnapshot::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.CoopCompletionSnapshot.ContributorSnapshot)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    user_id_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&contribution_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&last_contribution_time_) -
        reinterpret_cast<char*>(&contribution_)) + sizeof(last_contribution_time_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CoopCompletionSnapshot_ContributorSnapshot::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double contribution = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_contribution(&has_bits);
          contribution_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double soul_power = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_soul_power(&has_bits);
          soul_power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional string user_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.CoopCompletionSnapshot.ContributorSnapshot.user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tokens = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_tokens(&has_bits);
          tokens_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tokens_spent = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_tokens_spent(&has_bits);
          tokens_spent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double last_contribution_time = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_last_contribution_time(&has_bits);
          last_contribution_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CoopCompletionSnapshot_ContributorSnapshot::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.CoopCompletionSnapshot.ContributorSnapshot)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double contribution = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_contribution(), target);
  }

  // optional double soul_power = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_soul_power(), target);
  }

  // optional string user_id = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.CoopCompletionSnapshot.ContributorSnapshot.user_id");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_user_id(), target);
  }

  // optional uint32 tokens = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_tokens(), target);
  }

  // optional uint32 tokens_spent = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_tokens_spent(), target);
  }

  // optional double last_contribution_time = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_last_contribution_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.CoopCompletionSnapshot.ContributorSnapshot)
  return target;
}

size_t CoopCompletionSnapshot_ContributorSnapshot::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.CoopCompletionSnapshot.ContributorSnapshot)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string user_id = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_id());
    }

    // optional double contribution = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double soul_power = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional uint32 tokens = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tokens());
    }

    // optional uint32 tokens_spent = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tokens_spent());
    }

    // optional double last_contribution_time = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CoopCompletionSnapshot_ContributorSnapshot::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CoopCompletionSnapshot_ContributorSnapshot::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CoopCompletionSnapshot_ContributorSnapshot::GetClassData() const { return &_class_data_; }

void CoopCompletionSnapshot_ContributorSnapshot::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CoopCompletionSnapshot_ContributorSnapshot *>(to)->MergeFrom(
      static_cast<const CoopCompletionSnapshot_ContributorSnapshot &>(from));
}


void CoopCompletionSnapshot_ContributorSnapshot::MergeFrom(const CoopCompletionSnapshot_ContributorSnapshot& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.CoopCompletionSnapshot.ContributorSnapshot)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_id(from._internal_user_id());
    }
    if (cached_has_bits & 0x00000002u) {
      contribution_ = from.contribution_;
    }
    if (cached_has_bits & 0x00000004u) {
      soul_power_ = from.soul_power_;
    }
    if (cached_has_bits & 0x00000008u) {
      tokens_ = from.tokens_;
    }
    if (cached_has_bits & 0x00000010u) {
      tokens_spent_ = from.tokens_spent_;
    }
    if (cached_has_bits & 0x00000020u) {
      last_contribution_time_ = from.last_contribution_time_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CoopCompletionSnapshot_ContributorSnapshot::CopyFrom(const CoopCompletionSnapshot_ContributorSnapshot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.CoopCompletionSnapshot.ContributorSnapshot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CoopCompletionSnapshot_ContributorSnapshot::IsInitialized() const {
  return true;
}

void CoopCompletionSnapshot_ContributorSnapshot::InternalSwap(CoopCompletionSnapshot_ContributorSnapshot* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CoopCompletionSnapshot_ContributorSnapshot, last_contribution_time_)
      + sizeof(CoopCompletionSnapshot_ContributorSnapshot::last_contribution_time_)
      - PROTOBUF_FIELD_OFFSET(CoopCompletionSnapshot_ContributorSnapshot, contribution_)>(
          reinterpret_cast<char*>(&contribution_),
          reinterpret_cast<char*>(&other->contribution_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CoopCompletionSnapshot_ContributorSnapshot::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[45]);
}

// ===================================================================

class CoopCompletionSnapshot::_Internal {
 public:
};

CoopCompletionSnapshot::CoopCompletionSnapshot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  contributors_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.CoopCompletionSnapshot)
}
CoopCompletionSnapshot::CoopCompletionSnapshot(const CoopCompletionSnapshot& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      contributors_(from.contributors_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ei.CoopCompletionSnapshot)
}

inline void CoopCompletionSnapshot::SharedCtor() {
}

CoopCompletionSnapshot::~CoopCompletionSnapshot() {
  // @@protoc_insertion_point(destructor:ei.CoopCompletionSnapshot)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CoopCompletionSnapshot::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CoopCompletionSnapshot::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CoopCompletionSnapshot::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.CoopCompletionSnapshot)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  contributors_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CoopCompletionSnapshot::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .ei.CoopCompletionSnapshot.ContributorSnapshot contributors = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_contributors(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CoopCompletionSnapshot::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.CoopCompletionSnapshot)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ei.CoopCompletionSnapshot.ContributorSnapshot contributors = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_contributors_size()); i < n; i++) {
    const auto& repfield = this->_internal_contributors(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.CoopCompletionSnapshot)
  return target;
}

size_t CoopCompletionSnapshot::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.CoopCompletionSnapshot)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.CoopCompletionSnapshot.ContributorSnapshot contributors = 1;
  total_size += 1UL * this->_internal_contributors_size();
  for (const auto& msg : this->contributors_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CoopCompletionSnapshot::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CoopCompletionSnapshot::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CoopCompletionSnapshot::GetClassData() const { return &_class_data_; }

void CoopCompletionSnapshot::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CoopCompletionSnapshot *>(to)->MergeFrom(
      static_cast<const CoopCompletionSnapshot &>(from));
}


void CoopCompletionSnapshot::MergeFrom(const CoopCompletionSnapshot& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.CoopCompletionSnapshot)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  contributors_.MergeFrom(from.contributors_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CoopCompletionSnapshot::CopyFrom(const CoopCompletionSnapshot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.CoopCompletionSnapshot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CoopCompletionSnapshot::IsInitialized() const {
  return true;
}

void CoopCompletionSnapshot::InternalSwap(CoopCompletionSnapshot* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  contributors_.InternalSwap(&other->contributors_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CoopCompletionSnapshot::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[46]);
}

// ===================================================================

class BasicRequestInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<BasicRequestInfo>()._has_bits_);
  static void set_has_ei_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_build(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_platform(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_country(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_language(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_debug(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

BasicRequestInfo::BasicRequestInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.BasicRequestInfo)
}
BasicRequestInfo::BasicRequestInfo(const BasicRequestInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ei_user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ei_user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ei_user_id()) {
    ei_user_id_.Set(from._internal_ei_user_id(), 
      GetArenaForAllocation());
  }
  version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_version()) {
    version_.Set(from._internal_version(), 
      GetArenaForAllocation());
  }
  build_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    build_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_build()) {
    build_.Set(from._internal_build(), 
      GetArenaForAllocation());
  }
  platform_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    platform_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_platform()) {
    platform_.Set(from._internal_platform(), 
      GetArenaForAllocation());
  }
  country_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    country_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_country()) {
    country_.Set(from._internal_country(), 
      GetArenaForAllocation());
  }
  language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_language()) {
    language_.Set(from._internal_language(), 
      GetArenaForAllocation());
  }
  ::memcpy(&client_version_, &from.client_version_,
    static_cast<size_t>(reinterpret_cast<char*>(&debug_) -
    reinterpret_cast<char*>(&client_version_)) + sizeof(debug_));
  // @@protoc_insertion_point(copy_constructor:ei.BasicRequestInfo)
}

inline void BasicRequestInfo::SharedCtor() {
ei_user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ei_user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
build_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  build_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
platform_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  platform_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
country_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  country_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
language_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  language_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&client_version_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&debug_) -
    reinterpret_cast<char*>(&client_version_)) + sizeof(debug_));
}

BasicRequestInfo::~BasicRequestInfo() {
  // @@protoc_insertion_point(destructor:ei.BasicRequestInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BasicRequestInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ei_user_id_.Destroy();
  version_.Destroy();
  build_.Destroy();
  platform_.Destroy();
  country_.Destroy();
  language_.Destroy();
}

void BasicRequestInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BasicRequestInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.BasicRequestInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      ei_user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      build_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      platform_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      country_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      language_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&client_version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&debug_) -
        reinterpret_cast<char*>(&client_version_)) + sizeof(debug_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BasicRequestInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string ei_user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ei_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.BasicRequestInfo.ei_user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 client_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_client_version(&has_bits);
          client_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.BasicRequestInfo.version");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string build = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_build();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.BasicRequestInfo.build");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string platform = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_platform();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.BasicRequestInfo.platform");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string country = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_country();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.BasicRequestInfo.country");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string language = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_language();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.BasicRequestInfo.language");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool debug = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_debug(&has_bits);
          debug_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BasicRequestInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.BasicRequestInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string ei_user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ei_user_id().data(), static_cast<int>(this->_internal_ei_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.BasicRequestInfo.ei_user_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ei_user_id(), target);
  }

  // optional uint32 client_version = 2;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_client_version(), target);
  }

  // optional string version = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_version().data(), static_cast<int>(this->_internal_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.BasicRequestInfo.version");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_version(), target);
  }

  // optional string build = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_build().data(), static_cast<int>(this->_internal_build().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.BasicRequestInfo.build");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_build(), target);
  }

  // optional string platform = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_platform().data(), static_cast<int>(this->_internal_platform().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.BasicRequestInfo.platform");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_platform(), target);
  }

  // optional string country = 6;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_country().data(), static_cast<int>(this->_internal_country().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.BasicRequestInfo.country");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_country(), target);
  }

  // optional string language = 7;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_language().data(), static_cast<int>(this->_internal_language().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.BasicRequestInfo.language");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_language(), target);
  }

  // optional bool debug = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_debug(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.BasicRequestInfo)
  return target;
}

size_t BasicRequestInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.BasicRequestInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string ei_user_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ei_user_id());
    }

    // optional string version = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_version());
    }

    // optional string build = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_build());
    }

    // optional string platform = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_platform());
    }

    // optional string country = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_country());
    }

    // optional string language = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_language());
    }

    // optional uint32 client_version = 2;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_client_version());
    }

    // optional bool debug = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BasicRequestInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BasicRequestInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BasicRequestInfo::GetClassData() const { return &_class_data_; }

void BasicRequestInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BasicRequestInfo *>(to)->MergeFrom(
      static_cast<const BasicRequestInfo &>(from));
}


void BasicRequestInfo::MergeFrom(const BasicRequestInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.BasicRequestInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ei_user_id(from._internal_ei_user_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_version(from._internal_version());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_build(from._internal_build());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_platform(from._internal_platform());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_country(from._internal_country());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_language(from._internal_language());
    }
    if (cached_has_bits & 0x00000040u) {
      client_version_ = from.client_version_;
    }
    if (cached_has_bits & 0x00000080u) {
      debug_ = from.debug_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BasicRequestInfo::CopyFrom(const BasicRequestInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.BasicRequestInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BasicRequestInfo::IsInitialized() const {
  return true;
}

void BasicRequestInfo::InternalSwap(BasicRequestInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ei_user_id_, lhs_arena,
      &other->ei_user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &version_, lhs_arena,
      &other->version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &build_, lhs_arena,
      &other->build_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &platform_, lhs_arena,
      &other->platform_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &country_, lhs_arena,
      &other->country_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &language_, lhs_arena,
      &other->language_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BasicRequestInfo, debug_)
      + sizeof(BasicRequestInfo::debug_)
      - PROTOBUF_FIELD_OFFSET(BasicRequestInfo, client_version_)>(
          reinterpret_cast<char*>(&client_version_),
          reinterpret_cast<char*>(&other->client_version_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BasicRequestInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[47]);
}

// ===================================================================

class ContractSimConfig_ContractGradeSimConfig_GoalParams::_Internal {
 public:
  using HasBits = decltype(std::declval<ContractSimConfig_ContractGradeSimConfig_GoalParams>()._has_bits_);
  static void set_has_target_se(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cps_mult(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_earnings_mult(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_time_efficacy(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

ContractSimConfig_ContractGradeSimConfig_GoalParams::ContractSimConfig_ContractGradeSimConfig_GoalParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ContractSimConfig.ContractGradeSimConfig.GoalParams)
}
ContractSimConfig_ContractGradeSimConfig_GoalParams::ContractSimConfig_ContractGradeSimConfig_GoalParams(const ContractSimConfig_ContractGradeSimConfig_GoalParams& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&target_se_, &from.target_se_,
    static_cast<size_t>(reinterpret_cast<char*>(&time_efficacy_) -
    reinterpret_cast<char*>(&target_se_)) + sizeof(time_efficacy_));
  // @@protoc_insertion_point(copy_constructor:ei.ContractSimConfig.ContractGradeSimConfig.GoalParams)
}

inline void ContractSimConfig_ContractGradeSimConfig_GoalParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&target_se_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&time_efficacy_) -
    reinterpret_cast<char*>(&target_se_)) + sizeof(time_efficacy_));
}

ContractSimConfig_ContractGradeSimConfig_GoalParams::~ContractSimConfig_ContractGradeSimConfig_GoalParams() {
  // @@protoc_insertion_point(destructor:ei.ContractSimConfig.ContractGradeSimConfig.GoalParams)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContractSimConfig_ContractGradeSimConfig_GoalParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ContractSimConfig_ContractGradeSimConfig_GoalParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContractSimConfig_ContractGradeSimConfig_GoalParams::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ContractSimConfig.ContractGradeSimConfig.GoalParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&target_se_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&time_efficacy_) -
        reinterpret_cast<char*>(&target_se_)) + sizeof(time_efficacy_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContractSimConfig_ContractGradeSimConfig_GoalParams::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double target_se = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_target_se(&has_bits);
          target_se_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double cps_mult = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_cps_mult(&has_bits);
          cps_mult_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double earnings_mult = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_earnings_mult(&has_bits);
          earnings_mult_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double time_efficacy = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_time_efficacy(&has_bits);
          time_efficacy_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContractSimConfig_ContractGradeSimConfig_GoalParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ContractSimConfig.ContractGradeSimConfig.GoalParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double target_se = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_target_se(), target);
  }

  // optional double cps_mult = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_cps_mult(), target);
  }

  // optional double earnings_mult = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_earnings_mult(), target);
  }

  // optional double time_efficacy = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_time_efficacy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ContractSimConfig.ContractGradeSimConfig.GoalParams)
  return target;
}

size_t ContractSimConfig_ContractGradeSimConfig_GoalParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ContractSimConfig.ContractGradeSimConfig.GoalParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional double target_se = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double cps_mult = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double earnings_mult = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double time_efficacy = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContractSimConfig_ContractGradeSimConfig_GoalParams::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ContractSimConfig_ContractGradeSimConfig_GoalParams::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContractSimConfig_ContractGradeSimConfig_GoalParams::GetClassData() const { return &_class_data_; }

void ContractSimConfig_ContractGradeSimConfig_GoalParams::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ContractSimConfig_ContractGradeSimConfig_GoalParams *>(to)->MergeFrom(
      static_cast<const ContractSimConfig_ContractGradeSimConfig_GoalParams &>(from));
}


void ContractSimConfig_ContractGradeSimConfig_GoalParams::MergeFrom(const ContractSimConfig_ContractGradeSimConfig_GoalParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ContractSimConfig.ContractGradeSimConfig.GoalParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      target_se_ = from.target_se_;
    }
    if (cached_has_bits & 0x00000002u) {
      cps_mult_ = from.cps_mult_;
    }
    if (cached_has_bits & 0x00000004u) {
      earnings_mult_ = from.earnings_mult_;
    }
    if (cached_has_bits & 0x00000008u) {
      time_efficacy_ = from.time_efficacy_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContractSimConfig_ContractGradeSimConfig_GoalParams::CopyFrom(const ContractSimConfig_ContractGradeSimConfig_GoalParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ContractSimConfig.ContractGradeSimConfig.GoalParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContractSimConfig_ContractGradeSimConfig_GoalParams::IsInitialized() const {
  return true;
}

void ContractSimConfig_ContractGradeSimConfig_GoalParams::InternalSwap(ContractSimConfig_ContractGradeSimConfig_GoalParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContractSimConfig_ContractGradeSimConfig_GoalParams, time_efficacy_)
      + sizeof(ContractSimConfig_ContractGradeSimConfig_GoalParams::time_efficacy_)
      - PROTOBUF_FIELD_OFFSET(ContractSimConfig_ContractGradeSimConfig_GoalParams, target_se_)>(
          reinterpret_cast<char*>(&target_se_),
          reinterpret_cast<char*>(&other->target_se_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ContractSimConfig_ContractGradeSimConfig_GoalParams::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[48]);
}

// ===================================================================

class ContractSimConfig_ContractGradeSimConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<ContractSimConfig_ContractGradeSimConfig>()._has_bits_);
  static void set_has_grade(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ContractSimConfig_ContractGradeSimConfig::ContractSimConfig_ContractGradeSimConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  goal_params_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ContractSimConfig.ContractGradeSimConfig)
}
ContractSimConfig_ContractGradeSimConfig::ContractSimConfig_ContractGradeSimConfig(const ContractSimConfig_ContractGradeSimConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      goal_params_(from.goal_params_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  grade_ = from.grade_;
  // @@protoc_insertion_point(copy_constructor:ei.ContractSimConfig.ContractGradeSimConfig)
}

inline void ContractSimConfig_ContractGradeSimConfig::SharedCtor() {
grade_ = 0;
}

ContractSimConfig_ContractGradeSimConfig::~ContractSimConfig_ContractGradeSimConfig() {
  // @@protoc_insertion_point(destructor:ei.ContractSimConfig.ContractGradeSimConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContractSimConfig_ContractGradeSimConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ContractSimConfig_ContractGradeSimConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContractSimConfig_ContractGradeSimConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ContractSimConfig.ContractGradeSimConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  goal_params_.Clear();
  grade_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContractSimConfig_ContractGradeSimConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.Contract.PlayerGrade grade = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::Contract_PlayerGrade_IsValid(val))) {
            _internal_set_grade(static_cast<::ei::Contract_PlayerGrade>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ContractSimConfig.ContractGradeSimConfig.GoalParams goal_params = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_goal_params(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContractSimConfig_ContractGradeSimConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ContractSimConfig.ContractGradeSimConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.Contract.PlayerGrade grade = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_grade(), target);
  }

  // repeated .ei.ContractSimConfig.ContractGradeSimConfig.GoalParams goal_params = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_goal_params_size()); i < n; i++) {
    const auto& repfield = this->_internal_goal_params(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ContractSimConfig.ContractGradeSimConfig)
  return target;
}

size_t ContractSimConfig_ContractGradeSimConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ContractSimConfig.ContractGradeSimConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.ContractSimConfig.ContractGradeSimConfig.GoalParams goal_params = 2;
  total_size += 1UL * this->_internal_goal_params_size();
  for (const auto& msg : this->goal_params_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .ei.Contract.PlayerGrade grade = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_grade());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContractSimConfig_ContractGradeSimConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ContractSimConfig_ContractGradeSimConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContractSimConfig_ContractGradeSimConfig::GetClassData() const { return &_class_data_; }

void ContractSimConfig_ContractGradeSimConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ContractSimConfig_ContractGradeSimConfig *>(to)->MergeFrom(
      static_cast<const ContractSimConfig_ContractGradeSimConfig &>(from));
}


void ContractSimConfig_ContractGradeSimConfig::MergeFrom(const ContractSimConfig_ContractGradeSimConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ContractSimConfig.ContractGradeSimConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  goal_params_.MergeFrom(from.goal_params_);
  if (from._internal_has_grade()) {
    _internal_set_grade(from._internal_grade());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContractSimConfig_ContractGradeSimConfig::CopyFrom(const ContractSimConfig_ContractGradeSimConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ContractSimConfig.ContractGradeSimConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContractSimConfig_ContractGradeSimConfig::IsInitialized() const {
  return true;
}

void ContractSimConfig_ContractGradeSimConfig::InternalSwap(ContractSimConfig_ContractGradeSimConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  goal_params_.InternalSwap(&other->goal_params_);
  swap(grade_, other->grade_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ContractSimConfig_ContractGradeSimConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[49]);
}

// ===================================================================

class ContractSimConfig::_Internal {
 public:
};

ContractSimConfig::ContractSimConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  grade_configs_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ContractSimConfig)
}
ContractSimConfig::ContractSimConfig(const ContractSimConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      grade_configs_(from.grade_configs_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ei.ContractSimConfig)
}

inline void ContractSimConfig::SharedCtor() {
}

ContractSimConfig::~ContractSimConfig() {
  // @@protoc_insertion_point(destructor:ei.ContractSimConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContractSimConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ContractSimConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContractSimConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ContractSimConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  grade_configs_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContractSimConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .ei.ContractSimConfig.ContractGradeSimConfig grade_configs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_grade_configs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContractSimConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ContractSimConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ei.ContractSimConfig.ContractGradeSimConfig grade_configs = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_grade_configs_size()); i < n; i++) {
    const auto& repfield = this->_internal_grade_configs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ContractSimConfig)
  return target;
}

size_t ContractSimConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ContractSimConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.ContractSimConfig.ContractGradeSimConfig grade_configs = 1;
  total_size += 1UL * this->_internal_grade_configs_size();
  for (const auto& msg : this->grade_configs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContractSimConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ContractSimConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContractSimConfig::GetClassData() const { return &_class_data_; }

void ContractSimConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ContractSimConfig *>(to)->MergeFrom(
      static_cast<const ContractSimConfig &>(from));
}


void ContractSimConfig::MergeFrom(const ContractSimConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ContractSimConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  grade_configs_.MergeFrom(from.grade_configs_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContractSimConfig::CopyFrom(const ContractSimConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ContractSimConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContractSimConfig::IsInitialized() const {
  return true;
}

void ContractSimConfig::InternalSwap(ContractSimConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  grade_configs_.InternalSwap(&other->grade_configs_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ContractSimConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[50]);
}

// ===================================================================

class ContractSimPoll::_Internal {
 public:
  using HasBits = decltype(std::declval<ContractSimPoll>()._has_bits_);
  static void set_has_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ContractSimPoll::ContractSimPoll(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ContractSimPoll)
}
ContractSimPoll::ContractSimPoll(const ContractSimPoll& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  client_version_ = from.client_version_;
  // @@protoc_insertion_point(copy_constructor:ei.ContractSimPoll)
}

inline void ContractSimPoll::SharedCtor() {
client_version_ = 0u;
}

ContractSimPoll::~ContractSimPoll() {
  // @@protoc_insertion_point(destructor:ei.ContractSimPoll)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContractSimPoll::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ContractSimPoll::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContractSimPoll::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ContractSimPoll)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  client_version_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContractSimPoll::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 client_version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_client_version(&has_bits);
          client_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContractSimPoll::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ContractSimPoll)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 client_version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_client_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ContractSimPoll)
  return target;
}

size_t ContractSimPoll::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ContractSimPoll)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 client_version = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_client_version());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContractSimPoll::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ContractSimPoll::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContractSimPoll::GetClassData() const { return &_class_data_; }

void ContractSimPoll::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ContractSimPoll *>(to)->MergeFrom(
      static_cast<const ContractSimPoll &>(from));
}


void ContractSimPoll::MergeFrom(const ContractSimPoll& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ContractSimPoll)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_client_version()) {
    _internal_set_client_version(from._internal_client_version());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContractSimPoll::CopyFrom(const ContractSimPoll& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ContractSimPoll)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContractSimPoll::IsInitialized() const {
  return true;
}

void ContractSimPoll::InternalSwap(ContractSimPoll* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(client_version_, other->client_version_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ContractSimPoll::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[51]);
}

// ===================================================================

class ContractSimPollResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<ContractSimPollResponse>()._has_bits_);
  static const ::ei::Contract& contract_to_simulate(const ContractSimPollResponse* msg);
  static void set_has_contract_to_simulate(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ei::ContractSimConfig& sim_config(const ContractSimPollResponse* msg);
  static void set_has_sim_config(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::ei::Contract&
ContractSimPollResponse::_Internal::contract_to_simulate(const ContractSimPollResponse* msg) {
  return *msg->contract_to_simulate_;
}
const ::ei::ContractSimConfig&
ContractSimPollResponse::_Internal::sim_config(const ContractSimPollResponse* msg) {
  return *msg->sim_config_;
}
ContractSimPollResponse::ContractSimPollResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ContractSimPollResponse)
}
ContractSimPollResponse::ContractSimPollResponse(const ContractSimPollResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_contract_to_simulate()) {
    contract_to_simulate_ = new ::ei::Contract(*from.contract_to_simulate_);
  } else {
    contract_to_simulate_ = nullptr;
  }
  if (from._internal_has_sim_config()) {
    sim_config_ = new ::ei::ContractSimConfig(*from.sim_config_);
  } else {
    sim_config_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:ei.ContractSimPollResponse)
}

inline void ContractSimPollResponse::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&contract_to_simulate_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&sim_config_) -
    reinterpret_cast<char*>(&contract_to_simulate_)) + sizeof(sim_config_));
}

ContractSimPollResponse::~ContractSimPollResponse() {
  // @@protoc_insertion_point(destructor:ei.ContractSimPollResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContractSimPollResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete contract_to_simulate_;
  if (this != internal_default_instance()) delete sim_config_;
}

void ContractSimPollResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContractSimPollResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ContractSimPollResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(contract_to_simulate_ != nullptr);
      contract_to_simulate_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(sim_config_ != nullptr);
      sim_config_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContractSimPollResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.Contract contract_to_simulate = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_contract_to_simulate(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.ContractSimConfig sim_config = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_sim_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContractSimPollResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ContractSimPollResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.Contract contract_to_simulate = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::contract_to_simulate(this),
        _Internal::contract_to_simulate(this).GetCachedSize(), target, stream);
  }

  // optional .ei.ContractSimConfig sim_config = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::sim_config(this),
        _Internal::sim_config(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ContractSimPollResponse)
  return target;
}

size_t ContractSimPollResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ContractSimPollResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .ei.Contract contract_to_simulate = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *contract_to_simulate_);
    }

    // optional .ei.ContractSimConfig sim_config = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *sim_config_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContractSimPollResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ContractSimPollResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContractSimPollResponse::GetClassData() const { return &_class_data_; }

void ContractSimPollResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ContractSimPollResponse *>(to)->MergeFrom(
      static_cast<const ContractSimPollResponse &>(from));
}


void ContractSimPollResponse::MergeFrom(const ContractSimPollResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ContractSimPollResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_contract_to_simulate()->::ei::Contract::MergeFrom(from._internal_contract_to_simulate());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_sim_config()->::ei::ContractSimConfig::MergeFrom(from._internal_sim_config());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContractSimPollResponse::CopyFrom(const ContractSimPollResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ContractSimPollResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContractSimPollResponse::IsInitialized() const {
  return true;
}

void ContractSimPollResponse::InternalSwap(ContractSimPollResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContractSimPollResponse, sim_config_)
      + sizeof(ContractSimPollResponse::sim_config_)
      - PROTOBUF_FIELD_OFFSET(ContractSimPollResponse, contract_to_simulate_)>(
          reinterpret_cast<char*>(&contract_to_simulate_),
          reinterpret_cast<char*>(&other->contract_to_simulate_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ContractSimPollResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[52]);
}

// ===================================================================

class ContractSimResultUpdate_GoalInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ContractSimResultUpdate_GoalInfo>()._has_bits_);
  static void set_has_grade(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_goal_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_projected_eggs_laid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ContractSimResultUpdate_GoalInfo::ContractSimResultUpdate_GoalInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ContractSimResultUpdate.GoalInfo)
}
ContractSimResultUpdate_GoalInfo::ContractSimResultUpdate_GoalInfo(const ContractSimResultUpdate_GoalInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&grade_, &from.grade_,
    static_cast<size_t>(reinterpret_cast<char*>(&projected_eggs_laid_) -
    reinterpret_cast<char*>(&grade_)) + sizeof(projected_eggs_laid_));
  // @@protoc_insertion_point(copy_constructor:ei.ContractSimResultUpdate.GoalInfo)
}

inline void ContractSimResultUpdate_GoalInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&grade_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&projected_eggs_laid_) -
    reinterpret_cast<char*>(&grade_)) + sizeof(projected_eggs_laid_));
}

ContractSimResultUpdate_GoalInfo::~ContractSimResultUpdate_GoalInfo() {
  // @@protoc_insertion_point(destructor:ei.ContractSimResultUpdate.GoalInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContractSimResultUpdate_GoalInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ContractSimResultUpdate_GoalInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContractSimResultUpdate_GoalInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ContractSimResultUpdate.GoalInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&grade_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&projected_eggs_laid_) -
        reinterpret_cast<char*>(&grade_)) + sizeof(projected_eggs_laid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContractSimResultUpdate_GoalInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.Contract.PlayerGrade grade = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::Contract_PlayerGrade_IsValid(val))) {
            _internal_set_grade(static_cast<::ei::Contract_PlayerGrade>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 goal_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_goal_index(&has_bits);
          goal_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double projected_eggs_laid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_projected_eggs_laid(&has_bits);
          projected_eggs_laid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContractSimResultUpdate_GoalInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ContractSimResultUpdate.GoalInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.Contract.PlayerGrade grade = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_grade(), target);
  }

  // optional uint32 goal_index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_goal_index(), target);
  }

  // optional double projected_eggs_laid = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_projected_eggs_laid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ContractSimResultUpdate.GoalInfo)
  return target;
}

size_t ContractSimResultUpdate_GoalInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ContractSimResultUpdate.GoalInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .ei.Contract.PlayerGrade grade = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_grade());
    }

    // optional uint32 goal_index = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_goal_index());
    }

    // optional double projected_eggs_laid = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContractSimResultUpdate_GoalInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ContractSimResultUpdate_GoalInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContractSimResultUpdate_GoalInfo::GetClassData() const { return &_class_data_; }

void ContractSimResultUpdate_GoalInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ContractSimResultUpdate_GoalInfo *>(to)->MergeFrom(
      static_cast<const ContractSimResultUpdate_GoalInfo &>(from));
}


void ContractSimResultUpdate_GoalInfo::MergeFrom(const ContractSimResultUpdate_GoalInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ContractSimResultUpdate.GoalInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      grade_ = from.grade_;
    }
    if (cached_has_bits & 0x00000002u) {
      goal_index_ = from.goal_index_;
    }
    if (cached_has_bits & 0x00000004u) {
      projected_eggs_laid_ = from.projected_eggs_laid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContractSimResultUpdate_GoalInfo::CopyFrom(const ContractSimResultUpdate_GoalInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ContractSimResultUpdate.GoalInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContractSimResultUpdate_GoalInfo::IsInitialized() const {
  return true;
}

void ContractSimResultUpdate_GoalInfo::InternalSwap(ContractSimResultUpdate_GoalInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContractSimResultUpdate_GoalInfo, projected_eggs_laid_)
      + sizeof(ContractSimResultUpdate_GoalInfo::projected_eggs_laid_)
      - PROTOBUF_FIELD_OFFSET(ContractSimResultUpdate_GoalInfo, grade_)>(
          reinterpret_cast<char*>(&grade_),
          reinterpret_cast<char*>(&other->grade_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ContractSimResultUpdate_GoalInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[53]);
}

// ===================================================================

class ContractSimResultUpdate::_Internal {
 public:
  using HasBits = decltype(std::declval<ContractSimResultUpdate>()._has_bits_);
  static void set_has_contract_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ContractSimResultUpdate::ContractSimResultUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  goal_infos_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ContractSimResultUpdate)
}
ContractSimResultUpdate::ContractSimResultUpdate(const ContractSimResultUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      goal_infos_(from.goal_infos_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contract_id()) {
    contract_id_.Set(from._internal_contract_id(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:ei.ContractSimResultUpdate)
}

inline void ContractSimResultUpdate::SharedCtor() {
contract_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  contract_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ContractSimResultUpdate::~ContractSimResultUpdate() {
  // @@protoc_insertion_point(destructor:ei.ContractSimResultUpdate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContractSimResultUpdate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  contract_id_.Destroy();
}

void ContractSimResultUpdate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContractSimResultUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ContractSimResultUpdate)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  goal_infos_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    contract_id_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContractSimResultUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string contract_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractSimResultUpdate.contract_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ContractSimResultUpdate.GoalInfo goal_infos = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_goal_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContractSimResultUpdate::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ContractSimResultUpdate)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string contract_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_contract_id().data(), static_cast<int>(this->_internal_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractSimResultUpdate.contract_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_contract_id(), target);
  }

  // repeated .ei.ContractSimResultUpdate.GoalInfo goal_infos = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_goal_infos_size()); i < n; i++) {
    const auto& repfield = this->_internal_goal_infos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ContractSimResultUpdate)
  return target;
}

size_t ContractSimResultUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ContractSimResultUpdate)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.ContractSimResultUpdate.GoalInfo goal_infos = 2;
  total_size += 1UL * this->_internal_goal_infos_size();
  for (const auto& msg : this->goal_infos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string contract_id = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_contract_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContractSimResultUpdate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ContractSimResultUpdate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContractSimResultUpdate::GetClassData() const { return &_class_data_; }

void ContractSimResultUpdate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ContractSimResultUpdate *>(to)->MergeFrom(
      static_cast<const ContractSimResultUpdate &>(from));
}


void ContractSimResultUpdate::MergeFrom(const ContractSimResultUpdate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ContractSimResultUpdate)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  goal_infos_.MergeFrom(from.goal_infos_);
  if (from._internal_has_contract_id()) {
    _internal_set_contract_id(from._internal_contract_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContractSimResultUpdate::CopyFrom(const ContractSimResultUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ContractSimResultUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContractSimResultUpdate::IsInitialized() const {
  return true;
}

void ContractSimResultUpdate::InternalSwap(ContractSimResultUpdate* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  goal_infos_.InternalSwap(&other->goal_infos_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &contract_id_, lhs_arena,
      &other->contract_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ContractSimResultUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[54]);
}

// ===================================================================

class ContractsRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ContractsRequest>()._has_bits_);
  static void set_has_soul_eggs(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ContractsRequest::ContractsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ContractsRequest)
}
ContractsRequest::ContractsRequest(const ContractsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_id()) {
    user_id_.Set(from._internal_user_id(), 
      GetArenaForAllocation());
  }
  ::memcpy(&soul_eggs_, &from.soul_eggs_,
    static_cast<size_t>(reinterpret_cast<char*>(&client_version_) -
    reinterpret_cast<char*>(&soul_eggs_)) + sizeof(client_version_));
  // @@protoc_insertion_point(copy_constructor:ei.ContractsRequest)
}

inline void ContractsRequest::SharedCtor() {
user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&soul_eggs_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&client_version_) -
    reinterpret_cast<char*>(&soul_eggs_)) + sizeof(client_version_));
}

ContractsRequest::~ContractsRequest() {
  // @@protoc_insertion_point(destructor:ei.ContractsRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContractsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_id_.Destroy();
}

void ContractsRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContractsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ContractsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    user_id_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&soul_eggs_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&client_version_) -
        reinterpret_cast<char*>(&soul_eggs_)) + sizeof(client_version_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContractsRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double soul_eggs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_soul_eggs(&has_bits);
          soul_eggs_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional string user_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractsRequest.user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 client_version = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_client_version(&has_bits);
          client_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContractsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ContractsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double soul_eggs = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_soul_eggs(), target);
  }

  // optional string user_id = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractsRequest.user_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_user_id(), target);
  }

  // optional uint32 client_version = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_client_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ContractsRequest)
  return target;
}

size_t ContractsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ContractsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string user_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_id());
    }

    // optional double soul_eggs = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional uint32 client_version = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_client_version());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContractsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ContractsRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContractsRequest::GetClassData() const { return &_class_data_; }

void ContractsRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ContractsRequest *>(to)->MergeFrom(
      static_cast<const ContractsRequest &>(from));
}


void ContractsRequest::MergeFrom(const ContractsRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ContractsRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_id(from._internal_user_id());
    }
    if (cached_has_bits & 0x00000002u) {
      soul_eggs_ = from.soul_eggs_;
    }
    if (cached_has_bits & 0x00000004u) {
      client_version_ = from.client_version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContractsRequest::CopyFrom(const ContractsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ContractsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContractsRequest::IsInitialized() const {
  return true;
}

void ContractsRequest::InternalSwap(ContractsRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContractsRequest, client_version_)
      + sizeof(ContractsRequest::client_version_)
      - PROTOBUF_FIELD_OFFSET(ContractsRequest, soul_eggs_)>(
          reinterpret_cast<char*>(&soul_eggs_),
          reinterpret_cast<char*>(&other->soul_eggs_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ContractsRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[55]);
}

// ===================================================================

class ContractsResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<ContractsResponse>()._has_bits_);
  static void set_has_warning_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_server_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_max_eop(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ContractsResponse::ContractsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  contracts_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ContractsResponse)
}
ContractsResponse::ContractsResponse(const ContractsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      contracts_(from.contracts_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  warning_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    warning_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_warning_message()) {
    warning_message_.Set(from._internal_warning_message(), 
      GetArenaForAllocation());
  }
  ::memcpy(&server_time_, &from.server_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_eop_) -
    reinterpret_cast<char*>(&server_time_)) + sizeof(max_eop_));
  // @@protoc_insertion_point(copy_constructor:ei.ContractsResponse)
}

inline void ContractsResponse::SharedCtor() {
warning_message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  warning_message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
server_time_ = 0;
max_eop_ = 1000u;
}

ContractsResponse::~ContractsResponse() {
  // @@protoc_insertion_point(destructor:ei.ContractsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContractsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  warning_message_.Destroy();
}

void ContractsResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContractsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ContractsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  contracts_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    warning_message_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    server_time_ = 0;
    max_eop_ = 1000u;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContractsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .ei.Contract contracts = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_contracts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional double server_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_server_time(&has_bits);
          server_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 max_eop = 3 [default = 1000];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_max_eop(&has_bits);
          max_eop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string warning_message = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_warning_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractsResponse.warning_message");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContractsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ContractsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ei.Contract contracts = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_contracts_size()); i < n; i++) {
    const auto& repfield = this->_internal_contracts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional double server_time = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_server_time(), target);
  }

  // optional uint32 max_eop = 3 [default = 1000];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_max_eop(), target);
  }

  // optional string warning_message = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_warning_message().data(), static_cast<int>(this->_internal_warning_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractsResponse.warning_message");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_warning_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ContractsResponse)
  return target;
}

size_t ContractsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ContractsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.Contract contracts = 1;
  total_size += 1UL * this->_internal_contracts_size();
  for (const auto& msg : this->contracts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string warning_message = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_warning_message());
    }

    // optional double server_time = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional uint32 max_eop = 3 [default = 1000];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_max_eop());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContractsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ContractsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContractsResponse::GetClassData() const { return &_class_data_; }

void ContractsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ContractsResponse *>(to)->MergeFrom(
      static_cast<const ContractsResponse &>(from));
}


void ContractsResponse::MergeFrom(const ContractsResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ContractsResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  contracts_.MergeFrom(from.contracts_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_warning_message(from._internal_warning_message());
    }
    if (cached_has_bits & 0x00000002u) {
      server_time_ = from.server_time_;
    }
    if (cached_has_bits & 0x00000004u) {
      max_eop_ = from.max_eop_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContractsResponse::CopyFrom(const ContractsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ContractsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContractsResponse::IsInitialized() const {
  return true;
}

void ContractsResponse::InternalSwap(ContractsResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  contracts_.InternalSwap(&other->contracts_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &warning_message_, lhs_arena,
      &other->warning_message_, rhs_arena
  );
  swap(server_time_, other->server_time_);
  swap(max_eop_, other->max_eop_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ContractsResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[56]);
}

// ===================================================================

class ContractCoopStatusRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ContractCoopStatusRequest>()._has_bits_);
  static const ::ei::BasicRequestInfo& rinfo(const ContractCoopStatusRequest* msg);
  static void set_has_rinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_contract_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_coop_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::ei::BasicRequestInfo&
ContractCoopStatusRequest::_Internal::rinfo(const ContractCoopStatusRequest* msg) {
  return *msg->rinfo_;
}
ContractCoopStatusRequest::ContractCoopStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ContractCoopStatusRequest)
}
ContractCoopStatusRequest::ContractCoopStatusRequest(const ContractCoopStatusRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  contract_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    contract_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contract_identifier()) {
    contract_identifier_.Set(from._internal_contract_identifier(), 
      GetArenaForAllocation());
  }
  coop_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    coop_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_coop_identifier()) {
    coop_identifier_.Set(from._internal_coop_identifier(), 
      GetArenaForAllocation());
  }
  user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_id()) {
    user_id_.Set(from._internal_user_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_rinfo()) {
    rinfo_ = new ::ei::BasicRequestInfo(*from.rinfo_);
  } else {
    rinfo_ = nullptr;
  }
  client_version_ = from.client_version_;
  // @@protoc_insertion_point(copy_constructor:ei.ContractCoopStatusRequest)
}

inline void ContractCoopStatusRequest::SharedCtor() {
contract_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  contract_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
coop_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  coop_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rinfo_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&client_version_) -
    reinterpret_cast<char*>(&rinfo_)) + sizeof(client_version_));
}

ContractCoopStatusRequest::~ContractCoopStatusRequest() {
  // @@protoc_insertion_point(destructor:ei.ContractCoopStatusRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContractCoopStatusRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  contract_identifier_.Destroy();
  coop_identifier_.Destroy();
  user_id_.Destroy();
  if (this != internal_default_instance()) delete rinfo_;
}

void ContractCoopStatusRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContractCoopStatusRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ContractCoopStatusRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      contract_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      coop_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(rinfo_ != nullptr);
      rinfo_->Clear();
    }
  }
  client_version_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContractCoopStatusRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string contract_identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_contract_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractCoopStatusRequest.contract_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string coop_identifier = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_coop_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractCoopStatusRequest.coop_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string user_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractCoopStatusRequest.user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 client_version = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_client_version(&has_bits);
          client_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.BasicRequestInfo rinfo = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_rinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContractCoopStatusRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ContractCoopStatusRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string contract_identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_contract_identifier().data(), static_cast<int>(this->_internal_contract_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractCoopStatusRequest.contract_identifier");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_contract_identifier(), target);
  }

  // optional string coop_identifier = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_coop_identifier().data(), static_cast<int>(this->_internal_coop_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractCoopStatusRequest.coop_identifier");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_coop_identifier(), target);
  }

  // optional string user_id = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractCoopStatusRequest.user_id");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_user_id(), target);
  }

  // optional uint32 client_version = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_client_version(), target);
  }

  // optional .ei.BasicRequestInfo rinfo = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::rinfo(this),
        _Internal::rinfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ContractCoopStatusRequest)
  return target;
}

size_t ContractCoopStatusRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ContractCoopStatusRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string contract_identifier = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contract_identifier());
    }

    // optional string coop_identifier = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_coop_identifier());
    }

    // optional string user_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_id());
    }

    // optional .ei.BasicRequestInfo rinfo = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rinfo_);
    }

    // optional uint32 client_version = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_client_version());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContractCoopStatusRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ContractCoopStatusRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContractCoopStatusRequest::GetClassData() const { return &_class_data_; }

void ContractCoopStatusRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ContractCoopStatusRequest *>(to)->MergeFrom(
      static_cast<const ContractCoopStatusRequest &>(from));
}


void ContractCoopStatusRequest::MergeFrom(const ContractCoopStatusRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ContractCoopStatusRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_contract_identifier(from._internal_contract_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_coop_identifier(from._internal_coop_identifier());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_user_id(from._internal_user_id());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_rinfo()->::ei::BasicRequestInfo::MergeFrom(from._internal_rinfo());
    }
    if (cached_has_bits & 0x00000010u) {
      client_version_ = from.client_version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContractCoopStatusRequest::CopyFrom(const ContractCoopStatusRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ContractCoopStatusRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContractCoopStatusRequest::IsInitialized() const {
  return true;
}

void ContractCoopStatusRequest::InternalSwap(ContractCoopStatusRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &contract_identifier_, lhs_arena,
      &other->contract_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &coop_identifier_, lhs_arena,
      &other->coop_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContractCoopStatusRequest, client_version_)
      + sizeof(ContractCoopStatusRequest::client_version_)
      - PROTOBUF_FIELD_OFFSET(ContractCoopStatusRequest, rinfo_)>(
          reinterpret_cast<char*>(&rinfo_),
          reinterpret_cast<char*>(&other->rinfo_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ContractCoopStatusRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[57]);
}

// ===================================================================

class FarmProductionParams::_Internal {
 public:
  using HasBits = decltype(std::declval<FarmProductionParams>()._has_bits_);
  static void set_has_farm_population(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_farm_capacity(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_elr(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ihr(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_sr(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_delivered(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

FarmProductionParams::FarmProductionParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.FarmProductionParams)
}
FarmProductionParams::FarmProductionParams(const FarmProductionParams& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&farm_population_, &from.farm_population_,
    static_cast<size_t>(reinterpret_cast<char*>(&delivered_) -
    reinterpret_cast<char*>(&farm_population_)) + sizeof(delivered_));
  // @@protoc_insertion_point(copy_constructor:ei.FarmProductionParams)
}

inline void FarmProductionParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&farm_population_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&delivered_) -
    reinterpret_cast<char*>(&farm_population_)) + sizeof(delivered_));
}

FarmProductionParams::~FarmProductionParams() {
  // @@protoc_insertion_point(destructor:ei.FarmProductionParams)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FarmProductionParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FarmProductionParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FarmProductionParams::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.FarmProductionParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&farm_population_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&delivered_) -
        reinterpret_cast<char*>(&farm_population_)) + sizeof(delivered_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FarmProductionParams::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double farm_population = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_farm_population(&has_bits);
          farm_population_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double farm_capacity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_farm_capacity(&has_bits);
          farm_capacity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double elr = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_elr(&has_bits);
          elr_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double ihr = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_ihr(&has_bits);
          ihr_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double sr = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_sr(&has_bits);
          sr_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double delivered = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_delivered(&has_bits);
          delivered_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FarmProductionParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.FarmProductionParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double farm_population = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_farm_population(), target);
  }

  // optional double farm_capacity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_farm_capacity(), target);
  }

  // optional double elr = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_elr(), target);
  }

  // optional double ihr = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_ihr(), target);
  }

  // optional double sr = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_sr(), target);
  }

  // optional double delivered = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_delivered(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.FarmProductionParams)
  return target;
}

size_t FarmProductionParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.FarmProductionParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional double farm_population = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double farm_capacity = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double elr = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double ihr = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double sr = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double delivered = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FarmProductionParams::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FarmProductionParams::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FarmProductionParams::GetClassData() const { return &_class_data_; }

void FarmProductionParams::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<FarmProductionParams *>(to)->MergeFrom(
      static_cast<const FarmProductionParams &>(from));
}


void FarmProductionParams::MergeFrom(const FarmProductionParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.FarmProductionParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      farm_population_ = from.farm_population_;
    }
    if (cached_has_bits & 0x00000002u) {
      farm_capacity_ = from.farm_capacity_;
    }
    if (cached_has_bits & 0x00000004u) {
      elr_ = from.elr_;
    }
    if (cached_has_bits & 0x00000008u) {
      ihr_ = from.ihr_;
    }
    if (cached_has_bits & 0x00000010u) {
      sr_ = from.sr_;
    }
    if (cached_has_bits & 0x00000020u) {
      delivered_ = from.delivered_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FarmProductionParams::CopyFrom(const FarmProductionParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.FarmProductionParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FarmProductionParams::IsInitialized() const {
  return true;
}

void FarmProductionParams::InternalSwap(FarmProductionParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FarmProductionParams, delivered_)
      + sizeof(FarmProductionParams::delivered_)
      - PROTOBUF_FIELD_OFFSET(FarmProductionParams, farm_population_)>(
          reinterpret_cast<char*>(&farm_population_),
          reinterpret_cast<char*>(&other->farm_population_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FarmProductionParams::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[58]);
}

// ===================================================================

class PlayerFarmInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<PlayerFarmInfo>()._has_bits_);
  static void set_has_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_soul_eggs(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_eggs_of_prophecy(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_permit_level(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_hyperloop_station(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_egg_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_cash_on_hand(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_silos_owned(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_boost_tokens_on_hand(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_artifact_inventory_score(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::ei::ShellDB_FarmConfiguration& farm_appearance(const PlayerFarmInfo* msg);
  static void set_has_farm_appearance(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

const ::ei::ShellDB_FarmConfiguration&
PlayerFarmInfo::_Internal::farm_appearance(const PlayerFarmInfo* msg) {
  return *msg->farm_appearance_;
}
PlayerFarmInfo::PlayerFarmInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  egg_medal_level_(arena),
  epic_research_(arena),
  habs_(arena),
  hab_population_(arena),
  vehicles_(arena),
  train_length_(arena),
  common_research_(arena),
  active_boosts_(arena),
  equipped_artifacts_(arena),
  hab_capacity_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.PlayerFarmInfo)
}
PlayerFarmInfo::PlayerFarmInfo(const PlayerFarmInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      egg_medal_level_(from.egg_medal_level_),
      epic_research_(from.epic_research_),
      habs_(from.habs_),
      hab_population_(from.hab_population_),
      vehicles_(from.vehicles_),
      train_length_(from.train_length_),
      common_research_(from.common_research_),
      active_boosts_(from.active_boosts_),
      equipped_artifacts_(from.equipped_artifacts_),
      hab_capacity_(from.hab_capacity_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_farm_appearance()) {
    farm_appearance_ = new ::ei::ShellDB_FarmConfiguration(*from.farm_appearance_);
  } else {
    farm_appearance_ = nullptr;
  }
  ::memcpy(&soul_eggs_, &from.soul_eggs_,
    static_cast<size_t>(reinterpret_cast<char*>(&egg_type_) -
    reinterpret_cast<char*>(&soul_eggs_)) + sizeof(egg_type_));
  // @@protoc_insertion_point(copy_constructor:ei.PlayerFarmInfo)
}

inline void PlayerFarmInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&farm_appearance_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&client_version_) -
    reinterpret_cast<char*>(&farm_appearance_)) + sizeof(client_version_));
egg_type_ = 1;
}

PlayerFarmInfo::~PlayerFarmInfo() {
  // @@protoc_insertion_point(destructor:ei.PlayerFarmInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerFarmInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete farm_appearance_;
}

void PlayerFarmInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PlayerFarmInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.PlayerFarmInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  egg_medal_level_.Clear();
  epic_research_.Clear();
  habs_.Clear();
  hab_population_.Clear();
  vehicles_.Clear();
  train_length_.Clear();
  common_research_.Clear();
  active_boosts_.Clear();
  equipped_artifacts_.Clear();
  hab_capacity_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(farm_appearance_ != nullptr);
    farm_appearance_->Clear();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&soul_eggs_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&boost_tokens_on_hand_) -
        reinterpret_cast<char*>(&soul_eggs_)) + sizeof(boost_tokens_on_hand_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&artifact_inventory_score_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&client_version_) -
        reinterpret_cast<char*>(&artifact_inventory_score_)) + sizeof(client_version_));
    egg_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerFarmInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double soul_eggs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_soul_eggs(&has_bits);
          soul_eggs_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 eggs_of_prophecy = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_eggs_of_prophecy(&has_bits);
          eggs_of_prophecy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 permit_level = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_permit_level(&has_bits);
          permit_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool hyperloop_station = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_hyperloop_station(&has_bits);
          hyperloop_station_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 egg_medal_level = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_egg_medal_level(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_egg_medal_level(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.Backup.ResearchItem epic_research = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_epic_research(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .ei.Egg egg_type = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::Egg_IsValid(val))) {
            _internal_set_egg_type(static_cast<::ei::Egg>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional double cash_on_hand = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _Internal::set_has_cash_on_hand(&has_bits);
          cash_on_hand_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 habs = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_habs(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<72>(ptr));
        } else if (static_cast<uint8_t>(tag) == 74) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_habs(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 hab_population = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_hab_population(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<80>(ptr));
        } else if (static_cast<uint8_t>(tag) == 82) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_hab_population(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 vehicles = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_vehicles(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<88>(ptr));
        } else if (static_cast<uint8_t>(tag) == 90) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_vehicles(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 train_length = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_train_length(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<96>(ptr));
        } else if (static_cast<uint8_t>(tag) == 98) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_train_length(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 silos_owned = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_silos_owned(&has_bits);
          silos_owned_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.Backup.ResearchItem common_research = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_common_research(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<114>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.Backup.ActiveBoost active_boosts = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_active_boosts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<122>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 boost_tokens_on_hand = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_boost_tokens_on_hand(&has_bits);
          boost_tokens_on_hand_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.CompleteArtifact equipped_artifacts = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_equipped_artifacts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<138>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 artifact_inventory_score = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_artifact_inventory_score(&has_bits);
          artifact_inventory_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.ShellDB.FarmConfiguration farm_appearance = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_farm_appearance(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 client_version = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_client_version(&has_bits);
          client_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 hab_capacity = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_hab_capacity(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<168>(ptr));
        } else if (static_cast<uint8_t>(tag) == 170) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_hab_capacity(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double timestamp = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 177)) {
          _Internal::set_has_timestamp(&has_bits);
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerFarmInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.PlayerFarmInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double soul_eggs = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_soul_eggs(), target);
  }

  // optional uint64 eggs_of_prophecy = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_eggs_of_prophecy(), target);
  }

  // optional uint32 permit_level = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_permit_level(), target);
  }

  // optional bool hyperloop_station = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_hyperloop_station(), target);
  }

  // repeated uint32 egg_medal_level = 5;
  for (int i = 0, n = this->_internal_egg_medal_level_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_egg_medal_level(i), target);
  }

  // repeated .ei.Backup.ResearchItem epic_research = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_epic_research_size()); i < n; i++) {
    const auto& repfield = this->_internal_epic_research(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .ei.Egg egg_type = 7;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_egg_type(), target);
  }

  // optional double cash_on_hand = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_cash_on_hand(), target);
  }

  // repeated uint32 habs = 9;
  for (int i = 0, n = this->_internal_habs_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_habs(i), target);
  }

  // repeated uint64 hab_population = 10;
  for (int i = 0, n = this->_internal_hab_population_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(10, this->_internal_hab_population(i), target);
  }

  // repeated uint32 vehicles = 11;
  for (int i = 0, n = this->_internal_vehicles_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_vehicles(i), target);
  }

  // repeated uint32 train_length = 12;
  for (int i = 0, n = this->_internal_train_length_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_train_length(i), target);
  }

  // optional uint32 silos_owned = 13;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_silos_owned(), target);
  }

  // repeated .ei.Backup.ResearchItem common_research = 14;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_common_research_size()); i < n; i++) {
    const auto& repfield = this->_internal_common_research(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(14, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .ei.Backup.ActiveBoost active_boosts = 15;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_active_boosts_size()); i < n; i++) {
    const auto& repfield = this->_internal_active_boosts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(15, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 boost_tokens_on_hand = 16;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_boost_tokens_on_hand(), target);
  }

  // repeated .ei.CompleteArtifact equipped_artifacts = 17;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_equipped_artifacts_size()); i < n; i++) {
    const auto& repfield = this->_internal_equipped_artifacts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(17, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint64 artifact_inventory_score = 18;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(18, this->_internal_artifact_inventory_score(), target);
  }

  // optional .ei.ShellDB.FarmConfiguration farm_appearance = 19;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::farm_appearance(this),
        _Internal::farm_appearance(this).GetCachedSize(), target, stream);
  }

  // optional uint32 client_version = 20;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(20, this->_internal_client_version(), target);
  }

  // repeated uint64 hab_capacity = 21;
  for (int i = 0, n = this->_internal_hab_capacity_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(21, this->_internal_hab_capacity(i), target);
  }

  // optional double timestamp = 22;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(22, this->_internal_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.PlayerFarmInfo)
  return target;
}

size_t PlayerFarmInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.PlayerFarmInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 egg_medal_level = 5;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->egg_medal_level_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_egg_medal_level_size());
    total_size += data_size;
  }

  // repeated .ei.Backup.ResearchItem epic_research = 6;
  total_size += 1UL * this->_internal_epic_research_size();
  for (const auto& msg : this->epic_research_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint32 habs = 9;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->habs_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_habs_size());
    total_size += data_size;
  }

  // repeated uint64 hab_population = 10;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->hab_population_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_hab_population_size());
    total_size += data_size;
  }

  // repeated uint32 vehicles = 11;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->vehicles_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_vehicles_size());
    total_size += data_size;
  }

  // repeated uint32 train_length = 12;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->train_length_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_train_length_size());
    total_size += data_size;
  }

  // repeated .ei.Backup.ResearchItem common_research = 14;
  total_size += 1UL * this->_internal_common_research_size();
  for (const auto& msg : this->common_research_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.Backup.ActiveBoost active_boosts = 15;
  total_size += 1UL * this->_internal_active_boosts_size();
  for (const auto& msg : this->active_boosts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.CompleteArtifact equipped_artifacts = 17;
  total_size += 2UL * this->_internal_equipped_artifacts_size();
  for (const auto& msg : this->equipped_artifacts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint64 hab_capacity = 21;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->hab_capacity_);
    total_size += 2 *
                  ::_pbi::FromIntSize(this->_internal_hab_capacity_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .ei.ShellDB.FarmConfiguration farm_appearance = 19;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *farm_appearance_);
    }

    // optional double soul_eggs = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional uint64 eggs_of_prophecy = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_eggs_of_prophecy());
    }

    // optional uint32 permit_level = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_permit_level());
    }

    // optional bool hyperloop_station = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional double cash_on_hand = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional uint32 silos_owned = 13;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_silos_owned());
    }

    // optional uint32 boost_tokens_on_hand = 16;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_boost_tokens_on_hand());
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional uint64 artifact_inventory_score = 18;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_artifact_inventory_score());
    }

    // optional double timestamp = 22;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 + 8;
    }

    // optional uint32 client_version = 20;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_client_version());
    }

    // optional .ei.Egg egg_type = 7;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_egg_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerFarmInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PlayerFarmInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerFarmInfo::GetClassData() const { return &_class_data_; }

void PlayerFarmInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PlayerFarmInfo *>(to)->MergeFrom(
      static_cast<const PlayerFarmInfo &>(from));
}


void PlayerFarmInfo::MergeFrom(const PlayerFarmInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.PlayerFarmInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  egg_medal_level_.MergeFrom(from.egg_medal_level_);
  epic_research_.MergeFrom(from.epic_research_);
  habs_.MergeFrom(from.habs_);
  hab_population_.MergeFrom(from.hab_population_);
  vehicles_.MergeFrom(from.vehicles_);
  train_length_.MergeFrom(from.train_length_);
  common_research_.MergeFrom(from.common_research_);
  active_boosts_.MergeFrom(from.active_boosts_);
  equipped_artifacts_.MergeFrom(from.equipped_artifacts_);
  hab_capacity_.MergeFrom(from.hab_capacity_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_farm_appearance()->::ei::ShellDB_FarmConfiguration::MergeFrom(from._internal_farm_appearance());
    }
    if (cached_has_bits & 0x00000002u) {
      soul_eggs_ = from.soul_eggs_;
    }
    if (cached_has_bits & 0x00000004u) {
      eggs_of_prophecy_ = from.eggs_of_prophecy_;
    }
    if (cached_has_bits & 0x00000008u) {
      permit_level_ = from.permit_level_;
    }
    if (cached_has_bits & 0x00000010u) {
      hyperloop_station_ = from.hyperloop_station_;
    }
    if (cached_has_bits & 0x00000020u) {
      cash_on_hand_ = from.cash_on_hand_;
    }
    if (cached_has_bits & 0x00000040u) {
      silos_owned_ = from.silos_owned_;
    }
    if (cached_has_bits & 0x00000080u) {
      boost_tokens_on_hand_ = from.boost_tokens_on_hand_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      artifact_inventory_score_ = from.artifact_inventory_score_;
    }
    if (cached_has_bits & 0x00000200u) {
      timestamp_ = from.timestamp_;
    }
    if (cached_has_bits & 0x00000400u) {
      client_version_ = from.client_version_;
    }
    if (cached_has_bits & 0x00000800u) {
      egg_type_ = from.egg_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerFarmInfo::CopyFrom(const PlayerFarmInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.PlayerFarmInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerFarmInfo::IsInitialized() const {
  return true;
}

void PlayerFarmInfo::InternalSwap(PlayerFarmInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  egg_medal_level_.InternalSwap(&other->egg_medal_level_);
  epic_research_.InternalSwap(&other->epic_research_);
  habs_.InternalSwap(&other->habs_);
  hab_population_.InternalSwap(&other->hab_population_);
  vehicles_.InternalSwap(&other->vehicles_);
  train_length_.InternalSwap(&other->train_length_);
  common_research_.InternalSwap(&other->common_research_);
  active_boosts_.InternalSwap(&other->active_boosts_);
  equipped_artifacts_.InternalSwap(&other->equipped_artifacts_);
  hab_capacity_.InternalSwap(&other->hab_capacity_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlayerFarmInfo, client_version_)
      + sizeof(PlayerFarmInfo::client_version_)
      - PROTOBUF_FIELD_OFFSET(PlayerFarmInfo, farm_appearance_)>(
          reinterpret_cast<char*>(&farm_appearance_),
          reinterpret_cast<char*>(&other->farm_appearance_));
  swap(egg_type_, other->egg_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerFarmInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[59]);
}

// ===================================================================

class ContractCoopStatusResponse_ContributionInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ContractCoopStatusResponse_ContributionInfo>()._has_bits_);
  static void set_has_uuid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_user_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_contract_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_contribution_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_contribution_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_soul_power(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::ei::FarmProductionParams& production_params(const ContractCoopStatusResponse_ContributionInfo* msg);
  static void set_has_production_params(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::ei::PlayerFarmInfo& farm_info(const ContractCoopStatusResponse_ContributionInfo* msg);
  static void set_has_farm_info(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_rank_change(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_active(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_leech(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_time_cheat_detected(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_platform(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_push_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ban_votes(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_autojoined(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_boost_tokens(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_boost_tokens_spent(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_chicken_run_cooldown(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
};

const ::ei::FarmProductionParams&
ContractCoopStatusResponse_ContributionInfo::_Internal::production_params(const ContractCoopStatusResponse_ContributionInfo* msg) {
  return *msg->production_params_;
}
const ::ei::PlayerFarmInfo&
ContractCoopStatusResponse_ContributionInfo::_Internal::farm_info(const ContractCoopStatusResponse_ContributionInfo* msg) {
  return *msg->farm_info_;
}
ContractCoopStatusResponse_ContributionInfo::ContractCoopStatusResponse_ContributionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  buff_history_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ContractCoopStatusResponse.ContributionInfo)
}
ContractCoopStatusResponse_ContributionInfo::ContractCoopStatusResponse_ContributionInfo(const ContractCoopStatusResponse_ContributionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      buff_history_(from.buff_history_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_id()) {
    user_id_.Set(from._internal_user_id(), 
      GetArenaForAllocation());
  }
  user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_name()) {
    user_name_.Set(from._internal_user_name(), 
      GetArenaForAllocation());
  }
  push_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    push_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_push_id()) {
    push_id_.Set(from._internal_push_id(), 
      GetArenaForAllocation());
  }
  contract_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    contract_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contract_identifier()) {
    contract_identifier_.Set(from._internal_contract_identifier(), 
      GetArenaForAllocation());
  }
  uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_uuid()) {
    uuid_.Set(from._internal_uuid(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_production_params()) {
    production_params_ = new ::ei::FarmProductionParams(*from.production_params_);
  } else {
    production_params_ = nullptr;
  }
  if (from._internal_has_farm_info()) {
    farm_info_ = new ::ei::PlayerFarmInfo(*from.farm_info_);
  } else {
    farm_info_ = nullptr;
  }
  ::memcpy(&contribution_amount_, &from.contribution_amount_,
    static_cast<size_t>(reinterpret_cast<char*>(&platform_) -
    reinterpret_cast<char*>(&contribution_amount_)) + sizeof(platform_));
  // @@protoc_insertion_point(copy_constructor:ei.ContractCoopStatusResponse.ContributionInfo)
}

inline void ContractCoopStatusResponse_ContributionInfo::SharedCtor() {
user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
user_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
push_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  push_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
contract_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  contract_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
uuid_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  uuid_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&production_params_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&boost_tokens_spent_) -
    reinterpret_cast<char*>(&production_params_)) + sizeof(boost_tokens_spent_));
platform_ = 1;
}

ContractCoopStatusResponse_ContributionInfo::~ContractCoopStatusResponse_ContributionInfo() {
  // @@protoc_insertion_point(destructor:ei.ContractCoopStatusResponse.ContributionInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContractCoopStatusResponse_ContributionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_id_.Destroy();
  user_name_.Destroy();
  push_id_.Destroy();
  contract_identifier_.Destroy();
  uuid_.Destroy();
  if (this != internal_default_instance()) delete production_params_;
  if (this != internal_default_instance()) delete farm_info_;
}

void ContractCoopStatusResponse_ContributionInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContractCoopStatusResponse_ContributionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ContractCoopStatusResponse.ContributionInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  buff_history_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      user_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      push_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      contract_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      uuid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(production_params_ != nullptr);
      production_params_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(farm_info_ != nullptr);
      farm_info_->Clear();
    }
  }
  contribution_amount_ = 0;
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&contribution_rate_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&autojoined_) -
        reinterpret_cast<char*>(&contribution_rate_)) + sizeof(autojoined_));
  }
  if (cached_has_bits & 0x000f0000u) {
    ::memset(&boost_tokens_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&boost_tokens_spent_) -
        reinterpret_cast<char*>(&boost_tokens_)) + sizeof(boost_tokens_spent_));
    platform_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContractCoopStatusResponse_ContributionInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractCoopStatusResponse.ContributionInfo.user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string user_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_user_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractCoopStatusResponse.ContributionInfo.user_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double contribution_amount = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_contribution_amount(&has_bits);
          contribution_amount_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool active = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_active(&has_bits);
          active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.Platform platform = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::Platform_IsValid(val))) {
            _internal_set_platform(static_cast<::ei::Platform>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional double contribution_rate = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_contribution_rate(&has_bits);
          contribution_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool time_cheat_detected = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_time_cheat_detected(&has_bits);
          time_cheat_detected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 rank_change = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_rank_change(&has_bits);
          rank_change_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string push_id = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_push_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractCoopStatusResponse.ContributionInfo.push_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ban_votes = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_ban_votes(&has_bits);
          ban_votes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double soul_power = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _Internal::set_has_soul_power(&has_bits);
          soul_power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 boost_tokens = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_boost_tokens(&has_bits);
          boost_tokens_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.CoopBuffState buff_history = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_buff_history(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 boost_tokens_spent = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_boost_tokens_spent(&has_bits);
          boost_tokens_spent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.FarmProductionParams production_params = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_production_params(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool leech = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_leech(&has_bits);
          leech_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool autojoined = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_autojoined(&has_bits);
          autojoined_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.PlayerFarmInfo farm_info = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_farm_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string contract_identifier = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          auto str = _internal_mutable_contract_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractCoopStatusResponse.ContributionInfo.contract_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double chicken_run_cooldown = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 161)) {
          _Internal::set_has_chicken_run_cooldown(&has_bits);
          chicken_run_cooldown_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional string uuid = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          auto str = _internal_mutable_uuid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractCoopStatusResponse.ContributionInfo.uuid");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContractCoopStatusResponse_ContributionInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ContractCoopStatusResponse.ContributionInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractCoopStatusResponse.ContributionInfo.user_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_id(), target);
  }

  // optional string user_name = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_name().data(), static_cast<int>(this->_internal_user_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractCoopStatusResponse.ContributionInfo.user_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_user_name(), target);
  }

  // optional double contribution_amount = 3;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_contribution_amount(), target);
  }

  // optional bool active = 4;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_active(), target);
  }

  // optional .ei.Platform platform = 5;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_platform(), target);
  }

  // optional double contribution_rate = 6;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_contribution_rate(), target);
  }

  // optional bool time_cheat_detected = 7;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_time_cheat_detected(), target);
  }

  // optional int32 rank_change = 8;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_rank_change(), target);
  }

  // optional string push_id = 9;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_push_id().data(), static_cast<int>(this->_internal_push_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractCoopStatusResponse.ContributionInfo.push_id");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_push_id(), target);
  }

  // optional uint32 ban_votes = 10;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_ban_votes(), target);
  }

  // optional double soul_power = 11;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(11, this->_internal_soul_power(), target);
  }

  // optional uint32 boost_tokens = 12;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_boost_tokens(), target);
  }

  // repeated .ei.CoopBuffState buff_history = 13;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_buff_history_size()); i < n; i++) {
    const auto& repfield = this->_internal_buff_history(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 boost_tokens_spent = 14;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_boost_tokens_spent(), target);
  }

  // optional .ei.FarmProductionParams production_params = 15;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::production_params(this),
        _Internal::production_params(this).GetCachedSize(), target, stream);
  }

  // optional bool leech = 16;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_leech(), target);
  }

  // optional bool autojoined = 17;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(17, this->_internal_autojoined(), target);
  }

  // optional .ei.PlayerFarmInfo farm_info = 18;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, _Internal::farm_info(this),
        _Internal::farm_info(this).GetCachedSize(), target, stream);
  }

  // optional string contract_identifier = 19;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_contract_identifier().data(), static_cast<int>(this->_internal_contract_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractCoopStatusResponse.ContributionInfo.contract_identifier");
    target = stream->WriteStringMaybeAliased(
        19, this->_internal_contract_identifier(), target);
  }

  // optional double chicken_run_cooldown = 20;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(20, this->_internal_chicken_run_cooldown(), target);
  }

  // optional string uuid = 21;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_uuid().data(), static_cast<int>(this->_internal_uuid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractCoopStatusResponse.ContributionInfo.uuid");
    target = stream->WriteStringMaybeAliased(
        21, this->_internal_uuid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ContractCoopStatusResponse.ContributionInfo)
  return target;
}

size_t ContractCoopStatusResponse_ContributionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ContractCoopStatusResponse.ContributionInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.CoopBuffState buff_history = 13;
  total_size += 1UL * this->_internal_buff_history_size();
  for (const auto& msg : this->buff_history_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string user_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_id());
    }

    // optional string user_name = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_name());
    }

    // optional string push_id = 9;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_push_id());
    }

    // optional string contract_identifier = 19;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contract_identifier());
    }

    // optional string uuid = 21;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_uuid());
    }

    // optional .ei.FarmProductionParams production_params = 15;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *production_params_);
    }

    // optional .ei.PlayerFarmInfo farm_info = 18;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *farm_info_);
    }

    // optional double contribution_amount = 3;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional double contribution_rate = 6;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 8;
    }

    // optional int32 rank_change = 8;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_rank_change());
    }

    // optional uint32 ban_votes = 10;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ban_votes());
    }

    // optional double soul_power = 11;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 8;
    }

    // optional bool active = 4;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool leech = 16;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 1;
    }

    // optional bool time_cheat_detected = 7;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

    // optional bool autojoined = 17;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x000f0000u) {
    // optional uint32 boost_tokens = 12;
    if (cached_has_bits & 0x00010000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_boost_tokens());
    }

    // optional double chicken_run_cooldown = 20;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 8;
    }

    // optional uint32 boost_tokens_spent = 14;
    if (cached_has_bits & 0x00040000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_boost_tokens_spent());
    }

    // optional .ei.Platform platform = 5;
    if (cached_has_bits & 0x00080000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_platform());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContractCoopStatusResponse_ContributionInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ContractCoopStatusResponse_ContributionInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContractCoopStatusResponse_ContributionInfo::GetClassData() const { return &_class_data_; }

void ContractCoopStatusResponse_ContributionInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ContractCoopStatusResponse_ContributionInfo *>(to)->MergeFrom(
      static_cast<const ContractCoopStatusResponse_ContributionInfo &>(from));
}


void ContractCoopStatusResponse_ContributionInfo::MergeFrom(const ContractCoopStatusResponse_ContributionInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ContractCoopStatusResponse.ContributionInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  buff_history_.MergeFrom(from.buff_history_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_id(from._internal_user_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_user_name(from._internal_user_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_push_id(from._internal_push_id());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_contract_identifier(from._internal_contract_identifier());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_uuid(from._internal_uuid());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_production_params()->::ei::FarmProductionParams::MergeFrom(from._internal_production_params());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_farm_info()->::ei::PlayerFarmInfo::MergeFrom(from._internal_farm_info());
    }
    if (cached_has_bits & 0x00000080u) {
      contribution_amount_ = from.contribution_amount_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      contribution_rate_ = from.contribution_rate_;
    }
    if (cached_has_bits & 0x00000200u) {
      rank_change_ = from.rank_change_;
    }
    if (cached_has_bits & 0x00000400u) {
      ban_votes_ = from.ban_votes_;
    }
    if (cached_has_bits & 0x00000800u) {
      soul_power_ = from.soul_power_;
    }
    if (cached_has_bits & 0x00001000u) {
      active_ = from.active_;
    }
    if (cached_has_bits & 0x00002000u) {
      leech_ = from.leech_;
    }
    if (cached_has_bits & 0x00004000u) {
      time_cheat_detected_ = from.time_cheat_detected_;
    }
    if (cached_has_bits & 0x00008000u) {
      autojoined_ = from.autojoined_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x000f0000u) {
    if (cached_has_bits & 0x00010000u) {
      boost_tokens_ = from.boost_tokens_;
    }
    if (cached_has_bits & 0x00020000u) {
      chicken_run_cooldown_ = from.chicken_run_cooldown_;
    }
    if (cached_has_bits & 0x00040000u) {
      boost_tokens_spent_ = from.boost_tokens_spent_;
    }
    if (cached_has_bits & 0x00080000u) {
      platform_ = from.platform_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContractCoopStatusResponse_ContributionInfo::CopyFrom(const ContractCoopStatusResponse_ContributionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ContractCoopStatusResponse.ContributionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContractCoopStatusResponse_ContributionInfo::IsInitialized() const {
  return true;
}

void ContractCoopStatusResponse_ContributionInfo::InternalSwap(ContractCoopStatusResponse_ContributionInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  buff_history_.InternalSwap(&other->buff_history_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_name_, lhs_arena,
      &other->user_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &push_id_, lhs_arena,
      &other->push_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &contract_identifier_, lhs_arena,
      &other->contract_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &uuid_, lhs_arena,
      &other->uuid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContractCoopStatusResponse_ContributionInfo, boost_tokens_spent_)
      + sizeof(ContractCoopStatusResponse_ContributionInfo::boost_tokens_spent_)
      - PROTOBUF_FIELD_OFFSET(ContractCoopStatusResponse_ContributionInfo, production_params_)>(
          reinterpret_cast<char*>(&production_params_),
          reinterpret_cast<char*>(&other->production_params_));
  swap(platform_, other->platform_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ContractCoopStatusResponse_ContributionInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[60]);
}

// ===================================================================

class ContractCoopStatusResponse_CoopGift::_Internal {
 public:
  using HasBits = decltype(std::declval<ContractCoopStatusResponse_CoopGift>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_user_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ContractCoopStatusResponse_CoopGift::ContractCoopStatusResponse_CoopGift(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ContractCoopStatusResponse.CoopGift)
}
ContractCoopStatusResponse_CoopGift::ContractCoopStatusResponse_CoopGift(const ContractCoopStatusResponse_CoopGift& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_id()) {
    user_id_.Set(from._internal_user_id(), 
      GetArenaForAllocation());
  }
  user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_name()) {
    user_name_.Set(from._internal_user_name(), 
      GetArenaForAllocation());
  }
  amount_ = from.amount_;
  // @@protoc_insertion_point(copy_constructor:ei.ContractCoopStatusResponse.CoopGift)
}

inline void ContractCoopStatusResponse_CoopGift::SharedCtor() {
user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
user_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
amount_ = 0u;
}

ContractCoopStatusResponse_CoopGift::~ContractCoopStatusResponse_CoopGift() {
  // @@protoc_insertion_point(destructor:ei.ContractCoopStatusResponse.CoopGift)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContractCoopStatusResponse_CoopGift::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_id_.Destroy();
  user_name_.Destroy();
}

void ContractCoopStatusResponse_CoopGift::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContractCoopStatusResponse_CoopGift::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ContractCoopStatusResponse.CoopGift)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      user_name_.ClearNonDefaultToEmpty();
    }
  }
  amount_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContractCoopStatusResponse_CoopGift::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractCoopStatusResponse.CoopGift.user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 amount = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_amount(&has_bits);
          amount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string user_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_user_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractCoopStatusResponse.CoopGift.user_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContractCoopStatusResponse_CoopGift::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ContractCoopStatusResponse.CoopGift)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractCoopStatusResponse.CoopGift.user_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_id(), target);
  }

  // optional uint32 amount = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_amount(), target);
  }

  // optional string user_name = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_name().data(), static_cast<int>(this->_internal_user_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractCoopStatusResponse.CoopGift.user_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_user_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ContractCoopStatusResponse.CoopGift)
  return target;
}

size_t ContractCoopStatusResponse_CoopGift::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ContractCoopStatusResponse.CoopGift)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string user_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_id());
    }

    // optional string user_name = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_name());
    }

    // optional uint32 amount = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_amount());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContractCoopStatusResponse_CoopGift::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ContractCoopStatusResponse_CoopGift::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContractCoopStatusResponse_CoopGift::GetClassData() const { return &_class_data_; }

void ContractCoopStatusResponse_CoopGift::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ContractCoopStatusResponse_CoopGift *>(to)->MergeFrom(
      static_cast<const ContractCoopStatusResponse_CoopGift &>(from));
}


void ContractCoopStatusResponse_CoopGift::MergeFrom(const ContractCoopStatusResponse_CoopGift& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ContractCoopStatusResponse.CoopGift)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_id(from._internal_user_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_user_name(from._internal_user_name());
    }
    if (cached_has_bits & 0x00000004u) {
      amount_ = from.amount_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContractCoopStatusResponse_CoopGift::CopyFrom(const ContractCoopStatusResponse_CoopGift& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ContractCoopStatusResponse.CoopGift)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContractCoopStatusResponse_CoopGift::IsInitialized() const {
  return true;
}

void ContractCoopStatusResponse_CoopGift::InternalSwap(ContractCoopStatusResponse_CoopGift* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_name_, lhs_arena,
      &other->user_name_, rhs_arena
  );
  swap(amount_, other->amount_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ContractCoopStatusResponse_CoopGift::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[61]);
}

// ===================================================================

class ContractCoopStatusResponse_ChickenRun::_Internal {
 public:
  using HasBits = decltype(std::declval<ContractCoopStatusResponse_ChickenRun>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_user_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ContractCoopStatusResponse_ChickenRun::ContractCoopStatusResponse_ChickenRun(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ContractCoopStatusResponse.ChickenRun)
}
ContractCoopStatusResponse_ChickenRun::ContractCoopStatusResponse_ChickenRun(const ContractCoopStatusResponse_ChickenRun& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_id()) {
    user_id_.Set(from._internal_user_id(), 
      GetArenaForAllocation());
  }
  user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_name()) {
    user_name_.Set(from._internal_user_name(), 
      GetArenaForAllocation());
  }
  amount_ = from.amount_;
  // @@protoc_insertion_point(copy_constructor:ei.ContractCoopStatusResponse.ChickenRun)
}

inline void ContractCoopStatusResponse_ChickenRun::SharedCtor() {
user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
user_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
amount_ = uint64_t{0u};
}

ContractCoopStatusResponse_ChickenRun::~ContractCoopStatusResponse_ChickenRun() {
  // @@protoc_insertion_point(destructor:ei.ContractCoopStatusResponse.ChickenRun)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContractCoopStatusResponse_ChickenRun::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_id_.Destroy();
  user_name_.Destroy();
}

void ContractCoopStatusResponse_ChickenRun::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContractCoopStatusResponse_ChickenRun::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ContractCoopStatusResponse.ChickenRun)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      user_name_.ClearNonDefaultToEmpty();
    }
  }
  amount_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContractCoopStatusResponse_ChickenRun::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractCoopStatusResponse.ChickenRun.user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint64 amount = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_amount(&has_bits);
          amount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string user_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_user_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractCoopStatusResponse.ChickenRun.user_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContractCoopStatusResponse_ChickenRun::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ContractCoopStatusResponse.ChickenRun)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractCoopStatusResponse.ChickenRun.user_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_id(), target);
  }

  // optional uint64 amount = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_amount(), target);
  }

  // optional string user_name = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_name().data(), static_cast<int>(this->_internal_user_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractCoopStatusResponse.ChickenRun.user_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_user_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ContractCoopStatusResponse.ChickenRun)
  return target;
}

size_t ContractCoopStatusResponse_ChickenRun::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ContractCoopStatusResponse.ChickenRun)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string user_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_id());
    }

    // optional string user_name = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_name());
    }

    // optional uint64 amount = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_amount());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContractCoopStatusResponse_ChickenRun::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ContractCoopStatusResponse_ChickenRun::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContractCoopStatusResponse_ChickenRun::GetClassData() const { return &_class_data_; }

void ContractCoopStatusResponse_ChickenRun::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ContractCoopStatusResponse_ChickenRun *>(to)->MergeFrom(
      static_cast<const ContractCoopStatusResponse_ChickenRun &>(from));
}


void ContractCoopStatusResponse_ChickenRun::MergeFrom(const ContractCoopStatusResponse_ChickenRun& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ContractCoopStatusResponse.ChickenRun)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_id(from._internal_user_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_user_name(from._internal_user_name());
    }
    if (cached_has_bits & 0x00000004u) {
      amount_ = from.amount_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContractCoopStatusResponse_ChickenRun::CopyFrom(const ContractCoopStatusResponse_ChickenRun& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ContractCoopStatusResponse.ChickenRun)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContractCoopStatusResponse_ChickenRun::IsInitialized() const {
  return true;
}

void ContractCoopStatusResponse_ChickenRun::InternalSwap(ContractCoopStatusResponse_ChickenRun* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_name_, lhs_arena,
      &other->user_name_, rhs_arena
  );
  swap(amount_, other->amount_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ContractCoopStatusResponse_ChickenRun::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[62]);
}

// ===================================================================

class ContractCoopStatusResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<ContractCoopStatusResponse>()._has_bits_);
  static void set_has_contract_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_total_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_coop_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_auto_generated(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_public_(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_creator_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_seconds_remaining(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_all_goals_achieved(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_all_members_reporting(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_grace_period_seconds_remaining(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_local_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

ContractCoopStatusResponse::ContractCoopStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  contributors_(arena),
  gifts_(arena),
  chicken_runs_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ContractCoopStatusResponse)
}
ContractCoopStatusResponse::ContractCoopStatusResponse(const ContractCoopStatusResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      contributors_(from.contributors_),
      gifts_(from.gifts_),
      chicken_runs_(from.chicken_runs_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  contract_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    contract_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contract_identifier()) {
    contract_identifier_.Set(from._internal_contract_identifier(), 
      GetArenaForAllocation());
  }
  coop_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    coop_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_coop_identifier()) {
    coop_identifier_.Set(from._internal_coop_identifier(), 
      GetArenaForAllocation());
  }
  creator_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    creator_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_creator_id()) {
    creator_id_.Set(from._internal_creator_id(), 
      GetArenaForAllocation());
  }
  ::memcpy(&total_amount_, &from.total_amount_,
    static_cast<size_t>(reinterpret_cast<char*>(&all_members_reporting_) -
    reinterpret_cast<char*>(&total_amount_)) + sizeof(all_members_reporting_));
  // @@protoc_insertion_point(copy_constructor:ei.ContractCoopStatusResponse)
}

inline void ContractCoopStatusResponse::SharedCtor() {
contract_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  contract_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
coop_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  coop_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
creator_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  creator_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&total_amount_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&all_members_reporting_) -
    reinterpret_cast<char*>(&total_amount_)) + sizeof(all_members_reporting_));
}

ContractCoopStatusResponse::~ContractCoopStatusResponse() {
  // @@protoc_insertion_point(destructor:ei.ContractCoopStatusResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContractCoopStatusResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  contract_identifier_.Destroy();
  coop_identifier_.Destroy();
  creator_id_.Destroy();
}

void ContractCoopStatusResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContractCoopStatusResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ContractCoopStatusResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  contributors_.Clear();
  gifts_.Clear();
  chicken_runs_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      contract_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      coop_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      creator_id_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&total_amount_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&auto_generated_) -
        reinterpret_cast<char*>(&total_amount_)) + sizeof(auto_generated_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&public__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&all_members_reporting_) -
        reinterpret_cast<char*>(&public__)) + sizeof(all_members_reporting_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContractCoopStatusResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string contract_identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_contract_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractCoopStatusResponse.contract_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double total_amount = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_total_amount(&has_bits);
          total_amount_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional string coop_identifier = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_coop_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractCoopStatusResponse.coop_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ContractCoopStatusResponse.ContributionInfo contributors = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_contributors(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional double seconds_remaining = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_seconds_remaining(&has_bits);
          seconds_remaining_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool all_members_reporting = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_all_members_reporting(&has_bits);
          all_members_reporting_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double grace_period_seconds_remaining = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _Internal::set_has_grace_period_seconds_remaining(&has_bits);
          grace_period_seconds_remaining_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool auto_generated = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_auto_generated(&has_bits);
          auto_generated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string creator_id = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_creator_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractCoopStatusResponse.creator_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool public = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_public_(&has_bits);
          public__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ContractCoopStatusResponse.CoopGift gifts = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_gifts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional double local_timestamp = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 97)) {
          _Internal::set_has_local_timestamp(&has_bits);
          local_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ContractCoopStatusResponse.ChickenRun chicken_runs = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_chicken_runs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool all_goals_achieved = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_all_goals_achieved(&has_bits);
          all_goals_achieved_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContractCoopStatusResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ContractCoopStatusResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string contract_identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_contract_identifier().data(), static_cast<int>(this->_internal_contract_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractCoopStatusResponse.contract_identifier");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_contract_identifier(), target);
  }

  // optional double total_amount = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_total_amount(), target);
  }

  // optional string coop_identifier = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_coop_identifier().data(), static_cast<int>(this->_internal_coop_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractCoopStatusResponse.coop_identifier");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_coop_identifier(), target);
  }

  // repeated .ei.ContractCoopStatusResponse.ContributionInfo contributors = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_contributors_size()); i < n; i++) {
    const auto& repfield = this->_internal_contributors(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional double seconds_remaining = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_seconds_remaining(), target);
  }

  // optional bool all_members_reporting = 6;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_all_members_reporting(), target);
  }

  // optional double grace_period_seconds_remaining = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_grace_period_seconds_remaining(), target);
  }

  // optional bool auto_generated = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_auto_generated(), target);
  }

  // optional string creator_id = 9;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_creator_id().data(), static_cast<int>(this->_internal_creator_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractCoopStatusResponse.creator_id");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_creator_id(), target);
  }

  // optional bool public = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_public_(), target);
  }

  // repeated .ei.ContractCoopStatusResponse.CoopGift gifts = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_gifts_size()); i < n; i++) {
    const auto& repfield = this->_internal_gifts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional double local_timestamp = 12;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(12, this->_internal_local_timestamp(), target);
  }

  // repeated .ei.ContractCoopStatusResponse.ChickenRun chicken_runs = 13;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_chicken_runs_size()); i < n; i++) {
    const auto& repfield = this->_internal_chicken_runs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool all_goals_achieved = 14;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_all_goals_achieved(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ContractCoopStatusResponse)
  return target;
}

size_t ContractCoopStatusResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ContractCoopStatusResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.ContractCoopStatusResponse.ContributionInfo contributors = 4;
  total_size += 1UL * this->_internal_contributors_size();
  for (const auto& msg : this->contributors_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.ContractCoopStatusResponse.CoopGift gifts = 11;
  total_size += 1UL * this->_internal_gifts_size();
  for (const auto& msg : this->gifts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.ContractCoopStatusResponse.ChickenRun chicken_runs = 13;
  total_size += 1UL * this->_internal_chicken_runs_size();
  for (const auto& msg : this->chicken_runs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string contract_identifier = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contract_identifier());
    }

    // optional string coop_identifier = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_coop_identifier());
    }

    // optional string creator_id = 9;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_creator_id());
    }

    // optional double total_amount = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double seconds_remaining = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double grace_period_seconds_remaining = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional double local_timestamp = 12;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional bool auto_generated = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional bool public = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool all_goals_achieved = 14;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool all_members_reporting = 6;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContractCoopStatusResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ContractCoopStatusResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContractCoopStatusResponse::GetClassData() const { return &_class_data_; }

void ContractCoopStatusResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ContractCoopStatusResponse *>(to)->MergeFrom(
      static_cast<const ContractCoopStatusResponse &>(from));
}


void ContractCoopStatusResponse::MergeFrom(const ContractCoopStatusResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ContractCoopStatusResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  contributors_.MergeFrom(from.contributors_);
  gifts_.MergeFrom(from.gifts_);
  chicken_runs_.MergeFrom(from.chicken_runs_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_contract_identifier(from._internal_contract_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_coop_identifier(from._internal_coop_identifier());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_creator_id(from._internal_creator_id());
    }
    if (cached_has_bits & 0x00000008u) {
      total_amount_ = from.total_amount_;
    }
    if (cached_has_bits & 0x00000010u) {
      seconds_remaining_ = from.seconds_remaining_;
    }
    if (cached_has_bits & 0x00000020u) {
      grace_period_seconds_remaining_ = from.grace_period_seconds_remaining_;
    }
    if (cached_has_bits & 0x00000040u) {
      local_timestamp_ = from.local_timestamp_;
    }
    if (cached_has_bits & 0x00000080u) {
      auto_generated_ = from.auto_generated_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      public__ = from.public__;
    }
    if (cached_has_bits & 0x00000200u) {
      all_goals_achieved_ = from.all_goals_achieved_;
    }
    if (cached_has_bits & 0x00000400u) {
      all_members_reporting_ = from.all_members_reporting_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContractCoopStatusResponse::CopyFrom(const ContractCoopStatusResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ContractCoopStatusResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContractCoopStatusResponse::IsInitialized() const {
  return true;
}

void ContractCoopStatusResponse::InternalSwap(ContractCoopStatusResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  contributors_.InternalSwap(&other->contributors_);
  gifts_.InternalSwap(&other->gifts_);
  chicken_runs_.InternalSwap(&other->chicken_runs_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &contract_identifier_, lhs_arena,
      &other->contract_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &coop_identifier_, lhs_arena,
      &other->coop_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &creator_id_, lhs_arena,
      &other->creator_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContractCoopStatusResponse, all_members_reporting_)
      + sizeof(ContractCoopStatusResponse::all_members_reporting_)
      - PROTOBUF_FIELD_OFFSET(ContractCoopStatusResponse, total_amount_)>(
          reinterpret_cast<char*>(&total_amount_),
          reinterpret_cast<char*>(&other->total_amount_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ContractCoopStatusResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[63]);
}

// ===================================================================

class LocalContract::_Internal {
 public:
  using HasBits = decltype(std::declval<LocalContract>()._has_bits_);
  static const ::ei::Contract& contract(const LocalContract* msg);
  static void set_has_contract(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_coop_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_accepted(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_time_accepted(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_cancelled(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_new_(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_coop_shared_end_time(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_coop_grace_period_end_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_coop_contribution_finalized(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_coop_last_uploaded_contribution(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_coop_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_coop_share_farm(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_last_amount_when_reward_given(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_num_goals_achieved(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_boosts_used(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_points_replay(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_league(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_grade(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_last_nag_time(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static const ::ei::ContractEvaluation& evaluation(const LocalContract* msg);
  static void set_has_evaluation(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::ei::Contract&
LocalContract::_Internal::contract(const LocalContract* msg) {
  return *msg->contract_;
}
const ::ei::ContractEvaluation&
LocalContract::_Internal::evaluation(const LocalContract* msg) {
  return *msg->evaluation_;
}
LocalContract::LocalContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  reported_uuids_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.LocalContract)
}
LocalContract::LocalContract(const LocalContract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      reported_uuids_(from.reported_uuids_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  coop_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    coop_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_coop_identifier()) {
    coop_identifier_.Set(from._internal_coop_identifier(), 
      GetArenaForAllocation());
  }
  coop_user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    coop_user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_coop_user_id()) {
    coop_user_id_.Set(from._internal_coop_user_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_contract()) {
    contract_ = new ::ei::Contract(*from.contract_);
  } else {
    contract_ = nullptr;
  }
  if (from._internal_has_evaluation()) {
    evaluation_ = new ::ei::ContractEvaluation(*from.evaluation_);
  } else {
    evaluation_ = nullptr;
  }
  ::memcpy(&time_accepted_, &from.time_accepted_,
    static_cast<size_t>(reinterpret_cast<char*>(&points_replay_) -
    reinterpret_cast<char*>(&time_accepted_)) + sizeof(points_replay_));
  // @@protoc_insertion_point(copy_constructor:ei.LocalContract)
}

inline void LocalContract::SharedCtor() {
coop_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  coop_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
coop_user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  coop_user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&contract_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&points_replay_) -
    reinterpret_cast<char*>(&contract_)) + sizeof(points_replay_));
}

LocalContract::~LocalContract() {
  // @@protoc_insertion_point(destructor:ei.LocalContract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LocalContract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  coop_identifier_.Destroy();
  coop_user_id_.Destroy();
  if (this != internal_default_instance()) delete contract_;
  if (this != internal_default_instance()) delete evaluation_;
}

void LocalContract::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LocalContract::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.LocalContract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  reported_uuids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      coop_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      coop_user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(contract_ != nullptr);
      contract_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(evaluation_ != nullptr);
      evaluation_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&time_accepted_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&accepted_) -
        reinterpret_cast<char*>(&time_accepted_)) + sizeof(accepted_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&cancelled_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&league_) -
        reinterpret_cast<char*>(&cancelled_)) + sizeof(league_));
  }
  if (cached_has_bits & 0x000f0000u) {
    ::memset(&last_nag_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&points_replay_) -
        reinterpret_cast<char*>(&last_nag_time_)) + sizeof(points_replay_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LocalContract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.Contract contract = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_contract(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string coop_identifier = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_coop_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.LocalContract.coop_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double time_accepted = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_time_accepted(&has_bits);
          time_accepted_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool cancelled = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_cancelled(&has_bits);
          cancelled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double coop_shared_end_time = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_coop_shared_end_time(&has_bits);
          coop_shared_end_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double last_amount_when_reward_given = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_last_amount_when_reward_given(&has_bits);
          last_amount_when_reward_given_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool accepted = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_accepted(&has_bits);
          accepted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool new = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_new_(&has_bits);
          new__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double coop_grace_period_end_time = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          _Internal::set_has_coop_grace_period_end_time(&has_bits);
          coop_grace_period_end_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool coop_contribution_finalized = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_coop_contribution_finalized(&has_bits);
          coop_contribution_finalized_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double coop_last_uploaded_contribution = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _Internal::set_has_coop_last_uploaded_contribution(&has_bits);
          coop_last_uploaded_contribution_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 boosts_used = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_boosts_used(&has_bits);
          boosts_used_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string coop_user_id = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_coop_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.LocalContract.coop_user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 num_goals_achieved = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_num_goals_achieved(&has_bits);
          num_goals_achieved_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 league = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_league(&has_bits);
          league_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double last_nag_time = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 129)) {
          _Internal::set_has_last_nag_time(&has_bits);
          last_nag_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool coop_share_farm = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_coop_share_farm(&has_bits);
          coop_share_farm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.Contract.PlayerGrade grade = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::Contract_PlayerGrade_IsValid(val))) {
            _internal_set_grade(static_cast<::ei::Contract_PlayerGrade>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(18, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .ei.ContractEvaluation evaluation = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_evaluation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool points_replay = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_points_replay(&has_bits);
          points_replay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string reported_uuids = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_reported_uuids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "ei.LocalContract.reported_uuids");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<170>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LocalContract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.LocalContract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.Contract contract = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::contract(this),
        _Internal::contract(this).GetCachedSize(), target, stream);
  }

  // optional string coop_identifier = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_coop_identifier().data(), static_cast<int>(this->_internal_coop_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.LocalContract.coop_identifier");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_coop_identifier(), target);
  }

  // optional double time_accepted = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_time_accepted(), target);
  }

  // optional bool cancelled = 4;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_cancelled(), target);
  }

  // optional double coop_shared_end_time = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_coop_shared_end_time(), target);
  }

  // optional double last_amount_when_reward_given = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_last_amount_when_reward_given(), target);
  }

  // optional bool accepted = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_accepted(), target);
  }

  // optional bool new = 8;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_new_(), target);
  }

  // optional double coop_grace_period_end_time = 9;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(9, this->_internal_coop_grace_period_end_time(), target);
  }

  // optional bool coop_contribution_finalized = 10;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_coop_contribution_finalized(), target);
  }

  // optional double coop_last_uploaded_contribution = 11;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(11, this->_internal_coop_last_uploaded_contribution(), target);
  }

  // optional uint32 boosts_used = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_boosts_used(), target);
  }

  // optional string coop_user_id = 13;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_coop_user_id().data(), static_cast<int>(this->_internal_coop_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.LocalContract.coop_user_id");
    target = stream->WriteStringMaybeAliased(
        13, this->_internal_coop_user_id(), target);
  }

  // optional uint32 num_goals_achieved = 14;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_num_goals_achieved(), target);
  }

  // optional uint32 league = 15;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_league(), target);
  }

  // optional double last_nag_time = 16;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(16, this->_internal_last_nag_time(), target);
  }

  // optional bool coop_share_farm = 17;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(17, this->_internal_coop_share_farm(), target);
  }

  // optional .ei.Contract.PlayerGrade grade = 18;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      18, this->_internal_grade(), target);
  }

  // optional .ei.ContractEvaluation evaluation = 19;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::evaluation(this),
        _Internal::evaluation(this).GetCachedSize(), target, stream);
  }

  // optional bool points_replay = 20;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(20, this->_internal_points_replay(), target);
  }

  // repeated string reported_uuids = 21;
  for (int i = 0, n = this->_internal_reported_uuids_size(); i < n; i++) {
    const auto& s = this->_internal_reported_uuids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.LocalContract.reported_uuids");
    target = stream->WriteString(21, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.LocalContract)
  return target;
}

size_t LocalContract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.LocalContract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string reported_uuids = 21;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(reported_uuids_.size());
  for (int i = 0, n = reported_uuids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      reported_uuids_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string coop_identifier = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_coop_identifier());
    }

    // optional string coop_user_id = 13;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_coop_user_id());
    }

    // optional .ei.Contract contract = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *contract_);
    }

    // optional .ei.ContractEvaluation evaluation = 19;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *evaluation_);
    }

    // optional double time_accepted = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double coop_shared_end_time = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional double last_amount_when_reward_given = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional bool accepted = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool cancelled = 4;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool new = 8;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool coop_contribution_finalized = 10;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional uint32 boosts_used = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_boosts_used());
    }

    // optional double coop_grace_period_end_time = 9;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 8;
    }

    // optional double coop_last_uploaded_contribution = 11;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 8;
    }

    // optional uint32 num_goals_achieved = 14;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_goals_achieved());
    }

    // optional uint32 league = 15;
    if (cached_has_bits & 0x00008000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_league());
    }

  }
  if (cached_has_bits & 0x000f0000u) {
    // optional double last_nag_time = 16;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 8;
    }

    // optional .ei.Contract.PlayerGrade grade = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_grade());
    }

    // optional bool coop_share_farm = 17;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 1;
    }

    // optional bool points_replay = 20;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LocalContract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LocalContract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LocalContract::GetClassData() const { return &_class_data_; }

void LocalContract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LocalContract *>(to)->MergeFrom(
      static_cast<const LocalContract &>(from));
}


void LocalContract::MergeFrom(const LocalContract& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.LocalContract)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  reported_uuids_.MergeFrom(from.reported_uuids_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_coop_identifier(from._internal_coop_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_coop_user_id(from._internal_coop_user_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_contract()->::ei::Contract::MergeFrom(from._internal_contract());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_evaluation()->::ei::ContractEvaluation::MergeFrom(from._internal_evaluation());
    }
    if (cached_has_bits & 0x00000010u) {
      time_accepted_ = from.time_accepted_;
    }
    if (cached_has_bits & 0x00000020u) {
      coop_shared_end_time_ = from.coop_shared_end_time_;
    }
    if (cached_has_bits & 0x00000040u) {
      last_amount_when_reward_given_ = from.last_amount_when_reward_given_;
    }
    if (cached_has_bits & 0x00000080u) {
      accepted_ = from.accepted_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      cancelled_ = from.cancelled_;
    }
    if (cached_has_bits & 0x00000200u) {
      new__ = from.new__;
    }
    if (cached_has_bits & 0x00000400u) {
      coop_contribution_finalized_ = from.coop_contribution_finalized_;
    }
    if (cached_has_bits & 0x00000800u) {
      boosts_used_ = from.boosts_used_;
    }
    if (cached_has_bits & 0x00001000u) {
      coop_grace_period_end_time_ = from.coop_grace_period_end_time_;
    }
    if (cached_has_bits & 0x00002000u) {
      coop_last_uploaded_contribution_ = from.coop_last_uploaded_contribution_;
    }
    if (cached_has_bits & 0x00004000u) {
      num_goals_achieved_ = from.num_goals_achieved_;
    }
    if (cached_has_bits & 0x00008000u) {
      league_ = from.league_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x000f0000u) {
    if (cached_has_bits & 0x00010000u) {
      last_nag_time_ = from.last_nag_time_;
    }
    if (cached_has_bits & 0x00020000u) {
      grade_ = from.grade_;
    }
    if (cached_has_bits & 0x00040000u) {
      coop_share_farm_ = from.coop_share_farm_;
    }
    if (cached_has_bits & 0x00080000u) {
      points_replay_ = from.points_replay_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LocalContract::CopyFrom(const LocalContract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.LocalContract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LocalContract::IsInitialized() const {
  return true;
}

void LocalContract::InternalSwap(LocalContract* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  reported_uuids_.InternalSwap(&other->reported_uuids_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &coop_identifier_, lhs_arena,
      &other->coop_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &coop_user_id_, lhs_arena,
      &other->coop_user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LocalContract, points_replay_)
      + sizeof(LocalContract::points_replay_)
      - PROTOBUF_FIELD_OFFSET(LocalContract, contract_)>(
          reinterpret_cast<char*>(&contract_),
          reinterpret_cast<char*>(&other->contract_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LocalContract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[64]);
}

// ===================================================================

class MyContracts::_Internal {
 public:
  using HasBits = decltype(std::declval<MyContracts>()._has_bits_);
  static const ::ei::ContractPlayerInfo& last_cpi(const MyContracts* msg);
  static void set_has_last_cpi(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_initial_grade_revealed(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_last_grade_progress_shown(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_show_advanced_evaluations(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::ei::ContractPlayerInfo&
MyContracts::_Internal::last_cpi(const MyContracts* msg) {
  return *msg->last_cpi_;
}
MyContracts::MyContracts(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  contracts_(arena),
  archive_(arena),
  contract_ids_seen_(arena),
  current_coop_statuses_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.MyContracts)
}
MyContracts::MyContracts(const MyContracts& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      contracts_(from.contracts_),
      archive_(from.archive_),
      contract_ids_seen_(from.contract_ids_seen_),
      current_coop_statuses_(from.current_coop_statuses_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_last_cpi()) {
    last_cpi_ = new ::ei::ContractPlayerInfo(*from.last_cpi_);
  } else {
    last_cpi_ = nullptr;
  }
  ::memcpy(&last_grade_progress_shown_, &from.last_grade_progress_shown_,
    static_cast<size_t>(reinterpret_cast<char*>(&show_advanced_evaluations_) -
    reinterpret_cast<char*>(&last_grade_progress_shown_)) + sizeof(show_advanced_evaluations_));
  // @@protoc_insertion_point(copy_constructor:ei.MyContracts)
}

inline void MyContracts::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&last_cpi_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&show_advanced_evaluations_) -
    reinterpret_cast<char*>(&last_cpi_)) + sizeof(show_advanced_evaluations_));
}

MyContracts::~MyContracts() {
  // @@protoc_insertion_point(destructor:ei.MyContracts)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MyContracts::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete last_cpi_;
}

void MyContracts::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MyContracts::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.MyContracts)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  contracts_.Clear();
  archive_.Clear();
  contract_ids_seen_.Clear();
  current_coop_statuses_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(last_cpi_ != nullptr);
    last_cpi_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&last_grade_progress_shown_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&show_advanced_evaluations_) -
        reinterpret_cast<char*>(&last_grade_progress_shown_)) + sizeof(show_advanced_evaluations_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MyContracts::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .ei.LocalContract contracts = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_contracts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.LocalContract archive = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_archive(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string contract_ids_seen = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_contract_ids_seen();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "ei.MyContracts.contract_ids_seen");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ContractCoopStatusResponse current_coop_statuses = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_current_coop_statuses(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .ei.ContractPlayerInfo last_cpi = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_last_cpi(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool initial_grade_revealed = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_initial_grade_revealed(&has_bits);
          initial_grade_revealed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double last_grade_progress_shown = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _Internal::set_has_last_grade_progress_shown(&has_bits);
          last_grade_progress_shown_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool show_advanced_evaluations = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_show_advanced_evaluations(&has_bits);
          show_advanced_evaluations_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MyContracts::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.MyContracts)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ei.LocalContract contracts = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_contracts_size()); i < n; i++) {
    const auto& repfield = this->_internal_contracts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .ei.LocalContract archive = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_archive_size()); i < n; i++) {
    const auto& repfield = this->_internal_archive(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string contract_ids_seen = 3;
  for (int i = 0, n = this->_internal_contract_ids_seen_size(); i < n; i++) {
    const auto& s = this->_internal_contract_ids_seen(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.MyContracts.contract_ids_seen");
    target = stream->WriteString(3, s, target);
  }

  // repeated .ei.ContractCoopStatusResponse current_coop_statuses = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_current_coop_statuses_size()); i < n; i++) {
    const auto& repfield = this->_internal_current_coop_statuses(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional .ei.ContractPlayerInfo last_cpi = 5;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::last_cpi(this),
        _Internal::last_cpi(this).GetCachedSize(), target, stream);
  }

  // optional bool initial_grade_revealed = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_initial_grade_revealed(), target);
  }

  // optional double last_grade_progress_shown = 7;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_last_grade_progress_shown(), target);
  }

  // optional bool show_advanced_evaluations = 8;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_show_advanced_evaluations(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.MyContracts)
  return target;
}

size_t MyContracts::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.MyContracts)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.LocalContract contracts = 1;
  total_size += 1UL * this->_internal_contracts_size();
  for (const auto& msg : this->contracts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.LocalContract archive = 2;
  total_size += 1UL * this->_internal_archive_size();
  for (const auto& msg : this->archive_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string contract_ids_seen = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(contract_ids_seen_.size());
  for (int i = 0, n = contract_ids_seen_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      contract_ids_seen_.Get(i));
  }

  // repeated .ei.ContractCoopStatusResponse current_coop_statuses = 4;
  total_size += 1UL * this->_internal_current_coop_statuses_size();
  for (const auto& msg : this->current_coop_statuses_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .ei.ContractPlayerInfo last_cpi = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *last_cpi_);
    }

    // optional double last_grade_progress_shown = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional bool initial_grade_revealed = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool show_advanced_evaluations = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MyContracts::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MyContracts::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MyContracts::GetClassData() const { return &_class_data_; }

void MyContracts::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MyContracts *>(to)->MergeFrom(
      static_cast<const MyContracts &>(from));
}


void MyContracts::MergeFrom(const MyContracts& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.MyContracts)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  contracts_.MergeFrom(from.contracts_);
  archive_.MergeFrom(from.archive_);
  contract_ids_seen_.MergeFrom(from.contract_ids_seen_);
  current_coop_statuses_.MergeFrom(from.current_coop_statuses_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_last_cpi()->::ei::ContractPlayerInfo::MergeFrom(from._internal_last_cpi());
    }
    if (cached_has_bits & 0x00000002u) {
      last_grade_progress_shown_ = from.last_grade_progress_shown_;
    }
    if (cached_has_bits & 0x00000004u) {
      initial_grade_revealed_ = from.initial_grade_revealed_;
    }
    if (cached_has_bits & 0x00000008u) {
      show_advanced_evaluations_ = from.show_advanced_evaluations_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MyContracts::CopyFrom(const MyContracts& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.MyContracts)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MyContracts::IsInitialized() const {
  return true;
}

void MyContracts::InternalSwap(MyContracts* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  contracts_.InternalSwap(&other->contracts_);
  archive_.InternalSwap(&other->archive_);
  contract_ids_seen_.InternalSwap(&other->contract_ids_seen_);
  current_coop_statuses_.InternalSwap(&other->current_coop_statuses_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MyContracts, show_advanced_evaluations_)
      + sizeof(MyContracts::show_advanced_evaluations_)
      - PROTOBUF_FIELD_OFFSET(MyContracts, last_cpi_)>(
          reinterpret_cast<char*>(&last_cpi_),
          reinterpret_cast<char*>(&other->last_cpi_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MyContracts::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[65]);
}

// ===================================================================

class QueryCoopRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<QueryCoopRequest>()._has_bits_);
  static const ::ei::BasicRequestInfo& rinfo(const QueryCoopRequest* msg);
  static void set_has_rinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_contract_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_coop_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_league(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_grade(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::ei::BasicRequestInfo&
QueryCoopRequest::_Internal::rinfo(const QueryCoopRequest* msg) {
  return *msg->rinfo_;
}
QueryCoopRequest::QueryCoopRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.QueryCoopRequest)
}
QueryCoopRequest::QueryCoopRequest(const QueryCoopRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  contract_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    contract_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contract_identifier()) {
    contract_identifier_.Set(from._internal_contract_identifier(), 
      GetArenaForAllocation());
  }
  coop_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    coop_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_coop_identifier()) {
    coop_identifier_.Set(from._internal_coop_identifier(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_rinfo()) {
    rinfo_ = new ::ei::BasicRequestInfo(*from.rinfo_);
  } else {
    rinfo_ = nullptr;
  }
  ::memcpy(&client_version_, &from.client_version_,
    static_cast<size_t>(reinterpret_cast<char*>(&grade_) -
    reinterpret_cast<char*>(&client_version_)) + sizeof(grade_));
  // @@protoc_insertion_point(copy_constructor:ei.QueryCoopRequest)
}

inline void QueryCoopRequest::SharedCtor() {
contract_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  contract_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
coop_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  coop_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rinfo_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&grade_) -
    reinterpret_cast<char*>(&rinfo_)) + sizeof(grade_));
}

QueryCoopRequest::~QueryCoopRequest() {
  // @@protoc_insertion_point(destructor:ei.QueryCoopRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void QueryCoopRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  contract_identifier_.Destroy();
  coop_identifier_.Destroy();
  if (this != internal_default_instance()) delete rinfo_;
}

void QueryCoopRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void QueryCoopRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.QueryCoopRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      contract_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      coop_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(rinfo_ != nullptr);
      rinfo_->Clear();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&client_version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&grade_) -
        reinterpret_cast<char*>(&client_version_)) + sizeof(grade_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* QueryCoopRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string contract_identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_contract_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.QueryCoopRequest.contract_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string coop_identifier = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_coop_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.QueryCoopRequest.coop_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 client_version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_client_version(&has_bits);
          client_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 league = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_league(&has_bits);
          league_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.BasicRequestInfo rinfo = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_rinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.Contract.PlayerGrade grade = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::Contract_PlayerGrade_IsValid(val))) {
            _internal_set_grade(static_cast<::ei::Contract_PlayerGrade>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* QueryCoopRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.QueryCoopRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string contract_identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_contract_identifier().data(), static_cast<int>(this->_internal_contract_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.QueryCoopRequest.contract_identifier");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_contract_identifier(), target);
  }

  // optional string coop_identifier = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_coop_identifier().data(), static_cast<int>(this->_internal_coop_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.QueryCoopRequest.coop_identifier");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_coop_identifier(), target);
  }

  // optional uint32 client_version = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_client_version(), target);
  }

  // optional uint32 league = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_league(), target);
  }

  // optional .ei.BasicRequestInfo rinfo = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::rinfo(this),
        _Internal::rinfo(this).GetCachedSize(), target, stream);
  }

  // optional .ei.Contract.PlayerGrade grade = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_grade(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.QueryCoopRequest)
  return target;
}

size_t QueryCoopRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.QueryCoopRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string contract_identifier = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contract_identifier());
    }

    // optional string coop_identifier = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_coop_identifier());
    }

    // optional .ei.BasicRequestInfo rinfo = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rinfo_);
    }

    // optional uint32 client_version = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_client_version());
    }

    // optional uint32 league = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_league());
    }

    // optional .ei.Contract.PlayerGrade grade = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_grade());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData QueryCoopRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    QueryCoopRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*QueryCoopRequest::GetClassData() const { return &_class_data_; }

void QueryCoopRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<QueryCoopRequest *>(to)->MergeFrom(
      static_cast<const QueryCoopRequest &>(from));
}


void QueryCoopRequest::MergeFrom(const QueryCoopRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.QueryCoopRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_contract_identifier(from._internal_contract_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_coop_identifier(from._internal_coop_identifier());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_rinfo()->::ei::BasicRequestInfo::MergeFrom(from._internal_rinfo());
    }
    if (cached_has_bits & 0x00000008u) {
      client_version_ = from.client_version_;
    }
    if (cached_has_bits & 0x00000010u) {
      league_ = from.league_;
    }
    if (cached_has_bits & 0x00000020u) {
      grade_ = from.grade_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void QueryCoopRequest::CopyFrom(const QueryCoopRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.QueryCoopRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QueryCoopRequest::IsInitialized() const {
  return true;
}

void QueryCoopRequest::InternalSwap(QueryCoopRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &contract_identifier_, lhs_arena,
      &other->contract_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &coop_identifier_, lhs_arena,
      &other->coop_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(QueryCoopRequest, grade_)
      + sizeof(QueryCoopRequest::grade_)
      - PROTOBUF_FIELD_OFFSET(QueryCoopRequest, rinfo_)>(
          reinterpret_cast<char*>(&rinfo_),
          reinterpret_cast<char*>(&other->rinfo_));
}

::PROTOBUF_NAMESPACE_ID::Metadata QueryCoopRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[66]);
}

// ===================================================================

class QueryCoopResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<QueryCoopResponse>()._has_bits_);
  static void set_has_exists(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_full(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_expired(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_different_league(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_different_grade(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_cc_only(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_banned(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

QueryCoopResponse::QueryCoopResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.QueryCoopResponse)
}
QueryCoopResponse::QueryCoopResponse(const QueryCoopResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&exists_, &from.exists_,
    static_cast<size_t>(reinterpret_cast<char*>(&banned_) -
    reinterpret_cast<char*>(&exists_)) + sizeof(banned_));
  // @@protoc_insertion_point(copy_constructor:ei.QueryCoopResponse)
}

inline void QueryCoopResponse::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&exists_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&banned_) -
    reinterpret_cast<char*>(&exists_)) + sizeof(banned_));
}

QueryCoopResponse::~QueryCoopResponse() {
  // @@protoc_insertion_point(destructor:ei.QueryCoopResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void QueryCoopResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void QueryCoopResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void QueryCoopResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.QueryCoopResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&exists_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&banned_) -
        reinterpret_cast<char*>(&exists_)) + sizeof(banned_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* QueryCoopResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool exists = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_exists(&has_bits);
          exists_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool full = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_full(&has_bits);
          full_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool banned = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_banned(&has_bits);
          banned_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool different_league = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_different_league(&has_bits);
          different_league_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool expired = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_expired(&has_bits);
          expired_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool different_grade = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_different_grade(&has_bits);
          different_grade_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool cc_only = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_cc_only(&has_bits);
          cc_only_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* QueryCoopResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.QueryCoopResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool exists = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_exists(), target);
  }

  // optional bool full = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_full(), target);
  }

  // optional bool banned = 3;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_banned(), target);
  }

  // optional bool different_league = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_different_league(), target);
  }

  // optional bool expired = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_expired(), target);
  }

  // optional bool different_grade = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_different_grade(), target);
  }

  // optional bool cc_only = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_cc_only(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.QueryCoopResponse)
  return target;
}

size_t QueryCoopResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.QueryCoopResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bool exists = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool full = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool expired = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool different_league = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool different_grade = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool cc_only = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool banned = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData QueryCoopResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    QueryCoopResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*QueryCoopResponse::GetClassData() const { return &_class_data_; }

void QueryCoopResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<QueryCoopResponse *>(to)->MergeFrom(
      static_cast<const QueryCoopResponse &>(from));
}


void QueryCoopResponse::MergeFrom(const QueryCoopResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.QueryCoopResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      exists_ = from.exists_;
    }
    if (cached_has_bits & 0x00000002u) {
      full_ = from.full_;
    }
    if (cached_has_bits & 0x00000004u) {
      expired_ = from.expired_;
    }
    if (cached_has_bits & 0x00000008u) {
      different_league_ = from.different_league_;
    }
    if (cached_has_bits & 0x00000010u) {
      different_grade_ = from.different_grade_;
    }
    if (cached_has_bits & 0x00000020u) {
      cc_only_ = from.cc_only_;
    }
    if (cached_has_bits & 0x00000040u) {
      banned_ = from.banned_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void QueryCoopResponse::CopyFrom(const QueryCoopResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.QueryCoopResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QueryCoopResponse::IsInitialized() const {
  return true;
}

void QueryCoopResponse::InternalSwap(QueryCoopResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(QueryCoopResponse, banned_)
      + sizeof(QueryCoopResponse::banned_)
      - PROTOBUF_FIELD_OFFSET(QueryCoopResponse, exists_)>(
          reinterpret_cast<char*>(&exists_),
          reinterpret_cast<char*>(&other->exists_));
}

::PROTOBUF_NAMESPACE_ID::Metadata QueryCoopResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[67]);
}

// ===================================================================

class CreateCoopRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CreateCoopRequest>()._has_bits_);
  static const ::ei::BasicRequestInfo& rinfo(const CreateCoopRequest* msg);
  static void set_has_rinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_contract_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_coop_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_public_(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_cc_only(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_seconds_remaining(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_user_name(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_soul_power(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_eop(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_league(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_grade(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_platform(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::ei::BasicRequestInfo&
CreateCoopRequest::_Internal::rinfo(const CreateCoopRequest* msg) {
  return *msg->rinfo_;
}
CreateCoopRequest::CreateCoopRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.CreateCoopRequest)
}
CreateCoopRequest::CreateCoopRequest(const CreateCoopRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  contract_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    contract_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contract_identifier()) {
    contract_identifier_.Set(from._internal_contract_identifier(), 
      GetArenaForAllocation());
  }
  coop_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    coop_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_coop_identifier()) {
    coop_identifier_.Set(from._internal_coop_identifier(), 
      GetArenaForAllocation());
  }
  user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_id()) {
    user_id_.Set(from._internal_user_id(), 
      GetArenaForAllocation());
  }
  user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_name()) {
    user_name_.Set(from._internal_user_name(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_rinfo()) {
    rinfo_ = new ::ei::BasicRequestInfo(*from.rinfo_);
  } else {
    rinfo_ = nullptr;
  }
  ::memcpy(&seconds_remaining_, &from.seconds_remaining_,
    static_cast<size_t>(reinterpret_cast<char*>(&platform_) -
    reinterpret_cast<char*>(&seconds_remaining_)) + sizeof(platform_));
  // @@protoc_insertion_point(copy_constructor:ei.CreateCoopRequest)
}

inline void CreateCoopRequest::SharedCtor() {
contract_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  contract_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
coop_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  coop_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
user_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rinfo_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&cc_only_) -
    reinterpret_cast<char*>(&rinfo_)) + sizeof(cc_only_));
platform_ = 1;
}

CreateCoopRequest::~CreateCoopRequest() {
  // @@protoc_insertion_point(destructor:ei.CreateCoopRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateCoopRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  contract_identifier_.Destroy();
  coop_identifier_.Destroy();
  user_id_.Destroy();
  user_name_.Destroy();
  if (this != internal_default_instance()) delete rinfo_;
}

void CreateCoopRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CreateCoopRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.CreateCoopRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      contract_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      coop_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      user_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(rinfo_ != nullptr);
      rinfo_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&seconds_remaining_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&client_version_) -
        reinterpret_cast<char*>(&seconds_remaining_)) + sizeof(client_version_));
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&league_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&cc_only_) -
        reinterpret_cast<char*>(&league_)) + sizeof(cc_only_));
    platform_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateCoopRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string contract_identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_contract_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.CreateCoopRequest.contract_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string coop_identifier = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_coop_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.CreateCoopRequest.coop_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double seconds_remaining = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_seconds_remaining(&has_bits);
          seconds_remaining_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional string user_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.CreateCoopRequest.user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string user_name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_user_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.CreateCoopRequest.user_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .ei.Platform platform = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::Platform_IsValid(val))) {
            _internal_set_platform(static_cast<::ei::Platform>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 client_version = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_client_version(&has_bits);
          client_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double soul_power = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _Internal::set_has_soul_power(&has_bits);
          soul_power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 league = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_league(&has_bits);
          league_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.BasicRequestInfo rinfo = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_rinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double eop = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _Internal::set_has_eop(&has_bits);
          eop_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.Contract.PlayerGrade grade = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::Contract_PlayerGrade_IsValid(val))) {
            _internal_set_grade(static_cast<::ei::Contract_PlayerGrade>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(12, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool public = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_public_(&has_bits);
          public__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool cc_only = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_cc_only(&has_bits);
          cc_only_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateCoopRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.CreateCoopRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string contract_identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_contract_identifier().data(), static_cast<int>(this->_internal_contract_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.CreateCoopRequest.contract_identifier");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_contract_identifier(), target);
  }

  // optional string coop_identifier = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_coop_identifier().data(), static_cast<int>(this->_internal_coop_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.CreateCoopRequest.coop_identifier");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_coop_identifier(), target);
  }

  // optional double seconds_remaining = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_seconds_remaining(), target);
  }

  // optional string user_id = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.CreateCoopRequest.user_id");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_user_id(), target);
  }

  // optional string user_name = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_name().data(), static_cast<int>(this->_internal_user_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.CreateCoopRequest.user_name");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_user_name(), target);
  }

  // optional .ei.Platform platform = 6;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_platform(), target);
  }

  // optional uint32 client_version = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_client_version(), target);
  }

  // optional double soul_power = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_soul_power(), target);
  }

  // optional uint32 league = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_league(), target);
  }

  // optional .ei.BasicRequestInfo rinfo = 10;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::rinfo(this),
        _Internal::rinfo(this).GetCachedSize(), target, stream);
  }

  // optional double eop = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(11, this->_internal_eop(), target);
  }

  // optional .ei.Contract.PlayerGrade grade = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      12, this->_internal_grade(), target);
  }

  // optional bool public = 13;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_public_(), target);
  }

  // optional bool cc_only = 14;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_cc_only(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.CreateCoopRequest)
  return target;
}

size_t CreateCoopRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.CreateCoopRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string contract_identifier = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contract_identifier());
    }

    // optional string coop_identifier = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_coop_identifier());
    }

    // optional string user_id = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_id());
    }

    // optional string user_name = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_name());
    }

    // optional .ei.BasicRequestInfo rinfo = 10;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rinfo_);
    }

    // optional double seconds_remaining = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional double soul_power = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional uint32 client_version = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_client_version());
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional uint32 league = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_league());
    }

    // optional double eop = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional .ei.Contract.PlayerGrade grade = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_grade());
    }

    // optional bool public = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool cc_only = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional .ei.Platform platform = 6;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_platform());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateCoopRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CreateCoopRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateCoopRequest::GetClassData() const { return &_class_data_; }

void CreateCoopRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CreateCoopRequest *>(to)->MergeFrom(
      static_cast<const CreateCoopRequest &>(from));
}


void CreateCoopRequest::MergeFrom(const CreateCoopRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.CreateCoopRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_contract_identifier(from._internal_contract_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_coop_identifier(from._internal_coop_identifier());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_user_id(from._internal_user_id());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_user_name(from._internal_user_name());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_rinfo()->::ei::BasicRequestInfo::MergeFrom(from._internal_rinfo());
    }
    if (cached_has_bits & 0x00000020u) {
      seconds_remaining_ = from.seconds_remaining_;
    }
    if (cached_has_bits & 0x00000040u) {
      soul_power_ = from.soul_power_;
    }
    if (cached_has_bits & 0x00000080u) {
      client_version_ = from.client_version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      league_ = from.league_;
    }
    if (cached_has_bits & 0x00000200u) {
      eop_ = from.eop_;
    }
    if (cached_has_bits & 0x00000400u) {
      grade_ = from.grade_;
    }
    if (cached_has_bits & 0x00000800u) {
      public__ = from.public__;
    }
    if (cached_has_bits & 0x00001000u) {
      cc_only_ = from.cc_only_;
    }
    if (cached_has_bits & 0x00002000u) {
      platform_ = from.platform_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateCoopRequest::CopyFrom(const CreateCoopRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.CreateCoopRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateCoopRequest::IsInitialized() const {
  return true;
}

void CreateCoopRequest::InternalSwap(CreateCoopRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &contract_identifier_, lhs_arena,
      &other->contract_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &coop_identifier_, lhs_arena,
      &other->coop_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_name_, lhs_arena,
      &other->user_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CreateCoopRequest, cc_only_)
      + sizeof(CreateCoopRequest::cc_only_)
      - PROTOBUF_FIELD_OFFSET(CreateCoopRequest, rinfo_)>(
          reinterpret_cast<char*>(&rinfo_),
          reinterpret_cast<char*>(&other->rinfo_));
  swap(platform_, other->platform_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateCoopRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[68]);
}

// ===================================================================

class CreateCoopResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CreateCoopResponse>()._has_bits_);
  static void set_has_success(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CreateCoopResponse::CreateCoopResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.CreateCoopResponse)
}
CreateCoopResponse::CreateCoopResponse(const CreateCoopResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    message_.Set(from._internal_message(), 
      GetArenaForAllocation());
  }
  success_ = from.success_;
  // @@protoc_insertion_point(copy_constructor:ei.CreateCoopResponse)
}

inline void CreateCoopResponse::SharedCtor() {
message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
success_ = false;
}

CreateCoopResponse::~CreateCoopResponse() {
  // @@protoc_insertion_point(destructor:ei.CreateCoopResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateCoopResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  message_.Destroy();
}

void CreateCoopResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CreateCoopResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.CreateCoopResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    message_.ClearNonDefaultToEmpty();
  }
  success_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateCoopResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool success = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_success(&has_bits);
          success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.CreateCoopResponse.message");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateCoopResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.CreateCoopResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool success = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_success(), target);
  }

  // optional string message = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_message().data(), static_cast<int>(this->_internal_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.CreateCoopResponse.message");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.CreateCoopResponse)
  return target;
}

size_t CreateCoopResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.CreateCoopResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string message = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_message());
    }

    // optional bool success = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateCoopResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CreateCoopResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateCoopResponse::GetClassData() const { return &_class_data_; }

void CreateCoopResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CreateCoopResponse *>(to)->MergeFrom(
      static_cast<const CreateCoopResponse &>(from));
}


void CreateCoopResponse::MergeFrom(const CreateCoopResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.CreateCoopResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      success_ = from.success_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateCoopResponse::CopyFrom(const CreateCoopResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.CreateCoopResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateCoopResponse::IsInitialized() const {
  return true;
}

void CreateCoopResponse::InternalSwap(CreateCoopResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &message_, lhs_arena,
      &other->message_, rhs_arena
  );
  swap(success_, other->success_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateCoopResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[69]);
}

// ===================================================================

class JoinCoopRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<JoinCoopRequest>()._has_bits_);
  static const ::ei::BasicRequestInfo& rinfo(const JoinCoopRequest* msg);
  static void set_has_rinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_contract_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_coop_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_user_name(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_soul_power(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_eop(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_league(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_grade(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_platform(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_seconds_remaining(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::ei::BasicRequestInfo&
JoinCoopRequest::_Internal::rinfo(const JoinCoopRequest* msg) {
  return *msg->rinfo_;
}
JoinCoopRequest::JoinCoopRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.JoinCoopRequest)
}
JoinCoopRequest::JoinCoopRequest(const JoinCoopRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  contract_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    contract_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contract_identifier()) {
    contract_identifier_.Set(from._internal_contract_identifier(), 
      GetArenaForAllocation());
  }
  coop_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    coop_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_coop_identifier()) {
    coop_identifier_.Set(from._internal_coop_identifier(), 
      GetArenaForAllocation());
  }
  user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_id()) {
    user_id_.Set(from._internal_user_id(), 
      GetArenaForAllocation());
  }
  user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_name()) {
    user_name_.Set(from._internal_user_name(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_rinfo()) {
    rinfo_ = new ::ei::BasicRequestInfo(*from.rinfo_);
  } else {
    rinfo_ = nullptr;
  }
  ::memcpy(&soul_power_, &from.soul_power_,
    static_cast<size_t>(reinterpret_cast<char*>(&platform_) -
    reinterpret_cast<char*>(&soul_power_)) + sizeof(platform_));
  // @@protoc_insertion_point(copy_constructor:ei.JoinCoopRequest)
}

inline void JoinCoopRequest::SharedCtor() {
contract_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  contract_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
coop_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  coop_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
user_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rinfo_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&grade_) -
    reinterpret_cast<char*>(&rinfo_)) + sizeof(grade_));
platform_ = 1;
}

JoinCoopRequest::~JoinCoopRequest() {
  // @@protoc_insertion_point(destructor:ei.JoinCoopRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void JoinCoopRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  contract_identifier_.Destroy();
  coop_identifier_.Destroy();
  user_id_.Destroy();
  user_name_.Destroy();
  if (this != internal_default_instance()) delete rinfo_;
}

void JoinCoopRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void JoinCoopRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.JoinCoopRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      contract_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      coop_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      user_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(rinfo_ != nullptr);
      rinfo_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&soul_power_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&league_) -
        reinterpret_cast<char*>(&soul_power_)) + sizeof(league_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&seconds_remaining_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&grade_) -
        reinterpret_cast<char*>(&seconds_remaining_)) + sizeof(grade_));
    platform_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* JoinCoopRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string contract_identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_contract_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.JoinCoopRequest.contract_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string coop_identifier = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_coop_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.JoinCoopRequest.coop_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string user_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.JoinCoopRequest.user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string user_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_user_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.JoinCoopRequest.user_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .ei.Platform platform = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::Platform_IsValid(val))) {
            _internal_set_platform(static_cast<::ei::Platform>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 client_version = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_client_version(&has_bits);
          client_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double soul_power = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _Internal::set_has_soul_power(&has_bits);
          soul_power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 league = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_league(&has_bits);
          league_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.BasicRequestInfo rinfo = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_rinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double seconds_remaining = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _Internal::set_has_seconds_remaining(&has_bits);
          seconds_remaining_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double eop = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 97)) {
          _Internal::set_has_eop(&has_bits);
          eop_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.Contract.PlayerGrade grade = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::Contract_PlayerGrade_IsValid(val))) {
            _internal_set_grade(static_cast<::ei::Contract_PlayerGrade>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(13, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* JoinCoopRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.JoinCoopRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string contract_identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_contract_identifier().data(), static_cast<int>(this->_internal_contract_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.JoinCoopRequest.contract_identifier");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_contract_identifier(), target);
  }

  // optional string coop_identifier = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_coop_identifier().data(), static_cast<int>(this->_internal_coop_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.JoinCoopRequest.coop_identifier");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_coop_identifier(), target);
  }

  // optional string user_id = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.JoinCoopRequest.user_id");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_user_id(), target);
  }

  // optional string user_name = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_name().data(), static_cast<int>(this->_internal_user_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.JoinCoopRequest.user_name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_user_name(), target);
  }

  // optional .ei.Platform platform = 5;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_platform(), target);
  }

  // optional uint32 client_version = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_client_version(), target);
  }

  // optional double soul_power = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_soul_power(), target);
  }

  // optional uint32 league = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_league(), target);
  }

  // optional .ei.BasicRequestInfo rinfo = 10;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::rinfo(this),
        _Internal::rinfo(this).GetCachedSize(), target, stream);
  }

  // optional double seconds_remaining = 11;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(11, this->_internal_seconds_remaining(), target);
  }

  // optional double eop = 12;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(12, this->_internal_eop(), target);
  }

  // optional .ei.Contract.PlayerGrade grade = 13;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      13, this->_internal_grade(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.JoinCoopRequest)
  return target;
}

size_t JoinCoopRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.JoinCoopRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string contract_identifier = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contract_identifier());
    }

    // optional string coop_identifier = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_coop_identifier());
    }

    // optional string user_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_id());
    }

    // optional string user_name = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_name());
    }

    // optional .ei.BasicRequestInfo rinfo = 10;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rinfo_);
    }

    // optional double soul_power = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional uint32 client_version = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_client_version());
    }

    // optional uint32 league = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_league());
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional double seconds_remaining = 11;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 8;
    }

    // optional double eop = 12;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional .ei.Contract.PlayerGrade grade = 13;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_grade());
    }

    // optional .ei.Platform platform = 5;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_platform());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData JoinCoopRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    JoinCoopRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*JoinCoopRequest::GetClassData() const { return &_class_data_; }

void JoinCoopRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<JoinCoopRequest *>(to)->MergeFrom(
      static_cast<const JoinCoopRequest &>(from));
}


void JoinCoopRequest::MergeFrom(const JoinCoopRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.JoinCoopRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_contract_identifier(from._internal_contract_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_coop_identifier(from._internal_coop_identifier());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_user_id(from._internal_user_id());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_user_name(from._internal_user_name());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_rinfo()->::ei::BasicRequestInfo::MergeFrom(from._internal_rinfo());
    }
    if (cached_has_bits & 0x00000020u) {
      soul_power_ = from.soul_power_;
    }
    if (cached_has_bits & 0x00000040u) {
      client_version_ = from.client_version_;
    }
    if (cached_has_bits & 0x00000080u) {
      league_ = from.league_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      seconds_remaining_ = from.seconds_remaining_;
    }
    if (cached_has_bits & 0x00000200u) {
      eop_ = from.eop_;
    }
    if (cached_has_bits & 0x00000400u) {
      grade_ = from.grade_;
    }
    if (cached_has_bits & 0x00000800u) {
      platform_ = from.platform_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void JoinCoopRequest::CopyFrom(const JoinCoopRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.JoinCoopRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JoinCoopRequest::IsInitialized() const {
  return true;
}

void JoinCoopRequest::InternalSwap(JoinCoopRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &contract_identifier_, lhs_arena,
      &other->contract_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &coop_identifier_, lhs_arena,
      &other->coop_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_name_, lhs_arena,
      &other->user_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(JoinCoopRequest, grade_)
      + sizeof(JoinCoopRequest::grade_)
      - PROTOBUF_FIELD_OFFSET(JoinCoopRequest, rinfo_)>(
          reinterpret_cast<char*>(&rinfo_),
          reinterpret_cast<char*>(&other->rinfo_));
  swap(platform_, other->platform_);
}

::PROTOBUF_NAMESPACE_ID::Metadata JoinCoopRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[70]);
}

// ===================================================================

class JoinCoopResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<JoinCoopResponse>()._has_bits_);
  static void set_has_success(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_banned(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_coop_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_seconds_remaining(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_match_percent(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_num_members(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_grade(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_can_start(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

JoinCoopResponse::JoinCoopResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.JoinCoopResponse)
}
JoinCoopResponse::JoinCoopResponse(const JoinCoopResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    message_.Set(from._internal_message(), 
      GetArenaForAllocation());
  }
  coop_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    coop_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_coop_identifier()) {
    coop_identifier_.Set(from._internal_coop_identifier(), 
      GetArenaForAllocation());
  }
  ::memcpy(&seconds_remaining_, &from.seconds_remaining_,
    static_cast<size_t>(reinterpret_cast<char*>(&grade_) -
    reinterpret_cast<char*>(&seconds_remaining_)) + sizeof(grade_));
  // @@protoc_insertion_point(copy_constructor:ei.JoinCoopResponse)
}

inline void JoinCoopResponse::SharedCtor() {
message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
coop_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  coop_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&seconds_remaining_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&grade_) -
    reinterpret_cast<char*>(&seconds_remaining_)) + sizeof(grade_));
}

JoinCoopResponse::~JoinCoopResponse() {
  // @@protoc_insertion_point(destructor:ei.JoinCoopResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void JoinCoopResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  message_.Destroy();
  coop_identifier_.Destroy();
}

void JoinCoopResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void JoinCoopResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.JoinCoopResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      coop_identifier_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&seconds_remaining_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&match_percent_) -
        reinterpret_cast<char*>(&seconds_remaining_)) + sizeof(match_percent_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&status_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&grade_) -
        reinterpret_cast<char*>(&status_)) + sizeof(grade_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* JoinCoopResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool success = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_success(&has_bits);
          success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.JoinCoopResponse.message");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double seconds_remaining = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_seconds_remaining(&has_bits);
          seconds_remaining_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool banned = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_banned(&has_bits);
          banned_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string coop_identifier = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_coop_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.JoinCoopResponse.coop_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double match_percent = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_match_percent(&has_bits);
          match_percent_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 num_members = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_num_members(&has_bits);
          num_members_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.ContractCoopStatusResponse.Status status = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::ContractCoopStatusResponse_Status_IsValid(val))) {
            _internal_set_status(static_cast<::ei::ContractCoopStatusResponse_Status>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .ei.Contract.PlayerGrade grade = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::Contract_PlayerGrade_IsValid(val))) {
            _internal_set_grade(static_cast<::ei::Contract_PlayerGrade>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool can_start = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_can_start(&has_bits);
          can_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* JoinCoopResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.JoinCoopResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool success = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_success(), target);
  }

  // optional string message = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_message().data(), static_cast<int>(this->_internal_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.JoinCoopResponse.message");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_message(), target);
  }

  // optional double seconds_remaining = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_seconds_remaining(), target);
  }

  // optional bool banned = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_banned(), target);
  }

  // optional string coop_identifier = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_coop_identifier().data(), static_cast<int>(this->_internal_coop_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.JoinCoopResponse.coop_identifier");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_coop_identifier(), target);
  }

  // optional double match_percent = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_match_percent(), target);
  }

  // optional uint32 num_members = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_num_members(), target);
  }

  // optional .ei.ContractCoopStatusResponse.Status status = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_status(), target);
  }

  // optional .ei.Contract.PlayerGrade grade = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_grade(), target);
  }

  // optional bool can_start = 10;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_can_start(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.JoinCoopResponse)
  return target;
}

size_t JoinCoopResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.JoinCoopResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string message = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_message());
    }

    // optional string coop_identifier = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_coop_identifier());
    }

    // optional double seconds_remaining = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional bool success = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool banned = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool can_start = 10;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional uint32 num_members = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_members());
    }

    // optional double match_percent = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional .ei.ContractCoopStatusResponse.Status status = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
    }

    // optional .ei.Contract.PlayerGrade grade = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_grade());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData JoinCoopResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    JoinCoopResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*JoinCoopResponse::GetClassData() const { return &_class_data_; }

void JoinCoopResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<JoinCoopResponse *>(to)->MergeFrom(
      static_cast<const JoinCoopResponse &>(from));
}


void JoinCoopResponse::MergeFrom(const JoinCoopResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.JoinCoopResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_coop_identifier(from._internal_coop_identifier());
    }
    if (cached_has_bits & 0x00000004u) {
      seconds_remaining_ = from.seconds_remaining_;
    }
    if (cached_has_bits & 0x00000008u) {
      success_ = from.success_;
    }
    if (cached_has_bits & 0x00000010u) {
      banned_ = from.banned_;
    }
    if (cached_has_bits & 0x00000020u) {
      can_start_ = from.can_start_;
    }
    if (cached_has_bits & 0x00000040u) {
      num_members_ = from.num_members_;
    }
    if (cached_has_bits & 0x00000080u) {
      match_percent_ = from.match_percent_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      status_ = from.status_;
    }
    if (cached_has_bits & 0x00000200u) {
      grade_ = from.grade_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void JoinCoopResponse::CopyFrom(const JoinCoopResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.JoinCoopResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JoinCoopResponse::IsInitialized() const {
  return true;
}

void JoinCoopResponse::InternalSwap(JoinCoopResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &message_, lhs_arena,
      &other->message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &coop_identifier_, lhs_arena,
      &other->coop_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(JoinCoopResponse, grade_)
      + sizeof(JoinCoopResponse::grade_)
      - PROTOBUF_FIELD_OFFSET(JoinCoopResponse, seconds_remaining_)>(
          reinterpret_cast<char*>(&seconds_remaining_),
          reinterpret_cast<char*>(&other->seconds_remaining_));
}

::PROTOBUF_NAMESPACE_ID::Metadata JoinCoopResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[71]);
}

// ===================================================================

class AutoJoinCoopRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<AutoJoinCoopRequest>()._has_bits_);
  static const ::ei::BasicRequestInfo& rinfo(const AutoJoinCoopRequest* msg);
  static void set_has_rinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_contract_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_user_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_soul_power(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_eop(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_league(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_grade(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_seconds_remaining(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_platform(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::ei::BasicRequestInfo&
AutoJoinCoopRequest::_Internal::rinfo(const AutoJoinCoopRequest* msg) {
  return *msg->rinfo_;
}
AutoJoinCoopRequest::AutoJoinCoopRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.AutoJoinCoopRequest)
}
AutoJoinCoopRequest::AutoJoinCoopRequest(const AutoJoinCoopRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  contract_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    contract_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contract_identifier()) {
    contract_identifier_.Set(from._internal_contract_identifier(), 
      GetArenaForAllocation());
  }
  user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_id()) {
    user_id_.Set(from._internal_user_id(), 
      GetArenaForAllocation());
  }
  user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_name()) {
    user_name_.Set(from._internal_user_name(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_rinfo()) {
    rinfo_ = new ::ei::BasicRequestInfo(*from.rinfo_);
  } else {
    rinfo_ = nullptr;
  }
  ::memcpy(&soul_power_, &from.soul_power_,
    static_cast<size_t>(reinterpret_cast<char*>(&platform_) -
    reinterpret_cast<char*>(&soul_power_)) + sizeof(platform_));
  // @@protoc_insertion_point(copy_constructor:ei.AutoJoinCoopRequest)
}

inline void AutoJoinCoopRequest::SharedCtor() {
contract_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  contract_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
user_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rinfo_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&grade_) -
    reinterpret_cast<char*>(&rinfo_)) + sizeof(grade_));
platform_ = 1;
}

AutoJoinCoopRequest::~AutoJoinCoopRequest() {
  // @@protoc_insertion_point(destructor:ei.AutoJoinCoopRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AutoJoinCoopRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  contract_identifier_.Destroy();
  user_id_.Destroy();
  user_name_.Destroy();
  if (this != internal_default_instance()) delete rinfo_;
}

void AutoJoinCoopRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AutoJoinCoopRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.AutoJoinCoopRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      contract_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      user_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(rinfo_ != nullptr);
      rinfo_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&soul_power_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&league_) -
        reinterpret_cast<char*>(&soul_power_)) + sizeof(league_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&eop_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&grade_) -
        reinterpret_cast<char*>(&eop_)) + sizeof(grade_));
    platform_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AutoJoinCoopRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string contract_identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_contract_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AutoJoinCoopRequest.contract_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string user_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AutoJoinCoopRequest.user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string user_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_user_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AutoJoinCoopRequest.user_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double soul_power = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_soul_power(&has_bits);
          soul_power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double seconds_remaining = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_seconds_remaining(&has_bits);
          seconds_remaining_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.Platform platform = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::Platform_IsValid(val))) {
            _internal_set_platform(static_cast<::ei::Platform>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 client_version = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_client_version(&has_bits);
          client_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 league = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_league(&has_bits);
          league_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.BasicRequestInfo rinfo = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_rinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double eop = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _Internal::set_has_eop(&has_bits);
          eop_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.Contract.PlayerGrade grade = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::Contract_PlayerGrade_IsValid(val))) {
            _internal_set_grade(static_cast<::ei::Contract_PlayerGrade>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(12, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AutoJoinCoopRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.AutoJoinCoopRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string contract_identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_contract_identifier().data(), static_cast<int>(this->_internal_contract_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AutoJoinCoopRequest.contract_identifier");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_contract_identifier(), target);
  }

  // optional string user_id = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AutoJoinCoopRequest.user_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_user_id(), target);
  }

  // optional string user_name = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_name().data(), static_cast<int>(this->_internal_user_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AutoJoinCoopRequest.user_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_user_name(), target);
  }

  // optional double soul_power = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_soul_power(), target);
  }

  // optional double seconds_remaining = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_seconds_remaining(), target);
  }

  // optional .ei.Platform platform = 6;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_platform(), target);
  }

  // optional uint32 client_version = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_client_version(), target);
  }

  // optional uint32 league = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_league(), target);
  }

  // optional .ei.BasicRequestInfo rinfo = 9;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::rinfo(this),
        _Internal::rinfo(this).GetCachedSize(), target, stream);
  }

  // optional double eop = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(10, this->_internal_eop(), target);
  }

  // optional .ei.Contract.PlayerGrade grade = 12;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      12, this->_internal_grade(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.AutoJoinCoopRequest)
  return target;
}

size_t AutoJoinCoopRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.AutoJoinCoopRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string contract_identifier = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contract_identifier());
    }

    // optional string user_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_id());
    }

    // optional string user_name = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_name());
    }

    // optional .ei.BasicRequestInfo rinfo = 9;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rinfo_);
    }

    // optional double soul_power = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double seconds_remaining = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional uint32 client_version = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_client_version());
    }

    // optional uint32 league = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_league());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional double eop = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 8;
    }

    // optional .ei.Contract.PlayerGrade grade = 12;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_grade());
    }

    // optional .ei.Platform platform = 6;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_platform());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AutoJoinCoopRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AutoJoinCoopRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AutoJoinCoopRequest::GetClassData() const { return &_class_data_; }

void AutoJoinCoopRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AutoJoinCoopRequest *>(to)->MergeFrom(
      static_cast<const AutoJoinCoopRequest &>(from));
}


void AutoJoinCoopRequest::MergeFrom(const AutoJoinCoopRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.AutoJoinCoopRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_contract_identifier(from._internal_contract_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_user_id(from._internal_user_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_user_name(from._internal_user_name());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_rinfo()->::ei::BasicRequestInfo::MergeFrom(from._internal_rinfo());
    }
    if (cached_has_bits & 0x00000010u) {
      soul_power_ = from.soul_power_;
    }
    if (cached_has_bits & 0x00000020u) {
      seconds_remaining_ = from.seconds_remaining_;
    }
    if (cached_has_bits & 0x00000040u) {
      client_version_ = from.client_version_;
    }
    if (cached_has_bits & 0x00000080u) {
      league_ = from.league_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      eop_ = from.eop_;
    }
    if (cached_has_bits & 0x00000200u) {
      grade_ = from.grade_;
    }
    if (cached_has_bits & 0x00000400u) {
      platform_ = from.platform_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AutoJoinCoopRequest::CopyFrom(const AutoJoinCoopRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.AutoJoinCoopRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AutoJoinCoopRequest::IsInitialized() const {
  return true;
}

void AutoJoinCoopRequest::InternalSwap(AutoJoinCoopRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &contract_identifier_, lhs_arena,
      &other->contract_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_name_, lhs_arena,
      &other->user_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AutoJoinCoopRequest, grade_)
      + sizeof(AutoJoinCoopRequest::grade_)
      - PROTOBUF_FIELD_OFFSET(AutoJoinCoopRequest, rinfo_)>(
          reinterpret_cast<char*>(&rinfo_),
          reinterpret_cast<char*>(&other->rinfo_));
  swap(platform_, other->platform_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AutoJoinCoopRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[72]);
}

// ===================================================================

class UpdateCoopPermissionsRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<UpdateCoopPermissionsRequest>()._has_bits_);
  static const ::ei::BasicRequestInfo& rinfo(const UpdateCoopPermissionsRequest* msg);
  static void set_has_rinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_contract_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_coop_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_requesting_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_public_(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::ei::BasicRequestInfo&
UpdateCoopPermissionsRequest::_Internal::rinfo(const UpdateCoopPermissionsRequest* msg) {
  return *msg->rinfo_;
}
UpdateCoopPermissionsRequest::UpdateCoopPermissionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.UpdateCoopPermissionsRequest)
}
UpdateCoopPermissionsRequest::UpdateCoopPermissionsRequest(const UpdateCoopPermissionsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  contract_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    contract_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contract_identifier()) {
    contract_identifier_.Set(from._internal_contract_identifier(), 
      GetArenaForAllocation());
  }
  coop_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    coop_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_coop_identifier()) {
    coop_identifier_.Set(from._internal_coop_identifier(), 
      GetArenaForAllocation());
  }
  requesting_user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    requesting_user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_requesting_user_id()) {
    requesting_user_id_.Set(from._internal_requesting_user_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_rinfo()) {
    rinfo_ = new ::ei::BasicRequestInfo(*from.rinfo_);
  } else {
    rinfo_ = nullptr;
  }
  ::memcpy(&public__, &from.public__,
    static_cast<size_t>(reinterpret_cast<char*>(&client_version_) -
    reinterpret_cast<char*>(&public__)) + sizeof(client_version_));
  // @@protoc_insertion_point(copy_constructor:ei.UpdateCoopPermissionsRequest)
}

inline void UpdateCoopPermissionsRequest::SharedCtor() {
contract_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  contract_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
coop_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  coop_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
requesting_user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  requesting_user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rinfo_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&client_version_) -
    reinterpret_cast<char*>(&rinfo_)) + sizeof(client_version_));
}

UpdateCoopPermissionsRequest::~UpdateCoopPermissionsRequest() {
  // @@protoc_insertion_point(destructor:ei.UpdateCoopPermissionsRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateCoopPermissionsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  contract_identifier_.Destroy();
  coop_identifier_.Destroy();
  requesting_user_id_.Destroy();
  if (this != internal_default_instance()) delete rinfo_;
}

void UpdateCoopPermissionsRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UpdateCoopPermissionsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.UpdateCoopPermissionsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      contract_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      coop_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      requesting_user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(rinfo_ != nullptr);
      rinfo_->Clear();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    ::memset(&public__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&client_version_) -
        reinterpret_cast<char*>(&public__)) + sizeof(client_version_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateCoopPermissionsRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string contract_identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_contract_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.UpdateCoopPermissionsRequest.contract_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string coop_identifier = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_coop_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.UpdateCoopPermissionsRequest.coop_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string requesting_user_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_requesting_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.UpdateCoopPermissionsRequest.requesting_user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool public = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_public_(&has_bits);
          public__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 client_version = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_client_version(&has_bits);
          client_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.BasicRequestInfo rinfo = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_rinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateCoopPermissionsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.UpdateCoopPermissionsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string contract_identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_contract_identifier().data(), static_cast<int>(this->_internal_contract_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.UpdateCoopPermissionsRequest.contract_identifier");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_contract_identifier(), target);
  }

  // optional string coop_identifier = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_coop_identifier().data(), static_cast<int>(this->_internal_coop_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.UpdateCoopPermissionsRequest.coop_identifier");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_coop_identifier(), target);
  }

  // optional string requesting_user_id = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_requesting_user_id().data(), static_cast<int>(this->_internal_requesting_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.UpdateCoopPermissionsRequest.requesting_user_id");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_requesting_user_id(), target);
  }

  // optional bool public = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_public_(), target);
  }

  // optional uint32 client_version = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_client_version(), target);
  }

  // optional .ei.BasicRequestInfo rinfo = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::rinfo(this),
        _Internal::rinfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.UpdateCoopPermissionsRequest)
  return target;
}

size_t UpdateCoopPermissionsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.UpdateCoopPermissionsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string contract_identifier = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contract_identifier());
    }

    // optional string coop_identifier = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_coop_identifier());
    }

    // optional string requesting_user_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_requesting_user_id());
    }

    // optional .ei.BasicRequestInfo rinfo = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rinfo_);
    }

    // optional bool public = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional uint32 client_version = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_client_version());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateCoopPermissionsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UpdateCoopPermissionsRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateCoopPermissionsRequest::GetClassData() const { return &_class_data_; }

void UpdateCoopPermissionsRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UpdateCoopPermissionsRequest *>(to)->MergeFrom(
      static_cast<const UpdateCoopPermissionsRequest &>(from));
}


void UpdateCoopPermissionsRequest::MergeFrom(const UpdateCoopPermissionsRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.UpdateCoopPermissionsRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_contract_identifier(from._internal_contract_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_coop_identifier(from._internal_coop_identifier());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_requesting_user_id(from._internal_requesting_user_id());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_rinfo()->::ei::BasicRequestInfo::MergeFrom(from._internal_rinfo());
    }
    if (cached_has_bits & 0x00000010u) {
      public__ = from.public__;
    }
    if (cached_has_bits & 0x00000020u) {
      client_version_ = from.client_version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateCoopPermissionsRequest::CopyFrom(const UpdateCoopPermissionsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.UpdateCoopPermissionsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateCoopPermissionsRequest::IsInitialized() const {
  return true;
}

void UpdateCoopPermissionsRequest::InternalSwap(UpdateCoopPermissionsRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &contract_identifier_, lhs_arena,
      &other->contract_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &coop_identifier_, lhs_arena,
      &other->coop_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &requesting_user_id_, lhs_arena,
      &other->requesting_user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpdateCoopPermissionsRequest, client_version_)
      + sizeof(UpdateCoopPermissionsRequest::client_version_)
      - PROTOBUF_FIELD_OFFSET(UpdateCoopPermissionsRequest, rinfo_)>(
          reinterpret_cast<char*>(&rinfo_),
          reinterpret_cast<char*>(&other->rinfo_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateCoopPermissionsRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[73]);
}

// ===================================================================

class UpdateCoopPermissionsResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<UpdateCoopPermissionsResponse>()._has_bits_);
  static void set_has_success(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

UpdateCoopPermissionsResponse::UpdateCoopPermissionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.UpdateCoopPermissionsResponse)
}
UpdateCoopPermissionsResponse::UpdateCoopPermissionsResponse(const UpdateCoopPermissionsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    message_.Set(from._internal_message(), 
      GetArenaForAllocation());
  }
  success_ = from.success_;
  // @@protoc_insertion_point(copy_constructor:ei.UpdateCoopPermissionsResponse)
}

inline void UpdateCoopPermissionsResponse::SharedCtor() {
message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
success_ = false;
}

UpdateCoopPermissionsResponse::~UpdateCoopPermissionsResponse() {
  // @@protoc_insertion_point(destructor:ei.UpdateCoopPermissionsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateCoopPermissionsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  message_.Destroy();
}

void UpdateCoopPermissionsResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UpdateCoopPermissionsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.UpdateCoopPermissionsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    message_.ClearNonDefaultToEmpty();
  }
  success_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateCoopPermissionsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool success = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_success(&has_bits);
          success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.UpdateCoopPermissionsResponse.message");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateCoopPermissionsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.UpdateCoopPermissionsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool success = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_success(), target);
  }

  // optional string message = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_message().data(), static_cast<int>(this->_internal_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.UpdateCoopPermissionsResponse.message");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.UpdateCoopPermissionsResponse)
  return target;
}

size_t UpdateCoopPermissionsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.UpdateCoopPermissionsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string message = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_message());
    }

    // optional bool success = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateCoopPermissionsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UpdateCoopPermissionsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateCoopPermissionsResponse::GetClassData() const { return &_class_data_; }

void UpdateCoopPermissionsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UpdateCoopPermissionsResponse *>(to)->MergeFrom(
      static_cast<const UpdateCoopPermissionsResponse &>(from));
}


void UpdateCoopPermissionsResponse::MergeFrom(const UpdateCoopPermissionsResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.UpdateCoopPermissionsResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      success_ = from.success_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateCoopPermissionsResponse::CopyFrom(const UpdateCoopPermissionsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.UpdateCoopPermissionsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateCoopPermissionsResponse::IsInitialized() const {
  return true;
}

void UpdateCoopPermissionsResponse::InternalSwap(UpdateCoopPermissionsResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &message_, lhs_arena,
      &other->message_, rhs_arena
  );
  swap(success_, other->success_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateCoopPermissionsResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[74]);
}

// ===================================================================

class LeaveCoopRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<LeaveCoopRequest>()._has_bits_);
  static const ::ei::BasicRequestInfo& rinfo(const LeaveCoopRequest* msg);
  static void set_has_rinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_contract_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_coop_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_player_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::ei::BasicRequestInfo&
LeaveCoopRequest::_Internal::rinfo(const LeaveCoopRequest* msg) {
  return *msg->rinfo_;
}
LeaveCoopRequest::LeaveCoopRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.LeaveCoopRequest)
}
LeaveCoopRequest::LeaveCoopRequest(const LeaveCoopRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  contract_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    contract_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contract_identifier()) {
    contract_identifier_.Set(from._internal_contract_identifier(), 
      GetArenaForAllocation());
  }
  coop_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    coop_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_coop_identifier()) {
    coop_identifier_.Set(from._internal_coop_identifier(), 
      GetArenaForAllocation());
  }
  player_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    player_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_player_identifier()) {
    player_identifier_.Set(from._internal_player_identifier(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_rinfo()) {
    rinfo_ = new ::ei::BasicRequestInfo(*from.rinfo_);
  } else {
    rinfo_ = nullptr;
  }
  client_version_ = from.client_version_;
  // @@protoc_insertion_point(copy_constructor:ei.LeaveCoopRequest)
}

inline void LeaveCoopRequest::SharedCtor() {
contract_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  contract_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
coop_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  coop_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
player_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  player_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rinfo_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&client_version_) -
    reinterpret_cast<char*>(&rinfo_)) + sizeof(client_version_));
}

LeaveCoopRequest::~LeaveCoopRequest() {
  // @@protoc_insertion_point(destructor:ei.LeaveCoopRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LeaveCoopRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  contract_identifier_.Destroy();
  coop_identifier_.Destroy();
  player_identifier_.Destroy();
  if (this != internal_default_instance()) delete rinfo_;
}

void LeaveCoopRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LeaveCoopRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.LeaveCoopRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      contract_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      coop_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      player_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(rinfo_ != nullptr);
      rinfo_->Clear();
    }
  }
  client_version_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LeaveCoopRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string contract_identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_contract_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.LeaveCoopRequest.contract_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string coop_identifier = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_coop_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.LeaveCoopRequest.coop_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string player_identifier = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_player_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.LeaveCoopRequest.player_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 client_version = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_client_version(&has_bits);
          client_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.BasicRequestInfo rinfo = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_rinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LeaveCoopRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.LeaveCoopRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string contract_identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_contract_identifier().data(), static_cast<int>(this->_internal_contract_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.LeaveCoopRequest.contract_identifier");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_contract_identifier(), target);
  }

  // optional string coop_identifier = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_coop_identifier().data(), static_cast<int>(this->_internal_coop_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.LeaveCoopRequest.coop_identifier");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_coop_identifier(), target);
  }

  // optional string player_identifier = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_player_identifier().data(), static_cast<int>(this->_internal_player_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.LeaveCoopRequest.player_identifier");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_player_identifier(), target);
  }

  // optional uint32 client_version = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_client_version(), target);
  }

  // optional .ei.BasicRequestInfo rinfo = 8;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::rinfo(this),
        _Internal::rinfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.LeaveCoopRequest)
  return target;
}

size_t LeaveCoopRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.LeaveCoopRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string contract_identifier = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contract_identifier());
    }

    // optional string coop_identifier = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_coop_identifier());
    }

    // optional string player_identifier = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_player_identifier());
    }

    // optional .ei.BasicRequestInfo rinfo = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rinfo_);
    }

    // optional uint32 client_version = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_client_version());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LeaveCoopRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LeaveCoopRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LeaveCoopRequest::GetClassData() const { return &_class_data_; }

void LeaveCoopRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LeaveCoopRequest *>(to)->MergeFrom(
      static_cast<const LeaveCoopRequest &>(from));
}


void LeaveCoopRequest::MergeFrom(const LeaveCoopRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.LeaveCoopRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_contract_identifier(from._internal_contract_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_coop_identifier(from._internal_coop_identifier());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_player_identifier(from._internal_player_identifier());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_rinfo()->::ei::BasicRequestInfo::MergeFrom(from._internal_rinfo());
    }
    if (cached_has_bits & 0x00000010u) {
      client_version_ = from.client_version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LeaveCoopRequest::CopyFrom(const LeaveCoopRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.LeaveCoopRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaveCoopRequest::IsInitialized() const {
  return true;
}

void LeaveCoopRequest::InternalSwap(LeaveCoopRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &contract_identifier_, lhs_arena,
      &other->contract_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &coop_identifier_, lhs_arena,
      &other->coop_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &player_identifier_, lhs_arena,
      &other->player_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LeaveCoopRequest, client_version_)
      + sizeof(LeaveCoopRequest::client_version_)
      - PROTOBUF_FIELD_OFFSET(LeaveCoopRequest, rinfo_)>(
          reinterpret_cast<char*>(&rinfo_),
          reinterpret_cast<char*>(&other->rinfo_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LeaveCoopRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[75]);
}

// ===================================================================

class GiftPlayerCoopRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<GiftPlayerCoopRequest>()._has_bits_);
  static const ::ei::BasicRequestInfo& rinfo(const GiftPlayerCoopRequest* msg);
  static void set_has_rinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_contract_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_coop_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_player_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_requesting_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_requesting_user_name(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::ei::BasicRequestInfo&
GiftPlayerCoopRequest::_Internal::rinfo(const GiftPlayerCoopRequest* msg) {
  return *msg->rinfo_;
}
GiftPlayerCoopRequest::GiftPlayerCoopRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.GiftPlayerCoopRequest)
}
GiftPlayerCoopRequest::GiftPlayerCoopRequest(const GiftPlayerCoopRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  contract_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    contract_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contract_identifier()) {
    contract_identifier_.Set(from._internal_contract_identifier(), 
      GetArenaForAllocation());
  }
  coop_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    coop_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_coop_identifier()) {
    coop_identifier_.Set(from._internal_coop_identifier(), 
      GetArenaForAllocation());
  }
  player_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    player_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_player_identifier()) {
    player_identifier_.Set(from._internal_player_identifier(), 
      GetArenaForAllocation());
  }
  requesting_user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    requesting_user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_requesting_user_id()) {
    requesting_user_id_.Set(from._internal_requesting_user_id(), 
      GetArenaForAllocation());
  }
  requesting_user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    requesting_user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_requesting_user_name()) {
    requesting_user_name_.Set(from._internal_requesting_user_name(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_rinfo()) {
    rinfo_ = new ::ei::BasicRequestInfo(*from.rinfo_);
  } else {
    rinfo_ = nullptr;
  }
  ::memcpy(&amount_, &from.amount_,
    static_cast<size_t>(reinterpret_cast<char*>(&client_version_) -
    reinterpret_cast<char*>(&amount_)) + sizeof(client_version_));
  // @@protoc_insertion_point(copy_constructor:ei.GiftPlayerCoopRequest)
}

inline void GiftPlayerCoopRequest::SharedCtor() {
contract_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  contract_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
coop_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  coop_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
player_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  player_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
requesting_user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  requesting_user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
requesting_user_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  requesting_user_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rinfo_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&client_version_) -
    reinterpret_cast<char*>(&rinfo_)) + sizeof(client_version_));
}

GiftPlayerCoopRequest::~GiftPlayerCoopRequest() {
  // @@protoc_insertion_point(destructor:ei.GiftPlayerCoopRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GiftPlayerCoopRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  contract_identifier_.Destroy();
  coop_identifier_.Destroy();
  player_identifier_.Destroy();
  requesting_user_id_.Destroy();
  requesting_user_name_.Destroy();
  if (this != internal_default_instance()) delete rinfo_;
}

void GiftPlayerCoopRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GiftPlayerCoopRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.GiftPlayerCoopRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      contract_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      coop_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      player_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      requesting_user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      requesting_user_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(rinfo_ != nullptr);
      rinfo_->Clear();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&amount_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&client_version_) -
        reinterpret_cast<char*>(&amount_)) + sizeof(client_version_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GiftPlayerCoopRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string contract_identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_contract_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.GiftPlayerCoopRequest.contract_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string coop_identifier = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_coop_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.GiftPlayerCoopRequest.coop_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string player_identifier = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_player_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.GiftPlayerCoopRequest.player_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string requesting_user_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_requesting_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.GiftPlayerCoopRequest.requesting_user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 amount = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_amount(&has_bits);
          amount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string requesting_user_name = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_requesting_user_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.GiftPlayerCoopRequest.requesting_user_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 client_version = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_client_version(&has_bits);
          client_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.BasicRequestInfo rinfo = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_rinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GiftPlayerCoopRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.GiftPlayerCoopRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string contract_identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_contract_identifier().data(), static_cast<int>(this->_internal_contract_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.GiftPlayerCoopRequest.contract_identifier");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_contract_identifier(), target);
  }

  // optional string coop_identifier = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_coop_identifier().data(), static_cast<int>(this->_internal_coop_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.GiftPlayerCoopRequest.coop_identifier");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_coop_identifier(), target);
  }

  // optional string player_identifier = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_player_identifier().data(), static_cast<int>(this->_internal_player_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.GiftPlayerCoopRequest.player_identifier");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_player_identifier(), target);
  }

  // optional string requesting_user_id = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_requesting_user_id().data(), static_cast<int>(this->_internal_requesting_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.GiftPlayerCoopRequest.requesting_user_id");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_requesting_user_id(), target);
  }

  // optional uint32 amount = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_amount(), target);
  }

  // optional string requesting_user_name = 6;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_requesting_user_name().data(), static_cast<int>(this->_internal_requesting_user_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.GiftPlayerCoopRequest.requesting_user_name");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_requesting_user_name(), target);
  }

  // optional uint32 client_version = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_client_version(), target);
  }

  // optional .ei.BasicRequestInfo rinfo = 8;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::rinfo(this),
        _Internal::rinfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.GiftPlayerCoopRequest)
  return target;
}

size_t GiftPlayerCoopRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.GiftPlayerCoopRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string contract_identifier = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contract_identifier());
    }

    // optional string coop_identifier = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_coop_identifier());
    }

    // optional string player_identifier = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_player_identifier());
    }

    // optional string requesting_user_id = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_requesting_user_id());
    }

    // optional string requesting_user_name = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_requesting_user_name());
    }

    // optional .ei.BasicRequestInfo rinfo = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rinfo_);
    }

    // optional uint32 amount = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_amount());
    }

    // optional uint32 client_version = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_client_version());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GiftPlayerCoopRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GiftPlayerCoopRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GiftPlayerCoopRequest::GetClassData() const { return &_class_data_; }

void GiftPlayerCoopRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GiftPlayerCoopRequest *>(to)->MergeFrom(
      static_cast<const GiftPlayerCoopRequest &>(from));
}


void GiftPlayerCoopRequest::MergeFrom(const GiftPlayerCoopRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.GiftPlayerCoopRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_contract_identifier(from._internal_contract_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_coop_identifier(from._internal_coop_identifier());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_player_identifier(from._internal_player_identifier());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_requesting_user_id(from._internal_requesting_user_id());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_requesting_user_name(from._internal_requesting_user_name());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_rinfo()->::ei::BasicRequestInfo::MergeFrom(from._internal_rinfo());
    }
    if (cached_has_bits & 0x00000040u) {
      amount_ = from.amount_;
    }
    if (cached_has_bits & 0x00000080u) {
      client_version_ = from.client_version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GiftPlayerCoopRequest::CopyFrom(const GiftPlayerCoopRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.GiftPlayerCoopRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GiftPlayerCoopRequest::IsInitialized() const {
  return true;
}

void GiftPlayerCoopRequest::InternalSwap(GiftPlayerCoopRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &contract_identifier_, lhs_arena,
      &other->contract_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &coop_identifier_, lhs_arena,
      &other->coop_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &player_identifier_, lhs_arena,
      &other->player_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &requesting_user_id_, lhs_arena,
      &other->requesting_user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &requesting_user_name_, lhs_arena,
      &other->requesting_user_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GiftPlayerCoopRequest, client_version_)
      + sizeof(GiftPlayerCoopRequest::client_version_)
      - PROTOBUF_FIELD_OFFSET(GiftPlayerCoopRequest, rinfo_)>(
          reinterpret_cast<char*>(&rinfo_),
          reinterpret_cast<char*>(&other->rinfo_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GiftPlayerCoopRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[76]);
}

// ===================================================================

class SendChickenRunCoopRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<SendChickenRunCoopRequest>()._has_bits_);
  static const ::ei::BasicRequestInfo& rinfo(const SendChickenRunCoopRequest* msg);
  static void set_has_rinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_contract_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_coop_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_player_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_requesting_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_requesting_user_name(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_farm_pop(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::ei::BasicRequestInfo&
SendChickenRunCoopRequest::_Internal::rinfo(const SendChickenRunCoopRequest* msg) {
  return *msg->rinfo_;
}
SendChickenRunCoopRequest::SendChickenRunCoopRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.SendChickenRunCoopRequest)
}
SendChickenRunCoopRequest::SendChickenRunCoopRequest(const SendChickenRunCoopRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  contract_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    contract_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contract_identifier()) {
    contract_identifier_.Set(from._internal_contract_identifier(), 
      GetArenaForAllocation());
  }
  coop_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    coop_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_coop_identifier()) {
    coop_identifier_.Set(from._internal_coop_identifier(), 
      GetArenaForAllocation());
  }
  player_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    player_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_player_identifier()) {
    player_identifier_.Set(from._internal_player_identifier(), 
      GetArenaForAllocation());
  }
  requesting_user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    requesting_user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_requesting_user_id()) {
    requesting_user_id_.Set(from._internal_requesting_user_id(), 
      GetArenaForAllocation());
  }
  requesting_user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    requesting_user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_requesting_user_name()) {
    requesting_user_name_.Set(from._internal_requesting_user_name(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_rinfo()) {
    rinfo_ = new ::ei::BasicRequestInfo(*from.rinfo_);
  } else {
    rinfo_ = nullptr;
  }
  ::memcpy(&farm_pop_, &from.farm_pop_,
    static_cast<size_t>(reinterpret_cast<char*>(&client_version_) -
    reinterpret_cast<char*>(&farm_pop_)) + sizeof(client_version_));
  // @@protoc_insertion_point(copy_constructor:ei.SendChickenRunCoopRequest)
}

inline void SendChickenRunCoopRequest::SharedCtor() {
contract_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  contract_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
coop_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  coop_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
player_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  player_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
requesting_user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  requesting_user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
requesting_user_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  requesting_user_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rinfo_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&client_version_) -
    reinterpret_cast<char*>(&rinfo_)) + sizeof(client_version_));
}

SendChickenRunCoopRequest::~SendChickenRunCoopRequest() {
  // @@protoc_insertion_point(destructor:ei.SendChickenRunCoopRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SendChickenRunCoopRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  contract_identifier_.Destroy();
  coop_identifier_.Destroy();
  player_identifier_.Destroy();
  requesting_user_id_.Destroy();
  requesting_user_name_.Destroy();
  if (this != internal_default_instance()) delete rinfo_;
}

void SendChickenRunCoopRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SendChickenRunCoopRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.SendChickenRunCoopRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      contract_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      coop_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      player_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      requesting_user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      requesting_user_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(rinfo_ != nullptr);
      rinfo_->Clear();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&farm_pop_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&client_version_) -
        reinterpret_cast<char*>(&farm_pop_)) + sizeof(client_version_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SendChickenRunCoopRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string contract_identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_contract_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.SendChickenRunCoopRequest.contract_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string coop_identifier = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_coop_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.SendChickenRunCoopRequest.coop_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string player_identifier = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_player_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.SendChickenRunCoopRequest.player_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string requesting_user_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_requesting_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.SendChickenRunCoopRequest.requesting_user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint64 farm_pop = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_farm_pop(&has_bits);
          farm_pop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string requesting_user_name = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_requesting_user_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.SendChickenRunCoopRequest.requesting_user_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 client_version = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_client_version(&has_bits);
          client_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.BasicRequestInfo rinfo = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_rinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SendChickenRunCoopRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.SendChickenRunCoopRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string contract_identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_contract_identifier().data(), static_cast<int>(this->_internal_contract_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.SendChickenRunCoopRequest.contract_identifier");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_contract_identifier(), target);
  }

  // optional string coop_identifier = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_coop_identifier().data(), static_cast<int>(this->_internal_coop_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.SendChickenRunCoopRequest.coop_identifier");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_coop_identifier(), target);
  }

  // optional string player_identifier = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_player_identifier().data(), static_cast<int>(this->_internal_player_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.SendChickenRunCoopRequest.player_identifier");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_player_identifier(), target);
  }

  // optional string requesting_user_id = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_requesting_user_id().data(), static_cast<int>(this->_internal_requesting_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.SendChickenRunCoopRequest.requesting_user_id");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_requesting_user_id(), target);
  }

  // optional uint64 farm_pop = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_farm_pop(), target);
  }

  // optional string requesting_user_name = 6;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_requesting_user_name().data(), static_cast<int>(this->_internal_requesting_user_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.SendChickenRunCoopRequest.requesting_user_name");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_requesting_user_name(), target);
  }

  // optional uint32 client_version = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_client_version(), target);
  }

  // optional .ei.BasicRequestInfo rinfo = 8;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::rinfo(this),
        _Internal::rinfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.SendChickenRunCoopRequest)
  return target;
}

size_t SendChickenRunCoopRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.SendChickenRunCoopRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string contract_identifier = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contract_identifier());
    }

    // optional string coop_identifier = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_coop_identifier());
    }

    // optional string player_identifier = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_player_identifier());
    }

    // optional string requesting_user_id = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_requesting_user_id());
    }

    // optional string requesting_user_name = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_requesting_user_name());
    }

    // optional .ei.BasicRequestInfo rinfo = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rinfo_);
    }

    // optional uint64 farm_pop = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_farm_pop());
    }

    // optional uint32 client_version = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_client_version());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SendChickenRunCoopRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SendChickenRunCoopRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SendChickenRunCoopRequest::GetClassData() const { return &_class_data_; }

void SendChickenRunCoopRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SendChickenRunCoopRequest *>(to)->MergeFrom(
      static_cast<const SendChickenRunCoopRequest &>(from));
}


void SendChickenRunCoopRequest::MergeFrom(const SendChickenRunCoopRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.SendChickenRunCoopRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_contract_identifier(from._internal_contract_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_coop_identifier(from._internal_coop_identifier());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_player_identifier(from._internal_player_identifier());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_requesting_user_id(from._internal_requesting_user_id());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_requesting_user_name(from._internal_requesting_user_name());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_rinfo()->::ei::BasicRequestInfo::MergeFrom(from._internal_rinfo());
    }
    if (cached_has_bits & 0x00000040u) {
      farm_pop_ = from.farm_pop_;
    }
    if (cached_has_bits & 0x00000080u) {
      client_version_ = from.client_version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SendChickenRunCoopRequest::CopyFrom(const SendChickenRunCoopRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.SendChickenRunCoopRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SendChickenRunCoopRequest::IsInitialized() const {
  return true;
}

void SendChickenRunCoopRequest::InternalSwap(SendChickenRunCoopRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &contract_identifier_, lhs_arena,
      &other->contract_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &coop_identifier_, lhs_arena,
      &other->coop_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &player_identifier_, lhs_arena,
      &other->player_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &requesting_user_id_, lhs_arena,
      &other->requesting_user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &requesting_user_name_, lhs_arena,
      &other->requesting_user_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SendChickenRunCoopRequest, client_version_)
      + sizeof(SendChickenRunCoopRequest::client_version_)
      - PROTOBUF_FIELD_OFFSET(SendChickenRunCoopRequest, rinfo_)>(
          reinterpret_cast<char*>(&rinfo_),
          reinterpret_cast<char*>(&other->rinfo_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SendChickenRunCoopRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[77]);
}

// ===================================================================

class ReportPlayerCoopRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ReportPlayerCoopRequest>()._has_bits_);
  static const ::ei::BasicRequestInfo& rinfo(const ReportPlayerCoopRequest* msg);
  static void set_has_rinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_contract_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_coop_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::ei::BasicRequestInfo&
ReportPlayerCoopRequest::_Internal::rinfo(const ReportPlayerCoopRequest* msg) {
  return *msg->rinfo_;
}
ReportPlayerCoopRequest::ReportPlayerCoopRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ReportPlayerCoopRequest)
}
ReportPlayerCoopRequest::ReportPlayerCoopRequest(const ReportPlayerCoopRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  contract_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    contract_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contract_identifier()) {
    contract_identifier_.Set(from._internal_contract_identifier(), 
      GetArenaForAllocation());
  }
  coop_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    coop_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_coop_identifier()) {
    coop_identifier_.Set(from._internal_coop_identifier(), 
      GetArenaForAllocation());
  }
  user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_id()) {
    user_id_.Set(from._internal_user_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_rinfo()) {
    rinfo_ = new ::ei::BasicRequestInfo(*from.rinfo_);
  } else {
    rinfo_ = nullptr;
  }
  reason_ = from.reason_;
  // @@protoc_insertion_point(copy_constructor:ei.ReportPlayerCoopRequest)
}

inline void ReportPlayerCoopRequest::SharedCtor() {
contract_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  contract_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
coop_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  coop_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rinfo_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&reason_) -
    reinterpret_cast<char*>(&rinfo_)) + sizeof(reason_));
}

ReportPlayerCoopRequest::~ReportPlayerCoopRequest() {
  // @@protoc_insertion_point(destructor:ei.ReportPlayerCoopRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReportPlayerCoopRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  contract_identifier_.Destroy();
  coop_identifier_.Destroy();
  user_id_.Destroy();
  if (this != internal_default_instance()) delete rinfo_;
}

void ReportPlayerCoopRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ReportPlayerCoopRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ReportPlayerCoopRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      contract_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      coop_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(rinfo_ != nullptr);
      rinfo_->Clear();
    }
  }
  reason_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReportPlayerCoopRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.BasicRequestInfo rinfo = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_rinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string contract_identifier = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_contract_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ReportPlayerCoopRequest.contract_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string coop_identifier = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_coop_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ReportPlayerCoopRequest.coop_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string user_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ReportPlayerCoopRequest.user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .ei.ReportPlayerCoopRequest.Reason reason = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::ReportPlayerCoopRequest_Reason_IsValid(val))) {
            _internal_set_reason(static_cast<::ei::ReportPlayerCoopRequest_Reason>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReportPlayerCoopRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ReportPlayerCoopRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.BasicRequestInfo rinfo = 1;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::rinfo(this),
        _Internal::rinfo(this).GetCachedSize(), target, stream);
  }

  // optional string contract_identifier = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_contract_identifier().data(), static_cast<int>(this->_internal_contract_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ReportPlayerCoopRequest.contract_identifier");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_contract_identifier(), target);
  }

  // optional string coop_identifier = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_coop_identifier().data(), static_cast<int>(this->_internal_coop_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ReportPlayerCoopRequest.coop_identifier");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_coop_identifier(), target);
  }

  // optional string user_id = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ReportPlayerCoopRequest.user_id");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_user_id(), target);
  }

  // optional .ei.ReportPlayerCoopRequest.Reason reason = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_reason(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ReportPlayerCoopRequest)
  return target;
}

size_t ReportPlayerCoopRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ReportPlayerCoopRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string contract_identifier = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contract_identifier());
    }

    // optional string coop_identifier = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_coop_identifier());
    }

    // optional string user_id = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_id());
    }

    // optional .ei.BasicRequestInfo rinfo = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rinfo_);
    }

    // optional .ei.ReportPlayerCoopRequest.Reason reason = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_reason());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReportPlayerCoopRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ReportPlayerCoopRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReportPlayerCoopRequest::GetClassData() const { return &_class_data_; }

void ReportPlayerCoopRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ReportPlayerCoopRequest *>(to)->MergeFrom(
      static_cast<const ReportPlayerCoopRequest &>(from));
}


void ReportPlayerCoopRequest::MergeFrom(const ReportPlayerCoopRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ReportPlayerCoopRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_contract_identifier(from._internal_contract_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_coop_identifier(from._internal_coop_identifier());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_user_id(from._internal_user_id());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_rinfo()->::ei::BasicRequestInfo::MergeFrom(from._internal_rinfo());
    }
    if (cached_has_bits & 0x00000010u) {
      reason_ = from.reason_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReportPlayerCoopRequest::CopyFrom(const ReportPlayerCoopRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ReportPlayerCoopRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReportPlayerCoopRequest::IsInitialized() const {
  return true;
}

void ReportPlayerCoopRequest::InternalSwap(ReportPlayerCoopRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &contract_identifier_, lhs_arena,
      &other->contract_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &coop_identifier_, lhs_arena,
      &other->coop_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReportPlayerCoopRequest, reason_)
      + sizeof(ReportPlayerCoopRequest::reason_)
      - PROTOBUF_FIELD_OFFSET(ReportPlayerCoopRequest, rinfo_)>(
          reinterpret_cast<char*>(&rinfo_),
          reinterpret_cast<char*>(&other->rinfo_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ReportPlayerCoopRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[78]);
}

// ===================================================================

class KickPlayerCoopRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<KickPlayerCoopRequest>()._has_bits_);
  static const ::ei::BasicRequestInfo& rinfo(const KickPlayerCoopRequest* msg);
  static void set_has_rinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_contract_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_coop_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_player_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_requesting_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::ei::BasicRequestInfo&
KickPlayerCoopRequest::_Internal::rinfo(const KickPlayerCoopRequest* msg) {
  return *msg->rinfo_;
}
KickPlayerCoopRequest::KickPlayerCoopRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.KickPlayerCoopRequest)
}
KickPlayerCoopRequest::KickPlayerCoopRequest(const KickPlayerCoopRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  contract_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    contract_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contract_identifier()) {
    contract_identifier_.Set(from._internal_contract_identifier(), 
      GetArenaForAllocation());
  }
  coop_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    coop_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_coop_identifier()) {
    coop_identifier_.Set(from._internal_coop_identifier(), 
      GetArenaForAllocation());
  }
  player_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    player_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_player_identifier()) {
    player_identifier_.Set(from._internal_player_identifier(), 
      GetArenaForAllocation());
  }
  requesting_user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    requesting_user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_requesting_user_id()) {
    requesting_user_id_.Set(from._internal_requesting_user_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_rinfo()) {
    rinfo_ = new ::ei::BasicRequestInfo(*from.rinfo_);
  } else {
    rinfo_ = nullptr;
  }
  ::memcpy(&client_version_, &from.client_version_,
    static_cast<size_t>(reinterpret_cast<char*>(&reason_) -
    reinterpret_cast<char*>(&client_version_)) + sizeof(reason_));
  // @@protoc_insertion_point(copy_constructor:ei.KickPlayerCoopRequest)
}

inline void KickPlayerCoopRequest::SharedCtor() {
contract_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  contract_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
coop_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  coop_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
player_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  player_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
requesting_user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  requesting_user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rinfo_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&reason_) -
    reinterpret_cast<char*>(&rinfo_)) + sizeof(reason_));
}

KickPlayerCoopRequest::~KickPlayerCoopRequest() {
  // @@protoc_insertion_point(destructor:ei.KickPlayerCoopRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KickPlayerCoopRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  contract_identifier_.Destroy();
  coop_identifier_.Destroy();
  player_identifier_.Destroy();
  requesting_user_id_.Destroy();
  if (this != internal_default_instance()) delete rinfo_;
}

void KickPlayerCoopRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KickPlayerCoopRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.KickPlayerCoopRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      contract_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      coop_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      player_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      requesting_user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(rinfo_ != nullptr);
      rinfo_->Clear();
    }
  }
  if (cached_has_bits & 0x00000060u) {
    ::memset(&client_version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&reason_) -
        reinterpret_cast<char*>(&client_version_)) + sizeof(reason_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KickPlayerCoopRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string contract_identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_contract_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.KickPlayerCoopRequest.contract_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string coop_identifier = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_coop_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.KickPlayerCoopRequest.coop_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string player_identifier = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_player_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.KickPlayerCoopRequest.player_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string requesting_user_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_requesting_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.KickPlayerCoopRequest.requesting_user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 client_version = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_client_version(&has_bits);
          client_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.BasicRequestInfo rinfo = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_rinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.KickPlayerCoopRequest.Reason reason = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::KickPlayerCoopRequest_Reason_IsValid(val))) {
            _internal_set_reason(static_cast<::ei::KickPlayerCoopRequest_Reason>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KickPlayerCoopRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.KickPlayerCoopRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string contract_identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_contract_identifier().data(), static_cast<int>(this->_internal_contract_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.KickPlayerCoopRequest.contract_identifier");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_contract_identifier(), target);
  }

  // optional string coop_identifier = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_coop_identifier().data(), static_cast<int>(this->_internal_coop_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.KickPlayerCoopRequest.coop_identifier");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_coop_identifier(), target);
  }

  // optional string player_identifier = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_player_identifier().data(), static_cast<int>(this->_internal_player_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.KickPlayerCoopRequest.player_identifier");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_player_identifier(), target);
  }

  // optional string requesting_user_id = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_requesting_user_id().data(), static_cast<int>(this->_internal_requesting_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.KickPlayerCoopRequest.requesting_user_id");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_requesting_user_id(), target);
  }

  // optional uint32 client_version = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_client_version(), target);
  }

  // optional .ei.BasicRequestInfo rinfo = 8;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::rinfo(this),
        _Internal::rinfo(this).GetCachedSize(), target, stream);
  }

  // optional .ei.KickPlayerCoopRequest.Reason reason = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_reason(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.KickPlayerCoopRequest)
  return target;
}

size_t KickPlayerCoopRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.KickPlayerCoopRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string contract_identifier = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contract_identifier());
    }

    // optional string coop_identifier = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_coop_identifier());
    }

    // optional string player_identifier = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_player_identifier());
    }

    // optional string requesting_user_id = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_requesting_user_id());
    }

    // optional .ei.BasicRequestInfo rinfo = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rinfo_);
    }

    // optional uint32 client_version = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_client_version());
    }

    // optional .ei.KickPlayerCoopRequest.Reason reason = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_reason());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KickPlayerCoopRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    KickPlayerCoopRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KickPlayerCoopRequest::GetClassData() const { return &_class_data_; }

void KickPlayerCoopRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<KickPlayerCoopRequest *>(to)->MergeFrom(
      static_cast<const KickPlayerCoopRequest &>(from));
}


void KickPlayerCoopRequest::MergeFrom(const KickPlayerCoopRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.KickPlayerCoopRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_contract_identifier(from._internal_contract_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_coop_identifier(from._internal_coop_identifier());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_player_identifier(from._internal_player_identifier());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_requesting_user_id(from._internal_requesting_user_id());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_rinfo()->::ei::BasicRequestInfo::MergeFrom(from._internal_rinfo());
    }
    if (cached_has_bits & 0x00000020u) {
      client_version_ = from.client_version_;
    }
    if (cached_has_bits & 0x00000040u) {
      reason_ = from.reason_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KickPlayerCoopRequest::CopyFrom(const KickPlayerCoopRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.KickPlayerCoopRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KickPlayerCoopRequest::IsInitialized() const {
  return true;
}

void KickPlayerCoopRequest::InternalSwap(KickPlayerCoopRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &contract_identifier_, lhs_arena,
      &other->contract_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &coop_identifier_, lhs_arena,
      &other->coop_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &player_identifier_, lhs_arena,
      &other->player_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &requesting_user_id_, lhs_arena,
      &other->requesting_user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KickPlayerCoopRequest, reason_)
      + sizeof(KickPlayerCoopRequest::reason_)
      - PROTOBUF_FIELD_OFFSET(KickPlayerCoopRequest, rinfo_)>(
          reinterpret_cast<char*>(&rinfo_),
          reinterpret_cast<char*>(&other->rinfo_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KickPlayerCoopRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[79]);
}

// ===================================================================

class ContractCoopStatusUpdateRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ContractCoopStatusUpdateRequest>()._has_bits_);
  static const ::ei::BasicRequestInfo& rinfo(const ContractCoopStatusUpdateRequest* msg);
  static void set_has_rinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_contract_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_coop_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_push_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_time_cheats_detected(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_soul_power(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_eop(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_boost_tokens(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_boost_tokens_spent(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::ei::FarmProductionParams& production_params(const ContractCoopStatusUpdateRequest* msg);
  static void set_has_production_params(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::ei::PlayerFarmInfo& farm_info(const ContractCoopStatusUpdateRequest* msg);
  static void set_has_farm_info(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_egg_laying_rate_buff(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_earnings_buff(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
};

const ::ei::BasicRequestInfo&
ContractCoopStatusUpdateRequest::_Internal::rinfo(const ContractCoopStatusUpdateRequest* msg) {
  return *msg->rinfo_;
}
const ::ei::FarmProductionParams&
ContractCoopStatusUpdateRequest::_Internal::production_params(const ContractCoopStatusUpdateRequest* msg) {
  return *msg->production_params_;
}
const ::ei::PlayerFarmInfo&
ContractCoopStatusUpdateRequest::_Internal::farm_info(const ContractCoopStatusUpdateRequest* msg) {
  return *msg->farm_info_;
}
ContractCoopStatusUpdateRequest::ContractCoopStatusUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ContractCoopStatusUpdateRequest)
}
ContractCoopStatusUpdateRequest::ContractCoopStatusUpdateRequest(const ContractCoopStatusUpdateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_id()) {
    user_id_.Set(from._internal_user_id(), 
      GetArenaForAllocation());
  }
  contract_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    contract_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contract_identifier()) {
    contract_identifier_.Set(from._internal_contract_identifier(), 
      GetArenaForAllocation());
  }
  coop_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    coop_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_coop_identifier()) {
    coop_identifier_.Set(from._internal_coop_identifier(), 
      GetArenaForAllocation());
  }
  push_user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    push_user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_push_user_id()) {
    push_user_id_.Set(from._internal_push_user_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_rinfo()) {
    rinfo_ = new ::ei::BasicRequestInfo(*from.rinfo_);
  } else {
    rinfo_ = nullptr;
  }
  if (from._internal_has_production_params()) {
    production_params_ = new ::ei::FarmProductionParams(*from.production_params_);
  } else {
    production_params_ = nullptr;
  }
  if (from._internal_has_farm_info()) {
    farm_info_ = new ::ei::PlayerFarmInfo(*from.farm_info_);
  } else {
    farm_info_ = nullptr;
  }
  ::memcpy(&amount_, &from.amount_,
    static_cast<size_t>(reinterpret_cast<char*>(&earnings_buff_) -
    reinterpret_cast<char*>(&amount_)) + sizeof(earnings_buff_));
  // @@protoc_insertion_point(copy_constructor:ei.ContractCoopStatusUpdateRequest)
}

inline void ContractCoopStatusUpdateRequest::SharedCtor() {
user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
contract_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  contract_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
coop_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  coop_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
push_user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  push_user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rinfo_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&eop_) -
    reinterpret_cast<char*>(&rinfo_)) + sizeof(eop_));
egg_laying_rate_buff_ = 1;
earnings_buff_ = 1;
}

ContractCoopStatusUpdateRequest::~ContractCoopStatusUpdateRequest() {
  // @@protoc_insertion_point(destructor:ei.ContractCoopStatusUpdateRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContractCoopStatusUpdateRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_id_.Destroy();
  contract_identifier_.Destroy();
  coop_identifier_.Destroy();
  push_user_id_.Destroy();
  if (this != internal_default_instance()) delete rinfo_;
  if (this != internal_default_instance()) delete production_params_;
  if (this != internal_default_instance()) delete farm_info_;
}

void ContractCoopStatusUpdateRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContractCoopStatusUpdateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ContractCoopStatusUpdateRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      contract_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      coop_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      push_user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(rinfo_ != nullptr);
      rinfo_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(production_params_ != nullptr);
      production_params_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(farm_info_ != nullptr);
      farm_info_->Clear();
    }
  }
  amount_ = 0;
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&rate_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&eop_) -
        reinterpret_cast<char*>(&rate_)) + sizeof(eop_));
    egg_laying_rate_buff_ = 1;
    earnings_buff_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContractCoopStatusUpdateRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractCoopStatusUpdateRequest.user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string contract_identifier = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_contract_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractCoopStatusUpdateRequest.contract_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string coop_identifier = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_coop_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractCoopStatusUpdateRequest.coop_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double amount = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_amount(&has_bits);
          amount_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double rate = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_rate(&has_bits);
          rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 time_cheats_detected = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_time_cheats_detected(&has_bits);
          time_cheats_detected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double soul_power = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _Internal::set_has_soul_power(&has_bits);
          soul_power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional string push_user_id = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_push_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractCoopStatusUpdateRequest.push_user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 boost_tokens = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_boost_tokens(&has_bits);
          boost_tokens_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double egg_laying_rate_buff = 10 [default = 1];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _Internal::set_has_egg_laying_rate_buff(&has_bits);
          egg_laying_rate_buff_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double earnings_buff = 11 [default = 1];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _Internal::set_has_earnings_buff(&has_bits);
          earnings_buff_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.BasicRequestInfo rinfo = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_rinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 boost_tokens_spent = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_boost_tokens_spent(&has_bits);
          boost_tokens_spent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.FarmProductionParams production_params = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_production_params(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 eop = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_eop(&has_bits);
          eop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.PlayerFarmInfo farm_info = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_farm_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContractCoopStatusUpdateRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ContractCoopStatusUpdateRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractCoopStatusUpdateRequest.user_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_id(), target);
  }

  // optional string contract_identifier = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_contract_identifier().data(), static_cast<int>(this->_internal_contract_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractCoopStatusUpdateRequest.contract_identifier");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_contract_identifier(), target);
  }

  // optional string coop_identifier = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_coop_identifier().data(), static_cast<int>(this->_internal_coop_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractCoopStatusUpdateRequest.coop_identifier");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_coop_identifier(), target);
  }

  // optional double amount = 4;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_amount(), target);
  }

  // optional double rate = 5;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_rate(), target);
  }

  // optional uint32 time_cheats_detected = 6;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_time_cheats_detected(), target);
  }

  // optional double soul_power = 7;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_soul_power(), target);
  }

  // optional string push_user_id = 8;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_push_user_id().data(), static_cast<int>(this->_internal_push_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractCoopStatusUpdateRequest.push_user_id");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_push_user_id(), target);
  }

  // optional uint32 boost_tokens = 9;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_boost_tokens(), target);
  }

  // optional double egg_laying_rate_buff = 10 [default = 1];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(10, this->_internal_egg_laying_rate_buff(), target);
  }

  // optional double earnings_buff = 11 [default = 1];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(11, this->_internal_earnings_buff(), target);
  }

  // optional .ei.BasicRequestInfo rinfo = 12;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::rinfo(this),
        _Internal::rinfo(this).GetCachedSize(), target, stream);
  }

  // optional uint32 boost_tokens_spent = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_boost_tokens_spent(), target);
  }

  // optional .ei.FarmProductionParams production_params = 14;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::production_params(this),
        _Internal::production_params(this).GetCachedSize(), target, stream);
  }

  // optional uint32 eop = 15;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_eop(), target);
  }

  // optional .ei.PlayerFarmInfo farm_info = 16;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::farm_info(this),
        _Internal::farm_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ContractCoopStatusUpdateRequest)
  return target;
}

size_t ContractCoopStatusUpdateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ContractCoopStatusUpdateRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string user_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_id());
    }

    // optional string contract_identifier = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contract_identifier());
    }

    // optional string coop_identifier = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_coop_identifier());
    }

    // optional string push_user_id = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_push_user_id());
    }

    // optional .ei.BasicRequestInfo rinfo = 12;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rinfo_);
    }

    // optional .ei.FarmProductionParams production_params = 14;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *production_params_);
    }

    // optional .ei.PlayerFarmInfo farm_info = 16;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *farm_info_);
    }

    // optional double amount = 4;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional double rate = 5;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 8;
    }

    // optional double soul_power = 7;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional uint32 time_cheats_detected = 6;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_time_cheats_detected());
    }

    // optional uint32 boost_tokens = 9;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_boost_tokens());
    }

    // optional uint32 boost_tokens_spent = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_boost_tokens_spent());
    }

    // optional uint32 eop = 15;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_eop());
    }

    // optional double egg_laying_rate_buff = 10 [default = 1];
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 8;
    }

    // optional double earnings_buff = 11 [default = 1];
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContractCoopStatusUpdateRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ContractCoopStatusUpdateRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContractCoopStatusUpdateRequest::GetClassData() const { return &_class_data_; }

void ContractCoopStatusUpdateRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ContractCoopStatusUpdateRequest *>(to)->MergeFrom(
      static_cast<const ContractCoopStatusUpdateRequest &>(from));
}


void ContractCoopStatusUpdateRequest::MergeFrom(const ContractCoopStatusUpdateRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ContractCoopStatusUpdateRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_id(from._internal_user_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_contract_identifier(from._internal_contract_identifier());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_coop_identifier(from._internal_coop_identifier());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_push_user_id(from._internal_push_user_id());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_rinfo()->::ei::BasicRequestInfo::MergeFrom(from._internal_rinfo());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_production_params()->::ei::FarmProductionParams::MergeFrom(from._internal_production_params());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_farm_info()->::ei::PlayerFarmInfo::MergeFrom(from._internal_farm_info());
    }
    if (cached_has_bits & 0x00000080u) {
      amount_ = from.amount_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      rate_ = from.rate_;
    }
    if (cached_has_bits & 0x00000200u) {
      soul_power_ = from.soul_power_;
    }
    if (cached_has_bits & 0x00000400u) {
      time_cheats_detected_ = from.time_cheats_detected_;
    }
    if (cached_has_bits & 0x00000800u) {
      boost_tokens_ = from.boost_tokens_;
    }
    if (cached_has_bits & 0x00001000u) {
      boost_tokens_spent_ = from.boost_tokens_spent_;
    }
    if (cached_has_bits & 0x00002000u) {
      eop_ = from.eop_;
    }
    if (cached_has_bits & 0x00004000u) {
      egg_laying_rate_buff_ = from.egg_laying_rate_buff_;
    }
    if (cached_has_bits & 0x00008000u) {
      earnings_buff_ = from.earnings_buff_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContractCoopStatusUpdateRequest::CopyFrom(const ContractCoopStatusUpdateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ContractCoopStatusUpdateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContractCoopStatusUpdateRequest::IsInitialized() const {
  return true;
}

void ContractCoopStatusUpdateRequest::InternalSwap(ContractCoopStatusUpdateRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &contract_identifier_, lhs_arena,
      &other->contract_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &coop_identifier_, lhs_arena,
      &other->coop_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &push_user_id_, lhs_arena,
      &other->push_user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContractCoopStatusUpdateRequest, eop_)
      + sizeof(ContractCoopStatusUpdateRequest::eop_)
      - PROTOBUF_FIELD_OFFSET(ContractCoopStatusUpdateRequest, rinfo_)>(
          reinterpret_cast<char*>(&rinfo_),
          reinterpret_cast<char*>(&other->rinfo_));
  swap(egg_laying_rate_buff_, other->egg_laying_rate_buff_);
  swap(earnings_buff_, other->earnings_buff_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ContractCoopStatusUpdateRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[80]);
}

// ===================================================================

class ContractCoopStatusUpdateResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<ContractCoopStatusUpdateResponse>()._has_bits_);
  static void set_has_finalized(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_exists(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ContractCoopStatusUpdateResponse::ContractCoopStatusUpdateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ContractCoopStatusUpdateResponse)
}
ContractCoopStatusUpdateResponse::ContractCoopStatusUpdateResponse(const ContractCoopStatusUpdateResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&finalized_, &from.finalized_,
    static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&finalized_)) + sizeof(status_));
  // @@protoc_insertion_point(copy_constructor:ei.ContractCoopStatusUpdateResponse)
}

inline void ContractCoopStatusUpdateResponse::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&finalized_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&finalized_)) + sizeof(status_));
}

ContractCoopStatusUpdateResponse::~ContractCoopStatusUpdateResponse() {
  // @@protoc_insertion_point(destructor:ei.ContractCoopStatusUpdateResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContractCoopStatusUpdateResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ContractCoopStatusUpdateResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContractCoopStatusUpdateResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ContractCoopStatusUpdateResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&finalized_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&status_) -
        reinterpret_cast<char*>(&finalized_)) + sizeof(status_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContractCoopStatusUpdateResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool finalized = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_finalized(&has_bits);
          finalized_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool exists = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_exists(&has_bits);
          exists_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.ContractCoopStatusResponse.MemberStatus status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::ContractCoopStatusResponse_MemberStatus_IsValid(val))) {
            _internal_set_status(static_cast<::ei::ContractCoopStatusResponse_MemberStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContractCoopStatusUpdateResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ContractCoopStatusUpdateResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool finalized = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_finalized(), target);
  }

  // optional bool exists = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_exists(), target);
  }

  // optional .ei.ContractCoopStatusResponse.MemberStatus status = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ContractCoopStatusUpdateResponse)
  return target;
}

size_t ContractCoopStatusUpdateResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ContractCoopStatusUpdateResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bool finalized = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool exists = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional .ei.ContractCoopStatusResponse.MemberStatus status = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContractCoopStatusUpdateResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ContractCoopStatusUpdateResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContractCoopStatusUpdateResponse::GetClassData() const { return &_class_data_; }

void ContractCoopStatusUpdateResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ContractCoopStatusUpdateResponse *>(to)->MergeFrom(
      static_cast<const ContractCoopStatusUpdateResponse &>(from));
}


void ContractCoopStatusUpdateResponse::MergeFrom(const ContractCoopStatusUpdateResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ContractCoopStatusUpdateResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      finalized_ = from.finalized_;
    }
    if (cached_has_bits & 0x00000002u) {
      exists_ = from.exists_;
    }
    if (cached_has_bits & 0x00000004u) {
      status_ = from.status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContractCoopStatusUpdateResponse::CopyFrom(const ContractCoopStatusUpdateResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ContractCoopStatusUpdateResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContractCoopStatusUpdateResponse::IsInitialized() const {
  return true;
}

void ContractCoopStatusUpdateResponse::InternalSwap(ContractCoopStatusUpdateResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContractCoopStatusUpdateResponse, status_)
      + sizeof(ContractCoopStatusUpdateResponse::status_)
      - PROTOBUF_FIELD_OFFSET(ContractCoopStatusUpdateResponse, finalized_)>(
          reinterpret_cast<char*>(&finalized_),
          reinterpret_cast<char*>(&other->finalized_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ContractCoopStatusUpdateResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[81]);
}

// ===================================================================

class CoopBuffState::_Internal {
 public:
  using HasBits = decltype(std::declval<CoopBuffState>()._has_bits_);
  static void set_has_egg_laying_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_earnings(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_server_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CoopBuffState::CoopBuffState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.CoopBuffState)
}
CoopBuffState::CoopBuffState(const CoopBuffState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&server_timestamp_, &from.server_timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&earnings_) -
    reinterpret_cast<char*>(&server_timestamp_)) + sizeof(earnings_));
  // @@protoc_insertion_point(copy_constructor:ei.CoopBuffState)
}

inline void CoopBuffState::SharedCtor() {
server_timestamp_ = 0;
egg_laying_rate_ = 1;
earnings_ = 1;
}

CoopBuffState::~CoopBuffState() {
  // @@protoc_insertion_point(destructor:ei.CoopBuffState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CoopBuffState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CoopBuffState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CoopBuffState::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.CoopBuffState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    server_timestamp_ = 0;
    egg_laying_rate_ = 1;
    earnings_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CoopBuffState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double egg_laying_rate = 1 [default = 1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_egg_laying_rate(&has_bits);
          egg_laying_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double earnings = 2 [default = 1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_earnings(&has_bits);
          earnings_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double server_timestamp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_server_timestamp(&has_bits);
          server_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CoopBuffState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.CoopBuffState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double egg_laying_rate = 1 [default = 1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_egg_laying_rate(), target);
  }

  // optional double earnings = 2 [default = 1];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_earnings(), target);
  }

  // optional double server_timestamp = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_server_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.CoopBuffState)
  return target;
}

size_t CoopBuffState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.CoopBuffState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double server_timestamp = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double egg_laying_rate = 1 [default = 1];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double earnings = 2 [default = 1];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CoopBuffState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CoopBuffState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CoopBuffState::GetClassData() const { return &_class_data_; }

void CoopBuffState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CoopBuffState *>(to)->MergeFrom(
      static_cast<const CoopBuffState &>(from));
}


void CoopBuffState::MergeFrom(const CoopBuffState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.CoopBuffState)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      server_timestamp_ = from.server_timestamp_;
    }
    if (cached_has_bits & 0x00000002u) {
      egg_laying_rate_ = from.egg_laying_rate_;
    }
    if (cached_has_bits & 0x00000004u) {
      earnings_ = from.earnings_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CoopBuffState::CopyFrom(const CoopBuffState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.CoopBuffState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CoopBuffState::IsInitialized() const {
  return true;
}

void CoopBuffState::InternalSwap(CoopBuffState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(server_timestamp_, other->server_timestamp_);
  swap(egg_laying_rate_, other->egg_laying_rate_);
  swap(earnings_, other->earnings_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CoopBuffState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[82]);
}

// ===================================================================

class CoopBuffHistory::_Internal {
 public:
};

CoopBuffHistory::CoopBuffHistory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  history_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.CoopBuffHistory)
}
CoopBuffHistory::CoopBuffHistory(const CoopBuffHistory& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      history_(from.history_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ei.CoopBuffHistory)
}

inline void CoopBuffHistory::SharedCtor() {
}

CoopBuffHistory::~CoopBuffHistory() {
  // @@protoc_insertion_point(destructor:ei.CoopBuffHistory)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CoopBuffHistory::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CoopBuffHistory::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CoopBuffHistory::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.CoopBuffHistory)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  history_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CoopBuffHistory::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .ei.CoopBuffState history = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_history(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CoopBuffHistory::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.CoopBuffHistory)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ei.CoopBuffState history = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_history_size()); i < n; i++) {
    const auto& repfield = this->_internal_history(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.CoopBuffHistory)
  return target;
}

size_t CoopBuffHistory::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.CoopBuffHistory)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.CoopBuffState history = 1;
  total_size += 1UL * this->_internal_history_size();
  for (const auto& msg : this->history_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CoopBuffHistory::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CoopBuffHistory::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CoopBuffHistory::GetClassData() const { return &_class_data_; }

void CoopBuffHistory::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CoopBuffHistory *>(to)->MergeFrom(
      static_cast<const CoopBuffHistory &>(from));
}


void CoopBuffHistory::MergeFrom(const CoopBuffHistory& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.CoopBuffHistory)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  history_.MergeFrom(from.history_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CoopBuffHistory::CopyFrom(const CoopBuffHistory& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.CoopBuffHistory)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CoopBuffHistory::IsInitialized() const {
  return true;
}

void CoopBuffHistory::InternalSwap(CoopBuffHistory* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  history_.InternalSwap(&other->history_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CoopBuffHistory::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[83]);
}

// ===================================================================

class CoopChickenRunEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<CoopChickenRunEntry>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_server_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CoopChickenRunEntry::CoopChickenRunEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.CoopChickenRunEntry)
}
CoopChickenRunEntry::CoopChickenRunEntry(const CoopChickenRunEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_id()) {
    user_id_.Set(from._internal_user_id(), 
      GetArenaForAllocation());
  }
  server_timestamp_ = from.server_timestamp_;
  // @@protoc_insertion_point(copy_constructor:ei.CoopChickenRunEntry)
}

inline void CoopChickenRunEntry::SharedCtor() {
user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
server_timestamp_ = 0;
}

CoopChickenRunEntry::~CoopChickenRunEntry() {
  // @@protoc_insertion_point(destructor:ei.CoopChickenRunEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CoopChickenRunEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_id_.Destroy();
}

void CoopChickenRunEntry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CoopChickenRunEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.CoopChickenRunEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    user_id_.ClearNonDefaultToEmpty();
  }
  server_timestamp_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CoopChickenRunEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.CoopChickenRunEntry.user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double server_timestamp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_server_timestamp(&has_bits);
          server_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CoopChickenRunEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.CoopChickenRunEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.CoopChickenRunEntry.user_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_id(), target);
  }

  // optional double server_timestamp = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_server_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.CoopChickenRunEntry)
  return target;
}

size_t CoopChickenRunEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.CoopChickenRunEntry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string user_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_id());
    }

    // optional double server_timestamp = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CoopChickenRunEntry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CoopChickenRunEntry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CoopChickenRunEntry::GetClassData() const { return &_class_data_; }

void CoopChickenRunEntry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CoopChickenRunEntry *>(to)->MergeFrom(
      static_cast<const CoopChickenRunEntry &>(from));
}


void CoopChickenRunEntry::MergeFrom(const CoopChickenRunEntry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.CoopChickenRunEntry)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_id(from._internal_user_id());
    }
    if (cached_has_bits & 0x00000002u) {
      server_timestamp_ = from.server_timestamp_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CoopChickenRunEntry::CopyFrom(const CoopChickenRunEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.CoopChickenRunEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CoopChickenRunEntry::IsInitialized() const {
  return true;
}

void CoopChickenRunEntry::InternalSwap(CoopChickenRunEntry* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  swap(server_timestamp_, other->server_timestamp_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CoopChickenRunEntry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[84]);
}

// ===================================================================

class CoopLastChickenRunTimes::_Internal {
 public:
};

CoopLastChickenRunTimes::CoopLastChickenRunTimes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  entries_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.CoopLastChickenRunTimes)
}
CoopLastChickenRunTimes::CoopLastChickenRunTimes(const CoopLastChickenRunTimes& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      entries_(from.entries_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ei.CoopLastChickenRunTimes)
}

inline void CoopLastChickenRunTimes::SharedCtor() {
}

CoopLastChickenRunTimes::~CoopLastChickenRunTimes() {
  // @@protoc_insertion_point(destructor:ei.CoopLastChickenRunTimes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CoopLastChickenRunTimes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CoopLastChickenRunTimes::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CoopLastChickenRunTimes::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.CoopLastChickenRunTimes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  entries_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CoopLastChickenRunTimes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .ei.CoopChickenRunEntry entries = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CoopLastChickenRunTimes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.CoopLastChickenRunTimes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ei.CoopChickenRunEntry entries = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entries_size()); i < n; i++) {
    const auto& repfield = this->_internal_entries(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.CoopLastChickenRunTimes)
  return target;
}

size_t CoopLastChickenRunTimes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.CoopLastChickenRunTimes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.CoopChickenRunEntry entries = 3;
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CoopLastChickenRunTimes::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CoopLastChickenRunTimes::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CoopLastChickenRunTimes::GetClassData() const { return &_class_data_; }

void CoopLastChickenRunTimes::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CoopLastChickenRunTimes *>(to)->MergeFrom(
      static_cast<const CoopLastChickenRunTimes &>(from));
}


void CoopLastChickenRunTimes::MergeFrom(const CoopLastChickenRunTimes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.CoopLastChickenRunTimes)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  entries_.MergeFrom(from.entries_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CoopLastChickenRunTimes::CopyFrom(const CoopLastChickenRunTimes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.CoopLastChickenRunTimes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CoopLastChickenRunTimes::IsInitialized() const {
  return true;
}

void CoopLastChickenRunTimes::InternalSwap(CoopLastChickenRunTimes* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  entries_.InternalSwap(&other->entries_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CoopLastChickenRunTimes::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[85]);
}

// ===================================================================

class LeaderboardAnalysis_Chunk::_Internal {
 public:
  using HasBits = decltype(std::declval<LeaderboardAnalysis_Chunk>()._has_bits_);
  static void set_has_start_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_end_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_high_score(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_low_score(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_start_cursor(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_end_cursor(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

LeaderboardAnalysis_Chunk::LeaderboardAnalysis_Chunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.LeaderboardAnalysis.Chunk)
}
LeaderboardAnalysis_Chunk::LeaderboardAnalysis_Chunk(const LeaderboardAnalysis_Chunk& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  start_cursor_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    start_cursor_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_start_cursor()) {
    start_cursor_.Set(from._internal_start_cursor(), 
      GetArenaForAllocation());
  }
  end_cursor_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    end_cursor_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_end_cursor()) {
    end_cursor_.Set(from._internal_end_cursor(), 
      GetArenaForAllocation());
  }
  ::memcpy(&start_index_, &from.start_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&low_score_) -
    reinterpret_cast<char*>(&start_index_)) + sizeof(low_score_));
  // @@protoc_insertion_point(copy_constructor:ei.LeaderboardAnalysis.Chunk)
}

inline void LeaderboardAnalysis_Chunk::SharedCtor() {
start_cursor_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  start_cursor_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
end_cursor_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  end_cursor_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&start_index_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&low_score_) -
    reinterpret_cast<char*>(&start_index_)) + sizeof(low_score_));
}

LeaderboardAnalysis_Chunk::~LeaderboardAnalysis_Chunk() {
  // @@protoc_insertion_point(destructor:ei.LeaderboardAnalysis.Chunk)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LeaderboardAnalysis_Chunk::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  start_cursor_.Destroy();
  end_cursor_.Destroy();
}

void LeaderboardAnalysis_Chunk::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LeaderboardAnalysis_Chunk::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.LeaderboardAnalysis.Chunk)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      start_cursor_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      end_cursor_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&start_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&low_score_) -
        reinterpret_cast<char*>(&start_index_)) + sizeof(low_score_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LeaderboardAnalysis_Chunk::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 start_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_start_index(&has_bits);
          start_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 end_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_end_index(&has_bits);
          end_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double high_score = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_high_score(&has_bits);
          high_score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double low_score = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_low_score(&has_bits);
          low_score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional string start_cursor = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_start_cursor();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.LeaderboardAnalysis.Chunk.start_cursor");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string end_cursor = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_end_cursor();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.LeaderboardAnalysis.Chunk.end_cursor");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LeaderboardAnalysis_Chunk::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.LeaderboardAnalysis.Chunk)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 start_index = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_start_index(), target);
  }

  // optional uint32 end_index = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_end_index(), target);
  }

  // optional double high_score = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_high_score(), target);
  }

  // optional double low_score = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_low_score(), target);
  }

  // optional string start_cursor = 5;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_start_cursor().data(), static_cast<int>(this->_internal_start_cursor().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.LeaderboardAnalysis.Chunk.start_cursor");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_start_cursor(), target);
  }

  // optional string end_cursor = 6;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_end_cursor().data(), static_cast<int>(this->_internal_end_cursor().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.LeaderboardAnalysis.Chunk.end_cursor");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_end_cursor(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.LeaderboardAnalysis.Chunk)
  return target;
}

size_t LeaderboardAnalysis_Chunk::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.LeaderboardAnalysis.Chunk)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string start_cursor = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_start_cursor());
    }

    // optional string end_cursor = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_end_cursor());
    }

    // optional uint32 start_index = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_start_index());
    }

    // optional uint32 end_index = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_end_index());
    }

    // optional double high_score = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double low_score = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LeaderboardAnalysis_Chunk::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LeaderboardAnalysis_Chunk::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LeaderboardAnalysis_Chunk::GetClassData() const { return &_class_data_; }

void LeaderboardAnalysis_Chunk::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LeaderboardAnalysis_Chunk *>(to)->MergeFrom(
      static_cast<const LeaderboardAnalysis_Chunk &>(from));
}


void LeaderboardAnalysis_Chunk::MergeFrom(const LeaderboardAnalysis_Chunk& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.LeaderboardAnalysis.Chunk)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_start_cursor(from._internal_start_cursor());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_end_cursor(from._internal_end_cursor());
    }
    if (cached_has_bits & 0x00000004u) {
      start_index_ = from.start_index_;
    }
    if (cached_has_bits & 0x00000008u) {
      end_index_ = from.end_index_;
    }
    if (cached_has_bits & 0x00000010u) {
      high_score_ = from.high_score_;
    }
    if (cached_has_bits & 0x00000020u) {
      low_score_ = from.low_score_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LeaderboardAnalysis_Chunk::CopyFrom(const LeaderboardAnalysis_Chunk& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.LeaderboardAnalysis.Chunk)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaderboardAnalysis_Chunk::IsInitialized() const {
  return true;
}

void LeaderboardAnalysis_Chunk::InternalSwap(LeaderboardAnalysis_Chunk* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &start_cursor_, lhs_arena,
      &other->start_cursor_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &end_cursor_, lhs_arena,
      &other->end_cursor_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LeaderboardAnalysis_Chunk, low_score_)
      + sizeof(LeaderboardAnalysis_Chunk::low_score_)
      - PROTOBUF_FIELD_OFFSET(LeaderboardAnalysis_Chunk, start_index_)>(
          reinterpret_cast<char*>(&start_index_),
          reinterpret_cast<char*>(&other->start_index_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LeaderboardAnalysis_Chunk::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[86]);
}

// ===================================================================

class LeaderboardAnalysis::_Internal {
 public:
  using HasBits = decltype(std::declval<LeaderboardAnalysis>()._has_bits_);
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_high_score(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_low_score(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

LeaderboardAnalysis::LeaderboardAnalysis(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  chunks_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.LeaderboardAnalysis)
}
LeaderboardAnalysis::LeaderboardAnalysis(const LeaderboardAnalysis& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      chunks_(from.chunks_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&high_score_, &from.high_score_,
    static_cast<size_t>(reinterpret_cast<char*>(&count_) -
    reinterpret_cast<char*>(&high_score_)) + sizeof(count_));
  // @@protoc_insertion_point(copy_constructor:ei.LeaderboardAnalysis)
}

inline void LeaderboardAnalysis::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&high_score_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&count_) -
    reinterpret_cast<char*>(&high_score_)) + sizeof(count_));
}

LeaderboardAnalysis::~LeaderboardAnalysis() {
  // @@protoc_insertion_point(destructor:ei.LeaderboardAnalysis)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LeaderboardAnalysis::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LeaderboardAnalysis::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LeaderboardAnalysis::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.LeaderboardAnalysis)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  chunks_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&high_score_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&count_) -
        reinterpret_cast<char*>(&high_score_)) + sizeof(count_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LeaderboardAnalysis::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .ei.LeaderboardAnalysis.Chunk chunks = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_chunks(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_count(&has_bits);
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double high_score = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_high_score(&has_bits);
          high_score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double low_score = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_low_score(&has_bits);
          low_score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LeaderboardAnalysis::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.LeaderboardAnalysis)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ei.LeaderboardAnalysis.Chunk chunks = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_chunks_size()); i < n; i++) {
    const auto& repfield = this->_internal_chunks(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional uint32 count = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_count(), target);
  }

  // optional double high_score = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_high_score(), target);
  }

  // optional double low_score = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_low_score(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.LeaderboardAnalysis)
  return target;
}

size_t LeaderboardAnalysis::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.LeaderboardAnalysis)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.LeaderboardAnalysis.Chunk chunks = 1;
  total_size += 1UL * this->_internal_chunks_size();
  for (const auto& msg : this->chunks_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double high_score = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double low_score = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional uint32 count = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LeaderboardAnalysis::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LeaderboardAnalysis::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LeaderboardAnalysis::GetClassData() const { return &_class_data_; }

void LeaderboardAnalysis::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LeaderboardAnalysis *>(to)->MergeFrom(
      static_cast<const LeaderboardAnalysis &>(from));
}


void LeaderboardAnalysis::MergeFrom(const LeaderboardAnalysis& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.LeaderboardAnalysis)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  chunks_.MergeFrom(from.chunks_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      high_score_ = from.high_score_;
    }
    if (cached_has_bits & 0x00000002u) {
      low_score_ = from.low_score_;
    }
    if (cached_has_bits & 0x00000004u) {
      count_ = from.count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LeaderboardAnalysis::CopyFrom(const LeaderboardAnalysis& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.LeaderboardAnalysis)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaderboardAnalysis::IsInitialized() const {
  return true;
}

void LeaderboardAnalysis::InternalSwap(LeaderboardAnalysis* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  chunks_.InternalSwap(&other->chunks_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LeaderboardAnalysis, count_)
      + sizeof(LeaderboardAnalysis::count_)
      - PROTOBUF_FIELD_OFFSET(LeaderboardAnalysis, high_score_)>(
          reinterpret_cast<char*>(&high_score_),
          reinterpret_cast<char*>(&other->high_score_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LeaderboardAnalysis::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[87]);
}

// ===================================================================

class LeaderboardInfo_Season::_Internal {
 public:
  using HasBits = decltype(std::declval<LeaderboardInfo_Season>()._has_bits_);
  static void set_has_scope(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

LeaderboardInfo_Season::LeaderboardInfo_Season(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.LeaderboardInfo.Season)
}
LeaderboardInfo_Season::LeaderboardInfo_Season(const LeaderboardInfo_Season& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  scope_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    scope_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_scope()) {
    scope_.Set(from._internal_scope(), 
      GetArenaForAllocation());
  }
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:ei.LeaderboardInfo.Season)
}

inline void LeaderboardInfo_Season::SharedCtor() {
scope_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  scope_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LeaderboardInfo_Season::~LeaderboardInfo_Season() {
  // @@protoc_insertion_point(destructor:ei.LeaderboardInfo.Season)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LeaderboardInfo_Season::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  scope_.Destroy();
  name_.Destroy();
}

void LeaderboardInfo_Season::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LeaderboardInfo_Season::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.LeaderboardInfo.Season)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      scope_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      name_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LeaderboardInfo_Season::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string scope = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_scope();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.LeaderboardInfo.Season.scope");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.LeaderboardInfo.Season.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LeaderboardInfo_Season::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.LeaderboardInfo.Season)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string scope = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_scope().data(), static_cast<int>(this->_internal_scope().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.LeaderboardInfo.Season.scope");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_scope(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.LeaderboardInfo.Season.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.LeaderboardInfo.Season)
  return target;
}

size_t LeaderboardInfo_Season::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.LeaderboardInfo.Season)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string scope = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_scope());
    }

    // optional string name = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LeaderboardInfo_Season::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LeaderboardInfo_Season::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LeaderboardInfo_Season::GetClassData() const { return &_class_data_; }

void LeaderboardInfo_Season::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LeaderboardInfo_Season *>(to)->MergeFrom(
      static_cast<const LeaderboardInfo_Season &>(from));
}


void LeaderboardInfo_Season::MergeFrom(const LeaderboardInfo_Season& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.LeaderboardInfo.Season)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_scope(from._internal_scope());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_name(from._internal_name());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LeaderboardInfo_Season::CopyFrom(const LeaderboardInfo_Season& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.LeaderboardInfo.Season)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaderboardInfo_Season::IsInitialized() const {
  return true;
}

void LeaderboardInfo_Season::InternalSwap(LeaderboardInfo_Season* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &scope_, lhs_arena,
      &other->scope_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata LeaderboardInfo_Season::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[88]);
}

// ===================================================================

class LeaderboardInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<LeaderboardInfo>()._has_bits_);
  static void set_has_all_time_scope(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

LeaderboardInfo::LeaderboardInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  seasons_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.LeaderboardInfo)
}
LeaderboardInfo::LeaderboardInfo(const LeaderboardInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      seasons_(from.seasons_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  all_time_scope_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    all_time_scope_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_all_time_scope()) {
    all_time_scope_.Set(from._internal_all_time_scope(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:ei.LeaderboardInfo)
}

inline void LeaderboardInfo::SharedCtor() {
all_time_scope_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  all_time_scope_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LeaderboardInfo::~LeaderboardInfo() {
  // @@protoc_insertion_point(destructor:ei.LeaderboardInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LeaderboardInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  all_time_scope_.Destroy();
}

void LeaderboardInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LeaderboardInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.LeaderboardInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  seasons_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    all_time_scope_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LeaderboardInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .ei.LeaderboardInfo.Season seasons = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_seasons(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string all_time_scope = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_all_time_scope();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.LeaderboardInfo.all_time_scope");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LeaderboardInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.LeaderboardInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ei.LeaderboardInfo.Season seasons = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_seasons_size()); i < n; i++) {
    const auto& repfield = this->_internal_seasons(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional string all_time_scope = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_all_time_scope().data(), static_cast<int>(this->_internal_all_time_scope().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.LeaderboardInfo.all_time_scope");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_all_time_scope(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.LeaderboardInfo)
  return target;
}

size_t LeaderboardInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.LeaderboardInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.LeaderboardInfo.Season seasons = 1;
  total_size += 1UL * this->_internal_seasons_size();
  for (const auto& msg : this->seasons_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string all_time_scope = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_all_time_scope());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LeaderboardInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LeaderboardInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LeaderboardInfo::GetClassData() const { return &_class_data_; }

void LeaderboardInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LeaderboardInfo *>(to)->MergeFrom(
      static_cast<const LeaderboardInfo &>(from));
}


void LeaderboardInfo::MergeFrom(const LeaderboardInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.LeaderboardInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  seasons_.MergeFrom(from.seasons_);
  if (from._internal_has_all_time_scope()) {
    _internal_set_all_time_scope(from._internal_all_time_scope());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LeaderboardInfo::CopyFrom(const LeaderboardInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.LeaderboardInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaderboardInfo::IsInitialized() const {
  return true;
}

void LeaderboardInfo::InternalSwap(LeaderboardInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  seasons_.InternalSwap(&other->seasons_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &all_time_scope_, lhs_arena,
      &other->all_time_scope_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata LeaderboardInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[89]);
}

// ===================================================================

class LeaderboardRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<LeaderboardRequest>()._has_bits_);
  static const ::ei::BasicRequestInfo& rinfo(const LeaderboardRequest* msg);
  static void set_has_rinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_scope(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_grade(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::ei::BasicRequestInfo&
LeaderboardRequest::_Internal::rinfo(const LeaderboardRequest* msg) {
  return *msg->rinfo_;
}
LeaderboardRequest::LeaderboardRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.LeaderboardRequest)
}
LeaderboardRequest::LeaderboardRequest(const LeaderboardRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  scope_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    scope_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_scope()) {
    scope_.Set(from._internal_scope(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_rinfo()) {
    rinfo_ = new ::ei::BasicRequestInfo(*from.rinfo_);
  } else {
    rinfo_ = nullptr;
  }
  grade_ = from.grade_;
  // @@protoc_insertion_point(copy_constructor:ei.LeaderboardRequest)
}

inline void LeaderboardRequest::SharedCtor() {
scope_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  scope_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rinfo_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&grade_) -
    reinterpret_cast<char*>(&rinfo_)) + sizeof(grade_));
}

LeaderboardRequest::~LeaderboardRequest() {
  // @@protoc_insertion_point(destructor:ei.LeaderboardRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LeaderboardRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  scope_.Destroy();
  if (this != internal_default_instance()) delete rinfo_;
}

void LeaderboardRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LeaderboardRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.LeaderboardRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      scope_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(rinfo_ != nullptr);
      rinfo_->Clear();
    }
  }
  grade_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LeaderboardRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.BasicRequestInfo rinfo = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_rinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string scope = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_scope();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.LeaderboardRequest.scope");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .ei.Contract.PlayerGrade grade = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::Contract_PlayerGrade_IsValid(val))) {
            _internal_set_grade(static_cast<::ei::Contract_PlayerGrade>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LeaderboardRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.LeaderboardRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.BasicRequestInfo rinfo = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::rinfo(this),
        _Internal::rinfo(this).GetCachedSize(), target, stream);
  }

  // optional string scope = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_scope().data(), static_cast<int>(this->_internal_scope().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.LeaderboardRequest.scope");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_scope(), target);
  }

  // optional .ei.Contract.PlayerGrade grade = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_grade(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.LeaderboardRequest)
  return target;
}

size_t LeaderboardRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.LeaderboardRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string scope = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_scope());
    }

    // optional .ei.BasicRequestInfo rinfo = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rinfo_);
    }

    // optional .ei.Contract.PlayerGrade grade = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_grade());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LeaderboardRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LeaderboardRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LeaderboardRequest::GetClassData() const { return &_class_data_; }

void LeaderboardRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LeaderboardRequest *>(to)->MergeFrom(
      static_cast<const LeaderboardRequest &>(from));
}


void LeaderboardRequest::MergeFrom(const LeaderboardRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.LeaderboardRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_scope(from._internal_scope());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_rinfo()->::ei::BasicRequestInfo::MergeFrom(from._internal_rinfo());
    }
    if (cached_has_bits & 0x00000004u) {
      grade_ = from.grade_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LeaderboardRequest::CopyFrom(const LeaderboardRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.LeaderboardRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaderboardRequest::IsInitialized() const {
  return true;
}

void LeaderboardRequest::InternalSwap(LeaderboardRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &scope_, lhs_arena,
      &other->scope_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LeaderboardRequest, grade_)
      + sizeof(LeaderboardRequest::grade_)
      - PROTOBUF_FIELD_OFFSET(LeaderboardRequest, rinfo_)>(
          reinterpret_cast<char*>(&rinfo_),
          reinterpret_cast<char*>(&other->rinfo_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LeaderboardRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[90]);
}

// ===================================================================

class LeaderboardResponse_Entry::_Internal {
 public:
  using HasBits = decltype(std::declval<LeaderboardResponse_Entry>()._has_bits_);
  static void set_has_rank(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_alias(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_score(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

LeaderboardResponse_Entry::LeaderboardResponse_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.LeaderboardResponse.Entry)
}
LeaderboardResponse_Entry::LeaderboardResponse_Entry(const LeaderboardResponse_Entry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  alias_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    alias_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_alias()) {
    alias_.Set(from._internal_alias(), 
      GetArenaForAllocation());
  }
  ::memcpy(&score_, &from.score_,
    static_cast<size_t>(reinterpret_cast<char*>(&rank_) -
    reinterpret_cast<char*>(&score_)) + sizeof(rank_));
  // @@protoc_insertion_point(copy_constructor:ei.LeaderboardResponse.Entry)
}

inline void LeaderboardResponse_Entry::SharedCtor() {
alias_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  alias_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&score_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&rank_) -
    reinterpret_cast<char*>(&score_)) + sizeof(rank_));
}

LeaderboardResponse_Entry::~LeaderboardResponse_Entry() {
  // @@protoc_insertion_point(destructor:ei.LeaderboardResponse.Entry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LeaderboardResponse_Entry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  alias_.Destroy();
}

void LeaderboardResponse_Entry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LeaderboardResponse_Entry::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.LeaderboardResponse.Entry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    alias_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&score_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&rank_) -
        reinterpret_cast<char*>(&score_)) + sizeof(rank_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LeaderboardResponse_Entry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 rank = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_rank(&has_bits);
          rank_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string alias = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_alias();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.LeaderboardResponse.Entry.alias");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double score = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_score(&has_bits);
          score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LeaderboardResponse_Entry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.LeaderboardResponse.Entry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 rank = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_rank(), target);
  }

  // optional string alias = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_alias().data(), static_cast<int>(this->_internal_alias().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.LeaderboardResponse.Entry.alias");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_alias(), target);
  }

  // optional double score = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_score(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.LeaderboardResponse.Entry)
  return target;
}

size_t LeaderboardResponse_Entry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.LeaderboardResponse.Entry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string alias = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_alias());
    }

    // optional double score = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional uint32 rank = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rank());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LeaderboardResponse_Entry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LeaderboardResponse_Entry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LeaderboardResponse_Entry::GetClassData() const { return &_class_data_; }

void LeaderboardResponse_Entry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LeaderboardResponse_Entry *>(to)->MergeFrom(
      static_cast<const LeaderboardResponse_Entry &>(from));
}


void LeaderboardResponse_Entry::MergeFrom(const LeaderboardResponse_Entry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.LeaderboardResponse.Entry)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_alias(from._internal_alias());
    }
    if (cached_has_bits & 0x00000002u) {
      score_ = from.score_;
    }
    if (cached_has_bits & 0x00000004u) {
      rank_ = from.rank_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LeaderboardResponse_Entry::CopyFrom(const LeaderboardResponse_Entry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.LeaderboardResponse.Entry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaderboardResponse_Entry::IsInitialized() const {
  return true;
}

void LeaderboardResponse_Entry::InternalSwap(LeaderboardResponse_Entry* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &alias_, lhs_arena,
      &other->alias_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LeaderboardResponse_Entry, rank_)
      + sizeof(LeaderboardResponse_Entry::rank_)
      - PROTOBUF_FIELD_OFFSET(LeaderboardResponse_Entry, score_)>(
          reinterpret_cast<char*>(&score_),
          reinterpret_cast<char*>(&other->score_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LeaderboardResponse_Entry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[91]);
}

// ===================================================================

class LeaderboardResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<LeaderboardResponse>()._has_bits_);
  static void set_has_scope(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_grade(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_rank(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_score(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

LeaderboardResponse::LeaderboardResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  top_entries_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.LeaderboardResponse)
}
LeaderboardResponse::LeaderboardResponse(const LeaderboardResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      top_entries_(from.top_entries_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  scope_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    scope_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_scope()) {
    scope_.Set(from._internal_scope(), 
      GetArenaForAllocation());
  }
  ::memcpy(&grade_, &from.grade_,
    static_cast<size_t>(reinterpret_cast<char*>(&rank_) -
    reinterpret_cast<char*>(&grade_)) + sizeof(rank_));
  // @@protoc_insertion_point(copy_constructor:ei.LeaderboardResponse)
}

inline void LeaderboardResponse::SharedCtor() {
scope_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  scope_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&grade_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&rank_) -
    reinterpret_cast<char*>(&grade_)) + sizeof(rank_));
}

LeaderboardResponse::~LeaderboardResponse() {
  // @@protoc_insertion_point(destructor:ei.LeaderboardResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LeaderboardResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  scope_.Destroy();
}

void LeaderboardResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LeaderboardResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.LeaderboardResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  top_entries_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    scope_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&grade_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&rank_) -
        reinterpret_cast<char*>(&grade_)) + sizeof(rank_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LeaderboardResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string scope = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_scope();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.LeaderboardResponse.scope");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .ei.Contract.PlayerGrade grade = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::Contract_PlayerGrade_IsValid(val))) {
            _internal_set_grade(static_cast<::ei::Contract_PlayerGrade>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.LeaderboardResponse.Entry top_entries = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_top_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_count(&has_bits);
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rank = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_rank(&has_bits);
          rank_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double score = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_score(&has_bits);
          score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LeaderboardResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.LeaderboardResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string scope = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_scope().data(), static_cast<int>(this->_internal_scope().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.LeaderboardResponse.scope");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_scope(), target);
  }

  // optional .ei.Contract.PlayerGrade grade = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_grade(), target);
  }

  // repeated .ei.LeaderboardResponse.Entry top_entries = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_top_entries_size()); i < n; i++) {
    const auto& repfield = this->_internal_top_entries(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 count = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_count(), target);
  }

  // optional uint32 rank = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_rank(), target);
  }

  // optional double score = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_score(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.LeaderboardResponse)
  return target;
}

size_t LeaderboardResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.LeaderboardResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.LeaderboardResponse.Entry top_entries = 3;
  total_size += 1UL * this->_internal_top_entries_size();
  for (const auto& msg : this->top_entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string scope = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_scope());
    }

    // optional .ei.Contract.PlayerGrade grade = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_grade());
    }

    // optional uint32 count = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
    }

    // optional double score = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional uint32 rank = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rank());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LeaderboardResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LeaderboardResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LeaderboardResponse::GetClassData() const { return &_class_data_; }

void LeaderboardResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LeaderboardResponse *>(to)->MergeFrom(
      static_cast<const LeaderboardResponse &>(from));
}


void LeaderboardResponse::MergeFrom(const LeaderboardResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.LeaderboardResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  top_entries_.MergeFrom(from.top_entries_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_scope(from._internal_scope());
    }
    if (cached_has_bits & 0x00000002u) {
      grade_ = from.grade_;
    }
    if (cached_has_bits & 0x00000004u) {
      count_ = from.count_;
    }
    if (cached_has_bits & 0x00000008u) {
      score_ = from.score_;
    }
    if (cached_has_bits & 0x00000010u) {
      rank_ = from.rank_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LeaderboardResponse::CopyFrom(const LeaderboardResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.LeaderboardResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaderboardResponse::IsInitialized() const {
  return true;
}

void LeaderboardResponse::InternalSwap(LeaderboardResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  top_entries_.InternalSwap(&other->top_entries_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &scope_, lhs_arena,
      &other->scope_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LeaderboardResponse, rank_)
      + sizeof(LeaderboardResponse::rank_)
      - PROTOBUF_FIELD_OFFSET(LeaderboardResponse, grade_)>(
          reinterpret_cast<char*>(&grade_),
          reinterpret_cast<char*>(&other->grade_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LeaderboardResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[92]);
}

// ===================================================================

class ContractsArchive::_Internal {
 public:
};

ContractsArchive::ContractsArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  archive_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ContractsArchive)
}
ContractsArchive::ContractsArchive(const ContractsArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      archive_(from.archive_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ei.ContractsArchive)
}

inline void ContractsArchive::SharedCtor() {
}

ContractsArchive::~ContractsArchive() {
  // @@protoc_insertion_point(destructor:ei.ContractsArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContractsArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ContractsArchive::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContractsArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ContractsArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  archive_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContractsArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .ei.LocalContract archive = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_archive(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContractsArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ContractsArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ei.LocalContract archive = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_archive_size()); i < n; i++) {
    const auto& repfield = this->_internal_archive(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ContractsArchive)
  return target;
}

size_t ContractsArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ContractsArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.LocalContract archive = 1;
  total_size += 1UL * this->_internal_archive_size();
  for (const auto& msg : this->archive_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContractsArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ContractsArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContractsArchive::GetClassData() const { return &_class_data_; }

void ContractsArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ContractsArchive *>(to)->MergeFrom(
      static_cast<const ContractsArchive &>(from));
}


void ContractsArchive::MergeFrom(const ContractsArchive& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ContractsArchive)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  archive_.MergeFrom(from.archive_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContractsArchive::CopyFrom(const ContractsArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ContractsArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContractsArchive::IsInitialized() const {
  return true;
}

void ContractsArchive::InternalSwap(ContractsArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  archive_.InternalSwap(&other->archive_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ContractsArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[93]);
}

// ===================================================================

class ContractAction::_Internal {
 public:
  using HasBits = decltype(std::declval<ContractAction>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_action_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_approx_time(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_dest_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_contract_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_coop_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_autojoin(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_grade(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_replay(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_points_replay(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_reward_type(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_reward_subtype(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_reward_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_goal_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_boost_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_tokens(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_kick_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_public_(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_cc_only(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
};

ContractAction::ContractAction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ContractAction)
}
ContractAction::ContractAction(const ContractAction& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_id()) {
    user_id_.Set(from._internal_user_id(), 
      GetArenaForAllocation());
  }
  action_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    action_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_action_name()) {
    action_name_.Set(from._internal_action_name(), 
      GetArenaForAllocation());
  }
  dest_user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    dest_user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_dest_user_id()) {
    dest_user_id_.Set(from._internal_dest_user_id(), 
      GetArenaForAllocation());
  }
  contract_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    contract_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contract_id()) {
    contract_id_.Set(from._internal_contract_id(), 
      GetArenaForAllocation());
  }
  coop_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    coop_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_coop_id()) {
    coop_id_.Set(from._internal_coop_id(), 
      GetArenaForAllocation());
  }
  reward_subtype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    reward_subtype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_reward_subtype()) {
    reward_subtype_.Set(from._internal_reward_subtype(), 
      GetArenaForAllocation());
  }
  boost_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    boost_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_boost_id()) {
    boost_id_.Set(from._internal_boost_id(), 
      GetArenaForAllocation());
  }
  ::memcpy(&approx_time_, &from.approx_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&cc_only_) -
    reinterpret_cast<char*>(&approx_time_)) + sizeof(cc_only_));
  // @@protoc_insertion_point(copy_constructor:ei.ContractAction)
}

inline void ContractAction::SharedCtor() {
user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
action_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  action_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
dest_user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  dest_user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
contract_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  contract_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
coop_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  coop_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
reward_subtype_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  reward_subtype_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
boost_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  boost_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&approx_time_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&cc_only_) -
    reinterpret_cast<char*>(&approx_time_)) + sizeof(cc_only_));
}

ContractAction::~ContractAction() {
  // @@protoc_insertion_point(destructor:ei.ContractAction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContractAction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_id_.Destroy();
  action_name_.Destroy();
  dest_user_id_.Destroy();
  contract_id_.Destroy();
  coop_id_.Destroy();
  reward_subtype_.Destroy();
  boost_id_.Destroy();
}

void ContractAction::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContractAction::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ContractAction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      action_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      dest_user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      contract_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      coop_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      reward_subtype_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      boost_id_.ClearNonDefaultToEmpty();
    }
  }
  approx_time_ = 0;
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&grade_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&reward_amount_) -
        reinterpret_cast<char*>(&grade_)) + sizeof(reward_amount_));
  }
  if (cached_has_bits & 0x00070000u) {
    ::memset(&tokens_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&cc_only_) -
        reinterpret_cast<char*>(&tokens_)) + sizeof(cc_only_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContractAction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractAction.user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string action_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_action_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractAction.action_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double approx_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_approx_time(&has_bits);
          approx_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional string dest_user_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_dest_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractAction.dest_user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string contract_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_contract_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractAction.contract_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string coop_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_coop_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractAction.coop_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool autojoin = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_autojoin(&has_bits);
          autojoin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 grade = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_grade(&has_bits);
          grade_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool replay = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_replay(&has_bits);
          replay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool points_replay = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_points_replay(&has_bits);
          points_replay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 reward_type = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_reward_type(&has_bits);
          reward_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string reward_subtype = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_reward_subtype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractAction.reward_subtype");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double reward_amount = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 105)) {
          _Internal::set_has_reward_amount(&has_bits);
          reward_amount_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 goal_index = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_goal_index(&has_bits);
          goal_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string boost_id = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_boost_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ContractAction.boost_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tokens = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_tokens(&has_bits);
          tokens_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 kick_reason = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_kick_reason(&has_bits);
          kick_reason_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool public = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_public_(&has_bits);
          public__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool cc_only = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_cc_only(&has_bits);
          cc_only_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContractAction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ContractAction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractAction.user_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_id(), target);
  }

  // optional string action_name = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_action_name().data(), static_cast<int>(this->_internal_action_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractAction.action_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_action_name(), target);
  }

  // optional double approx_time = 3;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_approx_time(), target);
  }

  // optional string dest_user_id = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_dest_user_id().data(), static_cast<int>(this->_internal_dest_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractAction.dest_user_id");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_dest_user_id(), target);
  }

  // optional string contract_id = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_contract_id().data(), static_cast<int>(this->_internal_contract_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractAction.contract_id");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_contract_id(), target);
  }

  // optional string coop_id = 6;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_coop_id().data(), static_cast<int>(this->_internal_coop_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractAction.coop_id");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_coop_id(), target);
  }

  // optional bool autojoin = 7;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_autojoin(), target);
  }

  // optional uint32 grade = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_grade(), target);
  }

  // optional bool replay = 9;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_replay(), target);
  }

  // optional bool points_replay = 10;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_points_replay(), target);
  }

  // optional uint32 reward_type = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_reward_type(), target);
  }

  // optional string reward_subtype = 12;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_reward_subtype().data(), static_cast<int>(this->_internal_reward_subtype().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractAction.reward_subtype");
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_reward_subtype(), target);
  }

  // optional double reward_amount = 13;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(13, this->_internal_reward_amount(), target);
  }

  // optional uint32 goal_index = 14;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_goal_index(), target);
  }

  // optional string boost_id = 15;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_boost_id().data(), static_cast<int>(this->_internal_boost_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ContractAction.boost_id");
    target = stream->WriteStringMaybeAliased(
        15, this->_internal_boost_id(), target);
  }

  // optional uint32 tokens = 16;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_tokens(), target);
  }

  // optional uint32 kick_reason = 17;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(17, this->_internal_kick_reason(), target);
  }

  // optional bool public = 18;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(18, this->_internal_public_(), target);
  }

  // optional bool cc_only = 19;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(19, this->_internal_cc_only(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ContractAction)
  return target;
}

size_t ContractAction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ContractAction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string user_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_id());
    }

    // optional string action_name = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_action_name());
    }

    // optional string dest_user_id = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_dest_user_id());
    }

    // optional string contract_id = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contract_id());
    }

    // optional string coop_id = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_coop_id());
    }

    // optional string reward_subtype = 12;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_reward_subtype());
    }

    // optional string boost_id = 15;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_boost_id());
    }

    // optional double approx_time = 3;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 grade = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_grade());
    }

    // optional uint32 reward_type = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_reward_type());
    }

    // optional bool autojoin = 7;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool replay = 9;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool points_replay = 10;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool public = 18;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 1;
    }

    // optional uint32 goal_index = 14;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_goal_index());
    }

    // optional double reward_amount = 13;
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x00070000u) {
    // optional uint32 tokens = 16;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_tokens());
    }

    // optional uint32 kick_reason = 17;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_kick_reason());
    }

    // optional bool cc_only = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContractAction::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ContractAction::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContractAction::GetClassData() const { return &_class_data_; }

void ContractAction::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ContractAction *>(to)->MergeFrom(
      static_cast<const ContractAction &>(from));
}


void ContractAction::MergeFrom(const ContractAction& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ContractAction)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_id(from._internal_user_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_action_name(from._internal_action_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_dest_user_id(from._internal_dest_user_id());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_contract_id(from._internal_contract_id());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_coop_id(from._internal_coop_id());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_reward_subtype(from._internal_reward_subtype());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_set_boost_id(from._internal_boost_id());
    }
    if (cached_has_bits & 0x00000080u) {
      approx_time_ = from.approx_time_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      grade_ = from.grade_;
    }
    if (cached_has_bits & 0x00000200u) {
      reward_type_ = from.reward_type_;
    }
    if (cached_has_bits & 0x00000400u) {
      autojoin_ = from.autojoin_;
    }
    if (cached_has_bits & 0x00000800u) {
      replay_ = from.replay_;
    }
    if (cached_has_bits & 0x00001000u) {
      points_replay_ = from.points_replay_;
    }
    if (cached_has_bits & 0x00002000u) {
      public__ = from.public__;
    }
    if (cached_has_bits & 0x00004000u) {
      goal_index_ = from.goal_index_;
    }
    if (cached_has_bits & 0x00008000u) {
      reward_amount_ = from.reward_amount_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00070000u) {
    if (cached_has_bits & 0x00010000u) {
      tokens_ = from.tokens_;
    }
    if (cached_has_bits & 0x00020000u) {
      kick_reason_ = from.kick_reason_;
    }
    if (cached_has_bits & 0x00040000u) {
      cc_only_ = from.cc_only_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContractAction::CopyFrom(const ContractAction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ContractAction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContractAction::IsInitialized() const {
  return true;
}

void ContractAction::InternalSwap(ContractAction* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &action_name_, lhs_arena,
      &other->action_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &dest_user_id_, lhs_arena,
      &other->dest_user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &contract_id_, lhs_arena,
      &other->contract_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &coop_id_, lhs_arena,
      &other->coop_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &reward_subtype_, lhs_arena,
      &other->reward_subtype_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &boost_id_, lhs_arena,
      &other->boost_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContractAction, cc_only_)
      + sizeof(ContractAction::cc_only_)
      - PROTOBUF_FIELD_OFFSET(ContractAction, approx_time_)>(
          reinterpret_cast<char*>(&approx_time_),
          reinterpret_cast<char*>(&other->approx_time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ContractAction::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[94]);
}

// ===================================================================

class UserDataInfoRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<UserDataInfoRequest>()._has_bits_);
  static const ::ei::BasicRequestInfo& rinfo(const UserDataInfoRequest* msg);
  static void set_has_rinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_device_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_backup_checksum(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::ei::BasicRequestInfo&
UserDataInfoRequest::_Internal::rinfo(const UserDataInfoRequest* msg) {
  return *msg->rinfo_;
}
UserDataInfoRequest::UserDataInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.UserDataInfoRequest)
}
UserDataInfoRequest::UserDataInfoRequest(const UserDataInfoRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_id()) {
    user_id_.Set(from._internal_user_id(), 
      GetArenaForAllocation());
  }
  device_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    device_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_id()) {
    device_id_.Set(from._internal_device_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_rinfo()) {
    rinfo_ = new ::ei::BasicRequestInfo(*from.rinfo_);
  } else {
    rinfo_ = nullptr;
  }
  backup_checksum_ = from.backup_checksum_;
  // @@protoc_insertion_point(copy_constructor:ei.UserDataInfoRequest)
}

inline void UserDataInfoRequest::SharedCtor() {
user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
device_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  device_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rinfo_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&backup_checksum_) -
    reinterpret_cast<char*>(&rinfo_)) + sizeof(backup_checksum_));
}

UserDataInfoRequest::~UserDataInfoRequest() {
  // @@protoc_insertion_point(destructor:ei.UserDataInfoRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserDataInfoRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_id_.Destroy();
  device_id_.Destroy();
  if (this != internal_default_instance()) delete rinfo_;
}

void UserDataInfoRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UserDataInfoRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.UserDataInfoRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      device_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(rinfo_ != nullptr);
      rinfo_->Clear();
    }
  }
  backup_checksum_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UserDataInfoRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.UserDataInfoRequest.user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string device_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_device_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.UserDataInfoRequest.device_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint64 backup_checksum = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_backup_checksum(&has_bits);
          backup_checksum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.BasicRequestInfo rinfo = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_rinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserDataInfoRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.UserDataInfoRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.UserDataInfoRequest.user_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_id(), target);
  }

  // optional string device_id = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_device_id().data(), static_cast<int>(this->_internal_device_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.UserDataInfoRequest.device_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_device_id(), target);
  }

  // optional uint64 backup_checksum = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_backup_checksum(), target);
  }

  // optional .ei.BasicRequestInfo rinfo = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::rinfo(this),
        _Internal::rinfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.UserDataInfoRequest)
  return target;
}

size_t UserDataInfoRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.UserDataInfoRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string user_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_id());
    }

    // optional string device_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_id());
    }

    // optional .ei.BasicRequestInfo rinfo = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rinfo_);
    }

    // optional uint64 backup_checksum = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_backup_checksum());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UserDataInfoRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UserDataInfoRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UserDataInfoRequest::GetClassData() const { return &_class_data_; }

void UserDataInfoRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UserDataInfoRequest *>(to)->MergeFrom(
      static_cast<const UserDataInfoRequest &>(from));
}


void UserDataInfoRequest::MergeFrom(const UserDataInfoRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.UserDataInfoRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_id(from._internal_user_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_device_id(from._internal_device_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_rinfo()->::ei::BasicRequestInfo::MergeFrom(from._internal_rinfo());
    }
    if (cached_has_bits & 0x00000008u) {
      backup_checksum_ = from.backup_checksum_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UserDataInfoRequest::CopyFrom(const UserDataInfoRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.UserDataInfoRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserDataInfoRequest::IsInitialized() const {
  return true;
}

void UserDataInfoRequest::InternalSwap(UserDataInfoRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &device_id_, lhs_arena,
      &other->device_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserDataInfoRequest, backup_checksum_)
      + sizeof(UserDataInfoRequest::backup_checksum_)
      - PROTOBUF_FIELD_OFFSET(UserDataInfoRequest, rinfo_)>(
          reinterpret_cast<char*>(&rinfo_),
          reinterpret_cast<char*>(&other->rinfo_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UserDataInfoRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[95]);
}

// ===================================================================

class UserDataInfoResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<UserDataInfoResponse>()._has_bits_);
  static void set_has_backup_checksum(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_backup_total_cash(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

UserDataInfoResponse::UserDataInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  coop_memberships_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.UserDataInfoResponse)
}
UserDataInfoResponse::UserDataInfoResponse(const UserDataInfoResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      coop_memberships_(from.coop_memberships_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&backup_checksum_, &from.backup_checksum_,
    static_cast<size_t>(reinterpret_cast<char*>(&backup_total_cash_) -
    reinterpret_cast<char*>(&backup_checksum_)) + sizeof(backup_total_cash_));
  // @@protoc_insertion_point(copy_constructor:ei.UserDataInfoResponse)
}

inline void UserDataInfoResponse::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&backup_checksum_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&backup_total_cash_) -
    reinterpret_cast<char*>(&backup_checksum_)) + sizeof(backup_total_cash_));
}

UserDataInfoResponse::~UserDataInfoResponse() {
  // @@protoc_insertion_point(destructor:ei.UserDataInfoResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserDataInfoResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UserDataInfoResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UserDataInfoResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.UserDataInfoResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  coop_memberships_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&backup_checksum_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&backup_total_cash_) -
        reinterpret_cast<char*>(&backup_checksum_)) + sizeof(backup_total_cash_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UserDataInfoResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 backup_checksum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_backup_checksum(&has_bits);
          backup_checksum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double backup_total_cash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_backup_total_cash(&has_bits);
          backup_total_cash_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated string coop_memberships = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_coop_memberships();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "ei.UserDataInfoResponse.coop_memberships");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserDataInfoResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.UserDataInfoResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 backup_checksum = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_backup_checksum(), target);
  }

  // optional double backup_total_cash = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_backup_total_cash(), target);
  }

  // repeated string coop_memberships = 3;
  for (int i = 0, n = this->_internal_coop_memberships_size(); i < n; i++) {
    const auto& s = this->_internal_coop_memberships(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.UserDataInfoResponse.coop_memberships");
    target = stream->WriteString(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.UserDataInfoResponse)
  return target;
}

size_t UserDataInfoResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.UserDataInfoResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string coop_memberships = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(coop_memberships_.size());
  for (int i = 0, n = coop_memberships_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      coop_memberships_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 backup_checksum = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_backup_checksum());
    }

    // optional double backup_total_cash = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UserDataInfoResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UserDataInfoResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UserDataInfoResponse::GetClassData() const { return &_class_data_; }

void UserDataInfoResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UserDataInfoResponse *>(to)->MergeFrom(
      static_cast<const UserDataInfoResponse &>(from));
}


void UserDataInfoResponse::MergeFrom(const UserDataInfoResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.UserDataInfoResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  coop_memberships_.MergeFrom(from.coop_memberships_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      backup_checksum_ = from.backup_checksum_;
    }
    if (cached_has_bits & 0x00000002u) {
      backup_total_cash_ = from.backup_total_cash_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UserDataInfoResponse::CopyFrom(const UserDataInfoResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.UserDataInfoResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserDataInfoResponse::IsInitialized() const {
  return true;
}

void UserDataInfoResponse::InternalSwap(UserDataInfoResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  coop_memberships_.InternalSwap(&other->coop_memberships_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserDataInfoResponse, backup_total_cash_)
      + sizeof(UserDataInfoResponse::backup_total_cash_)
      - PROTOBUF_FIELD_OFFSET(UserDataInfoResponse, backup_checksum_)>(
          reinterpret_cast<char*>(&backup_checksum_),
          reinterpret_cast<char*>(&other->backup_checksum_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UserDataInfoResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[96]);
}

// ===================================================================

class ClearAllUserDataRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ClearAllUserDataRequest>()._has_bits_);
  static const ::ei::BasicRequestInfo& rinfo(const ClearAllUserDataRequest* msg);
  static void set_has_rinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_device_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_backup_checksum(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::ei::BasicRequestInfo&
ClearAllUserDataRequest::_Internal::rinfo(const ClearAllUserDataRequest* msg) {
  return *msg->rinfo_;
}
ClearAllUserDataRequest::ClearAllUserDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ClearAllUserDataRequest)
}
ClearAllUserDataRequest::ClearAllUserDataRequest(const ClearAllUserDataRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_id()) {
    user_id_.Set(from._internal_user_id(), 
      GetArenaForAllocation());
  }
  device_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    device_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_id()) {
    device_id_.Set(from._internal_device_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_rinfo()) {
    rinfo_ = new ::ei::BasicRequestInfo(*from.rinfo_);
  } else {
    rinfo_ = nullptr;
  }
  backup_checksum_ = from.backup_checksum_;
  // @@protoc_insertion_point(copy_constructor:ei.ClearAllUserDataRequest)
}

inline void ClearAllUserDataRequest::SharedCtor() {
user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
device_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  device_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rinfo_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&backup_checksum_) -
    reinterpret_cast<char*>(&rinfo_)) + sizeof(backup_checksum_));
}

ClearAllUserDataRequest::~ClearAllUserDataRequest() {
  // @@protoc_insertion_point(destructor:ei.ClearAllUserDataRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClearAllUserDataRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_id_.Destroy();
  device_id_.Destroy();
  if (this != internal_default_instance()) delete rinfo_;
}

void ClearAllUserDataRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ClearAllUserDataRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ClearAllUserDataRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      device_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(rinfo_ != nullptr);
      rinfo_->Clear();
    }
  }
  backup_checksum_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ClearAllUserDataRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ClearAllUserDataRequest.user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string device_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_device_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ClearAllUserDataRequest.device_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint64 backup_checksum = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_backup_checksum(&has_bits);
          backup_checksum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.BasicRequestInfo rinfo = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_rinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClearAllUserDataRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ClearAllUserDataRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ClearAllUserDataRequest.user_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_id(), target);
  }

  // optional string device_id = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_device_id().data(), static_cast<int>(this->_internal_device_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ClearAllUserDataRequest.device_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_device_id(), target);
  }

  // optional uint64 backup_checksum = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_backup_checksum(), target);
  }

  // optional .ei.BasicRequestInfo rinfo = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::rinfo(this),
        _Internal::rinfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ClearAllUserDataRequest)
  return target;
}

size_t ClearAllUserDataRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ClearAllUserDataRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string user_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_id());
    }

    // optional string device_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_id());
    }

    // optional .ei.BasicRequestInfo rinfo = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rinfo_);
    }

    // optional uint64 backup_checksum = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_backup_checksum());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ClearAllUserDataRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ClearAllUserDataRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ClearAllUserDataRequest::GetClassData() const { return &_class_data_; }

void ClearAllUserDataRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ClearAllUserDataRequest *>(to)->MergeFrom(
      static_cast<const ClearAllUserDataRequest &>(from));
}


void ClearAllUserDataRequest::MergeFrom(const ClearAllUserDataRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ClearAllUserDataRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_id(from._internal_user_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_device_id(from._internal_device_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_rinfo()->::ei::BasicRequestInfo::MergeFrom(from._internal_rinfo());
    }
    if (cached_has_bits & 0x00000008u) {
      backup_checksum_ = from.backup_checksum_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ClearAllUserDataRequest::CopyFrom(const ClearAllUserDataRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ClearAllUserDataRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClearAllUserDataRequest::IsInitialized() const {
  return true;
}

void ClearAllUserDataRequest::InternalSwap(ClearAllUserDataRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &device_id_, lhs_arena,
      &other->device_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClearAllUserDataRequest, backup_checksum_)
      + sizeof(ClearAllUserDataRequest::backup_checksum_)
      - PROTOBUF_FIELD_OFFSET(ClearAllUserDataRequest, rinfo_)>(
          reinterpret_cast<char*>(&rinfo_),
          reinterpret_cast<char*>(&other->rinfo_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ClearAllUserDataRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[97]);
}

// ===================================================================

class ServerGift::_Internal {
 public:
  using HasBits = decltype(std::declval<ServerGift>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_reward_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_reward_sub_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_reward_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ServerGift::ServerGift(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ServerGift)
}
ServerGift::ServerGift(const ServerGift& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_id()) {
    user_id_.Set(from._internal_user_id(), 
      GetArenaForAllocation());
  }
  reward_sub_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    reward_sub_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_reward_sub_type()) {
    reward_sub_type_.Set(from._internal_reward_sub_type(), 
      GetArenaForAllocation());
  }
  ::memcpy(&reward_amount_, &from.reward_amount_,
    static_cast<size_t>(reinterpret_cast<char*>(&reward_type_) -
    reinterpret_cast<char*>(&reward_amount_)) + sizeof(reward_type_));
  // @@protoc_insertion_point(copy_constructor:ei.ServerGift)
}

inline void ServerGift::SharedCtor() {
user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
reward_sub_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  reward_sub_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
reward_amount_ = 0;
reward_type_ = 1;
}

ServerGift::~ServerGift() {
  // @@protoc_insertion_point(destructor:ei.ServerGift)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServerGift::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_id_.Destroy();
  reward_sub_type_.Destroy();
}

void ServerGift::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ServerGift::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ServerGift)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      reward_sub_type_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    reward_amount_ = 0;
    reward_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ServerGift::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ServerGift.user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .ei.RewardType reward_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::RewardType_IsValid(val))) {
            _internal_set_reward_type(static_cast<::ei::RewardType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string reward_sub_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_reward_sub_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ServerGift.reward_sub_type");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double reward_amount = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_reward_amount(&has_bits);
          reward_amount_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServerGift::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ServerGift)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ServerGift.user_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_id(), target);
  }

  // optional .ei.RewardType reward_type = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_reward_type(), target);
  }

  // optional string reward_sub_type = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_reward_sub_type().data(), static_cast<int>(this->_internal_reward_sub_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ServerGift.reward_sub_type");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_reward_sub_type(), target);
  }

  // optional double reward_amount = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_reward_amount(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ServerGift)
  return target;
}

size_t ServerGift::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ServerGift)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string user_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_id());
    }

    // optional string reward_sub_type = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_reward_sub_type());
    }

    // optional double reward_amount = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional .ei.RewardType reward_type = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_reward_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ServerGift::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ServerGift::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ServerGift::GetClassData() const { return &_class_data_; }

void ServerGift::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ServerGift *>(to)->MergeFrom(
      static_cast<const ServerGift &>(from));
}


void ServerGift::MergeFrom(const ServerGift& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ServerGift)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_id(from._internal_user_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_reward_sub_type(from._internal_reward_sub_type());
    }
    if (cached_has_bits & 0x00000004u) {
      reward_amount_ = from.reward_amount_;
    }
    if (cached_has_bits & 0x00000008u) {
      reward_type_ = from.reward_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ServerGift::CopyFrom(const ServerGift& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ServerGift)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServerGift::IsInitialized() const {
  return true;
}

void ServerGift::InternalSwap(ServerGift* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &reward_sub_type_, lhs_arena,
      &other->reward_sub_type_, rhs_arena
  );
  swap(reward_amount_, other->reward_amount_);
  swap(reward_type_, other->reward_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ServerGift::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[98]);
}

// ===================================================================

class LiveConfig_BoostsConfig_ItemConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<LiveConfig_BoostsConfig_ItemConfig>()._has_bits_);
  static void set_has_boost_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_price(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_token_price(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_se_required(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

LiveConfig_BoostsConfig_ItemConfig::LiveConfig_BoostsConfig_ItemConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.LiveConfig.BoostsConfig.ItemConfig)
}
LiveConfig_BoostsConfig_ItemConfig::LiveConfig_BoostsConfig_ItemConfig(const LiveConfig_BoostsConfig_ItemConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  boost_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    boost_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_boost_id()) {
    boost_id_.Set(from._internal_boost_id(), 
      GetArenaForAllocation());
  }
  ::memcpy(&price_, &from.price_,
    static_cast<size_t>(reinterpret_cast<char*>(&se_required_) -
    reinterpret_cast<char*>(&price_)) + sizeof(se_required_));
  // @@protoc_insertion_point(copy_constructor:ei.LiveConfig.BoostsConfig.ItemConfig)
}

inline void LiveConfig_BoostsConfig_ItemConfig::SharedCtor() {
boost_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  boost_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&price_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&se_required_) -
    reinterpret_cast<char*>(&price_)) + sizeof(se_required_));
}

LiveConfig_BoostsConfig_ItemConfig::~LiveConfig_BoostsConfig_ItemConfig() {
  // @@protoc_insertion_point(destructor:ei.LiveConfig.BoostsConfig.ItemConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LiveConfig_BoostsConfig_ItemConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  boost_id_.Destroy();
}

void LiveConfig_BoostsConfig_ItemConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LiveConfig_BoostsConfig_ItemConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.LiveConfig.BoostsConfig.ItemConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    boost_id_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&price_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&se_required_) -
        reinterpret_cast<char*>(&price_)) + sizeof(se_required_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LiveConfig_BoostsConfig_ItemConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string boost_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_boost_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.LiveConfig.BoostsConfig.ItemConfig.boost_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 price = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_price(&has_bits);
          price_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 token_price = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_token_price(&has_bits);
          token_price_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double se_required = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_se_required(&has_bits);
          se_required_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LiveConfig_BoostsConfig_ItemConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.LiveConfig.BoostsConfig.ItemConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string boost_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_boost_id().data(), static_cast<int>(this->_internal_boost_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.LiveConfig.BoostsConfig.ItemConfig.boost_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_boost_id(), target);
  }

  // optional uint32 price = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_price(), target);
  }

  // optional uint32 token_price = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_token_price(), target);
  }

  // optional double se_required = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_se_required(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.LiveConfig.BoostsConfig.ItemConfig)
  return target;
}

size_t LiveConfig_BoostsConfig_ItemConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.LiveConfig.BoostsConfig.ItemConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string boost_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_boost_id());
    }

    // optional uint32 price = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_price());
    }

    // optional uint32 token_price = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_token_price());
    }

    // optional double se_required = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LiveConfig_BoostsConfig_ItemConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LiveConfig_BoostsConfig_ItemConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LiveConfig_BoostsConfig_ItemConfig::GetClassData() const { return &_class_data_; }

void LiveConfig_BoostsConfig_ItemConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LiveConfig_BoostsConfig_ItemConfig *>(to)->MergeFrom(
      static_cast<const LiveConfig_BoostsConfig_ItemConfig &>(from));
}


void LiveConfig_BoostsConfig_ItemConfig::MergeFrom(const LiveConfig_BoostsConfig_ItemConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.LiveConfig.BoostsConfig.ItemConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_boost_id(from._internal_boost_id());
    }
    if (cached_has_bits & 0x00000002u) {
      price_ = from.price_;
    }
    if (cached_has_bits & 0x00000004u) {
      token_price_ = from.token_price_;
    }
    if (cached_has_bits & 0x00000008u) {
      se_required_ = from.se_required_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LiveConfig_BoostsConfig_ItemConfig::CopyFrom(const LiveConfig_BoostsConfig_ItemConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.LiveConfig.BoostsConfig.ItemConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LiveConfig_BoostsConfig_ItemConfig::IsInitialized() const {
  return true;
}

void LiveConfig_BoostsConfig_ItemConfig::InternalSwap(LiveConfig_BoostsConfig_ItemConfig* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &boost_id_, lhs_arena,
      &other->boost_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LiveConfig_BoostsConfig_ItemConfig, se_required_)
      + sizeof(LiveConfig_BoostsConfig_ItemConfig::se_required_)
      - PROTOBUF_FIELD_OFFSET(LiveConfig_BoostsConfig_ItemConfig, price_)>(
          reinterpret_cast<char*>(&price_),
          reinterpret_cast<char*>(&other->price_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LiveConfig_BoostsConfig_ItemConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[99]);
}

// ===================================================================

class LiveConfig_BoostsConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<LiveConfig_BoostsConfig>()._has_bits_);
  static void set_has_cash_boost_cooloff_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

LiveConfig_BoostsConfig::LiveConfig_BoostsConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  item_configs_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.LiveConfig.BoostsConfig)
}
LiveConfig_BoostsConfig::LiveConfig_BoostsConfig(const LiveConfig_BoostsConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      item_configs_(from.item_configs_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  cash_boost_cooloff_time_ = from.cash_boost_cooloff_time_;
  // @@protoc_insertion_point(copy_constructor:ei.LiveConfig.BoostsConfig)
}

inline void LiveConfig_BoostsConfig::SharedCtor() {
cash_boost_cooloff_time_ = 0;
}

LiveConfig_BoostsConfig::~LiveConfig_BoostsConfig() {
  // @@protoc_insertion_point(destructor:ei.LiveConfig.BoostsConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LiveConfig_BoostsConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LiveConfig_BoostsConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LiveConfig_BoostsConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.LiveConfig.BoostsConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  item_configs_.Clear();
  cash_boost_cooloff_time_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LiveConfig_BoostsConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .ei.LiveConfig.BoostsConfig.ItemConfig item_configs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_item_configs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional double cash_boost_cooloff_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_cash_boost_cooloff_time(&has_bits);
          cash_boost_cooloff_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LiveConfig_BoostsConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.LiveConfig.BoostsConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ei.LiveConfig.BoostsConfig.ItemConfig item_configs = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_item_configs_size()); i < n; i++) {
    const auto& repfield = this->_internal_item_configs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional double cash_boost_cooloff_time = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_cash_boost_cooloff_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.LiveConfig.BoostsConfig)
  return target;
}

size_t LiveConfig_BoostsConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.LiveConfig.BoostsConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.LiveConfig.BoostsConfig.ItemConfig item_configs = 1;
  total_size += 1UL * this->_internal_item_configs_size();
  for (const auto& msg : this->item_configs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional double cash_boost_cooloff_time = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LiveConfig_BoostsConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LiveConfig_BoostsConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LiveConfig_BoostsConfig::GetClassData() const { return &_class_data_; }

void LiveConfig_BoostsConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LiveConfig_BoostsConfig *>(to)->MergeFrom(
      static_cast<const LiveConfig_BoostsConfig &>(from));
}


void LiveConfig_BoostsConfig::MergeFrom(const LiveConfig_BoostsConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.LiveConfig.BoostsConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  item_configs_.MergeFrom(from.item_configs_);
  if (from._internal_has_cash_boost_cooloff_time()) {
    _internal_set_cash_boost_cooloff_time(from._internal_cash_boost_cooloff_time());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LiveConfig_BoostsConfig::CopyFrom(const LiveConfig_BoostsConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.LiveConfig.BoostsConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LiveConfig_BoostsConfig::IsInitialized() const {
  return true;
}

void LiveConfig_BoostsConfig::InternalSwap(LiveConfig_BoostsConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  item_configs_.InternalSwap(&other->item_configs_);
  swap(cash_boost_cooloff_time_, other->cash_boost_cooloff_time_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LiveConfig_BoostsConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[100]);
}

// ===================================================================

class LiveConfig_GiftConfig_GiftValueConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<LiveConfig_GiftConfig_GiftValueConfig>()._has_bits_);
  static void set_has_gift_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_rand_min(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_rand_max(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_video_min(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_video_max(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

LiveConfig_GiftConfig_GiftValueConfig::LiveConfig_GiftConfig_GiftValueConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.LiveConfig.GiftConfig.GiftValueConfig)
}
LiveConfig_GiftConfig_GiftValueConfig::LiveConfig_GiftConfig_GiftValueConfig(const LiveConfig_GiftConfig_GiftValueConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  gift_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    gift_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_gift_id()) {
    gift_id_.Set(from._internal_gift_id(), 
      GetArenaForAllocation());
  }
  ::memcpy(&rand_min_, &from.rand_min_,
    static_cast<size_t>(reinterpret_cast<char*>(&video_max_) -
    reinterpret_cast<char*>(&rand_min_)) + sizeof(video_max_));
  // @@protoc_insertion_point(copy_constructor:ei.LiveConfig.GiftConfig.GiftValueConfig)
}

inline void LiveConfig_GiftConfig_GiftValueConfig::SharedCtor() {
gift_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  gift_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rand_min_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&video_max_) -
    reinterpret_cast<char*>(&rand_min_)) + sizeof(video_max_));
}

LiveConfig_GiftConfig_GiftValueConfig::~LiveConfig_GiftConfig_GiftValueConfig() {
  // @@protoc_insertion_point(destructor:ei.LiveConfig.GiftConfig.GiftValueConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LiveConfig_GiftConfig_GiftValueConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  gift_id_.Destroy();
}

void LiveConfig_GiftConfig_GiftValueConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LiveConfig_GiftConfig_GiftValueConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.LiveConfig.GiftConfig.GiftValueConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    gift_id_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&rand_min_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&video_max_) -
        reinterpret_cast<char*>(&rand_min_)) + sizeof(video_max_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LiveConfig_GiftConfig_GiftValueConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string gift_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_gift_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.LiveConfig.GiftConfig.GiftValueConfig.gift_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double rand_min = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_rand_min(&has_bits);
          rand_min_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double rand_max = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_rand_max(&has_bits);
          rand_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double amount = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_amount(&has_bits);
          amount_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double video_min = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_video_min(&has_bits);
          video_min_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double video_max = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_video_max(&has_bits);
          video_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LiveConfig_GiftConfig_GiftValueConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.LiveConfig.GiftConfig.GiftValueConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string gift_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_gift_id().data(), static_cast<int>(this->_internal_gift_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.LiveConfig.GiftConfig.GiftValueConfig.gift_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_gift_id(), target);
  }

  // optional double rand_min = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_rand_min(), target);
  }

  // optional double rand_max = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_rand_max(), target);
  }

  // optional double amount = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_amount(), target);
  }

  // optional double video_min = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_video_min(), target);
  }

  // optional double video_max = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_video_max(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.LiveConfig.GiftConfig.GiftValueConfig)
  return target;
}

size_t LiveConfig_GiftConfig_GiftValueConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.LiveConfig.GiftConfig.GiftValueConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string gift_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_gift_id());
    }

    // optional double rand_min = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double rand_max = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double amount = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double video_min = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double video_max = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LiveConfig_GiftConfig_GiftValueConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LiveConfig_GiftConfig_GiftValueConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LiveConfig_GiftConfig_GiftValueConfig::GetClassData() const { return &_class_data_; }

void LiveConfig_GiftConfig_GiftValueConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LiveConfig_GiftConfig_GiftValueConfig *>(to)->MergeFrom(
      static_cast<const LiveConfig_GiftConfig_GiftValueConfig &>(from));
}


void LiveConfig_GiftConfig_GiftValueConfig::MergeFrom(const LiveConfig_GiftConfig_GiftValueConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.LiveConfig.GiftConfig.GiftValueConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_gift_id(from._internal_gift_id());
    }
    if (cached_has_bits & 0x00000002u) {
      rand_min_ = from.rand_min_;
    }
    if (cached_has_bits & 0x00000004u) {
      rand_max_ = from.rand_max_;
    }
    if (cached_has_bits & 0x00000008u) {
      amount_ = from.amount_;
    }
    if (cached_has_bits & 0x00000010u) {
      video_min_ = from.video_min_;
    }
    if (cached_has_bits & 0x00000020u) {
      video_max_ = from.video_max_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LiveConfig_GiftConfig_GiftValueConfig::CopyFrom(const LiveConfig_GiftConfig_GiftValueConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.LiveConfig.GiftConfig.GiftValueConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LiveConfig_GiftConfig_GiftValueConfig::IsInitialized() const {
  return true;
}

void LiveConfig_GiftConfig_GiftValueConfig::InternalSwap(LiveConfig_GiftConfig_GiftValueConfig* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &gift_id_, lhs_arena,
      &other->gift_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LiveConfig_GiftConfig_GiftValueConfig, video_max_)
      + sizeof(LiveConfig_GiftConfig_GiftValueConfig::video_max_)
      - PROTOBUF_FIELD_OFFSET(LiveConfig_GiftConfig_GiftValueConfig, rand_min_)>(
          reinterpret_cast<char*>(&rand_min_),
          reinterpret_cast<char*>(&other->rand_min_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LiveConfig_GiftConfig_GiftValueConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[101]);
}

// ===================================================================

class LiveConfig_GiftConfig_GiftMuConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<LiveConfig_GiftConfig_GiftMuConfig>()._has_bits_);
  static void set_has_min_spent(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_max_spent(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_overall_mult(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

LiveConfig_GiftConfig_GiftMuConfig::LiveConfig_GiftConfig_GiftMuConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.LiveConfig.GiftConfig.GiftMuConfig)
}
LiveConfig_GiftConfig_GiftMuConfig::LiveConfig_GiftConfig_GiftMuConfig(const LiveConfig_GiftConfig_GiftMuConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&min_spent_, &from.min_spent_,
    static_cast<size_t>(reinterpret_cast<char*>(&overall_mult_) -
    reinterpret_cast<char*>(&min_spent_)) + sizeof(overall_mult_));
  // @@protoc_insertion_point(copy_constructor:ei.LiveConfig.GiftConfig.GiftMuConfig)
}

inline void LiveConfig_GiftConfig_GiftMuConfig::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&min_spent_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&overall_mult_) -
    reinterpret_cast<char*>(&min_spent_)) + sizeof(overall_mult_));
}

LiveConfig_GiftConfig_GiftMuConfig::~LiveConfig_GiftConfig_GiftMuConfig() {
  // @@protoc_insertion_point(destructor:ei.LiveConfig.GiftConfig.GiftMuConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LiveConfig_GiftConfig_GiftMuConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LiveConfig_GiftConfig_GiftMuConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LiveConfig_GiftConfig_GiftMuConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.LiveConfig.GiftConfig.GiftMuConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&min_spent_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&overall_mult_) -
        reinterpret_cast<char*>(&min_spent_)) + sizeof(overall_mult_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LiveConfig_GiftConfig_GiftMuConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double min_spent = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_min_spent(&has_bits);
          min_spent_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double max_spent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_max_spent(&has_bits);
          max_spent_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double overall_mult = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_overall_mult(&has_bits);
          overall_mult_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LiveConfig_GiftConfig_GiftMuConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.LiveConfig.GiftConfig.GiftMuConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double min_spent = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_min_spent(), target);
  }

  // optional double max_spent = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_max_spent(), target);
  }

  // optional double overall_mult = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_overall_mult(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.LiveConfig.GiftConfig.GiftMuConfig)
  return target;
}

size_t LiveConfig_GiftConfig_GiftMuConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.LiveConfig.GiftConfig.GiftMuConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double min_spent = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double max_spent = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double overall_mult = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LiveConfig_GiftConfig_GiftMuConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LiveConfig_GiftConfig_GiftMuConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LiveConfig_GiftConfig_GiftMuConfig::GetClassData() const { return &_class_data_; }

void LiveConfig_GiftConfig_GiftMuConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LiveConfig_GiftConfig_GiftMuConfig *>(to)->MergeFrom(
      static_cast<const LiveConfig_GiftConfig_GiftMuConfig &>(from));
}


void LiveConfig_GiftConfig_GiftMuConfig::MergeFrom(const LiveConfig_GiftConfig_GiftMuConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.LiveConfig.GiftConfig.GiftMuConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      min_spent_ = from.min_spent_;
    }
    if (cached_has_bits & 0x00000002u) {
      max_spent_ = from.max_spent_;
    }
    if (cached_has_bits & 0x00000004u) {
      overall_mult_ = from.overall_mult_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LiveConfig_GiftConfig_GiftMuConfig::CopyFrom(const LiveConfig_GiftConfig_GiftMuConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.LiveConfig.GiftConfig.GiftMuConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LiveConfig_GiftConfig_GiftMuConfig::IsInitialized() const {
  return true;
}

void LiveConfig_GiftConfig_GiftMuConfig::InternalSwap(LiveConfig_GiftConfig_GiftMuConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LiveConfig_GiftConfig_GiftMuConfig, overall_mult_)
      + sizeof(LiveConfig_GiftConfig_GiftMuConfig::overall_mult_)
      - PROTOBUF_FIELD_OFFSET(LiveConfig_GiftConfig_GiftMuConfig, min_spent_)>(
          reinterpret_cast<char*>(&min_spent_),
          reinterpret_cast<char*>(&other->min_spent_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LiveConfig_GiftConfig_GiftMuConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[102]);
}

// ===================================================================

class LiveConfig_GiftConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<LiveConfig_GiftConfig>()._has_bits_);
  static void set_has_gift_mu_min_spent(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_gift_mu_max_spent(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_gift_mu_overall_mult(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::ei::LiveConfig_GiftConfig_GiftMuConfig& random_gift_mu_config(const LiveConfig_GiftConfig* msg);
  static void set_has_random_gift_mu_config(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ei::LiveConfig_GiftConfig_GiftMuConfig& video_gift_mu_config(const LiveConfig_GiftConfig* msg);
  static void set_has_video_gift_mu_config(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_package_interval(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_video_offer_interval(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_video_offer_interval_contract(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_video_offer_interval_piggy_full(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_video_offer_interval_piggy_extra_full(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_video_reset_on_idle(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_package_interval_contract(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_package_interval_piggy_full(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_package_interval_piggy_extra_full(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_package_reset_on_idle(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
};

const ::ei::LiveConfig_GiftConfig_GiftMuConfig&
LiveConfig_GiftConfig::_Internal::random_gift_mu_config(const LiveConfig_GiftConfig* msg) {
  return *msg->random_gift_mu_config_;
}
const ::ei::LiveConfig_GiftConfig_GiftMuConfig&
LiveConfig_GiftConfig::_Internal::video_gift_mu_config(const LiveConfig_GiftConfig* msg) {
  return *msg->video_gift_mu_config_;
}
LiveConfig_GiftConfig::LiveConfig_GiftConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  gift_configs_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.LiveConfig.GiftConfig)
}
LiveConfig_GiftConfig::LiveConfig_GiftConfig(const LiveConfig_GiftConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      gift_configs_(from.gift_configs_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_random_gift_mu_config()) {
    random_gift_mu_config_ = new ::ei::LiveConfig_GiftConfig_GiftMuConfig(*from.random_gift_mu_config_);
  } else {
    random_gift_mu_config_ = nullptr;
  }
  if (from._internal_has_video_gift_mu_config()) {
    video_gift_mu_config_ = new ::ei::LiveConfig_GiftConfig_GiftMuConfig(*from.video_gift_mu_config_);
  } else {
    video_gift_mu_config_ = nullptr;
  }
  ::memcpy(&package_interval_, &from.package_interval_,
    static_cast<size_t>(reinterpret_cast<char*>(&package_reset_on_idle_) -
    reinterpret_cast<char*>(&package_interval_)) + sizeof(package_reset_on_idle_));
  // @@protoc_insertion_point(copy_constructor:ei.LiveConfig.GiftConfig)
}

inline void LiveConfig_GiftConfig::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&random_gift_mu_config_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&package_reset_on_idle_) -
    reinterpret_cast<char*>(&random_gift_mu_config_)) + sizeof(package_reset_on_idle_));
}

LiveConfig_GiftConfig::~LiveConfig_GiftConfig() {
  // @@protoc_insertion_point(destructor:ei.LiveConfig.GiftConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LiveConfig_GiftConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete random_gift_mu_config_;
  if (this != internal_default_instance()) delete video_gift_mu_config_;
}

void LiveConfig_GiftConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LiveConfig_GiftConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.LiveConfig.GiftConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  gift_configs_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(random_gift_mu_config_ != nullptr);
      random_gift_mu_config_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(video_gift_mu_config_ != nullptr);
      video_gift_mu_config_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&package_interval_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&package_interval_contract_) -
        reinterpret_cast<char*>(&package_interval_)) + sizeof(package_interval_contract_));
  }
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&package_interval_piggy_full_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&package_reset_on_idle_) -
        reinterpret_cast<char*>(&package_interval_piggy_full_)) + sizeof(package_reset_on_idle_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LiveConfig_GiftConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double package_interval = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_package_interval(&has_bits);
          package_interval_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double video_offer_interval = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_video_offer_interval(&has_bits);
          video_offer_interval_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double video_offer_interval_contract = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_video_offer_interval_contract(&has_bits);
          video_offer_interval_contract_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double video_offer_interval_piggy_full = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_video_offer_interval_piggy_full(&has_bits);
          video_offer_interval_piggy_full_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double video_offer_interval_piggy_extra_full = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_video_offer_interval_piggy_extra_full(&has_bits);
          video_offer_interval_piggy_extra_full_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double package_interval_contract = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_package_interval_contract(&has_bits);
          package_interval_contract_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double package_interval_piggy_full = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _Internal::set_has_package_interval_piggy_full(&has_bits);
          package_interval_piggy_full_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double package_interval_piggy_extra_full = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _Internal::set_has_package_interval_piggy_extra_full(&has_bits);
          package_interval_piggy_extra_full_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.LiveConfig.GiftConfig.GiftValueConfig gift_configs = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_gift_configs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional double gift_mu_min_spent = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _Internal::set_has_gift_mu_min_spent(&has_bits);
          gift_mu_min_spent_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double gift_mu_max_spent = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _Internal::set_has_gift_mu_max_spent(&has_bits);
          gift_mu_max_spent_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double gift_mu_overall_mult = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 97)) {
          _Internal::set_has_gift_mu_overall_mult(&has_bits);
          gift_mu_overall_mult_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool package_reset_on_idle = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_package_reset_on_idle(&has_bits);
          package_reset_on_idle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool video_reset_on_idle = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_video_reset_on_idle(&has_bits);
          video_reset_on_idle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.LiveConfig.GiftConfig.GiftMuConfig random_gift_mu_config = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_random_gift_mu_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.LiveConfig.GiftConfig.GiftMuConfig video_gift_mu_config = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_video_gift_mu_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LiveConfig_GiftConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.LiveConfig.GiftConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double package_interval = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_package_interval(), target);
  }

  // optional double video_offer_interval = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_video_offer_interval(), target);
  }

  // optional double video_offer_interval_contract = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_video_offer_interval_contract(), target);
  }

  // optional double video_offer_interval_piggy_full = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_video_offer_interval_piggy_full(), target);
  }

  // optional double video_offer_interval_piggy_extra_full = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_video_offer_interval_piggy_extra_full(), target);
  }

  // optional double package_interval_contract = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_package_interval_contract(), target);
  }

  // optional double package_interval_piggy_full = 7;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_package_interval_piggy_full(), target);
  }

  // optional double package_interval_piggy_extra_full = 8;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_package_interval_piggy_extra_full(), target);
  }

  // repeated .ei.LiveConfig.GiftConfig.GiftValueConfig gift_configs = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_gift_configs_size()); i < n; i++) {
    const auto& repfield = this->_internal_gift_configs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional double gift_mu_min_spent = 10;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(10, this->_internal_gift_mu_min_spent(), target);
  }

  // optional double gift_mu_max_spent = 11;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(11, this->_internal_gift_mu_max_spent(), target);
  }

  // optional double gift_mu_overall_mult = 12;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(12, this->_internal_gift_mu_overall_mult(), target);
  }

  // optional bool package_reset_on_idle = 13;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_package_reset_on_idle(), target);
  }

  // optional bool video_reset_on_idle = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_video_reset_on_idle(), target);
  }

  // optional .ei.LiveConfig.GiftConfig.GiftMuConfig random_gift_mu_config = 15;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::random_gift_mu_config(this),
        _Internal::random_gift_mu_config(this).GetCachedSize(), target, stream);
  }

  // optional .ei.LiveConfig.GiftConfig.GiftMuConfig video_gift_mu_config = 16;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::video_gift_mu_config(this),
        _Internal::video_gift_mu_config(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.LiveConfig.GiftConfig)
  return target;
}

size_t LiveConfig_GiftConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.LiveConfig.GiftConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.LiveConfig.GiftConfig.GiftValueConfig gift_configs = 9;
  total_size += 1UL * this->_internal_gift_configs_size();
  for (const auto& msg : this->gift_configs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .ei.LiveConfig.GiftConfig.GiftMuConfig random_gift_mu_config = 15;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *random_gift_mu_config_);
    }

    // optional .ei.LiveConfig.GiftConfig.GiftMuConfig video_gift_mu_config = 16;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *video_gift_mu_config_);
    }

    // optional double package_interval = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double video_offer_interval = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double video_offer_interval_contract = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double video_offer_interval_piggy_full = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional double video_offer_interval_piggy_extra_full = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional double package_interval_contract = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional double package_interval_piggy_full = 7;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 8;
    }

    // optional double package_interval_piggy_extra_full = 8;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional double gift_mu_min_spent = 10;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 8;
    }

    // optional double gift_mu_max_spent = 11;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 8;
    }

    // optional double gift_mu_overall_mult = 12;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 8;
    }

    // optional bool video_reset_on_idle = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional bool package_reset_on_idle = 13;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LiveConfig_GiftConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LiveConfig_GiftConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LiveConfig_GiftConfig::GetClassData() const { return &_class_data_; }

void LiveConfig_GiftConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LiveConfig_GiftConfig *>(to)->MergeFrom(
      static_cast<const LiveConfig_GiftConfig &>(from));
}


void LiveConfig_GiftConfig::MergeFrom(const LiveConfig_GiftConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.LiveConfig.GiftConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  gift_configs_.MergeFrom(from.gift_configs_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_random_gift_mu_config()->::ei::LiveConfig_GiftConfig_GiftMuConfig::MergeFrom(from._internal_random_gift_mu_config());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_video_gift_mu_config()->::ei::LiveConfig_GiftConfig_GiftMuConfig::MergeFrom(from._internal_video_gift_mu_config());
    }
    if (cached_has_bits & 0x00000004u) {
      package_interval_ = from.package_interval_;
    }
    if (cached_has_bits & 0x00000008u) {
      video_offer_interval_ = from.video_offer_interval_;
    }
    if (cached_has_bits & 0x00000010u) {
      video_offer_interval_contract_ = from.video_offer_interval_contract_;
    }
    if (cached_has_bits & 0x00000020u) {
      video_offer_interval_piggy_full_ = from.video_offer_interval_piggy_full_;
    }
    if (cached_has_bits & 0x00000040u) {
      video_offer_interval_piggy_extra_full_ = from.video_offer_interval_piggy_extra_full_;
    }
    if (cached_has_bits & 0x00000080u) {
      package_interval_contract_ = from.package_interval_contract_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      package_interval_piggy_full_ = from.package_interval_piggy_full_;
    }
    if (cached_has_bits & 0x00000200u) {
      package_interval_piggy_extra_full_ = from.package_interval_piggy_extra_full_;
    }
    if (cached_has_bits & 0x00000400u) {
      gift_mu_min_spent_ = from.gift_mu_min_spent_;
    }
    if (cached_has_bits & 0x00000800u) {
      gift_mu_max_spent_ = from.gift_mu_max_spent_;
    }
    if (cached_has_bits & 0x00001000u) {
      gift_mu_overall_mult_ = from.gift_mu_overall_mult_;
    }
    if (cached_has_bits & 0x00002000u) {
      video_reset_on_idle_ = from.video_reset_on_idle_;
    }
    if (cached_has_bits & 0x00004000u) {
      package_reset_on_idle_ = from.package_reset_on_idle_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LiveConfig_GiftConfig::CopyFrom(const LiveConfig_GiftConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.LiveConfig.GiftConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LiveConfig_GiftConfig::IsInitialized() const {
  return true;
}

void LiveConfig_GiftConfig::InternalSwap(LiveConfig_GiftConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  gift_configs_.InternalSwap(&other->gift_configs_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LiveConfig_GiftConfig, package_reset_on_idle_)
      + sizeof(LiveConfig_GiftConfig::package_reset_on_idle_)
      - PROTOBUF_FIELD_OFFSET(LiveConfig_GiftConfig, random_gift_mu_config_)>(
          reinterpret_cast<char*>(&random_gift_mu_config_),
          reinterpret_cast<char*>(&other->random_gift_mu_config_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LiveConfig_GiftConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[103]);
}

// ===================================================================

class LiveConfig_MiscConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<LiveConfig_MiscConfig>()._has_bits_);
  static void set_has_ask_to_track(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ask_to_track_min_soul_eggs(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ask_to_track_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ask_to_track_show_pre_dialog(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ask_to_track_after_privacy(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_chicken_run_boost_percentage(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_shells_intro_tickets(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_shells_max_free_chicken_configs(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_shells_intro_alert_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_contracts_expert_league_min_soul_power(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_new_player_event_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_contracts_club_available(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_contracts_beta(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
};

LiveConfig_MiscConfig::LiveConfig_MiscConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.LiveConfig.MiscConfig)
}
LiveConfig_MiscConfig::LiveConfig_MiscConfig(const LiveConfig_MiscConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ask_to_track_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ask_to_track_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ask_to_track_message()) {
    ask_to_track_message_.Set(from._internal_ask_to_track_message(), 
      GetArenaForAllocation());
  }
  ::memcpy(&ask_to_track_min_soul_eggs_, &from.ask_to_track_min_soul_eggs_,
    static_cast<size_t>(reinterpret_cast<char*>(&contracts_beta_) -
    reinterpret_cast<char*>(&ask_to_track_min_soul_eggs_)) + sizeof(contracts_beta_));
  // @@protoc_insertion_point(copy_constructor:ei.LiveConfig.MiscConfig)
}

inline void LiveConfig_MiscConfig::SharedCtor() {
ask_to_track_message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ask_to_track_message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&ask_to_track_min_soul_eggs_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&contracts_beta_) -
    reinterpret_cast<char*>(&ask_to_track_min_soul_eggs_)) + sizeof(contracts_beta_));
}

LiveConfig_MiscConfig::~LiveConfig_MiscConfig() {
  // @@protoc_insertion_point(destructor:ei.LiveConfig.MiscConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LiveConfig_MiscConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ask_to_track_message_.Destroy();
}

void LiveConfig_MiscConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LiveConfig_MiscConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.LiveConfig.MiscConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ask_to_track_message_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&ask_to_track_min_soul_eggs_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&chicken_run_boost_percentage_) -
        reinterpret_cast<char*>(&ask_to_track_min_soul_eggs_)) + sizeof(chicken_run_boost_percentage_));
  }
  if (cached_has_bits & 0x00001f00u) {
    ::memset(&shells_max_free_chicken_configs_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&contracts_beta_) -
        reinterpret_cast<char*>(&shells_max_free_chicken_configs_)) + sizeof(contracts_beta_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LiveConfig_MiscConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool ask_to_track = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ask_to_track(&has_bits);
          ask_to_track_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double ask_to_track_min_soul_eggs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_ask_to_track_min_soul_eggs(&has_bits);
          ask_to_track_min_soul_eggs_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional string ask_to_track_message = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_ask_to_track_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.LiveConfig.MiscConfig.ask_to_track_message");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool ask_to_track_show_pre_dialog = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_ask_to_track_show_pre_dialog(&has_bits);
          ask_to_track_show_pre_dialog_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ask_to_track_after_privacy = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_ask_to_track_after_privacy(&has_bits);
          ask_to_track_after_privacy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double chicken_run_boost_percentage = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_chicken_run_boost_percentage(&has_bits);
          chicken_run_boost_percentage_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 shells_intro_tickets = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_shells_intro_tickets(&has_bits);
          shells_intro_tickets_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 shells_max_free_chicken_configs = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_shells_max_free_chicken_configs(&has_bits);
          shells_max_free_chicken_configs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 shells_intro_alert_threshold = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_shells_intro_alert_threshold(&has_bits);
          shells_intro_alert_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double contracts_expert_league_min_soul_power = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _Internal::set_has_contracts_expert_league_min_soul_power(&has_bits);
          contracts_expert_league_min_soul_power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double new_player_event_duration = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _Internal::set_has_new_player_event_duration(&has_bits);
          new_player_event_duration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool contracts_club_available = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_contracts_club_available(&has_bits);
          contracts_club_available_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool contracts_beta = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_contracts_beta(&has_bits);
          contracts_beta_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LiveConfig_MiscConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.LiveConfig.MiscConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool ask_to_track = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_ask_to_track(), target);
  }

  // optional double ask_to_track_min_soul_eggs = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_ask_to_track_min_soul_eggs(), target);
  }

  // optional string ask_to_track_message = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ask_to_track_message().data(), static_cast<int>(this->_internal_ask_to_track_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.LiveConfig.MiscConfig.ask_to_track_message");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_ask_to_track_message(), target);
  }

  // optional bool ask_to_track_show_pre_dialog = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_ask_to_track_show_pre_dialog(), target);
  }

  // optional bool ask_to_track_after_privacy = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_ask_to_track_after_privacy(), target);
  }

  // optional double chicken_run_boost_percentage = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_chicken_run_boost_percentage(), target);
  }

  // optional uint32 shells_intro_tickets = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_shells_intro_tickets(), target);
  }

  // optional uint32 shells_max_free_chicken_configs = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_shells_max_free_chicken_configs(), target);
  }

  // optional uint32 shells_intro_alert_threshold = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_shells_intro_alert_threshold(), target);
  }

  // optional double contracts_expert_league_min_soul_power = 10;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(10, this->_internal_contracts_expert_league_min_soul_power(), target);
  }

  // optional double new_player_event_duration = 11;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(11, this->_internal_new_player_event_duration(), target);
  }

  // optional bool contracts_club_available = 12;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_contracts_club_available(), target);
  }

  // optional bool contracts_beta = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_contracts_beta(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.LiveConfig.MiscConfig)
  return target;
}

size_t LiveConfig_MiscConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.LiveConfig.MiscConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string ask_to_track_message = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ask_to_track_message());
    }

    // optional double ask_to_track_min_soul_eggs = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional bool ask_to_track = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool ask_to_track_show_pre_dialog = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool ask_to_track_after_privacy = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool contracts_club_available = 12;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional uint32 shells_intro_tickets = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_shells_intro_tickets());
    }

    // optional double chicken_run_boost_percentage = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x00001f00u) {
    // optional uint32 shells_max_free_chicken_configs = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_shells_max_free_chicken_configs());
    }

    // optional uint32 shells_intro_alert_threshold = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_shells_intro_alert_threshold());
    }

    // optional double contracts_expert_league_min_soul_power = 10;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 8;
    }

    // optional double new_player_event_duration = 11;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 8;
    }

    // optional bool contracts_beta = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LiveConfig_MiscConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LiveConfig_MiscConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LiveConfig_MiscConfig::GetClassData() const { return &_class_data_; }

void LiveConfig_MiscConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LiveConfig_MiscConfig *>(to)->MergeFrom(
      static_cast<const LiveConfig_MiscConfig &>(from));
}


void LiveConfig_MiscConfig::MergeFrom(const LiveConfig_MiscConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.LiveConfig.MiscConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ask_to_track_message(from._internal_ask_to_track_message());
    }
    if (cached_has_bits & 0x00000002u) {
      ask_to_track_min_soul_eggs_ = from.ask_to_track_min_soul_eggs_;
    }
    if (cached_has_bits & 0x00000004u) {
      ask_to_track_ = from.ask_to_track_;
    }
    if (cached_has_bits & 0x00000008u) {
      ask_to_track_show_pre_dialog_ = from.ask_to_track_show_pre_dialog_;
    }
    if (cached_has_bits & 0x00000010u) {
      ask_to_track_after_privacy_ = from.ask_to_track_after_privacy_;
    }
    if (cached_has_bits & 0x00000020u) {
      contracts_club_available_ = from.contracts_club_available_;
    }
    if (cached_has_bits & 0x00000040u) {
      shells_intro_tickets_ = from.shells_intro_tickets_;
    }
    if (cached_has_bits & 0x00000080u) {
      chicken_run_boost_percentage_ = from.chicken_run_boost_percentage_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      shells_max_free_chicken_configs_ = from.shells_max_free_chicken_configs_;
    }
    if (cached_has_bits & 0x00000200u) {
      shells_intro_alert_threshold_ = from.shells_intro_alert_threshold_;
    }
    if (cached_has_bits & 0x00000400u) {
      contracts_expert_league_min_soul_power_ = from.contracts_expert_league_min_soul_power_;
    }
    if (cached_has_bits & 0x00000800u) {
      new_player_event_duration_ = from.new_player_event_duration_;
    }
    if (cached_has_bits & 0x00001000u) {
      contracts_beta_ = from.contracts_beta_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LiveConfig_MiscConfig::CopyFrom(const LiveConfig_MiscConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.LiveConfig.MiscConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LiveConfig_MiscConfig::IsInitialized() const {
  return true;
}

void LiveConfig_MiscConfig::InternalSwap(LiveConfig_MiscConfig* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ask_to_track_message_, lhs_arena,
      &other->ask_to_track_message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LiveConfig_MiscConfig, contracts_beta_)
      + sizeof(LiveConfig_MiscConfig::contracts_beta_)
      - PROTOBUF_FIELD_OFFSET(LiveConfig_MiscConfig, ask_to_track_min_soul_eggs_)>(
          reinterpret_cast<char*>(&ask_to_track_min_soul_eggs_),
          reinterpret_cast<char*>(&other->ask_to_track_min_soul_eggs_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LiveConfig_MiscConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[104]);
}

// ===================================================================

class LiveConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<LiveConfig>()._has_bits_);
  static void set_has_config_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ei::LiveConfig_BoostsConfig& boosts_config(const LiveConfig* msg);
  static void set_has_boosts_config(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::ei::LiveConfig_GiftConfig& gift_config(const LiveConfig* msg);
  static void set_has_gift_config(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::ei::LiveConfig_MiscConfig& misc_config(const LiveConfig* msg);
  static void set_has_misc_config(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::ei::LiveConfig_BoostsConfig&
LiveConfig::_Internal::boosts_config(const LiveConfig* msg) {
  return *msg->boosts_config_;
}
const ::ei::LiveConfig_GiftConfig&
LiveConfig::_Internal::gift_config(const LiveConfig* msg) {
  return *msg->gift_config_;
}
const ::ei::LiveConfig_MiscConfig&
LiveConfig::_Internal::misc_config(const LiveConfig* msg) {
  return *msg->misc_config_;
}
LiveConfig::LiveConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.LiveConfig)
}
LiveConfig::LiveConfig(const LiveConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  config_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    config_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_config_id()) {
    config_id_.Set(from._internal_config_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_boosts_config()) {
    boosts_config_ = new ::ei::LiveConfig_BoostsConfig(*from.boosts_config_);
  } else {
    boosts_config_ = nullptr;
  }
  if (from._internal_has_gift_config()) {
    gift_config_ = new ::ei::LiveConfig_GiftConfig(*from.gift_config_);
  } else {
    gift_config_ = nullptr;
  }
  if (from._internal_has_misc_config()) {
    misc_config_ = new ::ei::LiveConfig_MiscConfig(*from.misc_config_);
  } else {
    misc_config_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:ei.LiveConfig)
}

inline void LiveConfig::SharedCtor() {
config_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  config_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&boosts_config_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&misc_config_) -
    reinterpret_cast<char*>(&boosts_config_)) + sizeof(misc_config_));
}

LiveConfig::~LiveConfig() {
  // @@protoc_insertion_point(destructor:ei.LiveConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LiveConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  config_id_.Destroy();
  if (this != internal_default_instance()) delete boosts_config_;
  if (this != internal_default_instance()) delete gift_config_;
  if (this != internal_default_instance()) delete misc_config_;
}

void LiveConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LiveConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.LiveConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      config_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(boosts_config_ != nullptr);
      boosts_config_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(gift_config_ != nullptr);
      gift_config_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(misc_config_ != nullptr);
      misc_config_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LiveConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string config_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_config_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.LiveConfig.config_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .ei.LiveConfig.BoostsConfig boosts_config = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_boosts_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.LiveConfig.GiftConfig gift_config = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_gift_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.LiveConfig.MiscConfig misc_config = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_misc_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LiveConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.LiveConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string config_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_config_id().data(), static_cast<int>(this->_internal_config_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.LiveConfig.config_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_config_id(), target);
  }

  // optional .ei.LiveConfig.BoostsConfig boosts_config = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::boosts_config(this),
        _Internal::boosts_config(this).GetCachedSize(), target, stream);
  }

  // optional .ei.LiveConfig.GiftConfig gift_config = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::gift_config(this),
        _Internal::gift_config(this).GetCachedSize(), target, stream);
  }

  // optional .ei.LiveConfig.MiscConfig misc_config = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::misc_config(this),
        _Internal::misc_config(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.LiveConfig)
  return target;
}

size_t LiveConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.LiveConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string config_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_config_id());
    }

    // optional .ei.LiveConfig.BoostsConfig boosts_config = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *boosts_config_);
    }

    // optional .ei.LiveConfig.GiftConfig gift_config = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *gift_config_);
    }

    // optional .ei.LiveConfig.MiscConfig misc_config = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *misc_config_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LiveConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LiveConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LiveConfig::GetClassData() const { return &_class_data_; }

void LiveConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LiveConfig *>(to)->MergeFrom(
      static_cast<const LiveConfig &>(from));
}


void LiveConfig::MergeFrom(const LiveConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.LiveConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_config_id(from._internal_config_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_boosts_config()->::ei::LiveConfig_BoostsConfig::MergeFrom(from._internal_boosts_config());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_gift_config()->::ei::LiveConfig_GiftConfig::MergeFrom(from._internal_gift_config());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_misc_config()->::ei::LiveConfig_MiscConfig::MergeFrom(from._internal_misc_config());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LiveConfig::CopyFrom(const LiveConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.LiveConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LiveConfig::IsInitialized() const {
  return true;
}

void LiveConfig::InternalSwap(LiveConfig* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &config_id_, lhs_arena,
      &other->config_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LiveConfig, misc_config_)
      + sizeof(LiveConfig::misc_config_)
      - PROTOBUF_FIELD_OFFSET(LiveConfig, boosts_config_)>(
          reinterpret_cast<char*>(&boosts_config_),
          reinterpret_cast<char*>(&other->boosts_config_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LiveConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[105]);
}

// ===================================================================

class InGameMail::_Internal {
 public:
  using HasBits = decltype(std::declval<InGameMail>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_title(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_date(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_action(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_platform(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_min_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_max_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_min_soul_eggs(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_min_mystical_bonus(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_gold_tip(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

InGameMail::InGameMail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  builds_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.InGameMail)
}
InGameMail::InGameMail(const InGameMail& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      builds_(from.builds_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_id()) {
    id_.Set(from._internal_id(), 
      GetArenaForAllocation());
  }
  title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_title()) {
    title_.Set(from._internal_title(), 
      GetArenaForAllocation());
  }
  message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    message_.Set(from._internal_message(), 
      GetArenaForAllocation());
  }
  action_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    action_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_action()) {
    action_.Set(from._internal_action(), 
      GetArenaForAllocation());
  }
  url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    url_.Set(from._internal_url(), 
      GetArenaForAllocation());
  }
  date_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    date_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_date()) {
    date_.Set(from._internal_date(), 
      GetArenaForAllocation());
  }
  ::memcpy(&gold_tip_, &from.gold_tip_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_client_version_) -
    reinterpret_cast<char*>(&gold_tip_)) + sizeof(max_client_version_));
  // @@protoc_insertion_point(copy_constructor:ei.InGameMail)
}

inline void InGameMail::SharedCtor() {
id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
title_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  title_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
action_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  action_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
date_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  date_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gold_tip_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&max_client_version_) -
    reinterpret_cast<char*>(&gold_tip_)) + sizeof(max_client_version_));
}

InGameMail::~InGameMail() {
  // @@protoc_insertion_point(destructor:ei.InGameMail)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InGameMail::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  id_.Destroy();
  title_.Destroy();
  message_.Destroy();
  action_.Destroy();
  url_.Destroy();
  date_.Destroy();
}

void InGameMail::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void InGameMail::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.InGameMail)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  builds_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      title_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      action_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      date_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&gold_tip_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&platform_) -
        reinterpret_cast<char*>(&gold_tip_)) + sizeof(platform_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&min_client_version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&max_client_version_) -
        reinterpret_cast<char*>(&min_client_version_)) + sizeof(max_client_version_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InGameMail::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.InGameMail.id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string title = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.InGameMail.title");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string message = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.InGameMail.message");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string action = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_action();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.InGameMail.action");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string url = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.InGameMail.url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double gold_tip = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_gold_tip(&has_bits);
          gold_tip_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 platform = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_platform(&has_bits);
          platform_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string date = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_date();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.InGameMail.date");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated string builds = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_builds();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "ei.InGameMail.builds");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 min_client_version = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_min_client_version(&has_bits);
          min_client_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double min_soul_eggs = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _Internal::set_has_min_soul_eggs(&has_bits);
          min_soul_eggs_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 max_client_version = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_max_client_version(&has_bits);
          max_client_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double min_mystical_bonus = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 105)) {
          _Internal::set_has_min_mystical_bonus(&has_bits);
          min_mystical_bonus_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InGameMail::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.InGameMail)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.InGameMail.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // optional string title = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_title().data(), static_cast<int>(this->_internal_title().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.InGameMail.title");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_title(), target);
  }

  // optional string message = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_message().data(), static_cast<int>(this->_internal_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.InGameMail.message");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_message(), target);
  }

  // optional string action = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_action().data(), static_cast<int>(this->_internal_action().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.InGameMail.action");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_action(), target);
  }

  // optional string url = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_url().data(), static_cast<int>(this->_internal_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.InGameMail.url");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_url(), target);
  }

  // optional double gold_tip = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_gold_tip(), target);
  }

  // optional uint32 platform = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_platform(), target);
  }

  // optional string date = 8;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_date().data(), static_cast<int>(this->_internal_date().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.InGameMail.date");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_date(), target);
  }

  // repeated string builds = 9;
  for (int i = 0, n = this->_internal_builds_size(); i < n; i++) {
    const auto& s = this->_internal_builds(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.InGameMail.builds");
    target = stream->WriteString(9, s, target);
  }

  // optional uint32 min_client_version = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_min_client_version(), target);
  }

  // optional double min_soul_eggs = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(11, this->_internal_min_soul_eggs(), target);
  }

  // optional uint32 max_client_version = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_max_client_version(), target);
  }

  // optional double min_mystical_bonus = 13;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(13, this->_internal_min_mystical_bonus(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.InGameMail)
  return target;
}

size_t InGameMail::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.InGameMail)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string builds = 9;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(builds_.size());
  for (int i = 0, n = builds_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      builds_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_id());
    }

    // optional string title = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_title());
    }

    // optional string message = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_message());
    }

    // optional string action = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_action());
    }

    // optional string url = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

    // optional string date = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_date());
    }

    // optional double gold_tip = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional uint32 platform = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_platform());
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional uint32 min_client_version = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_min_client_version());
    }

    // optional double min_soul_eggs = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional double min_mystical_bonus = 13;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 8;
    }

    // optional uint32 max_client_version = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_max_client_version());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InGameMail::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    InGameMail::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InGameMail::GetClassData() const { return &_class_data_; }

void InGameMail::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<InGameMail *>(to)->MergeFrom(
      static_cast<const InGameMail &>(from));
}


void InGameMail::MergeFrom(const InGameMail& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.InGameMail)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  builds_.MergeFrom(from.builds_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_title(from._internal_title());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_action(from._internal_action());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_date(from._internal_date());
    }
    if (cached_has_bits & 0x00000040u) {
      gold_tip_ = from.gold_tip_;
    }
    if (cached_has_bits & 0x00000080u) {
      platform_ = from.platform_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      min_client_version_ = from.min_client_version_;
    }
    if (cached_has_bits & 0x00000200u) {
      min_soul_eggs_ = from.min_soul_eggs_;
    }
    if (cached_has_bits & 0x00000400u) {
      min_mystical_bonus_ = from.min_mystical_bonus_;
    }
    if (cached_has_bits & 0x00000800u) {
      max_client_version_ = from.max_client_version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InGameMail::CopyFrom(const InGameMail& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.InGameMail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InGameMail::IsInitialized() const {
  return true;
}

void InGameMail::InternalSwap(InGameMail* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  builds_.InternalSwap(&other->builds_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &id_, lhs_arena,
      &other->id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &title_, lhs_arena,
      &other->title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &message_, lhs_arena,
      &other->message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &action_, lhs_arena,
      &other->action_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &url_, lhs_arena,
      &other->url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &date_, lhs_arena,
      &other->date_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InGameMail, max_client_version_)
      + sizeof(InGameMail::max_client_version_)
      - PROTOBUF_FIELD_OFFSET(InGameMail, gold_tip_)>(
          reinterpret_cast<char*>(&gold_tip_),
          reinterpret_cast<char*>(&other->gold_tip_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InGameMail::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[106]);
}

// ===================================================================

class MailDB::_Internal {
 public:
};

MailDB::MailDB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  mail_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.MailDB)
}
MailDB::MailDB(const MailDB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      mail_(from.mail_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ei.MailDB)
}

inline void MailDB::SharedCtor() {
}

MailDB::~MailDB() {
  // @@protoc_insertion_point(destructor:ei.MailDB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MailDB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MailDB::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MailDB::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.MailDB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  mail_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MailDB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .ei.InGameMail mail = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_mail(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MailDB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.MailDB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ei.InGameMail mail = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_mail_size()); i < n; i++) {
    const auto& repfield = this->_internal_mail(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.MailDB)
  return target;
}

size_t MailDB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.MailDB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.InGameMail mail = 1;
  total_size += 1UL * this->_internal_mail_size();
  for (const auto& msg : this->mail_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MailDB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MailDB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MailDB::GetClassData() const { return &_class_data_; }

void MailDB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MailDB *>(to)->MergeFrom(
      static_cast<const MailDB &>(from));
}


void MailDB::MergeFrom(const MailDB& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.MailDB)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  mail_.MergeFrom(from.mail_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MailDB::CopyFrom(const MailDB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.MailDB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MailDB::IsInitialized() const {
  return true;
}

void MailDB::InternalSwap(MailDB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  mail_.InternalSwap(&other->mail_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MailDB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[107]);
}

// ===================================================================

class PeriodicalsResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<PeriodicalsResponse>()._has_bits_);
  static const ::ei::SalesInfo& sales(const PeriodicalsResponse* msg);
  static void set_has_sales(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ei::EggIncCurrentEvents& events(const PeriodicalsResponse* msg);
  static void set_has_events(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::ei::ContractsResponse& contracts(const PeriodicalsResponse* msg);
  static void set_has_contracts(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::ei::LiveConfig& live_config(const PeriodicalsResponse* msg);
  static void set_has_live_config(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::ei::MailDB& mail_bag(const PeriodicalsResponse* msg);
  static void set_has_mail_bag(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::ei::ContractPlayerInfo& contract_player_info(const PeriodicalsResponse* msg);
  static void set_has_contract_player_info(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::ei::SalesInfo&
PeriodicalsResponse::_Internal::sales(const PeriodicalsResponse* msg) {
  return *msg->sales_;
}
const ::ei::EggIncCurrentEvents&
PeriodicalsResponse::_Internal::events(const PeriodicalsResponse* msg) {
  return *msg->events_;
}
const ::ei::ContractsResponse&
PeriodicalsResponse::_Internal::contracts(const PeriodicalsResponse* msg) {
  return *msg->contracts_;
}
const ::ei::LiveConfig&
PeriodicalsResponse::_Internal::live_config(const PeriodicalsResponse* msg) {
  return *msg->live_config_;
}
const ::ei::MailDB&
PeriodicalsResponse::_Internal::mail_bag(const PeriodicalsResponse* msg) {
  return *msg->mail_bag_;
}
const ::ei::ContractPlayerInfo&
PeriodicalsResponse::_Internal::contract_player_info(const PeriodicalsResponse* msg) {
  return *msg->contract_player_info_;
}
PeriodicalsResponse::PeriodicalsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  gifts_(arena),
  evaluations_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.PeriodicalsResponse)
}
PeriodicalsResponse::PeriodicalsResponse(const PeriodicalsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      gifts_(from.gifts_),
      evaluations_(from.evaluations_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_sales()) {
    sales_ = new ::ei::SalesInfo(*from.sales_);
  } else {
    sales_ = nullptr;
  }
  if (from._internal_has_events()) {
    events_ = new ::ei::EggIncCurrentEvents(*from.events_);
  } else {
    events_ = nullptr;
  }
  if (from._internal_has_contracts()) {
    contracts_ = new ::ei::ContractsResponse(*from.contracts_);
  } else {
    contracts_ = nullptr;
  }
  if (from._internal_has_live_config()) {
    live_config_ = new ::ei::LiveConfig(*from.live_config_);
  } else {
    live_config_ = nullptr;
  }
  if (from._internal_has_mail_bag()) {
    mail_bag_ = new ::ei::MailDB(*from.mail_bag_);
  } else {
    mail_bag_ = nullptr;
  }
  if (from._internal_has_contract_player_info()) {
    contract_player_info_ = new ::ei::ContractPlayerInfo(*from.contract_player_info_);
  } else {
    contract_player_info_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:ei.PeriodicalsResponse)
}

inline void PeriodicalsResponse::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sales_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&contract_player_info_) -
    reinterpret_cast<char*>(&sales_)) + sizeof(contract_player_info_));
}

PeriodicalsResponse::~PeriodicalsResponse() {
  // @@protoc_insertion_point(destructor:ei.PeriodicalsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PeriodicalsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete sales_;
  if (this != internal_default_instance()) delete events_;
  if (this != internal_default_instance()) delete contracts_;
  if (this != internal_default_instance()) delete live_config_;
  if (this != internal_default_instance()) delete mail_bag_;
  if (this != internal_default_instance()) delete contract_player_info_;
}

void PeriodicalsResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PeriodicalsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.PeriodicalsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  gifts_.Clear();
  evaluations_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(sales_ != nullptr);
      sales_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(events_ != nullptr);
      events_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(contracts_ != nullptr);
      contracts_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(live_config_ != nullptr);
      live_config_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(mail_bag_ != nullptr);
      mail_bag_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(contract_player_info_ != nullptr);
      contract_player_info_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PeriodicalsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.SalesInfo sales = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_sales(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.EggIncCurrentEvents events = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_events(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.ContractsResponse contracts = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_contracts(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ServerGift gifts = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_gifts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .ei.LiveConfig live_config = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_live_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.MailDB mail_bag = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_mail_bag(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.ContractPlayerInfo contract_player_info = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_contract_player_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ContractEvaluation evaluations = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_evaluations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PeriodicalsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.PeriodicalsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.SalesInfo sales = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::sales(this),
        _Internal::sales(this).GetCachedSize(), target, stream);
  }

  // optional .ei.EggIncCurrentEvents events = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::events(this),
        _Internal::events(this).GetCachedSize(), target, stream);
  }

  // optional .ei.ContractsResponse contracts = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::contracts(this),
        _Internal::contracts(this).GetCachedSize(), target, stream);
  }

  // repeated .ei.ServerGift gifts = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_gifts_size()); i < n; i++) {
    const auto& repfield = this->_internal_gifts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .ei.LiveConfig live_config = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::live_config(this),
        _Internal::live_config(this).GetCachedSize(), target, stream);
  }

  // optional .ei.MailDB mail_bag = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::mail_bag(this),
        _Internal::mail_bag(this).GetCachedSize(), target, stream);
  }

  // optional .ei.ContractPlayerInfo contract_player_info = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::contract_player_info(this),
        _Internal::contract_player_info(this).GetCachedSize(), target, stream);
  }

  // repeated .ei.ContractEvaluation evaluations = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_evaluations_size()); i < n; i++) {
    const auto& repfield = this->_internal_evaluations(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.PeriodicalsResponse)
  return target;
}

size_t PeriodicalsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.PeriodicalsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.ServerGift gifts = 4;
  total_size += 1UL * this->_internal_gifts_size();
  for (const auto& msg : this->gifts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.ContractEvaluation evaluations = 8;
  total_size += 1UL * this->_internal_evaluations_size();
  for (const auto& msg : this->evaluations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .ei.SalesInfo sales = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *sales_);
    }

    // optional .ei.EggIncCurrentEvents events = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *events_);
    }

    // optional .ei.ContractsResponse contracts = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *contracts_);
    }

    // optional .ei.LiveConfig live_config = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *live_config_);
    }

    // optional .ei.MailDB mail_bag = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *mail_bag_);
    }

    // optional .ei.ContractPlayerInfo contract_player_info = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *contract_player_info_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PeriodicalsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PeriodicalsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PeriodicalsResponse::GetClassData() const { return &_class_data_; }

void PeriodicalsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PeriodicalsResponse *>(to)->MergeFrom(
      static_cast<const PeriodicalsResponse &>(from));
}


void PeriodicalsResponse::MergeFrom(const PeriodicalsResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.PeriodicalsResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  gifts_.MergeFrom(from.gifts_);
  evaluations_.MergeFrom(from.evaluations_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_sales()->::ei::SalesInfo::MergeFrom(from._internal_sales());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_events()->::ei::EggIncCurrentEvents::MergeFrom(from._internal_events());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_contracts()->::ei::ContractsResponse::MergeFrom(from._internal_contracts());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_live_config()->::ei::LiveConfig::MergeFrom(from._internal_live_config());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_mail_bag()->::ei::MailDB::MergeFrom(from._internal_mail_bag());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_contract_player_info()->::ei::ContractPlayerInfo::MergeFrom(from._internal_contract_player_info());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PeriodicalsResponse::CopyFrom(const PeriodicalsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.PeriodicalsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PeriodicalsResponse::IsInitialized() const {
  return true;
}

void PeriodicalsResponse::InternalSwap(PeriodicalsResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  gifts_.InternalSwap(&other->gifts_);
  evaluations_.InternalSwap(&other->evaluations_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PeriodicalsResponse, contract_player_info_)
      + sizeof(PeriodicalsResponse::contract_player_info_)
      - PROTOBUF_FIELD_OFFSET(PeriodicalsResponse, sales_)>(
          reinterpret_cast<char*>(&sales_),
          reinterpret_cast<char*>(&other->sales_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PeriodicalsResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[108]);
}

// ===================================================================

class GetPeriodicalsRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<GetPeriodicalsRequest>()._has_bits_);
  static const ::ei::BasicRequestInfo& rinfo(const GetPeriodicalsRequest* msg);
  static void set_has_rinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_piggy_full(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_piggy_found_full(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_seconds_full_realtime(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_seconds_full_gametime(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_lost_increments(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_soul_eggs(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_mystical_earnings_mult(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_eop(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_contracts_unlocked(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_artifacts_unlocked(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_current_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_debug(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
};

const ::ei::BasicRequestInfo&
GetPeriodicalsRequest::_Internal::rinfo(const GetPeriodicalsRequest* msg) {
  return *msg->rinfo_;
}
GetPeriodicalsRequest::GetPeriodicalsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.GetPeriodicalsRequest)
}
GetPeriodicalsRequest::GetPeriodicalsRequest(const GetPeriodicalsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_id()) {
    user_id_.Set(from._internal_user_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_rinfo()) {
    rinfo_ = new ::ei::BasicRequestInfo(*from.rinfo_);
  } else {
    rinfo_ = nullptr;
  }
  ::memcpy(&seconds_full_realtime_, &from.seconds_full_realtime_,
    static_cast<size_t>(reinterpret_cast<char*>(&eop_) -
    reinterpret_cast<char*>(&seconds_full_realtime_)) + sizeof(eop_));
  // @@protoc_insertion_point(copy_constructor:ei.GetPeriodicalsRequest)
}

inline void GetPeriodicalsRequest::SharedCtor() {
user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rinfo_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&eop_) -
    reinterpret_cast<char*>(&rinfo_)) + sizeof(eop_));
}

GetPeriodicalsRequest::~GetPeriodicalsRequest() {
  // @@protoc_insertion_point(destructor:ei.GetPeriodicalsRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetPeriodicalsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_id_.Destroy();
  if (this != internal_default_instance()) delete rinfo_;
}

void GetPeriodicalsRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetPeriodicalsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.GetPeriodicalsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(rinfo_ != nullptr);
      rinfo_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&seconds_full_realtime_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&piggy_found_full_) -
        reinterpret_cast<char*>(&seconds_full_realtime_)) + sizeof(piggy_found_full_));
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&contracts_unlocked_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&eop_) -
        reinterpret_cast<char*>(&contracts_unlocked_)) + sizeof(eop_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetPeriodicalsRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.GetPeriodicalsRequest.user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool piggy_full = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_piggy_full(&has_bits);
          piggy_full_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool piggy_found_full = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_piggy_found_full(&has_bits);
          piggy_found_full_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double seconds_full_realtime = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_seconds_full_realtime(&has_bits);
          seconds_full_realtime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double seconds_full_gametime = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_seconds_full_gametime(&has_bits);
          seconds_full_gametime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lost_increments = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_lost_increments(&has_bits);
          lost_increments_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double soul_eggs = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _Internal::set_has_soul_eggs(&has_bits);
          soul_eggs_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 current_client_version = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_current_client_version(&has_bits);
          current_client_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool debug = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_debug(&has_bits);
          debug_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.BasicRequestInfo rinfo = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_rinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double mystical_earnings_mult = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 105)) {
          _Internal::set_has_mystical_earnings_mult(&has_bits);
          mystical_earnings_mult_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 eop = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_eop(&has_bits);
          eop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool contracts_unlocked = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_contracts_unlocked(&has_bits);
          contracts_unlocked_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool artifacts_unlocked = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_artifacts_unlocked(&has_bits);
          artifacts_unlocked_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetPeriodicalsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.GetPeriodicalsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.GetPeriodicalsRequest.user_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_id(), target);
  }

  // optional bool piggy_full = 2;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_piggy_full(), target);
  }

  // optional bool piggy_found_full = 3;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_piggy_found_full(), target);
  }

  // optional double seconds_full_realtime = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_seconds_full_realtime(), target);
  }

  // optional double seconds_full_gametime = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_seconds_full_gametime(), target);
  }

  // optional uint32 lost_increments = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_lost_increments(), target);
  }

  // optional double soul_eggs = 8;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_soul_eggs(), target);
  }

  // optional uint32 current_client_version = 10;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_current_client_version(), target);
  }

  // optional bool debug = 11;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_debug(), target);
  }

  // optional .ei.BasicRequestInfo rinfo = 12;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::rinfo(this),
        _Internal::rinfo(this).GetCachedSize(), target, stream);
  }

  // optional double mystical_earnings_mult = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(13, this->_internal_mystical_earnings_mult(), target);
  }

  // optional uint32 eop = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_eop(), target);
  }

  // optional bool contracts_unlocked = 15;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_contracts_unlocked(), target);
  }

  // optional bool artifacts_unlocked = 16;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_artifacts_unlocked(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.GetPeriodicalsRequest)
  return target;
}

size_t GetPeriodicalsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.GetPeriodicalsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string user_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_id());
    }

    // optional .ei.BasicRequestInfo rinfo = 12;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rinfo_);
    }

    // optional double seconds_full_realtime = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double seconds_full_gametime = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double soul_eggs = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional uint32 lost_increments = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lost_increments());
    }

    // optional bool piggy_full = 2;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool piggy_found_full = 3;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional bool contracts_unlocked = 15;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool artifacts_unlocked = 16;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 + 1;
    }

    // optional uint32 current_client_version = 10;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_current_client_version());
    }

    // optional bool debug = 11;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional double mystical_earnings_mult = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 8;
    }

    // optional uint32 eop = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_eop());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetPeriodicalsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetPeriodicalsRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetPeriodicalsRequest::GetClassData() const { return &_class_data_; }

void GetPeriodicalsRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetPeriodicalsRequest *>(to)->MergeFrom(
      static_cast<const GetPeriodicalsRequest &>(from));
}


void GetPeriodicalsRequest::MergeFrom(const GetPeriodicalsRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.GetPeriodicalsRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_id(from._internal_user_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_rinfo()->::ei::BasicRequestInfo::MergeFrom(from._internal_rinfo());
    }
    if (cached_has_bits & 0x00000004u) {
      seconds_full_realtime_ = from.seconds_full_realtime_;
    }
    if (cached_has_bits & 0x00000008u) {
      seconds_full_gametime_ = from.seconds_full_gametime_;
    }
    if (cached_has_bits & 0x00000010u) {
      soul_eggs_ = from.soul_eggs_;
    }
    if (cached_has_bits & 0x00000020u) {
      lost_increments_ = from.lost_increments_;
    }
    if (cached_has_bits & 0x00000040u) {
      piggy_full_ = from.piggy_full_;
    }
    if (cached_has_bits & 0x00000080u) {
      piggy_found_full_ = from.piggy_found_full_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      contracts_unlocked_ = from.contracts_unlocked_;
    }
    if (cached_has_bits & 0x00000200u) {
      artifacts_unlocked_ = from.artifacts_unlocked_;
    }
    if (cached_has_bits & 0x00000400u) {
      current_client_version_ = from.current_client_version_;
    }
    if (cached_has_bits & 0x00000800u) {
      debug_ = from.debug_;
    }
    if (cached_has_bits & 0x00001000u) {
      mystical_earnings_mult_ = from.mystical_earnings_mult_;
    }
    if (cached_has_bits & 0x00002000u) {
      eop_ = from.eop_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetPeriodicalsRequest::CopyFrom(const GetPeriodicalsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.GetPeriodicalsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetPeriodicalsRequest::IsInitialized() const {
  return true;
}

void GetPeriodicalsRequest::InternalSwap(GetPeriodicalsRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetPeriodicalsRequest, eop_)
      + sizeof(GetPeriodicalsRequest::eop_)
      - PROTOBUF_FIELD_OFFSET(GetPeriodicalsRequest, rinfo_)>(
          reinterpret_cast<char*>(&rinfo_),
          reinterpret_cast<char*>(&other->rinfo_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GetPeriodicalsRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[109]);
}

// ===================================================================

class ConfigRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ConfigRequest>()._has_bits_);
  static const ::ei::BasicRequestInfo& rinfo(const ConfigRequest* msg);
  static void set_has_rinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_soul_eggs(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_artifacts_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_fuel_tank_unlocked(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::ei::BasicRequestInfo&
ConfigRequest::_Internal::rinfo(const ConfigRequest* msg) {
  return *msg->rinfo_;
}
ConfigRequest::ConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ConfigRequest)
}
ConfigRequest::ConfigRequest(const ConfigRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_rinfo()) {
    rinfo_ = new ::ei::BasicRequestInfo(*from.rinfo_);
  } else {
    rinfo_ = nullptr;
  }
  ::memcpy(&soul_eggs_, &from.soul_eggs_,
    static_cast<size_t>(reinterpret_cast<char*>(&fuel_tank_unlocked_) -
    reinterpret_cast<char*>(&soul_eggs_)) + sizeof(fuel_tank_unlocked_));
  // @@protoc_insertion_point(copy_constructor:ei.ConfigRequest)
}

inline void ConfigRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rinfo_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&fuel_tank_unlocked_) -
    reinterpret_cast<char*>(&rinfo_)) + sizeof(fuel_tank_unlocked_));
}

ConfigRequest::~ConfigRequest() {
  // @@protoc_insertion_point(destructor:ei.ConfigRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConfigRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete rinfo_;
}

void ConfigRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ConfigRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ConfigRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(rinfo_ != nullptr);
    rinfo_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&soul_eggs_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&fuel_tank_unlocked_) -
        reinterpret_cast<char*>(&soul_eggs_)) + sizeof(fuel_tank_unlocked_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConfigRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.BasicRequestInfo rinfo = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_rinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double soul_eggs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_soul_eggs(&has_bits);
          soul_eggs_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool artifacts_enabled = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_artifacts_enabled(&has_bits);
          artifacts_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool fuel_tank_unlocked = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_fuel_tank_unlocked(&has_bits);
          fuel_tank_unlocked_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConfigRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ConfigRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.BasicRequestInfo rinfo = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::rinfo(this),
        _Internal::rinfo(this).GetCachedSize(), target, stream);
  }

  // optional double soul_eggs = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_soul_eggs(), target);
  }

  // optional bool artifacts_enabled = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_artifacts_enabled(), target);
  }

  // optional bool fuel_tank_unlocked = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_fuel_tank_unlocked(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ConfigRequest)
  return target;
}

size_t ConfigRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ConfigRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .ei.BasicRequestInfo rinfo = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rinfo_);
    }

    // optional double soul_eggs = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional bool artifacts_enabled = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool fuel_tank_unlocked = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConfigRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ConfigRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConfigRequest::GetClassData() const { return &_class_data_; }

void ConfigRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ConfigRequest *>(to)->MergeFrom(
      static_cast<const ConfigRequest &>(from));
}


void ConfigRequest::MergeFrom(const ConfigRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ConfigRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_rinfo()->::ei::BasicRequestInfo::MergeFrom(from._internal_rinfo());
    }
    if (cached_has_bits & 0x00000002u) {
      soul_eggs_ = from.soul_eggs_;
    }
    if (cached_has_bits & 0x00000004u) {
      artifacts_enabled_ = from.artifacts_enabled_;
    }
    if (cached_has_bits & 0x00000008u) {
      fuel_tank_unlocked_ = from.fuel_tank_unlocked_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConfigRequest::CopyFrom(const ConfigRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ConfigRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigRequest::IsInitialized() const {
  return true;
}

void ConfigRequest::InternalSwap(ConfigRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConfigRequest, fuel_tank_unlocked_)
      + sizeof(ConfigRequest::fuel_tank_unlocked_)
      - PROTOBUF_FIELD_OFFSET(ConfigRequest, rinfo_)>(
          reinterpret_cast<char*>(&rinfo_),
          reinterpret_cast<char*>(&other->rinfo_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ConfigRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[110]);
}

// ===================================================================

class ConfigResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<ConfigResponse>()._has_bits_);
  static const ::ei::LiveConfig& live_config(const ConfigResponse* msg);
  static void set_has_live_config(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ei::MailDB& mail_bag(const ConfigResponse* msg);
  static void set_has_mail_bag(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::ei::DLCCatalog& dlc_catalog(const ConfigResponse* msg);
  static void set_has_dlc_catalog(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::ei::LiveConfig&
ConfigResponse::_Internal::live_config(const ConfigResponse* msg) {
  return *msg->live_config_;
}
const ::ei::MailDB&
ConfigResponse::_Internal::mail_bag(const ConfigResponse* msg) {
  return *msg->mail_bag_;
}
const ::ei::DLCCatalog&
ConfigResponse::_Internal::dlc_catalog(const ConfigResponse* msg) {
  return *msg->dlc_catalog_;
}
ConfigResponse::ConfigResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ConfigResponse)
}
ConfigResponse::ConfigResponse(const ConfigResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_live_config()) {
    live_config_ = new ::ei::LiveConfig(*from.live_config_);
  } else {
    live_config_ = nullptr;
  }
  if (from._internal_has_mail_bag()) {
    mail_bag_ = new ::ei::MailDB(*from.mail_bag_);
  } else {
    mail_bag_ = nullptr;
  }
  if (from._internal_has_dlc_catalog()) {
    dlc_catalog_ = new ::ei::DLCCatalog(*from.dlc_catalog_);
  } else {
    dlc_catalog_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:ei.ConfigResponse)
}

inline void ConfigResponse::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&live_config_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&dlc_catalog_) -
    reinterpret_cast<char*>(&live_config_)) + sizeof(dlc_catalog_));
}

ConfigResponse::~ConfigResponse() {
  // @@protoc_insertion_point(destructor:ei.ConfigResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConfigResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete live_config_;
  if (this != internal_default_instance()) delete mail_bag_;
  if (this != internal_default_instance()) delete dlc_catalog_;
}

void ConfigResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ConfigResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ConfigResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(live_config_ != nullptr);
      live_config_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(mail_bag_ != nullptr);
      mail_bag_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(dlc_catalog_ != nullptr);
      dlc_catalog_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConfigResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.LiveConfig live_config = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_live_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.MailDB mail_bag = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_mail_bag(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.DLCCatalog dlc_catalog = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_dlc_catalog(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConfigResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ConfigResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.LiveConfig live_config = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::live_config(this),
        _Internal::live_config(this).GetCachedSize(), target, stream);
  }

  // optional .ei.MailDB mail_bag = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::mail_bag(this),
        _Internal::mail_bag(this).GetCachedSize(), target, stream);
  }

  // optional .ei.DLCCatalog dlc_catalog = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::dlc_catalog(this),
        _Internal::dlc_catalog(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ConfigResponse)
  return target;
}

size_t ConfigResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ConfigResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .ei.LiveConfig live_config = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *live_config_);
    }

    // optional .ei.MailDB mail_bag = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *mail_bag_);
    }

    // optional .ei.DLCCatalog dlc_catalog = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *dlc_catalog_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConfigResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ConfigResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConfigResponse::GetClassData() const { return &_class_data_; }

void ConfigResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ConfigResponse *>(to)->MergeFrom(
      static_cast<const ConfigResponse &>(from));
}


void ConfigResponse::MergeFrom(const ConfigResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ConfigResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_live_config()->::ei::LiveConfig::MergeFrom(from._internal_live_config());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_mail_bag()->::ei::MailDB::MergeFrom(from._internal_mail_bag());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_dlc_catalog()->::ei::DLCCatalog::MergeFrom(from._internal_dlc_catalog());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConfigResponse::CopyFrom(const ConfigResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ConfigResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigResponse::IsInitialized() const {
  return true;
}

void ConfigResponse::InternalSwap(ConfigResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConfigResponse, dlc_catalog_)
      + sizeof(ConfigResponse::dlc_catalog_)
      - PROTOBUF_FIELD_OFFSET(ConfigResponse, live_config_)>(
          reinterpret_cast<char*>(&live_config_),
          reinterpret_cast<char*>(&other->live_config_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ConfigResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[111]);
}

// ===================================================================

class AdAttributionRawData::_Internal {
 public:
  using HasBits = decltype(std::declval<AdAttributionRawData>()._has_bits_);
  static void set_has_device_ad_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ad_network(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_json_data(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

AdAttributionRawData::AdAttributionRawData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.AdAttributionRawData)
}
AdAttributionRawData::AdAttributionRawData(const AdAttributionRawData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  device_ad_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    device_ad_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_ad_id()) {
    device_ad_id_.Set(from._internal_device_ad_id(), 
      GetArenaForAllocation());
  }
  ad_network_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ad_network_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ad_network()) {
    ad_network_.Set(from._internal_ad_network(), 
      GetArenaForAllocation());
  }
  json_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    json_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_json_data()) {
    json_data_.Set(from._internal_json_data(), 
      GetArenaForAllocation());
  }
  user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_id()) {
    user_id_.Set(from._internal_user_id(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:ei.AdAttributionRawData)
}

inline void AdAttributionRawData::SharedCtor() {
device_ad_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  device_ad_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
ad_network_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ad_network_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
json_data_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  json_data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AdAttributionRawData::~AdAttributionRawData() {
  // @@protoc_insertion_point(destructor:ei.AdAttributionRawData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AdAttributionRawData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  device_ad_id_.Destroy();
  ad_network_.Destroy();
  json_data_.Destroy();
  user_id_.Destroy();
}

void AdAttributionRawData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AdAttributionRawData::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.AdAttributionRawData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      device_ad_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ad_network_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      json_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      user_id_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AdAttributionRawData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string device_ad_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_device_ad_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AdAttributionRawData.device_ad_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string ad_network = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_ad_network();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AdAttributionRawData.ad_network");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string json_data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_json_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AdAttributionRawData.json_data");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string user_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AdAttributionRawData.user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AdAttributionRawData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.AdAttributionRawData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string device_ad_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_device_ad_id().data(), static_cast<int>(this->_internal_device_ad_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AdAttributionRawData.device_ad_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_device_ad_id(), target);
  }

  // optional string ad_network = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ad_network().data(), static_cast<int>(this->_internal_ad_network().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AdAttributionRawData.ad_network");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_ad_network(), target);
  }

  // optional string json_data = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_json_data().data(), static_cast<int>(this->_internal_json_data().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AdAttributionRawData.json_data");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_json_data(), target);
  }

  // optional string user_id = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AdAttributionRawData.user_id");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_user_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.AdAttributionRawData)
  return target;
}

size_t AdAttributionRawData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.AdAttributionRawData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string device_ad_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_ad_id());
    }

    // optional string ad_network = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ad_network());
    }

    // optional string json_data = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_json_data());
    }

    // optional string user_id = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AdAttributionRawData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AdAttributionRawData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AdAttributionRawData::GetClassData() const { return &_class_data_; }

void AdAttributionRawData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AdAttributionRawData *>(to)->MergeFrom(
      static_cast<const AdAttributionRawData &>(from));
}


void AdAttributionRawData::MergeFrom(const AdAttributionRawData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.AdAttributionRawData)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_device_ad_id(from._internal_device_ad_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_ad_network(from._internal_ad_network());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_json_data(from._internal_json_data());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_user_id(from._internal_user_id());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AdAttributionRawData::CopyFrom(const AdAttributionRawData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.AdAttributionRawData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AdAttributionRawData::IsInitialized() const {
  return true;
}

void AdAttributionRawData::InternalSwap(AdAttributionRawData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &device_ad_id_, lhs_arena,
      &other->device_ad_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ad_network_, lhs_arena,
      &other->ad_network_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &json_data_, lhs_arena,
      &other->json_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata AdAttributionRawData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[112]);
}

// ===================================================================

class AdAttributionRow::_Internal {
 public:
  using HasBits = decltype(std::declval<AdAttributionRow>()._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ad_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ad_network(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_campaign(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_keyword(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_extra(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_click_date(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_download_date(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_approx_time(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

AdAttributionRow::AdAttributionRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.AdAttributionRow)
}
AdAttributionRow::AdAttributionRow(const AdAttributionRow& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_id()) {
    user_id_.Set(from._internal_user_id(), 
      GetArenaForAllocation());
  }
  ad_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ad_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ad_id()) {
    ad_id_.Set(from._internal_ad_id(), 
      GetArenaForAllocation());
  }
  ad_network_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ad_network_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ad_network()) {
    ad_network_.Set(from._internal_ad_network(), 
      GetArenaForAllocation());
  }
  campaign_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    campaign_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_campaign()) {
    campaign_.Set(from._internal_campaign(), 
      GetArenaForAllocation());
  }
  keyword_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    keyword_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_keyword()) {
    keyword_.Set(from._internal_keyword(), 
      GetArenaForAllocation());
  }
  extra_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    extra_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_extra()) {
    extra_.Set(from._internal_extra(), 
      GetArenaForAllocation());
  }
  ::memcpy(&click_date_, &from.click_date_,
    static_cast<size_t>(reinterpret_cast<char*>(&approx_time_) -
    reinterpret_cast<char*>(&click_date_)) + sizeof(approx_time_));
  // @@protoc_insertion_point(copy_constructor:ei.AdAttributionRow)
}

inline void AdAttributionRow::SharedCtor() {
user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
ad_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ad_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
ad_network_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ad_network_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
campaign_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  campaign_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
keyword_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  keyword_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
extra_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  extra_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&click_date_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&approx_time_) -
    reinterpret_cast<char*>(&click_date_)) + sizeof(approx_time_));
}

AdAttributionRow::~AdAttributionRow() {
  // @@protoc_insertion_point(destructor:ei.AdAttributionRow)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AdAttributionRow::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_id_.Destroy();
  ad_id_.Destroy();
  ad_network_.Destroy();
  campaign_.Destroy();
  keyword_.Destroy();
  extra_.Destroy();
}

void AdAttributionRow::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AdAttributionRow::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.AdAttributionRow)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ad_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      ad_network_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      campaign_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      keyword_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      extra_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&click_date_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&download_date_) -
        reinterpret_cast<char*>(&click_date_)) + sizeof(download_date_));
  }
  approx_time_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AdAttributionRow::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AdAttributionRow.user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string ad_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_ad_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AdAttributionRow.ad_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string ad_network = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_ad_network();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AdAttributionRow.ad_network");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string campaign = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_campaign();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AdAttributionRow.campaign");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string keyword = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_keyword();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AdAttributionRow.keyword");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string extra = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_extra();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AdAttributionRow.extra");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional float click_date = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_click_date(&has_bits);
          click_date_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float download_date = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_download_date(&has_bits);
          download_date_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float approx_time = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_approx_time(&has_bits);
          approx_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AdAttributionRow::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.AdAttributionRow)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AdAttributionRow.user_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_id(), target);
  }

  // optional string ad_id = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ad_id().data(), static_cast<int>(this->_internal_ad_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AdAttributionRow.ad_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_ad_id(), target);
  }

  // optional string ad_network = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ad_network().data(), static_cast<int>(this->_internal_ad_network().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AdAttributionRow.ad_network");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_ad_network(), target);
  }

  // optional string campaign = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_campaign().data(), static_cast<int>(this->_internal_campaign().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AdAttributionRow.campaign");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_campaign(), target);
  }

  // optional string keyword = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_keyword().data(), static_cast<int>(this->_internal_keyword().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AdAttributionRow.keyword");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_keyword(), target);
  }

  // optional string extra = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_extra().data(), static_cast<int>(this->_internal_extra().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AdAttributionRow.extra");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_extra(), target);
  }

  // optional float click_date = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_click_date(), target);
  }

  // optional float download_date = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_download_date(), target);
  }

  // optional float approx_time = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_approx_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.AdAttributionRow)
  return target;
}

size_t AdAttributionRow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.AdAttributionRow)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string user_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_id());
    }

    // optional string ad_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ad_id());
    }

    // optional string ad_network = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ad_network());
    }

    // optional string campaign = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_campaign());
    }

    // optional string keyword = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_keyword());
    }

    // optional string extra = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_extra());
    }

    // optional float click_date = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float download_date = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  // optional float approx_time = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AdAttributionRow::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AdAttributionRow::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AdAttributionRow::GetClassData() const { return &_class_data_; }

void AdAttributionRow::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AdAttributionRow *>(to)->MergeFrom(
      static_cast<const AdAttributionRow &>(from));
}


void AdAttributionRow::MergeFrom(const AdAttributionRow& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.AdAttributionRow)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_id(from._internal_user_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_ad_id(from._internal_ad_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_ad_network(from._internal_ad_network());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_campaign(from._internal_campaign());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_keyword(from._internal_keyword());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_extra(from._internal_extra());
    }
    if (cached_has_bits & 0x00000040u) {
      click_date_ = from.click_date_;
    }
    if (cached_has_bits & 0x00000080u) {
      download_date_ = from.download_date_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_approx_time(from._internal_approx_time());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AdAttributionRow::CopyFrom(const AdAttributionRow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.AdAttributionRow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AdAttributionRow::IsInitialized() const {
  return true;
}

void AdAttributionRow::InternalSwap(AdAttributionRow* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ad_id_, lhs_arena,
      &other->ad_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ad_network_, lhs_arena,
      &other->ad_network_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &campaign_, lhs_arena,
      &other->campaign_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &keyword_, lhs_arena,
      &other->keyword_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &extra_, lhs_arena,
      &other->extra_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AdAttributionRow, approx_time_)
      + sizeof(AdAttributionRow::approx_time_)
      - PROTOBUF_FIELD_OFFSET(AdAttributionRow, click_date_)>(
          reinterpret_cast<char*>(&click_date_),
          reinterpret_cast<char*>(&other->click_date_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AdAttributionRow::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[113]);
}

// ===================================================================

class AdAttributionInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<AdAttributionInfo>()._has_bits_);
  static void set_has_device_ad_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_network_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_attribution(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_org_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_org_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_campaign_name(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_campaign_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_click_date(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_conversion_date(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_conversion_type(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_geo(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_adgroup_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_adgroup_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_keyword(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_keyword_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_keyword_extra(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_creativeset_name(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_creativeset_id(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
};

AdAttributionInfo::AdAttributionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.AdAttributionInfo)
}
AdAttributionInfo::AdAttributionInfo(const AdAttributionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  device_ad_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    device_ad_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_ad_id()) {
    device_ad_id_.Set(from._internal_device_ad_id(), 
      GetArenaForAllocation());
  }
  network_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    network_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_network_name()) {
    network_name_.Set(from._internal_network_name(), 
      GetArenaForAllocation());
  }
  org_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    org_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_org_name()) {
    org_name_.Set(from._internal_org_name(), 
      GetArenaForAllocation());
  }
  org_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    org_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_org_id()) {
    org_id_.Set(from._internal_org_id(), 
      GetArenaForAllocation());
  }
  campaign_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    campaign_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_campaign_name()) {
    campaign_name_.Set(from._internal_campaign_name(), 
      GetArenaForAllocation());
  }
  campaign_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    campaign_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_campaign_id()) {
    campaign_id_.Set(from._internal_campaign_id(), 
      GetArenaForAllocation());
  }
  click_date_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    click_date_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_click_date()) {
    click_date_.Set(from._internal_click_date(), 
      GetArenaForAllocation());
  }
  conversion_date_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    conversion_date_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_conversion_date()) {
    conversion_date_.Set(from._internal_conversion_date(), 
      GetArenaForAllocation());
  }
  conversion_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    conversion_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_conversion_type()) {
    conversion_type_.Set(from._internal_conversion_type(), 
      GetArenaForAllocation());
  }
  geo_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    geo_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_geo()) {
    geo_.Set(from._internal_geo(), 
      GetArenaForAllocation());
  }
  adgroup_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    adgroup_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_adgroup_name()) {
    adgroup_name_.Set(from._internal_adgroup_name(), 
      GetArenaForAllocation());
  }
  adgroup_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    adgroup_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_adgroup_id()) {
    adgroup_id_.Set(from._internal_adgroup_id(), 
      GetArenaForAllocation());
  }
  keyword_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    keyword_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_keyword()) {
    keyword_.Set(from._internal_keyword(), 
      GetArenaForAllocation());
  }
  keyword_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    keyword_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_keyword_id()) {
    keyword_id_.Set(from._internal_keyword_id(), 
      GetArenaForAllocation());
  }
  keyword_extra_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    keyword_extra_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_keyword_extra()) {
    keyword_extra_.Set(from._internal_keyword_extra(), 
      GetArenaForAllocation());
  }
  creativeset_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    creativeset_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_creativeset_name()) {
    creativeset_name_.Set(from._internal_creativeset_name(), 
      GetArenaForAllocation());
  }
  creativeset_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    creativeset_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_creativeset_id()) {
    creativeset_id_.Set(from._internal_creativeset_id(), 
      GetArenaForAllocation());
  }
  attribution_ = from.attribution_;
  // @@protoc_insertion_point(copy_constructor:ei.AdAttributionInfo)
}

inline void AdAttributionInfo::SharedCtor() {
device_ad_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  device_ad_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
network_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  network_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
org_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  org_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
org_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  org_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
campaign_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  campaign_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
campaign_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  campaign_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
click_date_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  click_date_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
conversion_date_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  conversion_date_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
conversion_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  conversion_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
geo_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  geo_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
adgroup_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  adgroup_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
adgroup_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  adgroup_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
keyword_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  keyword_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
keyword_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  keyword_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
keyword_extra_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  keyword_extra_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
creativeset_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  creativeset_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
creativeset_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  creativeset_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
attribution_ = false;
}

AdAttributionInfo::~AdAttributionInfo() {
  // @@protoc_insertion_point(destructor:ei.AdAttributionInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AdAttributionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  device_ad_id_.Destroy();
  network_name_.Destroy();
  org_name_.Destroy();
  org_id_.Destroy();
  campaign_name_.Destroy();
  campaign_id_.Destroy();
  click_date_.Destroy();
  conversion_date_.Destroy();
  conversion_type_.Destroy();
  geo_.Destroy();
  adgroup_name_.Destroy();
  adgroup_id_.Destroy();
  keyword_.Destroy();
  keyword_id_.Destroy();
  keyword_extra_.Destroy();
  creativeset_name_.Destroy();
  creativeset_id_.Destroy();
}

void AdAttributionInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AdAttributionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.AdAttributionInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      device_ad_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      network_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      org_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      org_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      campaign_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      campaign_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      click_date_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      conversion_date_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      conversion_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000200u) {
      geo_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000400u) {
      adgroup_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000800u) {
      adgroup_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00001000u) {
      keyword_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00002000u) {
      keyword_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00004000u) {
      keyword_extra_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00008000u) {
      creativeset_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00010000u) {
    creativeset_id_.ClearNonDefaultToEmpty();
  }
  attribution_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AdAttributionInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string device_ad_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_device_ad_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AdAttributionInfo.device_ad_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string network_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_network_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AdAttributionInfo.network_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool attribution = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_attribution(&has_bits);
          attribution_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string org_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_org_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AdAttributionInfo.org_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string org_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_org_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AdAttributionInfo.org_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string campaign_name = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_campaign_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AdAttributionInfo.campaign_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string campaign_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_campaign_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AdAttributionInfo.campaign_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string click_date = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_click_date();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AdAttributionInfo.click_date");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string conversion_date = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_conversion_date();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AdAttributionInfo.conversion_date");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string conversion_type = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_conversion_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AdAttributionInfo.conversion_type");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string geo = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_geo();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AdAttributionInfo.geo");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string adgroup_name = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_adgroup_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AdAttributionInfo.adgroup_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string adgroup_id = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_adgroup_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AdAttributionInfo.adgroup_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string keyword = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_keyword();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AdAttributionInfo.keyword");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string keyword_id = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_keyword_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AdAttributionInfo.keyword_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string keyword_extra = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          auto str = _internal_mutable_keyword_extra();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AdAttributionInfo.keyword_extra");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string creativeset_name = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          auto str = _internal_mutable_creativeset_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AdAttributionInfo.creativeset_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string creativeset_id = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          auto str = _internal_mutable_creativeset_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AdAttributionInfo.creativeset_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AdAttributionInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.AdAttributionInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string device_ad_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_device_ad_id().data(), static_cast<int>(this->_internal_device_ad_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AdAttributionInfo.device_ad_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_device_ad_id(), target);
  }

  // optional string network_name = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_network_name().data(), static_cast<int>(this->_internal_network_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AdAttributionInfo.network_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_network_name(), target);
  }

  // optional bool attribution = 3;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_attribution(), target);
  }

  // optional string org_name = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_org_name().data(), static_cast<int>(this->_internal_org_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AdAttributionInfo.org_name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_org_name(), target);
  }

  // optional string org_id = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_org_id().data(), static_cast<int>(this->_internal_org_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AdAttributionInfo.org_id");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_org_id(), target);
  }

  // optional string campaign_name = 6;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_campaign_name().data(), static_cast<int>(this->_internal_campaign_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AdAttributionInfo.campaign_name");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_campaign_name(), target);
  }

  // optional string campaign_id = 7;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_campaign_id().data(), static_cast<int>(this->_internal_campaign_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AdAttributionInfo.campaign_id");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_campaign_id(), target);
  }

  // optional string click_date = 8;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_click_date().data(), static_cast<int>(this->_internal_click_date().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AdAttributionInfo.click_date");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_click_date(), target);
  }

  // optional string conversion_date = 9;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_conversion_date().data(), static_cast<int>(this->_internal_conversion_date().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AdAttributionInfo.conversion_date");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_conversion_date(), target);
  }

  // optional string conversion_type = 10;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_conversion_type().data(), static_cast<int>(this->_internal_conversion_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AdAttributionInfo.conversion_type");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_conversion_type(), target);
  }

  // optional string geo = 11;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_geo().data(), static_cast<int>(this->_internal_geo().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AdAttributionInfo.geo");
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_geo(), target);
  }

  // optional string adgroup_name = 12;
  if (cached_has_bits & 0x00000400u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_adgroup_name().data(), static_cast<int>(this->_internal_adgroup_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AdAttributionInfo.adgroup_name");
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_adgroup_name(), target);
  }

  // optional string adgroup_id = 13;
  if (cached_has_bits & 0x00000800u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_adgroup_id().data(), static_cast<int>(this->_internal_adgroup_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AdAttributionInfo.adgroup_id");
    target = stream->WriteStringMaybeAliased(
        13, this->_internal_adgroup_id(), target);
  }

  // optional string keyword = 14;
  if (cached_has_bits & 0x00001000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_keyword().data(), static_cast<int>(this->_internal_keyword().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AdAttributionInfo.keyword");
    target = stream->WriteStringMaybeAliased(
        14, this->_internal_keyword(), target);
  }

  // optional string keyword_id = 15;
  if (cached_has_bits & 0x00002000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_keyword_id().data(), static_cast<int>(this->_internal_keyword_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AdAttributionInfo.keyword_id");
    target = stream->WriteStringMaybeAliased(
        15, this->_internal_keyword_id(), target);
  }

  // optional string keyword_extra = 16;
  if (cached_has_bits & 0x00004000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_keyword_extra().data(), static_cast<int>(this->_internal_keyword_extra().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AdAttributionInfo.keyword_extra");
    target = stream->WriteStringMaybeAliased(
        16, this->_internal_keyword_extra(), target);
  }

  // optional string creativeset_name = 17;
  if (cached_has_bits & 0x00008000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_creativeset_name().data(), static_cast<int>(this->_internal_creativeset_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AdAttributionInfo.creativeset_name");
    target = stream->WriteStringMaybeAliased(
        17, this->_internal_creativeset_name(), target);
  }

  // optional string creativeset_id = 18;
  if (cached_has_bits & 0x00010000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_creativeset_id().data(), static_cast<int>(this->_internal_creativeset_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AdAttributionInfo.creativeset_id");
    target = stream->WriteStringMaybeAliased(
        18, this->_internal_creativeset_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.AdAttributionInfo)
  return target;
}

size_t AdAttributionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.AdAttributionInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string device_ad_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_ad_id());
    }

    // optional string network_name = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_network_name());
    }

    // optional string org_name = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_org_name());
    }

    // optional string org_id = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_org_id());
    }

    // optional string campaign_name = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_campaign_name());
    }

    // optional string campaign_id = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_campaign_id());
    }

    // optional string click_date = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_click_date());
    }

    // optional string conversion_date = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_conversion_date());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional string conversion_type = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_conversion_type());
    }

    // optional string geo = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_geo());
    }

    // optional string adgroup_name = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_adgroup_name());
    }

    // optional string adgroup_id = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_adgroup_id());
    }

    // optional string keyword = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_keyword());
    }

    // optional string keyword_id = 15;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_keyword_id());
    }

    // optional string keyword_extra = 16;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_keyword_extra());
    }

    // optional string creativeset_name = 17;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_creativeset_name());
    }

  }
  if (cached_has_bits & 0x00030000u) {
    // optional string creativeset_id = 18;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_creativeset_id());
    }

    // optional bool attribution = 3;
    if (cached_has_bits & 0x00020000u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AdAttributionInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AdAttributionInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AdAttributionInfo::GetClassData() const { return &_class_data_; }

void AdAttributionInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AdAttributionInfo *>(to)->MergeFrom(
      static_cast<const AdAttributionInfo &>(from));
}


void AdAttributionInfo::MergeFrom(const AdAttributionInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.AdAttributionInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_device_ad_id(from._internal_device_ad_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_network_name(from._internal_network_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_org_name(from._internal_org_name());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_org_id(from._internal_org_id());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_campaign_name(from._internal_campaign_name());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_campaign_id(from._internal_campaign_id());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_set_click_date(from._internal_click_date());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_set_conversion_date(from._internal_conversion_date());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_set_conversion_type(from._internal_conversion_type());
    }
    if (cached_has_bits & 0x00000200u) {
      _internal_set_geo(from._internal_geo());
    }
    if (cached_has_bits & 0x00000400u) {
      _internal_set_adgroup_name(from._internal_adgroup_name());
    }
    if (cached_has_bits & 0x00000800u) {
      _internal_set_adgroup_id(from._internal_adgroup_id());
    }
    if (cached_has_bits & 0x00001000u) {
      _internal_set_keyword(from._internal_keyword());
    }
    if (cached_has_bits & 0x00002000u) {
      _internal_set_keyword_id(from._internal_keyword_id());
    }
    if (cached_has_bits & 0x00004000u) {
      _internal_set_keyword_extra(from._internal_keyword_extra());
    }
    if (cached_has_bits & 0x00008000u) {
      _internal_set_creativeset_name(from._internal_creativeset_name());
    }
  }
  if (cached_has_bits & 0x00030000u) {
    if (cached_has_bits & 0x00010000u) {
      _internal_set_creativeset_id(from._internal_creativeset_id());
    }
    if (cached_has_bits & 0x00020000u) {
      attribution_ = from.attribution_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AdAttributionInfo::CopyFrom(const AdAttributionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.AdAttributionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AdAttributionInfo::IsInitialized() const {
  return true;
}

void AdAttributionInfo::InternalSwap(AdAttributionInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &device_ad_id_, lhs_arena,
      &other->device_ad_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &network_name_, lhs_arena,
      &other->network_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &org_name_, lhs_arena,
      &other->org_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &org_id_, lhs_arena,
      &other->org_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &campaign_name_, lhs_arena,
      &other->campaign_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &campaign_id_, lhs_arena,
      &other->campaign_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &click_date_, lhs_arena,
      &other->click_date_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &conversion_date_, lhs_arena,
      &other->conversion_date_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &conversion_type_, lhs_arena,
      &other->conversion_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &geo_, lhs_arena,
      &other->geo_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &adgroup_name_, lhs_arena,
      &other->adgroup_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &adgroup_id_, lhs_arena,
      &other->adgroup_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &keyword_, lhs_arena,
      &other->keyword_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &keyword_id_, lhs_arena,
      &other->keyword_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &keyword_extra_, lhs_arena,
      &other->keyword_extra_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &creativeset_name_, lhs_arena,
      &other->creativeset_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &creativeset_id_, lhs_arena,
      &other->creativeset_id_, rhs_arena
  );
  swap(attribution_, other->attribution_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AdAttributionInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[114]);
}

// ===================================================================

class ArtifactsClientInfo_LaunchCount::_Internal {
 public:
  using HasBits = decltype(std::declval<ArtifactsClientInfo_LaunchCount>()._has_bits_);
  static void set_has_ship(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num_launches(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_launch_points(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ArtifactsClientInfo_LaunchCount::ArtifactsClientInfo_LaunchCount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ArtifactsClientInfo.LaunchCount)
}
ArtifactsClientInfo_LaunchCount::ArtifactsClientInfo_LaunchCount(const ArtifactsClientInfo_LaunchCount& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&ship_, &from.ship_,
    static_cast<size_t>(reinterpret_cast<char*>(&launch_points_) -
    reinterpret_cast<char*>(&ship_)) + sizeof(launch_points_));
  // @@protoc_insertion_point(copy_constructor:ei.ArtifactsClientInfo.LaunchCount)
}

inline void ArtifactsClientInfo_LaunchCount::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&ship_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&launch_points_) -
    reinterpret_cast<char*>(&ship_)) + sizeof(launch_points_));
}

ArtifactsClientInfo_LaunchCount::~ArtifactsClientInfo_LaunchCount() {
  // @@protoc_insertion_point(destructor:ei.ArtifactsClientInfo.LaunchCount)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ArtifactsClientInfo_LaunchCount::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ArtifactsClientInfo_LaunchCount::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ArtifactsClientInfo_LaunchCount::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ArtifactsClientInfo.LaunchCount)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&ship_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&launch_points_) -
        reinterpret_cast<char*>(&ship_)) + sizeof(launch_points_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ArtifactsClientInfo_LaunchCount::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.MissionInfo.Spaceship ship = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::MissionInfo_Spaceship_IsValid(val))) {
            _internal_set_ship(static_cast<::ei::MissionInfo_Spaceship>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 num_launches = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_num_launches(&has_bits);
          num_launches_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double launch_points = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_launch_points(&has_bits);
          launch_points_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArtifactsClientInfo_LaunchCount::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ArtifactsClientInfo.LaunchCount)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.MissionInfo.Spaceship ship = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_ship(), target);
  }

  // optional uint32 num_launches = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_num_launches(), target);
  }

  // optional double launch_points = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_launch_points(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ArtifactsClientInfo.LaunchCount)
  return target;
}

size_t ArtifactsClientInfo_LaunchCount::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ArtifactsClientInfo.LaunchCount)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .ei.MissionInfo.Spaceship ship = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_ship());
    }

    // optional uint32 num_launches = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_launches());
    }

    // optional double launch_points = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ArtifactsClientInfo_LaunchCount::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ArtifactsClientInfo_LaunchCount::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ArtifactsClientInfo_LaunchCount::GetClassData() const { return &_class_data_; }

void ArtifactsClientInfo_LaunchCount::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ArtifactsClientInfo_LaunchCount *>(to)->MergeFrom(
      static_cast<const ArtifactsClientInfo_LaunchCount &>(from));
}


void ArtifactsClientInfo_LaunchCount::MergeFrom(const ArtifactsClientInfo_LaunchCount& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ArtifactsClientInfo.LaunchCount)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ship_ = from.ship_;
    }
    if (cached_has_bits & 0x00000002u) {
      num_launches_ = from.num_launches_;
    }
    if (cached_has_bits & 0x00000004u) {
      launch_points_ = from.launch_points_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ArtifactsClientInfo_LaunchCount::CopyFrom(const ArtifactsClientInfo_LaunchCount& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ArtifactsClientInfo.LaunchCount)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArtifactsClientInfo_LaunchCount::IsInitialized() const {
  return true;
}

void ArtifactsClientInfo_LaunchCount::InternalSwap(ArtifactsClientInfo_LaunchCount* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ArtifactsClientInfo_LaunchCount, launch_points_)
      + sizeof(ArtifactsClientInfo_LaunchCount::launch_points_)
      - PROTOBUF_FIELD_OFFSET(ArtifactsClientInfo_LaunchCount, ship_)>(
          reinterpret_cast<char*>(&ship_),
          reinterpret_cast<char*>(&other->ship_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ArtifactsClientInfo_LaunchCount::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[115]);
}

// ===================================================================

class ArtifactsClientInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ArtifactsClientInfo>()._has_bits_);
  static void set_has_mission_capacity_mult(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_mission_duration_mult(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_mission_ftl_duration_mult(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ArtifactsClientInfo::ArtifactsClientInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  launch_counts_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ArtifactsClientInfo)
}
ArtifactsClientInfo::ArtifactsClientInfo(const ArtifactsClientInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      launch_counts_(from.launch_counts_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&mission_capacity_mult_, &from.mission_capacity_mult_,
    static_cast<size_t>(reinterpret_cast<char*>(&mission_ftl_duration_mult_) -
    reinterpret_cast<char*>(&mission_capacity_mult_)) + sizeof(mission_ftl_duration_mult_));
  // @@protoc_insertion_point(copy_constructor:ei.ArtifactsClientInfo)
}

inline void ArtifactsClientInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&mission_capacity_mult_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&mission_ftl_duration_mult_) -
    reinterpret_cast<char*>(&mission_capacity_mult_)) + sizeof(mission_ftl_duration_mult_));
}

ArtifactsClientInfo::~ArtifactsClientInfo() {
  // @@protoc_insertion_point(destructor:ei.ArtifactsClientInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ArtifactsClientInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ArtifactsClientInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ArtifactsClientInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ArtifactsClientInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  launch_counts_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&mission_capacity_mult_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mission_ftl_duration_mult_) -
        reinterpret_cast<char*>(&mission_capacity_mult_)) + sizeof(mission_ftl_duration_mult_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ArtifactsClientInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double mission_capacity_mult = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_mission_capacity_mult(&has_bits);
          mission_capacity_mult_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double mission_duration_mult = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_mission_duration_mult(&has_bits);
          mission_duration_mult_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ArtifactsClientInfo.LaunchCount launch_counts = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_launch_counts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional double mission_ftl_duration_mult = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_mission_ftl_duration_mult(&has_bits);
          mission_ftl_duration_mult_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArtifactsClientInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ArtifactsClientInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double mission_capacity_mult = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_mission_capacity_mult(), target);
  }

  // optional double mission_duration_mult = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_mission_duration_mult(), target);
  }

  // repeated .ei.ArtifactsClientInfo.LaunchCount launch_counts = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_launch_counts_size()); i < n; i++) {
    const auto& repfield = this->_internal_launch_counts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional double mission_ftl_duration_mult = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_mission_ftl_duration_mult(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ArtifactsClientInfo)
  return target;
}

size_t ArtifactsClientInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ArtifactsClientInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.ArtifactsClientInfo.LaunchCount launch_counts = 3;
  total_size += 1UL * this->_internal_launch_counts_size();
  for (const auto& msg : this->launch_counts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double mission_capacity_mult = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double mission_duration_mult = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double mission_ftl_duration_mult = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ArtifactsClientInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ArtifactsClientInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ArtifactsClientInfo::GetClassData() const { return &_class_data_; }

void ArtifactsClientInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ArtifactsClientInfo *>(to)->MergeFrom(
      static_cast<const ArtifactsClientInfo &>(from));
}


void ArtifactsClientInfo::MergeFrom(const ArtifactsClientInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ArtifactsClientInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  launch_counts_.MergeFrom(from.launch_counts_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      mission_capacity_mult_ = from.mission_capacity_mult_;
    }
    if (cached_has_bits & 0x00000002u) {
      mission_duration_mult_ = from.mission_duration_mult_;
    }
    if (cached_has_bits & 0x00000004u) {
      mission_ftl_duration_mult_ = from.mission_ftl_duration_mult_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ArtifactsClientInfo::CopyFrom(const ArtifactsClientInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ArtifactsClientInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArtifactsClientInfo::IsInitialized() const {
  return true;
}

void ArtifactsClientInfo::InternalSwap(ArtifactsClientInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  launch_counts_.InternalSwap(&other->launch_counts_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ArtifactsClientInfo, mission_ftl_duration_mult_)
      + sizeof(ArtifactsClientInfo::mission_ftl_duration_mult_)
      - PROTOBUF_FIELD_OFFSET(ArtifactsClientInfo, mission_capacity_mult_)>(
          reinterpret_cast<char*>(&mission_capacity_mult_),
          reinterpret_cast<char*>(&other->mission_capacity_mult_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ArtifactsClientInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[116]);
}

// ===================================================================

class MissionInfo_Fuel::_Internal {
 public:
  using HasBits = decltype(std::declval<MissionInfo_Fuel>()._has_bits_);
  static void set_has_egg(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

MissionInfo_Fuel::MissionInfo_Fuel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.MissionInfo.Fuel)
}
MissionInfo_Fuel::MissionInfo_Fuel(const MissionInfo_Fuel& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&amount_, &from.amount_,
    static_cast<size_t>(reinterpret_cast<char*>(&egg_) -
    reinterpret_cast<char*>(&amount_)) + sizeof(egg_));
  // @@protoc_insertion_point(copy_constructor:ei.MissionInfo.Fuel)
}

inline void MissionInfo_Fuel::SharedCtor() {
amount_ = 0;
egg_ = 1;
}

MissionInfo_Fuel::~MissionInfo_Fuel() {
  // @@protoc_insertion_point(destructor:ei.MissionInfo.Fuel)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MissionInfo_Fuel::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MissionInfo_Fuel::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MissionInfo_Fuel::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.MissionInfo.Fuel)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    amount_ = 0;
    egg_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MissionInfo_Fuel::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.Egg egg = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::Egg_IsValid(val))) {
            _internal_set_egg(static_cast<::ei::Egg>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional double amount = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_amount(&has_bits);
          amount_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MissionInfo_Fuel::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.MissionInfo.Fuel)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.Egg egg = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_egg(), target);
  }

  // optional double amount = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_amount(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.MissionInfo.Fuel)
  return target;
}

size_t MissionInfo_Fuel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.MissionInfo.Fuel)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional double amount = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional .ei.Egg egg = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_egg());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MissionInfo_Fuel::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MissionInfo_Fuel::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MissionInfo_Fuel::GetClassData() const { return &_class_data_; }

void MissionInfo_Fuel::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MissionInfo_Fuel *>(to)->MergeFrom(
      static_cast<const MissionInfo_Fuel &>(from));
}


void MissionInfo_Fuel::MergeFrom(const MissionInfo_Fuel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.MissionInfo.Fuel)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      amount_ = from.amount_;
    }
    if (cached_has_bits & 0x00000002u) {
      egg_ = from.egg_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MissionInfo_Fuel::CopyFrom(const MissionInfo_Fuel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.MissionInfo.Fuel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MissionInfo_Fuel::IsInitialized() const {
  return true;
}

void MissionInfo_Fuel::InternalSwap(MissionInfo_Fuel* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(amount_, other->amount_);
  swap(egg_, other->egg_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MissionInfo_Fuel::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[117]);
}

// ===================================================================

class MissionInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<MissionInfo>()._has_bits_);
  static void set_has_ship(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_duration_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_level(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_duration_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_capacity(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_quality_bump(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_seconds_remaining(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_start_time_derived(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_mission_log(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

MissionInfo::MissionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  fuel_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.MissionInfo)
}
MissionInfo::MissionInfo(const MissionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      fuel_(from.fuel_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_identifier()) {
    identifier_.Set(from._internal_identifier(), 
      GetArenaForAllocation());
  }
  mission_log_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    mission_log_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_mission_log()) {
    mission_log_.Set(from._internal_mission_log(), 
      GetArenaForAllocation());
  }
  ::memcpy(&ship_, &from.ship_,
    static_cast<size_t>(reinterpret_cast<char*>(&level_) -
    reinterpret_cast<char*>(&ship_)) + sizeof(level_));
  // @@protoc_insertion_point(copy_constructor:ei.MissionInfo)
}

inline void MissionInfo::SharedCtor() {
identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
mission_log_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  mission_log_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&ship_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&level_) -
    reinterpret_cast<char*>(&ship_)) + sizeof(level_));
}

MissionInfo::~MissionInfo() {
  // @@protoc_insertion_point(destructor:ei.MissionInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MissionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  identifier_.Destroy();
  mission_log_.Destroy();
}

void MissionInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MissionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.MissionInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  fuel_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      mission_log_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&ship_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&capacity_) -
        reinterpret_cast<char*>(&ship_)) + sizeof(capacity_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&start_time_derived_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&level_) -
        reinterpret_cast<char*>(&start_time_derived_)) + sizeof(level_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MissionInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.MissionInfo.Spaceship ship = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::MissionInfo_Spaceship_IsValid(val))) {
            _internal_set_ship(static_cast<::ei::MissionInfo_Spaceship>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .ei.MissionInfo.Status status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::MissionInfo_Status_IsValid(val))) {
            _internal_set_status(static_cast<::ei::MissionInfo_Status>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .ei.MissionInfo.DurationType duration_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::MissionInfo_DurationType_IsValid(val))) {
            _internal_set_duration_type(static_cast<::ei::MissionInfo_DurationType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.MissionInfo.Fuel fuel = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_fuel(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional double duration_seconds = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_duration_seconds(&has_bits);
          duration_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double seconds_remaining = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_seconds_remaining(&has_bits);
          seconds_remaining_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional string identifier = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.MissionInfo.identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double start_time_derived = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _Internal::set_has_start_time_derived(&has_bits);
          start_time_derived_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 capacity = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_capacity(&has_bits);
          capacity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string mission_log = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_mission_log();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.MissionInfo.mission_log");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double quality_bump = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _Internal::set_has_quality_bump(&has_bits);
          quality_bump_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 level = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_level(&has_bits);
          level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MissionInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.MissionInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.MissionInfo.Spaceship ship = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_ship(), target);
  }

  // optional .ei.MissionInfo.Status status = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_status(), target);
  }

  // optional .ei.MissionInfo.DurationType duration_type = 3;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_duration_type(), target);
  }

  // repeated .ei.MissionInfo.Fuel fuel = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_fuel_size()); i < n; i++) {
    const auto& repfield = this->_internal_fuel(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional double duration_seconds = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_duration_seconds(), target);
  }

  // optional double seconds_remaining = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_seconds_remaining(), target);
  }

  // optional string identifier = 7;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_identifier().data(), static_cast<int>(this->_internal_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.MissionInfo.identifier");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_identifier(), target);
  }

  // optional double start_time_derived = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_start_time_derived(), target);
  }

  // optional uint32 capacity = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_capacity(), target);
  }

  // optional string mission_log = 10;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_mission_log().data(), static_cast<int>(this->_internal_mission_log().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.MissionInfo.mission_log");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_mission_log(), target);
  }

  // optional double quality_bump = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(11, this->_internal_quality_bump(), target);
  }

  // optional uint32 level = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_level(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.MissionInfo)
  return target;
}

size_t MissionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.MissionInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.MissionInfo.Fuel fuel = 4;
  total_size += 1UL * this->_internal_fuel_size();
  for (const auto& msg : this->fuel_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string identifier = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_identifier());
    }

    // optional string mission_log = 10;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_mission_log());
    }

    // optional .ei.MissionInfo.Spaceship ship = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_ship());
    }

    // optional .ei.MissionInfo.Status status = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
    }

    // optional double duration_seconds = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double seconds_remaining = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional .ei.MissionInfo.DurationType duration_type = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_duration_type());
    }

    // optional uint32 capacity = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_capacity());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional double start_time_derived = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 8;
    }

    // optional double quality_bump = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional uint32 level = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_level());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MissionInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MissionInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MissionInfo::GetClassData() const { return &_class_data_; }

void MissionInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MissionInfo *>(to)->MergeFrom(
      static_cast<const MissionInfo &>(from));
}


void MissionInfo::MergeFrom(const MissionInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.MissionInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  fuel_.MergeFrom(from.fuel_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_identifier(from._internal_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_mission_log(from._internal_mission_log());
    }
    if (cached_has_bits & 0x00000004u) {
      ship_ = from.ship_;
    }
    if (cached_has_bits & 0x00000008u) {
      status_ = from.status_;
    }
    if (cached_has_bits & 0x00000010u) {
      duration_seconds_ = from.duration_seconds_;
    }
    if (cached_has_bits & 0x00000020u) {
      seconds_remaining_ = from.seconds_remaining_;
    }
    if (cached_has_bits & 0x00000040u) {
      duration_type_ = from.duration_type_;
    }
    if (cached_has_bits & 0x00000080u) {
      capacity_ = from.capacity_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      start_time_derived_ = from.start_time_derived_;
    }
    if (cached_has_bits & 0x00000200u) {
      quality_bump_ = from.quality_bump_;
    }
    if (cached_has_bits & 0x00000400u) {
      level_ = from.level_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MissionInfo::CopyFrom(const MissionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.MissionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MissionInfo::IsInitialized() const {
  return true;
}

void MissionInfo::InternalSwap(MissionInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  fuel_.InternalSwap(&other->fuel_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &identifier_, lhs_arena,
      &other->identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &mission_log_, lhs_arena,
      &other->mission_log_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MissionInfo, level_)
      + sizeof(MissionInfo::level_)
      - PROTOBUF_FIELD_OFFSET(MissionInfo, ship_)>(
          reinterpret_cast<char*>(&ship_),
          reinterpret_cast<char*>(&other->ship_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MissionInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[118]);
}

// ===================================================================

class ArtifactSpec::_Internal {
 public:
  using HasBits = decltype(std::declval<ArtifactSpec>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_level(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_rarity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_egg(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

ArtifactSpec::ArtifactSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ArtifactSpec)
}
ArtifactSpec::ArtifactSpec(const ArtifactSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&name_, &from.name_,
    static_cast<size_t>(reinterpret_cast<char*>(&egg_) -
    reinterpret_cast<char*>(&name_)) + sizeof(egg_));
  // @@protoc_insertion_point(copy_constructor:ei.ArtifactSpec)
}

inline void ArtifactSpec::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&name_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&rarity_) -
    reinterpret_cast<char*>(&name_)) + sizeof(rarity_));
egg_ = 1;
}

ArtifactSpec::~ArtifactSpec() {
  // @@protoc_insertion_point(destructor:ei.ArtifactSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ArtifactSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ArtifactSpec::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ArtifactSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ArtifactSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&name_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&rarity_) -
        reinterpret_cast<char*>(&name_)) + sizeof(rarity_));
    egg_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ArtifactSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.ArtifactSpec.Name name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::ArtifactSpec_Name_IsValid(val))) {
            _internal_set_name(static_cast<::ei::ArtifactSpec_Name>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .ei.ArtifactSpec.Level level = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::ArtifactSpec_Level_IsValid(val))) {
            _internal_set_level(static_cast<::ei::ArtifactSpec_Level>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .ei.ArtifactSpec.Rarity rarity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::ArtifactSpec_Rarity_IsValid(val))) {
            _internal_set_rarity(static_cast<::ei::ArtifactSpec_Rarity>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .ei.Egg egg = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::Egg_IsValid(val))) {
            _internal_set_egg(static_cast<::ei::Egg>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArtifactSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ArtifactSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.ArtifactSpec.Name name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_name(), target);
  }

  // optional .ei.ArtifactSpec.Level level = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_level(), target);
  }

  // optional .ei.ArtifactSpec.Rarity rarity = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_rarity(), target);
  }

  // optional .ei.Egg egg = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_egg(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ArtifactSpec)
  return target;
}

size_t ArtifactSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ArtifactSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .ei.ArtifactSpec.Name name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_name());
    }

    // optional .ei.ArtifactSpec.Level level = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_level());
    }

    // optional .ei.ArtifactSpec.Rarity rarity = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_rarity());
    }

    // optional .ei.Egg egg = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_egg());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ArtifactSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ArtifactSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ArtifactSpec::GetClassData() const { return &_class_data_; }

void ArtifactSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ArtifactSpec *>(to)->MergeFrom(
      static_cast<const ArtifactSpec &>(from));
}


void ArtifactSpec::MergeFrom(const ArtifactSpec& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ArtifactSpec)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      name_ = from.name_;
    }
    if (cached_has_bits & 0x00000002u) {
      level_ = from.level_;
    }
    if (cached_has_bits & 0x00000004u) {
      rarity_ = from.rarity_;
    }
    if (cached_has_bits & 0x00000008u) {
      egg_ = from.egg_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ArtifactSpec::CopyFrom(const ArtifactSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ArtifactSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArtifactSpec::IsInitialized() const {
  return true;
}

void ArtifactSpec::InternalSwap(ArtifactSpec* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ArtifactSpec, rarity_)
      + sizeof(ArtifactSpec::rarity_)
      - PROTOBUF_FIELD_OFFSET(ArtifactSpec, name_)>(
          reinterpret_cast<char*>(&name_),
          reinterpret_cast<char*>(&other->name_));
  swap(egg_, other->egg_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ArtifactSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[119]);
}

// ===================================================================

class CompleteArtifact::_Internal {
 public:
  using HasBits = decltype(std::declval<CompleteArtifact>()._has_bits_);
  static const ::ei::ArtifactSpec& spec(const CompleteArtifact* msg);
  static void set_has_spec(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::ei::ArtifactSpec&
CompleteArtifact::_Internal::spec(const CompleteArtifact* msg) {
  return *msg->spec_;
}
CompleteArtifact::CompleteArtifact(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  stones_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.CompleteArtifact)
}
CompleteArtifact::CompleteArtifact(const CompleteArtifact& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      stones_(from.stones_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_spec()) {
    spec_ = new ::ei::ArtifactSpec(*from.spec_);
  } else {
    spec_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:ei.CompleteArtifact)
}

inline void CompleteArtifact::SharedCtor() {
spec_ = nullptr;
}

CompleteArtifact::~CompleteArtifact() {
  // @@protoc_insertion_point(destructor:ei.CompleteArtifact)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CompleteArtifact::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete spec_;
}

void CompleteArtifact::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CompleteArtifact::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.CompleteArtifact)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  stones_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(spec_ != nullptr);
    spec_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CompleteArtifact::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.ArtifactSpec spec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ArtifactSpec stones = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_stones(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CompleteArtifact::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.CompleteArtifact)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.ArtifactSpec spec = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::spec(this),
        _Internal::spec(this).GetCachedSize(), target, stream);
  }

  // repeated .ei.ArtifactSpec stones = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_stones_size()); i < n; i++) {
    const auto& repfield = this->_internal_stones(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.CompleteArtifact)
  return target;
}

size_t CompleteArtifact::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.CompleteArtifact)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.ArtifactSpec stones = 2;
  total_size += 1UL * this->_internal_stones_size();
  for (const auto& msg : this->stones_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .ei.ArtifactSpec spec = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *spec_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CompleteArtifact::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CompleteArtifact::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CompleteArtifact::GetClassData() const { return &_class_data_; }

void CompleteArtifact::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CompleteArtifact *>(to)->MergeFrom(
      static_cast<const CompleteArtifact &>(from));
}


void CompleteArtifact::MergeFrom(const CompleteArtifact& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.CompleteArtifact)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  stones_.MergeFrom(from.stones_);
  if (from._internal_has_spec()) {
    _internal_mutable_spec()->::ei::ArtifactSpec::MergeFrom(from._internal_spec());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CompleteArtifact::CopyFrom(const CompleteArtifact& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.CompleteArtifact)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CompleteArtifact::IsInitialized() const {
  return true;
}

void CompleteArtifact::InternalSwap(CompleteArtifact* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  stones_.InternalSwap(&other->stones_);
  swap(spec_, other->spec_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CompleteArtifact::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[120]);
}

// ===================================================================

class ArtifactInventoryItem::_Internal {
 public:
  using HasBits = decltype(std::declval<ArtifactInventoryItem>()._has_bits_);
  static void set_has_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::ei::CompleteArtifact& artifact(const ArtifactInventoryItem* msg);
  static void set_has_artifact(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_quantity(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_server_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::ei::CompleteArtifact&
ArtifactInventoryItem::_Internal::artifact(const ArtifactInventoryItem* msg) {
  return *msg->artifact_;
}
ArtifactInventoryItem::ArtifactInventoryItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ArtifactInventoryItem)
}
ArtifactInventoryItem::ArtifactInventoryItem(const ArtifactInventoryItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  server_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    server_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_server_id()) {
    server_id_.Set(from._internal_server_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_artifact()) {
    artifact_ = new ::ei::CompleteArtifact(*from.artifact_);
  } else {
    artifact_ = nullptr;
  }
  ::memcpy(&item_id_, &from.item_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&quantity_) -
    reinterpret_cast<char*>(&item_id_)) + sizeof(quantity_));
  // @@protoc_insertion_point(copy_constructor:ei.ArtifactInventoryItem)
}

inline void ArtifactInventoryItem::SharedCtor() {
server_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  server_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&artifact_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&quantity_) -
    reinterpret_cast<char*>(&artifact_)) + sizeof(quantity_));
}

ArtifactInventoryItem::~ArtifactInventoryItem() {
  // @@protoc_insertion_point(destructor:ei.ArtifactInventoryItem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ArtifactInventoryItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  server_id_.Destroy();
  if (this != internal_default_instance()) delete artifact_;
}

void ArtifactInventoryItem::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ArtifactInventoryItem::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ArtifactInventoryItem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      server_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(artifact_ != nullptr);
      artifact_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&item_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&quantity_) -
        reinterpret_cast<char*>(&item_id_)) + sizeof(quantity_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ArtifactInventoryItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 item_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_item_id(&has_bits);
          item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.CompleteArtifact artifact = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_artifact(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double quantity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_quantity(&has_bits);
          quantity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional string server_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_server_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ArtifactInventoryItem.server_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArtifactInventoryItem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ArtifactInventoryItem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 item_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_item_id(), target);
  }

  // optional .ei.CompleteArtifact artifact = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::artifact(this),
        _Internal::artifact(this).GetCachedSize(), target, stream);
  }

  // optional double quantity = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_quantity(), target);
  }

  // optional string server_id = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_server_id().data(), static_cast<int>(this->_internal_server_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ArtifactInventoryItem.server_id");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_server_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ArtifactInventoryItem)
  return target;
}

size_t ArtifactInventoryItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ArtifactInventoryItem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string server_id = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_server_id());
    }

    // optional .ei.CompleteArtifact artifact = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *artifact_);
    }

    // optional uint64 item_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_item_id());
    }

    // optional double quantity = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ArtifactInventoryItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ArtifactInventoryItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ArtifactInventoryItem::GetClassData() const { return &_class_data_; }

void ArtifactInventoryItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ArtifactInventoryItem *>(to)->MergeFrom(
      static_cast<const ArtifactInventoryItem &>(from));
}


void ArtifactInventoryItem::MergeFrom(const ArtifactInventoryItem& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ArtifactInventoryItem)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_server_id(from._internal_server_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_artifact()->::ei::CompleteArtifact::MergeFrom(from._internal_artifact());
    }
    if (cached_has_bits & 0x00000004u) {
      item_id_ = from.item_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      quantity_ = from.quantity_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ArtifactInventoryItem::CopyFrom(const ArtifactInventoryItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ArtifactInventoryItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArtifactInventoryItem::IsInitialized() const {
  return true;
}

void ArtifactInventoryItem::InternalSwap(ArtifactInventoryItem* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &server_id_, lhs_arena,
      &other->server_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ArtifactInventoryItem, quantity_)
      + sizeof(ArtifactInventoryItem::quantity_)
      - PROTOBUF_FIELD_OFFSET(ArtifactInventoryItem, artifact_)>(
          reinterpret_cast<char*>(&artifact_),
          reinterpret_cast<char*>(&other->artifact_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ArtifactInventoryItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[121]);
}

// ===================================================================

class InventorySlot::_Internal {
 public:
  using HasBits = decltype(std::declval<InventorySlot>()._has_bits_);
  static void set_has_occupied(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

InventorySlot::InventorySlot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.InventorySlot)
}
InventorySlot::InventorySlot(const InventorySlot& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&occupied_, &from.occupied_,
    static_cast<size_t>(reinterpret_cast<char*>(&item_id_) -
    reinterpret_cast<char*>(&occupied_)) + sizeof(item_id_));
  // @@protoc_insertion_point(copy_constructor:ei.InventorySlot)
}

inline void InventorySlot::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&occupied_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&item_id_) -
    reinterpret_cast<char*>(&occupied_)) + sizeof(item_id_));
}

InventorySlot::~InventorySlot() {
  // @@protoc_insertion_point(destructor:ei.InventorySlot)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InventorySlot::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void InventorySlot::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void InventorySlot::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.InventorySlot)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&occupied_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&item_id_) -
        reinterpret_cast<char*>(&occupied_)) + sizeof(item_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InventorySlot::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool occupied = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_occupied(&has_bits);
          occupied_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 item_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_item_id(&has_bits);
          item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InventorySlot::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.InventorySlot)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool occupied = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_occupied(), target);
  }

  // optional uint32 item_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_item_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.InventorySlot)
  return target;
}

size_t InventorySlot::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.InventorySlot)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool occupied = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional uint32 item_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_item_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InventorySlot::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    InventorySlot::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InventorySlot::GetClassData() const { return &_class_data_; }

void InventorySlot::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<InventorySlot *>(to)->MergeFrom(
      static_cast<const InventorySlot &>(from));
}


void InventorySlot::MergeFrom(const InventorySlot& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.InventorySlot)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      occupied_ = from.occupied_;
    }
    if (cached_has_bits & 0x00000002u) {
      item_id_ = from.item_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InventorySlot::CopyFrom(const InventorySlot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.InventorySlot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InventorySlot::IsInitialized() const {
  return true;
}

void InventorySlot::InternalSwap(InventorySlot* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InventorySlot, item_id_)
      + sizeof(InventorySlot::item_id_)
      - PROTOBUF_FIELD_OFFSET(InventorySlot, occupied_)>(
          reinterpret_cast<char*>(&occupied_),
          reinterpret_cast<char*>(&other->occupied_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InventorySlot::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[122]);
}

// ===================================================================

class ArtifactsConfigurationRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ArtifactsConfigurationRequest>()._has_bits_);
  static const ::ei::BasicRequestInfo& rinfo(const ArtifactsConfigurationRequest* msg);
  static void set_has_rinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::ei::BasicRequestInfo&
ArtifactsConfigurationRequest::_Internal::rinfo(const ArtifactsConfigurationRequest* msg) {
  return *msg->rinfo_;
}
ArtifactsConfigurationRequest::ArtifactsConfigurationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ArtifactsConfigurationRequest)
}
ArtifactsConfigurationRequest::ArtifactsConfigurationRequest(const ArtifactsConfigurationRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_rinfo()) {
    rinfo_ = new ::ei::BasicRequestInfo(*from.rinfo_);
  } else {
    rinfo_ = nullptr;
  }
  client_version_ = from.client_version_;
  // @@protoc_insertion_point(copy_constructor:ei.ArtifactsConfigurationRequest)
}

inline void ArtifactsConfigurationRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rinfo_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&client_version_) -
    reinterpret_cast<char*>(&rinfo_)) + sizeof(client_version_));
}

ArtifactsConfigurationRequest::~ArtifactsConfigurationRequest() {
  // @@protoc_insertion_point(destructor:ei.ArtifactsConfigurationRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ArtifactsConfigurationRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete rinfo_;
}

void ArtifactsConfigurationRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ArtifactsConfigurationRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ArtifactsConfigurationRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(rinfo_ != nullptr);
    rinfo_->Clear();
  }
  client_version_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ArtifactsConfigurationRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 client_version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_client_version(&has_bits);
          client_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.BasicRequestInfo rinfo = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_rinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArtifactsConfigurationRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ArtifactsConfigurationRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 client_version = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_client_version(), target);
  }

  // optional .ei.BasicRequestInfo rinfo = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::rinfo(this),
        _Internal::rinfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ArtifactsConfigurationRequest)
  return target;
}

size_t ArtifactsConfigurationRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ArtifactsConfigurationRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .ei.BasicRequestInfo rinfo = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rinfo_);
    }

    // optional uint32 client_version = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_client_version());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ArtifactsConfigurationRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ArtifactsConfigurationRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ArtifactsConfigurationRequest::GetClassData() const { return &_class_data_; }

void ArtifactsConfigurationRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ArtifactsConfigurationRequest *>(to)->MergeFrom(
      static_cast<const ArtifactsConfigurationRequest &>(from));
}


void ArtifactsConfigurationRequest::MergeFrom(const ArtifactsConfigurationRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ArtifactsConfigurationRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_rinfo()->::ei::BasicRequestInfo::MergeFrom(from._internal_rinfo());
    }
    if (cached_has_bits & 0x00000002u) {
      client_version_ = from.client_version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ArtifactsConfigurationRequest::CopyFrom(const ArtifactsConfigurationRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ArtifactsConfigurationRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArtifactsConfigurationRequest::IsInitialized() const {
  return true;
}

void ArtifactsConfigurationRequest::InternalSwap(ArtifactsConfigurationRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ArtifactsConfigurationRequest, client_version_)
      + sizeof(ArtifactsConfigurationRequest::client_version_)
      - PROTOBUF_FIELD_OFFSET(ArtifactsConfigurationRequest, rinfo_)>(
          reinterpret_cast<char*>(&rinfo_),
          reinterpret_cast<char*>(&other->rinfo_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ArtifactsConfigurationRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[123]);
}

// ===================================================================

class ArtifactsConfigurationResponse_MissionParameters_Duration::_Internal {
 public:
  using HasBits = decltype(std::declval<ArtifactsConfigurationResponse_MissionParameters_Duration>()._has_bits_);
  static void set_has_duration_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_quality(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_min_quality(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_max_quality(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_capacity(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_level_capacity_bump(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_level_quality_bump(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

ArtifactsConfigurationResponse_MissionParameters_Duration::ArtifactsConfigurationResponse_MissionParameters_Duration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ArtifactsConfigurationResponse.MissionParameters.Duration)
}
ArtifactsConfigurationResponse_MissionParameters_Duration::ArtifactsConfigurationResponse_MissionParameters_Duration(const ArtifactsConfigurationResponse_MissionParameters_Duration& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&seconds_, &from.seconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&level_quality_bump_) -
    reinterpret_cast<char*>(&seconds_)) + sizeof(level_quality_bump_));
  // @@protoc_insertion_point(copy_constructor:ei.ArtifactsConfigurationResponse.MissionParameters.Duration)
}

inline void ArtifactsConfigurationResponse_MissionParameters_Duration::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&seconds_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&level_quality_bump_) -
    reinterpret_cast<char*>(&seconds_)) + sizeof(level_quality_bump_));
}

ArtifactsConfigurationResponse_MissionParameters_Duration::~ArtifactsConfigurationResponse_MissionParameters_Duration() {
  // @@protoc_insertion_point(destructor:ei.ArtifactsConfigurationResponse.MissionParameters.Duration)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ArtifactsConfigurationResponse_MissionParameters_Duration::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ArtifactsConfigurationResponse_MissionParameters_Duration::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ArtifactsConfigurationResponse_MissionParameters_Duration::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ArtifactsConfigurationResponse.MissionParameters.Duration)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&seconds_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&level_quality_bump_) -
        reinterpret_cast<char*>(&seconds_)) + sizeof(level_quality_bump_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ArtifactsConfigurationResponse_MissionParameters_Duration::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.MissionInfo.DurationType duration_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::MissionInfo_DurationType_IsValid(val))) {
            _internal_set_duration_type(static_cast<::ei::MissionInfo_DurationType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional double seconds = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_seconds(&has_bits);
          seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional float quality = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_quality(&has_bits);
          quality_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float min_quality = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_min_quality(&has_bits);
          min_quality_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float max_quality = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_max_quality(&has_bits);
          max_quality_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 capacity = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_capacity(&has_bits);
          capacity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 level_capacity_bump = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_level_capacity_bump(&has_bits);
          level_capacity_bump_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float level_quality_bump = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_level_quality_bump(&has_bits);
          level_quality_bump_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArtifactsConfigurationResponse_MissionParameters_Duration::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ArtifactsConfigurationResponse.MissionParameters.Duration)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.MissionInfo.DurationType duration_type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_duration_type(), target);
  }

  // optional double seconds = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_seconds(), target);
  }

  // optional float quality = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_quality(), target);
  }

  // optional float min_quality = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_min_quality(), target);
  }

  // optional float max_quality = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_max_quality(), target);
  }

  // optional uint32 capacity = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_capacity(), target);
  }

  // optional uint32 level_capacity_bump = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_level_capacity_bump(), target);
  }

  // optional float level_quality_bump = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_level_quality_bump(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ArtifactsConfigurationResponse.MissionParameters.Duration)
  return target;
}

size_t ArtifactsConfigurationResponse_MissionParameters_Duration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ArtifactsConfigurationResponse.MissionParameters.Duration)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional double seconds = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional .ei.MissionInfo.DurationType duration_type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_duration_type());
    }

    // optional float quality = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float min_quality = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float max_quality = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional uint32 capacity = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_capacity());
    }

    // optional uint32 level_capacity_bump = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_level_capacity_bump());
    }

    // optional float level_quality_bump = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ArtifactsConfigurationResponse_MissionParameters_Duration::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ArtifactsConfigurationResponse_MissionParameters_Duration::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ArtifactsConfigurationResponse_MissionParameters_Duration::GetClassData() const { return &_class_data_; }

void ArtifactsConfigurationResponse_MissionParameters_Duration::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ArtifactsConfigurationResponse_MissionParameters_Duration *>(to)->MergeFrom(
      static_cast<const ArtifactsConfigurationResponse_MissionParameters_Duration &>(from));
}


void ArtifactsConfigurationResponse_MissionParameters_Duration::MergeFrom(const ArtifactsConfigurationResponse_MissionParameters_Duration& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ArtifactsConfigurationResponse.MissionParameters.Duration)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      seconds_ = from.seconds_;
    }
    if (cached_has_bits & 0x00000002u) {
      duration_type_ = from.duration_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      quality_ = from.quality_;
    }
    if (cached_has_bits & 0x00000008u) {
      min_quality_ = from.min_quality_;
    }
    if (cached_has_bits & 0x00000010u) {
      max_quality_ = from.max_quality_;
    }
    if (cached_has_bits & 0x00000020u) {
      capacity_ = from.capacity_;
    }
    if (cached_has_bits & 0x00000040u) {
      level_capacity_bump_ = from.level_capacity_bump_;
    }
    if (cached_has_bits & 0x00000080u) {
      level_quality_bump_ = from.level_quality_bump_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ArtifactsConfigurationResponse_MissionParameters_Duration::CopyFrom(const ArtifactsConfigurationResponse_MissionParameters_Duration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ArtifactsConfigurationResponse.MissionParameters.Duration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArtifactsConfigurationResponse_MissionParameters_Duration::IsInitialized() const {
  return true;
}

void ArtifactsConfigurationResponse_MissionParameters_Duration::InternalSwap(ArtifactsConfigurationResponse_MissionParameters_Duration* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ArtifactsConfigurationResponse_MissionParameters_Duration, level_quality_bump_)
      + sizeof(ArtifactsConfigurationResponse_MissionParameters_Duration::level_quality_bump_)
      - PROTOBUF_FIELD_OFFSET(ArtifactsConfigurationResponse_MissionParameters_Duration, seconds_)>(
          reinterpret_cast<char*>(&seconds_),
          reinterpret_cast<char*>(&other->seconds_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ArtifactsConfigurationResponse_MissionParameters_Duration::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[124]);
}

// ===================================================================

class ArtifactsConfigurationResponse_MissionParameters::_Internal {
 public:
  using HasBits = decltype(std::declval<ArtifactsConfigurationResponse_MissionParameters>()._has_bits_);
  static void set_has_ship(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_capacity_deprecated(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ArtifactsConfigurationResponse_MissionParameters::ArtifactsConfigurationResponse_MissionParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  durations_(arena),
  level_mission_requirements_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ArtifactsConfigurationResponse.MissionParameters)
}
ArtifactsConfigurationResponse_MissionParameters::ArtifactsConfigurationResponse_MissionParameters(const ArtifactsConfigurationResponse_MissionParameters& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      durations_(from.durations_),
      level_mission_requirements_(from.level_mission_requirements_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&ship_, &from.ship_,
    static_cast<size_t>(reinterpret_cast<char*>(&capacity_deprecated_) -
    reinterpret_cast<char*>(&ship_)) + sizeof(capacity_deprecated_));
  // @@protoc_insertion_point(copy_constructor:ei.ArtifactsConfigurationResponse.MissionParameters)
}

inline void ArtifactsConfigurationResponse_MissionParameters::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&ship_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&capacity_deprecated_) -
    reinterpret_cast<char*>(&ship_)) + sizeof(capacity_deprecated_));
}

ArtifactsConfigurationResponse_MissionParameters::~ArtifactsConfigurationResponse_MissionParameters() {
  // @@protoc_insertion_point(destructor:ei.ArtifactsConfigurationResponse.MissionParameters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ArtifactsConfigurationResponse_MissionParameters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ArtifactsConfigurationResponse_MissionParameters::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ArtifactsConfigurationResponse_MissionParameters::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ArtifactsConfigurationResponse.MissionParameters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  durations_.Clear();
  level_mission_requirements_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&ship_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&capacity_deprecated_) -
        reinterpret_cast<char*>(&ship_)) + sizeof(capacity_deprecated_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ArtifactsConfigurationResponse_MissionParameters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.MissionInfo.Spaceship ship = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::MissionInfo_Spaceship_IsValid(val))) {
            _internal_set_ship(static_cast<::ei::MissionInfo_Spaceship>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 capacity_DEPRECATED = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_capacity_deprecated(&has_bits);
          capacity_deprecated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ArtifactsConfigurationResponse.MissionParameters.Duration durations = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_durations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 level_mission_requirements = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_level_mission_requirements(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_level_mission_requirements(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArtifactsConfigurationResponse_MissionParameters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ArtifactsConfigurationResponse.MissionParameters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.MissionInfo.Spaceship ship = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_ship(), target);
  }

  // optional uint32 capacity_DEPRECATED = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_capacity_deprecated(), target);
  }

  // repeated .ei.ArtifactsConfigurationResponse.MissionParameters.Duration durations = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_durations_size()); i < n; i++) {
    const auto& repfield = this->_internal_durations(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated uint32 level_mission_requirements = 4;
  for (int i = 0, n = this->_internal_level_mission_requirements_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_level_mission_requirements(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ArtifactsConfigurationResponse.MissionParameters)
  return target;
}

size_t ArtifactsConfigurationResponse_MissionParameters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ArtifactsConfigurationResponse.MissionParameters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.ArtifactsConfigurationResponse.MissionParameters.Duration durations = 3;
  total_size += 1UL * this->_internal_durations_size();
  for (const auto& msg : this->durations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint32 level_mission_requirements = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->level_mission_requirements_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_level_mission_requirements_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .ei.MissionInfo.Spaceship ship = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_ship());
    }

    // optional uint32 capacity_DEPRECATED = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_capacity_deprecated());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ArtifactsConfigurationResponse_MissionParameters::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ArtifactsConfigurationResponse_MissionParameters::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ArtifactsConfigurationResponse_MissionParameters::GetClassData() const { return &_class_data_; }

void ArtifactsConfigurationResponse_MissionParameters::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ArtifactsConfigurationResponse_MissionParameters *>(to)->MergeFrom(
      static_cast<const ArtifactsConfigurationResponse_MissionParameters &>(from));
}


void ArtifactsConfigurationResponse_MissionParameters::MergeFrom(const ArtifactsConfigurationResponse_MissionParameters& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ArtifactsConfigurationResponse.MissionParameters)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  durations_.MergeFrom(from.durations_);
  level_mission_requirements_.MergeFrom(from.level_mission_requirements_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ship_ = from.ship_;
    }
    if (cached_has_bits & 0x00000002u) {
      capacity_deprecated_ = from.capacity_deprecated_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ArtifactsConfigurationResponse_MissionParameters::CopyFrom(const ArtifactsConfigurationResponse_MissionParameters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ArtifactsConfigurationResponse.MissionParameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArtifactsConfigurationResponse_MissionParameters::IsInitialized() const {
  return true;
}

void ArtifactsConfigurationResponse_MissionParameters::InternalSwap(ArtifactsConfigurationResponse_MissionParameters* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  durations_.InternalSwap(&other->durations_);
  level_mission_requirements_.InternalSwap(&other->level_mission_requirements_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ArtifactsConfigurationResponse_MissionParameters, capacity_deprecated_)
      + sizeof(ArtifactsConfigurationResponse_MissionParameters::capacity_deprecated_)
      - PROTOBUF_FIELD_OFFSET(ArtifactsConfigurationResponse_MissionParameters, ship_)>(
          reinterpret_cast<char*>(&ship_),
          reinterpret_cast<char*>(&other->ship_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ArtifactsConfigurationResponse_MissionParameters::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[125]);
}

// ===================================================================

class ArtifactsConfigurationResponse_ArtifactParameters::_Internal {
 public:
  using HasBits = decltype(std::declval<ArtifactsConfigurationResponse_ArtifactParameters>()._has_bits_);
  static const ::ei::ArtifactSpec& spec(const ArtifactsConfigurationResponse_ArtifactParameters* msg);
  static void set_has_spec(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_base_quality(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_odds_multiplier(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_crafting_price(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_crafting_price_low(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_crafting_price_domain(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_crafting_price_curve(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_crafting_xp(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::ei::ArtifactSpec&
ArtifactsConfigurationResponse_ArtifactParameters::_Internal::spec(const ArtifactsConfigurationResponse_ArtifactParameters* msg) {
  return *msg->spec_;
}
ArtifactsConfigurationResponse_ArtifactParameters::ArtifactsConfigurationResponse_ArtifactParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ArtifactsConfigurationResponse.ArtifactParameters)
}
ArtifactsConfigurationResponse_ArtifactParameters::ArtifactsConfigurationResponse_ArtifactParameters(const ArtifactsConfigurationResponse_ArtifactParameters& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_spec()) {
    spec_ = new ::ei::ArtifactSpec(*from.spec_);
  } else {
    spec_ = nullptr;
  }
  ::memcpy(&base_quality_, &from.base_quality_,
    static_cast<size_t>(reinterpret_cast<char*>(&crafting_price_domain_) -
    reinterpret_cast<char*>(&base_quality_)) + sizeof(crafting_price_domain_));
  // @@protoc_insertion_point(copy_constructor:ei.ArtifactsConfigurationResponse.ArtifactParameters)
}

inline void ArtifactsConfigurationResponse_ArtifactParameters::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&spec_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&crafting_price_domain_) -
    reinterpret_cast<char*>(&spec_)) + sizeof(crafting_price_domain_));
}

ArtifactsConfigurationResponse_ArtifactParameters::~ArtifactsConfigurationResponse_ArtifactParameters() {
  // @@protoc_insertion_point(destructor:ei.ArtifactsConfigurationResponse.ArtifactParameters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ArtifactsConfigurationResponse_ArtifactParameters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete spec_;
}

void ArtifactsConfigurationResponse_ArtifactParameters::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ArtifactsConfigurationResponse_ArtifactParameters::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ArtifactsConfigurationResponse.ArtifactParameters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(spec_ != nullptr);
    spec_->Clear();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&base_quality_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&crafting_xp_) -
        reinterpret_cast<char*>(&base_quality_)) + sizeof(crafting_xp_));
  }
  crafting_price_domain_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ArtifactsConfigurationResponse_ArtifactParameters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.ArtifactSpec spec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double base_quality = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_base_quality(&has_bits);
          base_quality_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_value(&has_bits);
          value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double odds_multiplier = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_odds_multiplier(&has_bits);
          odds_multiplier_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double crafting_price = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_crafting_price(&has_bits);
          crafting_price_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double crafting_price_low = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_crafting_price_low(&has_bits);
          crafting_price_low_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 crafting_price_domain = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_crafting_price_domain(&has_bits);
          crafting_price_domain_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double crafting_price_curve = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _Internal::set_has_crafting_price_curve(&has_bits);
          crafting_price_curve_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 crafting_xp = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_crafting_xp(&has_bits);
          crafting_xp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArtifactsConfigurationResponse_ArtifactParameters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ArtifactsConfigurationResponse.ArtifactParameters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.ArtifactSpec spec = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::spec(this),
        _Internal::spec(this).GetCachedSize(), target, stream);
  }

  // optional double base_quality = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_base_quality(), target);
  }

  // optional double value = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_value(), target);
  }

  // optional double odds_multiplier = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_odds_multiplier(), target);
  }

  // optional double crafting_price = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_crafting_price(), target);
  }

  // optional double crafting_price_low = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_crafting_price_low(), target);
  }

  // optional uint32 crafting_price_domain = 7;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_crafting_price_domain(), target);
  }

  // optional double crafting_price_curve = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_crafting_price_curve(), target);
  }

  // optional uint64 crafting_xp = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(9, this->_internal_crafting_xp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ArtifactsConfigurationResponse.ArtifactParameters)
  return target;
}

size_t ArtifactsConfigurationResponse_ArtifactParameters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ArtifactsConfigurationResponse.ArtifactParameters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .ei.ArtifactSpec spec = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *spec_);
    }

    // optional double base_quality = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double value = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double odds_multiplier = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double crafting_price = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double crafting_price_low = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional double crafting_price_curve = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional uint64 crafting_xp = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_crafting_xp());
    }

  }
  // optional uint32 crafting_price_domain = 7;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_crafting_price_domain());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ArtifactsConfigurationResponse_ArtifactParameters::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ArtifactsConfigurationResponse_ArtifactParameters::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ArtifactsConfigurationResponse_ArtifactParameters::GetClassData() const { return &_class_data_; }

void ArtifactsConfigurationResponse_ArtifactParameters::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ArtifactsConfigurationResponse_ArtifactParameters *>(to)->MergeFrom(
      static_cast<const ArtifactsConfigurationResponse_ArtifactParameters &>(from));
}


void ArtifactsConfigurationResponse_ArtifactParameters::MergeFrom(const ArtifactsConfigurationResponse_ArtifactParameters& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ArtifactsConfigurationResponse.ArtifactParameters)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_spec()->::ei::ArtifactSpec::MergeFrom(from._internal_spec());
    }
    if (cached_has_bits & 0x00000002u) {
      base_quality_ = from.base_quality_;
    }
    if (cached_has_bits & 0x00000004u) {
      value_ = from.value_;
    }
    if (cached_has_bits & 0x00000008u) {
      odds_multiplier_ = from.odds_multiplier_;
    }
    if (cached_has_bits & 0x00000010u) {
      crafting_price_ = from.crafting_price_;
    }
    if (cached_has_bits & 0x00000020u) {
      crafting_price_low_ = from.crafting_price_low_;
    }
    if (cached_has_bits & 0x00000040u) {
      crafting_price_curve_ = from.crafting_price_curve_;
    }
    if (cached_has_bits & 0x00000080u) {
      crafting_xp_ = from.crafting_xp_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_crafting_price_domain(from._internal_crafting_price_domain());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ArtifactsConfigurationResponse_ArtifactParameters::CopyFrom(const ArtifactsConfigurationResponse_ArtifactParameters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ArtifactsConfigurationResponse.ArtifactParameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArtifactsConfigurationResponse_ArtifactParameters::IsInitialized() const {
  return true;
}

void ArtifactsConfigurationResponse_ArtifactParameters::InternalSwap(ArtifactsConfigurationResponse_ArtifactParameters* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ArtifactsConfigurationResponse_ArtifactParameters, crafting_price_domain_)
      + sizeof(ArtifactsConfigurationResponse_ArtifactParameters::crafting_price_domain_)
      - PROTOBUF_FIELD_OFFSET(ArtifactsConfigurationResponse_ArtifactParameters, spec_)>(
          reinterpret_cast<char*>(&spec_),
          reinterpret_cast<char*>(&other->spec_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ArtifactsConfigurationResponse_ArtifactParameters::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[126]);
}

// ===================================================================

class ArtifactsConfigurationResponse_CraftingLevelInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ArtifactsConfigurationResponse_CraftingLevelInfo>()._has_bits_);
  static void set_has_xp_required(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_rarity_mult(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ArtifactsConfigurationResponse_CraftingLevelInfo::ArtifactsConfigurationResponse_CraftingLevelInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ArtifactsConfigurationResponse.CraftingLevelInfo)
}
ArtifactsConfigurationResponse_CraftingLevelInfo::ArtifactsConfigurationResponse_CraftingLevelInfo(const ArtifactsConfigurationResponse_CraftingLevelInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&xp_required_, &from.xp_required_,
    static_cast<size_t>(reinterpret_cast<char*>(&rarity_mult_) -
    reinterpret_cast<char*>(&xp_required_)) + sizeof(rarity_mult_));
  // @@protoc_insertion_point(copy_constructor:ei.ArtifactsConfigurationResponse.CraftingLevelInfo)
}

inline void ArtifactsConfigurationResponse_CraftingLevelInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&xp_required_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&rarity_mult_) -
    reinterpret_cast<char*>(&xp_required_)) + sizeof(rarity_mult_));
}

ArtifactsConfigurationResponse_CraftingLevelInfo::~ArtifactsConfigurationResponse_CraftingLevelInfo() {
  // @@protoc_insertion_point(destructor:ei.ArtifactsConfigurationResponse.CraftingLevelInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ArtifactsConfigurationResponse_CraftingLevelInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ArtifactsConfigurationResponse_CraftingLevelInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ArtifactsConfigurationResponse_CraftingLevelInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ArtifactsConfigurationResponse.CraftingLevelInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&xp_required_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&rarity_mult_) -
        reinterpret_cast<char*>(&xp_required_)) + sizeof(rarity_mult_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ArtifactsConfigurationResponse_CraftingLevelInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double xp_required = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_xp_required(&has_bits);
          xp_required_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional float rarity_mult = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_rarity_mult(&has_bits);
          rarity_mult_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArtifactsConfigurationResponse_CraftingLevelInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ArtifactsConfigurationResponse.CraftingLevelInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double xp_required = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_xp_required(), target);
  }

  // optional float rarity_mult = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_rarity_mult(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ArtifactsConfigurationResponse.CraftingLevelInfo)
  return target;
}

size_t ArtifactsConfigurationResponse_CraftingLevelInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ArtifactsConfigurationResponse.CraftingLevelInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional double xp_required = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional float rarity_mult = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ArtifactsConfigurationResponse_CraftingLevelInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ArtifactsConfigurationResponse_CraftingLevelInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ArtifactsConfigurationResponse_CraftingLevelInfo::GetClassData() const { return &_class_data_; }

void ArtifactsConfigurationResponse_CraftingLevelInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ArtifactsConfigurationResponse_CraftingLevelInfo *>(to)->MergeFrom(
      static_cast<const ArtifactsConfigurationResponse_CraftingLevelInfo &>(from));
}


void ArtifactsConfigurationResponse_CraftingLevelInfo::MergeFrom(const ArtifactsConfigurationResponse_CraftingLevelInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ArtifactsConfigurationResponse.CraftingLevelInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      xp_required_ = from.xp_required_;
    }
    if (cached_has_bits & 0x00000002u) {
      rarity_mult_ = from.rarity_mult_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ArtifactsConfigurationResponse_CraftingLevelInfo::CopyFrom(const ArtifactsConfigurationResponse_CraftingLevelInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ArtifactsConfigurationResponse.CraftingLevelInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArtifactsConfigurationResponse_CraftingLevelInfo::IsInitialized() const {
  return true;
}

void ArtifactsConfigurationResponse_CraftingLevelInfo::InternalSwap(ArtifactsConfigurationResponse_CraftingLevelInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ArtifactsConfigurationResponse_CraftingLevelInfo, rarity_mult_)
      + sizeof(ArtifactsConfigurationResponse_CraftingLevelInfo::rarity_mult_)
      - PROTOBUF_FIELD_OFFSET(ArtifactsConfigurationResponse_CraftingLevelInfo, xp_required_)>(
          reinterpret_cast<char*>(&xp_required_),
          reinterpret_cast<char*>(&other->xp_required_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ArtifactsConfigurationResponse_CraftingLevelInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[127]);
}

// ===================================================================

class ArtifactsConfigurationResponse::_Internal {
 public:
};

ArtifactsConfigurationResponse::ArtifactsConfigurationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  mission_parameters_(arena),
  artifact_parameters_(arena),
  crafting_level_infos_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ArtifactsConfigurationResponse)
}
ArtifactsConfigurationResponse::ArtifactsConfigurationResponse(const ArtifactsConfigurationResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      mission_parameters_(from.mission_parameters_),
      artifact_parameters_(from.artifact_parameters_),
      crafting_level_infos_(from.crafting_level_infos_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ei.ArtifactsConfigurationResponse)
}

inline void ArtifactsConfigurationResponse::SharedCtor() {
}

ArtifactsConfigurationResponse::~ArtifactsConfigurationResponse() {
  // @@protoc_insertion_point(destructor:ei.ArtifactsConfigurationResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ArtifactsConfigurationResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ArtifactsConfigurationResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ArtifactsConfigurationResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ArtifactsConfigurationResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  mission_parameters_.Clear();
  artifact_parameters_.Clear();
  crafting_level_infos_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ArtifactsConfigurationResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .ei.ArtifactsConfigurationResponse.MissionParameters mission_parameters = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_mission_parameters(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ArtifactsConfigurationResponse.ArtifactParameters artifact_parameters = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_artifact_parameters(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ArtifactsConfigurationResponse.CraftingLevelInfo crafting_level_infos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_crafting_level_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArtifactsConfigurationResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ArtifactsConfigurationResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ei.ArtifactsConfigurationResponse.MissionParameters mission_parameters = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_mission_parameters_size()); i < n; i++) {
    const auto& repfield = this->_internal_mission_parameters(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .ei.ArtifactsConfigurationResponse.ArtifactParameters artifact_parameters = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_artifact_parameters_size()); i < n; i++) {
    const auto& repfield = this->_internal_artifact_parameters(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .ei.ArtifactsConfigurationResponse.CraftingLevelInfo crafting_level_infos = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_crafting_level_infos_size()); i < n; i++) {
    const auto& repfield = this->_internal_crafting_level_infos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ArtifactsConfigurationResponse)
  return target;
}

size_t ArtifactsConfigurationResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ArtifactsConfigurationResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.ArtifactsConfigurationResponse.MissionParameters mission_parameters = 1;
  total_size += 1UL * this->_internal_mission_parameters_size();
  for (const auto& msg : this->mission_parameters_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.ArtifactsConfigurationResponse.ArtifactParameters artifact_parameters = 2;
  total_size += 1UL * this->_internal_artifact_parameters_size();
  for (const auto& msg : this->artifact_parameters_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.ArtifactsConfigurationResponse.CraftingLevelInfo crafting_level_infos = 3;
  total_size += 1UL * this->_internal_crafting_level_infos_size();
  for (const auto& msg : this->crafting_level_infos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ArtifactsConfigurationResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ArtifactsConfigurationResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ArtifactsConfigurationResponse::GetClassData() const { return &_class_data_; }

void ArtifactsConfigurationResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ArtifactsConfigurationResponse *>(to)->MergeFrom(
      static_cast<const ArtifactsConfigurationResponse &>(from));
}


void ArtifactsConfigurationResponse::MergeFrom(const ArtifactsConfigurationResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ArtifactsConfigurationResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  mission_parameters_.MergeFrom(from.mission_parameters_);
  artifact_parameters_.MergeFrom(from.artifact_parameters_);
  crafting_level_infos_.MergeFrom(from.crafting_level_infos_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ArtifactsConfigurationResponse::CopyFrom(const ArtifactsConfigurationResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ArtifactsConfigurationResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArtifactsConfigurationResponse::IsInitialized() const {
  return true;
}

void ArtifactsConfigurationResponse::InternalSwap(ArtifactsConfigurationResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  mission_parameters_.InternalSwap(&other->mission_parameters_);
  artifact_parameters_.InternalSwap(&other->artifact_parameters_);
  crafting_level_infos_.InternalSwap(&other->crafting_level_infos_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ArtifactsConfigurationResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[128]);
}

// ===================================================================

class MissionRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<MissionRequest>()._has_bits_);
  static const ::ei::BasicRequestInfo& rinfo(const MissionRequest* msg);
  static void set_has_rinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ei_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ei::MissionInfo& info(const MissionRequest* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::ei::ArtifactsClientInfo& client_info(const MissionRequest* msg);
  static void set_has_client_info(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::ei::BasicRequestInfo&
MissionRequest::_Internal::rinfo(const MissionRequest* msg) {
  return *msg->rinfo_;
}
const ::ei::MissionInfo&
MissionRequest::_Internal::info(const MissionRequest* msg) {
  return *msg->info_;
}
const ::ei::ArtifactsClientInfo&
MissionRequest::_Internal::client_info(const MissionRequest* msg) {
  return *msg->client_info_;
}
MissionRequest::MissionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.MissionRequest)
}
MissionRequest::MissionRequest(const MissionRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ei_user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ei_user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ei_user_id()) {
    ei_user_id_.Set(from._internal_ei_user_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_info()) {
    info_ = new ::ei::MissionInfo(*from.info_);
  } else {
    info_ = nullptr;
  }
  if (from._internal_has_rinfo()) {
    rinfo_ = new ::ei::BasicRequestInfo(*from.rinfo_);
  } else {
    rinfo_ = nullptr;
  }
  if (from._internal_has_client_info()) {
    client_info_ = new ::ei::ArtifactsClientInfo(*from.client_info_);
  } else {
    client_info_ = nullptr;
  }
  client_version_ = from.client_version_;
  // @@protoc_insertion_point(copy_constructor:ei.MissionRequest)
}

inline void MissionRequest::SharedCtor() {
ei_user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ei_user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&info_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&client_version_) -
    reinterpret_cast<char*>(&info_)) + sizeof(client_version_));
}

MissionRequest::~MissionRequest() {
  // @@protoc_insertion_point(destructor:ei.MissionRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MissionRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ei_user_id_.Destroy();
  if (this != internal_default_instance()) delete info_;
  if (this != internal_default_instance()) delete rinfo_;
  if (this != internal_default_instance()) delete client_info_;
}

void MissionRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MissionRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.MissionRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      ei_user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(info_ != nullptr);
      info_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(rinfo_ != nullptr);
      rinfo_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(client_info_ != nullptr);
      client_info_->Clear();
    }
  }
  client_version_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MissionRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 client_version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_client_version(&has_bits);
          client_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.MissionInfo info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string ei_user_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_ei_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.MissionRequest.ei_user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .ei.BasicRequestInfo rinfo = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_rinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.ArtifactsClientInfo client_info = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_client_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MissionRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.MissionRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 client_version = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_client_version(), target);
  }

  // optional .ei.MissionInfo info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  // optional string ei_user_id = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ei_user_id().data(), static_cast<int>(this->_internal_ei_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.MissionRequest.ei_user_id");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_ei_user_id(), target);
  }

  // optional .ei.BasicRequestInfo rinfo = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::rinfo(this),
        _Internal::rinfo(this).GetCachedSize(), target, stream);
  }

  // optional .ei.ArtifactsClientInfo client_info = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::client_info(this),
        _Internal::client_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.MissionRequest)
  return target;
}

size_t MissionRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.MissionRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string ei_user_id = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ei_user_id());
    }

    // optional .ei.MissionInfo info = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *info_);
    }

    // optional .ei.BasicRequestInfo rinfo = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rinfo_);
    }

    // optional .ei.ArtifactsClientInfo client_info = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *client_info_);
    }

    // optional uint32 client_version = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_client_version());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MissionRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MissionRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MissionRequest::GetClassData() const { return &_class_data_; }

void MissionRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MissionRequest *>(to)->MergeFrom(
      static_cast<const MissionRequest &>(from));
}


void MissionRequest::MergeFrom(const MissionRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.MissionRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ei_user_id(from._internal_ei_user_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_info()->::ei::MissionInfo::MergeFrom(from._internal_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_rinfo()->::ei::BasicRequestInfo::MergeFrom(from._internal_rinfo());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_client_info()->::ei::ArtifactsClientInfo::MergeFrom(from._internal_client_info());
    }
    if (cached_has_bits & 0x00000010u) {
      client_version_ = from.client_version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MissionRequest::CopyFrom(const MissionRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.MissionRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MissionRequest::IsInitialized() const {
  return true;
}

void MissionRequest::InternalSwap(MissionRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ei_user_id_, lhs_arena,
      &other->ei_user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MissionRequest, client_version_)
      + sizeof(MissionRequest::client_version_)
      - PROTOBUF_FIELD_OFFSET(MissionRequest, info_)>(
          reinterpret_cast<char*>(&info_),
          reinterpret_cast<char*>(&other->info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MissionRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[129]);
}

// ===================================================================

class MissionResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<MissionResponse>()._has_bits_);
  static void set_has_success(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::ei::MissionInfo& info(const MissionResponse* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::ei::MissionInfo&
MissionResponse::_Internal::info(const MissionResponse* msg) {
  return *msg->info_;
}
MissionResponse::MissionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.MissionResponse)
}
MissionResponse::MissionResponse(const MissionResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_info()) {
    info_ = new ::ei::MissionInfo(*from.info_);
  } else {
    info_ = nullptr;
  }
  success_ = from.success_;
  // @@protoc_insertion_point(copy_constructor:ei.MissionResponse)
}

inline void MissionResponse::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&info_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&success_) -
    reinterpret_cast<char*>(&info_)) + sizeof(success_));
}

MissionResponse::~MissionResponse() {
  // @@protoc_insertion_point(destructor:ei.MissionResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MissionResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete info_;
}

void MissionResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MissionResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.MissionResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(info_ != nullptr);
    info_->Clear();
  }
  success_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MissionResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool success = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_success(&has_bits);
          success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.MissionInfo info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MissionResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.MissionResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool success = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_success(), target);
  }

  // optional .ei.MissionInfo info = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.MissionResponse)
  return target;
}

size_t MissionResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.MissionResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .ei.MissionInfo info = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *info_);
    }

    // optional bool success = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MissionResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MissionResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MissionResponse::GetClassData() const { return &_class_data_; }

void MissionResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MissionResponse *>(to)->MergeFrom(
      static_cast<const MissionResponse &>(from));
}


void MissionResponse::MergeFrom(const MissionResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.MissionResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_info()->::ei::MissionInfo::MergeFrom(from._internal_info());
    }
    if (cached_has_bits & 0x00000002u) {
      success_ = from.success_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MissionResponse::CopyFrom(const MissionResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.MissionResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MissionResponse::IsInitialized() const {
  return true;
}

void MissionResponse::InternalSwap(MissionResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MissionResponse, success_)
      + sizeof(MissionResponse::success_)
      - PROTOBUF_FIELD_OFFSET(MissionResponse, info_)>(
          reinterpret_cast<char*>(&info_),
          reinterpret_cast<char*>(&other->info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MissionResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[130]);
}

// ===================================================================

class CompleteMissionResponse_SecureArtifactSpec::_Internal {
 public:
  using HasBits = decltype(std::declval<CompleteMissionResponse_SecureArtifactSpec>()._has_bits_);
  static const ::ei::ArtifactSpec& spec(const CompleteMissionResponse_SecureArtifactSpec* msg);
  static void set_has_spec(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_server_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::ei::ArtifactSpec&
CompleteMissionResponse_SecureArtifactSpec::_Internal::spec(const CompleteMissionResponse_SecureArtifactSpec* msg) {
  return *msg->spec_;
}
CompleteMissionResponse_SecureArtifactSpec::CompleteMissionResponse_SecureArtifactSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.CompleteMissionResponse.SecureArtifactSpec)
}
CompleteMissionResponse_SecureArtifactSpec::CompleteMissionResponse_SecureArtifactSpec(const CompleteMissionResponse_SecureArtifactSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  server_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    server_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_server_id()) {
    server_id_.Set(from._internal_server_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_spec()) {
    spec_ = new ::ei::ArtifactSpec(*from.spec_);
  } else {
    spec_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:ei.CompleteMissionResponse.SecureArtifactSpec)
}

inline void CompleteMissionResponse_SecureArtifactSpec::SharedCtor() {
server_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  server_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
spec_ = nullptr;
}

CompleteMissionResponse_SecureArtifactSpec::~CompleteMissionResponse_SecureArtifactSpec() {
  // @@protoc_insertion_point(destructor:ei.CompleteMissionResponse.SecureArtifactSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CompleteMissionResponse_SecureArtifactSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  server_id_.Destroy();
  if (this != internal_default_instance()) delete spec_;
}

void CompleteMissionResponse_SecureArtifactSpec::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CompleteMissionResponse_SecureArtifactSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.CompleteMissionResponse.SecureArtifactSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      server_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(spec_ != nullptr);
      spec_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CompleteMissionResponse_SecureArtifactSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.ArtifactSpec spec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string server_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_server_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.CompleteMissionResponse.SecureArtifactSpec.server_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CompleteMissionResponse_SecureArtifactSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.CompleteMissionResponse.SecureArtifactSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.ArtifactSpec spec = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::spec(this),
        _Internal::spec(this).GetCachedSize(), target, stream);
  }

  // optional string server_id = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_server_id().data(), static_cast<int>(this->_internal_server_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.CompleteMissionResponse.SecureArtifactSpec.server_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_server_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.CompleteMissionResponse.SecureArtifactSpec)
  return target;
}

size_t CompleteMissionResponse_SecureArtifactSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.CompleteMissionResponse.SecureArtifactSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string server_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_server_id());
    }

    // optional .ei.ArtifactSpec spec = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *spec_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CompleteMissionResponse_SecureArtifactSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CompleteMissionResponse_SecureArtifactSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CompleteMissionResponse_SecureArtifactSpec::GetClassData() const { return &_class_data_; }

void CompleteMissionResponse_SecureArtifactSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CompleteMissionResponse_SecureArtifactSpec *>(to)->MergeFrom(
      static_cast<const CompleteMissionResponse_SecureArtifactSpec &>(from));
}


void CompleteMissionResponse_SecureArtifactSpec::MergeFrom(const CompleteMissionResponse_SecureArtifactSpec& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.CompleteMissionResponse.SecureArtifactSpec)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_server_id(from._internal_server_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_spec()->::ei::ArtifactSpec::MergeFrom(from._internal_spec());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CompleteMissionResponse_SecureArtifactSpec::CopyFrom(const CompleteMissionResponse_SecureArtifactSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.CompleteMissionResponse.SecureArtifactSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CompleteMissionResponse_SecureArtifactSpec::IsInitialized() const {
  return true;
}

void CompleteMissionResponse_SecureArtifactSpec::InternalSwap(CompleteMissionResponse_SecureArtifactSpec* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &server_id_, lhs_arena,
      &other->server_id_, rhs_arena
  );
  swap(spec_, other->spec_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CompleteMissionResponse_SecureArtifactSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[131]);
}

// ===================================================================

class CompleteMissionResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CompleteMissionResponse>()._has_bits_);
  static void set_has_success(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::ei::MissionInfo& info(const CompleteMissionResponse* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ei_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::ei::MissionInfo&
CompleteMissionResponse::_Internal::info(const CompleteMissionResponse* msg) {
  return *msg->info_;
}
CompleteMissionResponse::CompleteMissionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  artifacts_(arena),
  other_rewards_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.CompleteMissionResponse)
}
CompleteMissionResponse::CompleteMissionResponse(const CompleteMissionResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      artifacts_(from.artifacts_),
      other_rewards_(from.other_rewards_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ei_user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ei_user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ei_user_id()) {
    ei_user_id_.Set(from._internal_ei_user_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_info()) {
    info_ = new ::ei::MissionInfo(*from.info_);
  } else {
    info_ = nullptr;
  }
  success_ = from.success_;
  // @@protoc_insertion_point(copy_constructor:ei.CompleteMissionResponse)
}

inline void CompleteMissionResponse::SharedCtor() {
ei_user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ei_user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&info_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&success_) -
    reinterpret_cast<char*>(&info_)) + sizeof(success_));
}

CompleteMissionResponse::~CompleteMissionResponse() {
  // @@protoc_insertion_point(destructor:ei.CompleteMissionResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CompleteMissionResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ei_user_id_.Destroy();
  if (this != internal_default_instance()) delete info_;
}

void CompleteMissionResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CompleteMissionResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.CompleteMissionResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  artifacts_.Clear();
  other_rewards_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ei_user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(info_ != nullptr);
      info_->Clear();
    }
  }
  success_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CompleteMissionResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool success = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_success(&has_bits);
          success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.MissionInfo info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.CompleteMissionResponse.SecureArtifactSpec artifacts = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_artifacts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.Reward other_rewards = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_other_rewards(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string ei_user_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_ei_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.CompleteMissionResponse.ei_user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CompleteMissionResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.CompleteMissionResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool success = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_success(), target);
  }

  // optional .ei.MissionInfo info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  // repeated .ei.CompleteMissionResponse.SecureArtifactSpec artifacts = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_artifacts_size()); i < n; i++) {
    const auto& repfield = this->_internal_artifacts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .ei.Reward other_rewards = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_other_rewards_size()); i < n; i++) {
    const auto& repfield = this->_internal_other_rewards(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string ei_user_id = 5;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ei_user_id().data(), static_cast<int>(this->_internal_ei_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.CompleteMissionResponse.ei_user_id");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_ei_user_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.CompleteMissionResponse)
  return target;
}

size_t CompleteMissionResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.CompleteMissionResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.CompleteMissionResponse.SecureArtifactSpec artifacts = 3;
  total_size += 1UL * this->_internal_artifacts_size();
  for (const auto& msg : this->artifacts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.Reward other_rewards = 4;
  total_size += 1UL * this->_internal_other_rewards_size();
  for (const auto& msg : this->other_rewards_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string ei_user_id = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ei_user_id());
    }

    // optional .ei.MissionInfo info = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *info_);
    }

    // optional bool success = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CompleteMissionResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CompleteMissionResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CompleteMissionResponse::GetClassData() const { return &_class_data_; }

void CompleteMissionResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CompleteMissionResponse *>(to)->MergeFrom(
      static_cast<const CompleteMissionResponse &>(from));
}


void CompleteMissionResponse::MergeFrom(const CompleteMissionResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.CompleteMissionResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  artifacts_.MergeFrom(from.artifacts_);
  other_rewards_.MergeFrom(from.other_rewards_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ei_user_id(from._internal_ei_user_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_info()->::ei::MissionInfo::MergeFrom(from._internal_info());
    }
    if (cached_has_bits & 0x00000004u) {
      success_ = from.success_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CompleteMissionResponse::CopyFrom(const CompleteMissionResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.CompleteMissionResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CompleteMissionResponse::IsInitialized() const {
  return true;
}

void CompleteMissionResponse::InternalSwap(CompleteMissionResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  artifacts_.InternalSwap(&other->artifacts_);
  other_rewards_.InternalSwap(&other->other_rewards_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ei_user_id_, lhs_arena,
      &other->ei_user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CompleteMissionResponse, success_)
      + sizeof(CompleteMissionResponse::success_)
      - PROTOBUF_FIELD_OFFSET(CompleteMissionResponse, info_)>(
          reinterpret_cast<char*>(&info_),
          reinterpret_cast<char*>(&other->info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CompleteMissionResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[132]);
}

// ===================================================================

class CollectContractArtifactRewardsRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CollectContractArtifactRewardsRequest>()._has_bits_);
  static const ::ei::BasicRequestInfo& rinfo(const CollectContractArtifactRewardsRequest* msg);
  static void set_has_rinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_contract_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_league(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_grade(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_goal_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_best_ship(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::ei::BasicRequestInfo&
CollectContractArtifactRewardsRequest::_Internal::rinfo(const CollectContractArtifactRewardsRequest* msg) {
  return *msg->rinfo_;
}
CollectContractArtifactRewardsRequest::CollectContractArtifactRewardsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.CollectContractArtifactRewardsRequest)
}
CollectContractArtifactRewardsRequest::CollectContractArtifactRewardsRequest(const CollectContractArtifactRewardsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  contract_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    contract_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contract_identifier()) {
    contract_identifier_.Set(from._internal_contract_identifier(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_rinfo()) {
    rinfo_ = new ::ei::BasicRequestInfo(*from.rinfo_);
  } else {
    rinfo_ = nullptr;
  }
  ::memcpy(&goal_index_, &from.goal_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&grade_) -
    reinterpret_cast<char*>(&goal_index_)) + sizeof(grade_));
  // @@protoc_insertion_point(copy_constructor:ei.CollectContractArtifactRewardsRequest)
}

inline void CollectContractArtifactRewardsRequest::SharedCtor() {
contract_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  contract_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rinfo_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&grade_) -
    reinterpret_cast<char*>(&rinfo_)) + sizeof(grade_));
}

CollectContractArtifactRewardsRequest::~CollectContractArtifactRewardsRequest() {
  // @@protoc_insertion_point(destructor:ei.CollectContractArtifactRewardsRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CollectContractArtifactRewardsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  contract_identifier_.Destroy();
  if (this != internal_default_instance()) delete rinfo_;
}

void CollectContractArtifactRewardsRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CollectContractArtifactRewardsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.CollectContractArtifactRewardsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      contract_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(rinfo_ != nullptr);
      rinfo_->Clear();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&goal_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&grade_) -
        reinterpret_cast<char*>(&goal_index_)) + sizeof(grade_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CollectContractArtifactRewardsRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.BasicRequestInfo rinfo = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_rinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string contract_identifier = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_contract_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.CollectContractArtifactRewardsRequest.contract_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 goal_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_goal_index(&has_bits);
          goal_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.MissionInfo.Spaceship best_ship = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::MissionInfo_Spaceship_IsValid(val))) {
            _internal_set_best_ship(static_cast<::ei::MissionInfo_Spaceship>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 league = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_league(&has_bits);
          league_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.Contract.PlayerGrade grade = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::Contract_PlayerGrade_IsValid(val))) {
            _internal_set_grade(static_cast<::ei::Contract_PlayerGrade>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CollectContractArtifactRewardsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.CollectContractArtifactRewardsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.BasicRequestInfo rinfo = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::rinfo(this),
        _Internal::rinfo(this).GetCachedSize(), target, stream);
  }

  // optional string contract_identifier = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_contract_identifier().data(), static_cast<int>(this->_internal_contract_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.CollectContractArtifactRewardsRequest.contract_identifier");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_contract_identifier(), target);
  }

  // optional uint32 goal_index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_goal_index(), target);
  }

  // optional .ei.MissionInfo.Spaceship best_ship = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_best_ship(), target);
  }

  // optional uint32 league = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_league(), target);
  }

  // optional .ei.Contract.PlayerGrade grade = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_grade(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.CollectContractArtifactRewardsRequest)
  return target;
}

size_t CollectContractArtifactRewardsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.CollectContractArtifactRewardsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string contract_identifier = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contract_identifier());
    }

    // optional .ei.BasicRequestInfo rinfo = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rinfo_);
    }

    // optional uint32 goal_index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_goal_index());
    }

    // optional .ei.MissionInfo.Spaceship best_ship = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_best_ship());
    }

    // optional uint32 league = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_league());
    }

    // optional .ei.Contract.PlayerGrade grade = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_grade());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CollectContractArtifactRewardsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CollectContractArtifactRewardsRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CollectContractArtifactRewardsRequest::GetClassData() const { return &_class_data_; }

void CollectContractArtifactRewardsRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CollectContractArtifactRewardsRequest *>(to)->MergeFrom(
      static_cast<const CollectContractArtifactRewardsRequest &>(from));
}


void CollectContractArtifactRewardsRequest::MergeFrom(const CollectContractArtifactRewardsRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.CollectContractArtifactRewardsRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_contract_identifier(from._internal_contract_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_rinfo()->::ei::BasicRequestInfo::MergeFrom(from._internal_rinfo());
    }
    if (cached_has_bits & 0x00000004u) {
      goal_index_ = from.goal_index_;
    }
    if (cached_has_bits & 0x00000008u) {
      best_ship_ = from.best_ship_;
    }
    if (cached_has_bits & 0x00000010u) {
      league_ = from.league_;
    }
    if (cached_has_bits & 0x00000020u) {
      grade_ = from.grade_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CollectContractArtifactRewardsRequest::CopyFrom(const CollectContractArtifactRewardsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.CollectContractArtifactRewardsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CollectContractArtifactRewardsRequest::IsInitialized() const {
  return true;
}

void CollectContractArtifactRewardsRequest::InternalSwap(CollectContractArtifactRewardsRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &contract_identifier_, lhs_arena,
      &other->contract_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CollectContractArtifactRewardsRequest, grade_)
      + sizeof(CollectContractArtifactRewardsRequest::grade_)
      - PROTOBUF_FIELD_OFFSET(CollectContractArtifactRewardsRequest, rinfo_)>(
          reinterpret_cast<char*>(&rinfo_),
          reinterpret_cast<char*>(&other->rinfo_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CollectContractArtifactRewardsRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[133]);
}

// ===================================================================

class CraftArtifactRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CraftArtifactRequest>()._has_bits_);
  static const ::ei::BasicRequestInfo& rinfo(const CraftArtifactRequest* msg);
  static void set_has_rinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ei_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ei::ArtifactSpec& spec(const CraftArtifactRequest* msg);
  static void set_has_spec(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gold_price_paid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_crafting_count(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_crafting_xp(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::ei::BasicRequestInfo&
CraftArtifactRequest::_Internal::rinfo(const CraftArtifactRequest* msg) {
  return *msg->rinfo_;
}
const ::ei::ArtifactSpec&
CraftArtifactRequest::_Internal::spec(const CraftArtifactRequest* msg) {
  return *msg->spec_;
}
CraftArtifactRequest::CraftArtifactRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  ingredients_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.CraftArtifactRequest)
}
CraftArtifactRequest::CraftArtifactRequest(const CraftArtifactRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      ingredients_(from.ingredients_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ei_user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ei_user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ei_user_id()) {
    ei_user_id_.Set(from._internal_ei_user_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_spec()) {
    spec_ = new ::ei::ArtifactSpec(*from.spec_);
  } else {
    spec_ = nullptr;
  }
  if (from._internal_has_rinfo()) {
    rinfo_ = new ::ei::BasicRequestInfo(*from.rinfo_);
  } else {
    rinfo_ = nullptr;
  }
  ::memcpy(&item_id_, &from.item_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&crafting_count_) -
    reinterpret_cast<char*>(&item_id_)) + sizeof(crafting_count_));
  // @@protoc_insertion_point(copy_constructor:ei.CraftArtifactRequest)
}

inline void CraftArtifactRequest::SharedCtor() {
ei_user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ei_user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&spec_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&crafting_count_) -
    reinterpret_cast<char*>(&spec_)) + sizeof(crafting_count_));
}

CraftArtifactRequest::~CraftArtifactRequest() {
  // @@protoc_insertion_point(destructor:ei.CraftArtifactRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CraftArtifactRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ei_user_id_.Destroy();
  if (this != internal_default_instance()) delete spec_;
  if (this != internal_default_instance()) delete rinfo_;
}

void CraftArtifactRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CraftArtifactRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.CraftArtifactRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ingredients_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ei_user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(spec_ != nullptr);
      spec_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(rinfo_ != nullptr);
      rinfo_->Clear();
    }
  }
  if (cached_has_bits & 0x00000078u) {
    ::memset(&item_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&crafting_count_) -
        reinterpret_cast<char*>(&item_id_)) + sizeof(crafting_count_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CraftArtifactRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string ei_user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ei_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.CraftArtifactRequest.ei_user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .ei.ArtifactSpec spec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 item_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_item_id(&has_bits);
          item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ArtifactInventoryItem ingredients = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ingredients(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .ei.BasicRequestInfo rinfo = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_rinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double gold_price_paid = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_gold_price_paid(&has_bits);
          gold_price_paid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 crafting_count = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_crafting_count(&has_bits);
          crafting_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double crafting_xp = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _Internal::set_has_crafting_xp(&has_bits);
          crafting_xp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CraftArtifactRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.CraftArtifactRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string ei_user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ei_user_id().data(), static_cast<int>(this->_internal_ei_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.CraftArtifactRequest.ei_user_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ei_user_id(), target);
  }

  // optional .ei.ArtifactSpec spec = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::spec(this),
        _Internal::spec(this).GetCachedSize(), target, stream);
  }

  // optional uint64 item_id = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_item_id(), target);
  }

  // repeated .ei.ArtifactInventoryItem ingredients = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ingredients_size()); i < n; i++) {
    const auto& repfield = this->_internal_ingredients(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .ei.BasicRequestInfo rinfo = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::rinfo(this),
        _Internal::rinfo(this).GetCachedSize(), target, stream);
  }

  // optional double gold_price_paid = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_gold_price_paid(), target);
  }

  // optional uint32 crafting_count = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_crafting_count(), target);
  }

  // optional double crafting_xp = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_crafting_xp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.CraftArtifactRequest)
  return target;
}

size_t CraftArtifactRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.CraftArtifactRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.ArtifactInventoryItem ingredients = 4;
  total_size += 1UL * this->_internal_ingredients_size();
  for (const auto& msg : this->ingredients_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string ei_user_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ei_user_id());
    }

    // optional .ei.ArtifactSpec spec = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *spec_);
    }

    // optional .ei.BasicRequestInfo rinfo = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rinfo_);
    }

    // optional uint64 item_id = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_item_id());
    }

    // optional double gold_price_paid = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double crafting_xp = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional uint32 crafting_count = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_crafting_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CraftArtifactRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CraftArtifactRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CraftArtifactRequest::GetClassData() const { return &_class_data_; }

void CraftArtifactRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CraftArtifactRequest *>(to)->MergeFrom(
      static_cast<const CraftArtifactRequest &>(from));
}


void CraftArtifactRequest::MergeFrom(const CraftArtifactRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.CraftArtifactRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  ingredients_.MergeFrom(from.ingredients_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ei_user_id(from._internal_ei_user_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_spec()->::ei::ArtifactSpec::MergeFrom(from._internal_spec());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_rinfo()->::ei::BasicRequestInfo::MergeFrom(from._internal_rinfo());
    }
    if (cached_has_bits & 0x00000008u) {
      item_id_ = from.item_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      gold_price_paid_ = from.gold_price_paid_;
    }
    if (cached_has_bits & 0x00000020u) {
      crafting_xp_ = from.crafting_xp_;
    }
    if (cached_has_bits & 0x00000040u) {
      crafting_count_ = from.crafting_count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CraftArtifactRequest::CopyFrom(const CraftArtifactRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.CraftArtifactRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CraftArtifactRequest::IsInitialized() const {
  return true;
}

void CraftArtifactRequest::InternalSwap(CraftArtifactRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ingredients_.InternalSwap(&other->ingredients_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ei_user_id_, lhs_arena,
      &other->ei_user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CraftArtifactRequest, crafting_count_)
      + sizeof(CraftArtifactRequest::crafting_count_)
      - PROTOBUF_FIELD_OFFSET(CraftArtifactRequest, spec_)>(
          reinterpret_cast<char*>(&spec_),
          reinterpret_cast<char*>(&other->spec_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CraftArtifactRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[134]);
}

// ===================================================================

class CraftArtifactResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CraftArtifactResponse>()._has_bits_);
  static void set_has_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ei_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_rarity_achieved(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_server_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CraftArtifactResponse::CraftArtifactResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.CraftArtifactResponse)
}
CraftArtifactResponse::CraftArtifactResponse(const CraftArtifactResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  server_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    server_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_server_id()) {
    server_id_.Set(from._internal_server_id(), 
      GetArenaForAllocation());
  }
  ei_user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ei_user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ei_user_id()) {
    ei_user_id_.Set(from._internal_ei_user_id(), 
      GetArenaForAllocation());
  }
  ::memcpy(&item_id_, &from.item_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&rarity_achieved_) -
    reinterpret_cast<char*>(&item_id_)) + sizeof(rarity_achieved_));
  // @@protoc_insertion_point(copy_constructor:ei.CraftArtifactResponse)
}

inline void CraftArtifactResponse::SharedCtor() {
server_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  server_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
ei_user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ei_user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&item_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&rarity_achieved_) -
    reinterpret_cast<char*>(&item_id_)) + sizeof(rarity_achieved_));
}

CraftArtifactResponse::~CraftArtifactResponse() {
  // @@protoc_insertion_point(destructor:ei.CraftArtifactResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CraftArtifactResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  server_id_.Destroy();
  ei_user_id_.Destroy();
}

void CraftArtifactResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CraftArtifactResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.CraftArtifactResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      server_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ei_user_id_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&item_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&rarity_achieved_) -
        reinterpret_cast<char*>(&item_id_)) + sizeof(rarity_achieved_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CraftArtifactResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 item_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_item_id(&has_bits);
          item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.ArtifactSpec.Rarity rarity_achieved = 2 [default = COMMON];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::ArtifactSpec_Rarity_IsValid(val))) {
            _internal_set_rarity_achieved(static_cast<::ei::ArtifactSpec_Rarity>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string server_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_server_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.CraftArtifactResponse.server_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string ei_user_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_ei_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.CraftArtifactResponse.ei_user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CraftArtifactResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.CraftArtifactResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 item_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_item_id(), target);
  }

  // optional .ei.ArtifactSpec.Rarity rarity_achieved = 2 [default = COMMON];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_rarity_achieved(), target);
  }

  // optional string server_id = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_server_id().data(), static_cast<int>(this->_internal_server_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.CraftArtifactResponse.server_id");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_server_id(), target);
  }

  // optional string ei_user_id = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ei_user_id().data(), static_cast<int>(this->_internal_ei_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.CraftArtifactResponse.ei_user_id");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_ei_user_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.CraftArtifactResponse)
  return target;
}

size_t CraftArtifactResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.CraftArtifactResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string server_id = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_server_id());
    }

    // optional string ei_user_id = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ei_user_id());
    }

    // optional uint64 item_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_item_id());
    }

    // optional .ei.ArtifactSpec.Rarity rarity_achieved = 2 [default = COMMON];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_rarity_achieved());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CraftArtifactResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CraftArtifactResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CraftArtifactResponse::GetClassData() const { return &_class_data_; }

void CraftArtifactResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CraftArtifactResponse *>(to)->MergeFrom(
      static_cast<const CraftArtifactResponse &>(from));
}


void CraftArtifactResponse::MergeFrom(const CraftArtifactResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.CraftArtifactResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_server_id(from._internal_server_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_ei_user_id(from._internal_ei_user_id());
    }
    if (cached_has_bits & 0x00000004u) {
      item_id_ = from.item_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      rarity_achieved_ = from.rarity_achieved_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CraftArtifactResponse::CopyFrom(const CraftArtifactResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.CraftArtifactResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CraftArtifactResponse::IsInitialized() const {
  return true;
}

void CraftArtifactResponse::InternalSwap(CraftArtifactResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &server_id_, lhs_arena,
      &other->server_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ei_user_id_, lhs_arena,
      &other->ei_user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CraftArtifactResponse, rarity_achieved_)
      + sizeof(CraftArtifactResponse::rarity_achieved_)
      - PROTOBUF_FIELD_OFFSET(CraftArtifactResponse, item_id_)>(
          reinterpret_cast<char*>(&item_id_),
          reinterpret_cast<char*>(&other->item_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CraftArtifactResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[135]);
}

// ===================================================================

class ConsumeArtifactRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ConsumeArtifactRequest>()._has_bits_);
  static const ::ei::BasicRequestInfo& rinfo(const ConsumeArtifactRequest* msg);
  static void set_has_rinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ei_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ei::ArtifactSpec& spec(const ConsumeArtifactRequest* msg);
  static void set_has_spec(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_artifact_server_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_original_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_quantity(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::ei::BasicRequestInfo&
ConsumeArtifactRequest::_Internal::rinfo(const ConsumeArtifactRequest* msg) {
  return *msg->rinfo_;
}
const ::ei::ArtifactSpec&
ConsumeArtifactRequest::_Internal::spec(const ConsumeArtifactRequest* msg) {
  return *msg->spec_;
}
ConsumeArtifactRequest::ConsumeArtifactRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  additional_server_ids_(arena),
  additional_item_ids_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ConsumeArtifactRequest)
}
ConsumeArtifactRequest::ConsumeArtifactRequest(const ConsumeArtifactRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      additional_server_ids_(from.additional_server_ids_),
      additional_item_ids_(from.additional_item_ids_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ei_user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ei_user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ei_user_id()) {
    ei_user_id_.Set(from._internal_ei_user_id(), 
      GetArenaForAllocation());
  }
  artifact_server_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    artifact_server_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_artifact_server_id()) {
    artifact_server_id_.Set(from._internal_artifact_server_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_spec()) {
    spec_ = new ::ei::ArtifactSpec(*from.spec_);
  } else {
    spec_ = nullptr;
  }
  if (from._internal_has_rinfo()) {
    rinfo_ = new ::ei::BasicRequestInfo(*from.rinfo_);
  } else {
    rinfo_ = nullptr;
  }
  ::memcpy(&original_item_id_, &from.original_item_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&quantity_) -
    reinterpret_cast<char*>(&original_item_id_)) + sizeof(quantity_));
  // @@protoc_insertion_point(copy_constructor:ei.ConsumeArtifactRequest)
}

inline void ConsumeArtifactRequest::SharedCtor() {
ei_user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ei_user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
artifact_server_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  artifact_server_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&spec_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&quantity_) -
    reinterpret_cast<char*>(&spec_)) + sizeof(quantity_));
}

ConsumeArtifactRequest::~ConsumeArtifactRequest() {
  // @@protoc_insertion_point(destructor:ei.ConsumeArtifactRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConsumeArtifactRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ei_user_id_.Destroy();
  artifact_server_id_.Destroy();
  if (this != internal_default_instance()) delete spec_;
  if (this != internal_default_instance()) delete rinfo_;
}

void ConsumeArtifactRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ConsumeArtifactRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ConsumeArtifactRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  additional_server_ids_.Clear();
  additional_item_ids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      ei_user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      artifact_server_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(spec_ != nullptr);
      spec_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(rinfo_ != nullptr);
      rinfo_->Clear();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    ::memset(&original_item_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&quantity_) -
        reinterpret_cast<char*>(&original_item_id_)) + sizeof(quantity_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConsumeArtifactRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.ArtifactSpec spec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 original_item_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_original_item_id(&has_bits);
          original_item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string ei_user_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_ei_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ConsumeArtifactRequest.ei_user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .ei.BasicRequestInfo rinfo = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_rinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string artifact_server_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_artifact_server_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ConsumeArtifactRequest.artifact_server_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 quantity = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_quantity(&has_bits);
          quantity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string additional_server_ids = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_additional_server_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "ei.ConsumeArtifactRequest.additional_server_ids");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 additional_item_ids = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_additional_item_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<64>(ptr));
        } else if (static_cast<uint8_t>(tag) == 66) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_additional_item_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConsumeArtifactRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ConsumeArtifactRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.ArtifactSpec spec = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::spec(this),
        _Internal::spec(this).GetCachedSize(), target, stream);
  }

  // optional uint64 original_item_id = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_original_item_id(), target);
  }

  // optional string ei_user_id = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ei_user_id().data(), static_cast<int>(this->_internal_ei_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ConsumeArtifactRequest.ei_user_id");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_ei_user_id(), target);
  }

  // optional .ei.BasicRequestInfo rinfo = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::rinfo(this),
        _Internal::rinfo(this).GetCachedSize(), target, stream);
  }

  // optional string artifact_server_id = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_artifact_server_id().data(), static_cast<int>(this->_internal_artifact_server_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ConsumeArtifactRequest.artifact_server_id");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_artifact_server_id(), target);
  }

  // optional uint32 quantity = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_quantity(), target);
  }

  // repeated string additional_server_ids = 7;
  for (int i = 0, n = this->_internal_additional_server_ids_size(); i < n; i++) {
    const auto& s = this->_internal_additional_server_ids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ConsumeArtifactRequest.additional_server_ids");
    target = stream->WriteString(7, s, target);
  }

  // repeated uint64 additional_item_ids = 8;
  for (int i = 0, n = this->_internal_additional_item_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_additional_item_ids(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ConsumeArtifactRequest)
  return target;
}

size_t ConsumeArtifactRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ConsumeArtifactRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string additional_server_ids = 7;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(additional_server_ids_.size());
  for (int i = 0, n = additional_server_ids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      additional_server_ids_.Get(i));
  }

  // repeated uint64 additional_item_ids = 8;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->additional_item_ids_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_additional_item_ids_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string ei_user_id = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ei_user_id());
    }

    // optional string artifact_server_id = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_artifact_server_id());
    }

    // optional .ei.ArtifactSpec spec = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *spec_);
    }

    // optional .ei.BasicRequestInfo rinfo = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rinfo_);
    }

    // optional uint64 original_item_id = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_original_item_id());
    }

    // optional uint32 quantity = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_quantity());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConsumeArtifactRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ConsumeArtifactRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConsumeArtifactRequest::GetClassData() const { return &_class_data_; }

void ConsumeArtifactRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ConsumeArtifactRequest *>(to)->MergeFrom(
      static_cast<const ConsumeArtifactRequest &>(from));
}


void ConsumeArtifactRequest::MergeFrom(const ConsumeArtifactRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ConsumeArtifactRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  additional_server_ids_.MergeFrom(from.additional_server_ids_);
  additional_item_ids_.MergeFrom(from.additional_item_ids_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ei_user_id(from._internal_ei_user_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_artifact_server_id(from._internal_artifact_server_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_spec()->::ei::ArtifactSpec::MergeFrom(from._internal_spec());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_rinfo()->::ei::BasicRequestInfo::MergeFrom(from._internal_rinfo());
    }
    if (cached_has_bits & 0x00000010u) {
      original_item_id_ = from.original_item_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      quantity_ = from.quantity_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConsumeArtifactRequest::CopyFrom(const ConsumeArtifactRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ConsumeArtifactRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConsumeArtifactRequest::IsInitialized() const {
  return true;
}

void ConsumeArtifactRequest::InternalSwap(ConsumeArtifactRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  additional_server_ids_.InternalSwap(&other->additional_server_ids_);
  additional_item_ids_.InternalSwap(&other->additional_item_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ei_user_id_, lhs_arena,
      &other->ei_user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &artifact_server_id_, lhs_arena,
      &other->artifact_server_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConsumeArtifactRequest, quantity_)
      + sizeof(ConsumeArtifactRequest::quantity_)
      - PROTOBUF_FIELD_OFFSET(ConsumeArtifactRequest, spec_)>(
          reinterpret_cast<char*>(&spec_),
          reinterpret_cast<char*>(&other->spec_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ConsumeArtifactRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[136]);
}

// ===================================================================

class ConsumeArtifactResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<ConsumeArtifactResponse>()._has_bits_);
  static void set_has_success(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_original_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ei_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ConsumeArtifactResponse::ConsumeArtifactResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  byproducts_(arena),
  other_rewards_(arena),
  additional_item_ids_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ConsumeArtifactResponse)
}
ConsumeArtifactResponse::ConsumeArtifactResponse(const ConsumeArtifactResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      byproducts_(from.byproducts_),
      other_rewards_(from.other_rewards_),
      additional_item_ids_(from.additional_item_ids_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ei_user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ei_user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ei_user_id()) {
    ei_user_id_.Set(from._internal_ei_user_id(), 
      GetArenaForAllocation());
  }
  ::memcpy(&original_item_id_, &from.original_item_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&success_) -
    reinterpret_cast<char*>(&original_item_id_)) + sizeof(success_));
  // @@protoc_insertion_point(copy_constructor:ei.ConsumeArtifactResponse)
}

inline void ConsumeArtifactResponse::SharedCtor() {
ei_user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ei_user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&original_item_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&success_) -
    reinterpret_cast<char*>(&original_item_id_)) + sizeof(success_));
}

ConsumeArtifactResponse::~ConsumeArtifactResponse() {
  // @@protoc_insertion_point(destructor:ei.ConsumeArtifactResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConsumeArtifactResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ei_user_id_.Destroy();
}

void ConsumeArtifactResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ConsumeArtifactResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ConsumeArtifactResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  byproducts_.Clear();
  other_rewards_.Clear();
  additional_item_ids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ei_user_id_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&original_item_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&success_) -
        reinterpret_cast<char*>(&original_item_id_)) + sizeof(success_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConsumeArtifactResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool success = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_success(&has_bits);
          success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 original_item_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_original_item_id(&has_bits);
          original_item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ArtifactSpec byproducts = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_byproducts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.Reward other_rewards = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_other_rewards(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string ei_user_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_ei_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ConsumeArtifactResponse.ei_user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 additional_item_ids = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_additional_item_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<uint8_t>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_additional_item_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConsumeArtifactResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ConsumeArtifactResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool success = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_success(), target);
  }

  // optional uint64 original_item_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_original_item_id(), target);
  }

  // repeated .ei.ArtifactSpec byproducts = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_byproducts_size()); i < n; i++) {
    const auto& repfield = this->_internal_byproducts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .ei.Reward other_rewards = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_other_rewards_size()); i < n; i++) {
    const auto& repfield = this->_internal_other_rewards(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string ei_user_id = 5;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ei_user_id().data(), static_cast<int>(this->_internal_ei_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ConsumeArtifactResponse.ei_user_id");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_ei_user_id(), target);
  }

  // repeated uint64 additional_item_ids = 6;
  for (int i = 0, n = this->_internal_additional_item_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_additional_item_ids(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ConsumeArtifactResponse)
  return target;
}

size_t ConsumeArtifactResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ConsumeArtifactResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.ArtifactSpec byproducts = 3;
  total_size += 1UL * this->_internal_byproducts_size();
  for (const auto& msg : this->byproducts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.Reward other_rewards = 4;
  total_size += 1UL * this->_internal_other_rewards_size();
  for (const auto& msg : this->other_rewards_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint64 additional_item_ids = 6;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->additional_item_ids_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_additional_item_ids_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string ei_user_id = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ei_user_id());
    }

    // optional uint64 original_item_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_original_item_id());
    }

    // optional bool success = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConsumeArtifactResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ConsumeArtifactResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConsumeArtifactResponse::GetClassData() const { return &_class_data_; }

void ConsumeArtifactResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ConsumeArtifactResponse *>(to)->MergeFrom(
      static_cast<const ConsumeArtifactResponse &>(from));
}


void ConsumeArtifactResponse::MergeFrom(const ConsumeArtifactResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ConsumeArtifactResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  byproducts_.MergeFrom(from.byproducts_);
  other_rewards_.MergeFrom(from.other_rewards_);
  additional_item_ids_.MergeFrom(from.additional_item_ids_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ei_user_id(from._internal_ei_user_id());
    }
    if (cached_has_bits & 0x00000002u) {
      original_item_id_ = from.original_item_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      success_ = from.success_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConsumeArtifactResponse::CopyFrom(const ConsumeArtifactResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ConsumeArtifactResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConsumeArtifactResponse::IsInitialized() const {
  return true;
}

void ConsumeArtifactResponse::InternalSwap(ConsumeArtifactResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  byproducts_.InternalSwap(&other->byproducts_);
  other_rewards_.InternalSwap(&other->other_rewards_);
  additional_item_ids_.InternalSwap(&other->additional_item_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ei_user_id_, lhs_arena,
      &other->ei_user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConsumeArtifactResponse, success_)
      + sizeof(ConsumeArtifactResponse::success_)
      - PROTOBUF_FIELD_OFFSET(ConsumeArtifactResponse, original_item_id_)>(
          reinterpret_cast<char*>(&original_item_id_),
          reinterpret_cast<char*>(&other->original_item_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ConsumeArtifactResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[137]);
}

// ===================================================================

class AuthenticateArtifactResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<AuthenticateArtifactResponse>()._has_bits_);
  static void set_has_success(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_original_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_demote(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_delete_(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ei_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

AuthenticateArtifactResponse::AuthenticateArtifactResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.AuthenticateArtifactResponse)
}
AuthenticateArtifactResponse::AuthenticateArtifactResponse(const AuthenticateArtifactResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ei_user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ei_user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ei_user_id()) {
    ei_user_id_.Set(from._internal_ei_user_id(), 
      GetArenaForAllocation());
  }
  ::memcpy(&original_item_id_, &from.original_item_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&delete__) -
    reinterpret_cast<char*>(&original_item_id_)) + sizeof(delete__));
  // @@protoc_insertion_point(copy_constructor:ei.AuthenticateArtifactResponse)
}

inline void AuthenticateArtifactResponse::SharedCtor() {
ei_user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ei_user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&original_item_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&delete__) -
    reinterpret_cast<char*>(&original_item_id_)) + sizeof(delete__));
}

AuthenticateArtifactResponse::~AuthenticateArtifactResponse() {
  // @@protoc_insertion_point(destructor:ei.AuthenticateArtifactResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthenticateArtifactResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ei_user_id_.Destroy();
}

void AuthenticateArtifactResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AuthenticateArtifactResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.AuthenticateArtifactResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ei_user_id_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&original_item_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&delete__) -
        reinterpret_cast<char*>(&original_item_id_)) + sizeof(delete__));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthenticateArtifactResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool success = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_success(&has_bits);
          success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 original_item_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_original_item_id(&has_bits);
          original_item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool demote = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_demote(&has_bits);
          demote_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool delete = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_delete_(&has_bits);
          delete__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string ei_user_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_ei_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AuthenticateArtifactResponse.ei_user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AuthenticateArtifactResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.AuthenticateArtifactResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool success = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_success(), target);
  }

  // optional uint64 original_item_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_original_item_id(), target);
  }

  // optional bool demote = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_demote(), target);
  }

  // optional bool delete = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_delete_(), target);
  }

  // optional string ei_user_id = 5;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ei_user_id().data(), static_cast<int>(this->_internal_ei_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AuthenticateArtifactResponse.ei_user_id");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_ei_user_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.AuthenticateArtifactResponse)
  return target;
}

size_t AuthenticateArtifactResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.AuthenticateArtifactResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string ei_user_id = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ei_user_id());
    }

    // optional uint64 original_item_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_original_item_id());
    }

    // optional bool success = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool demote = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool delete = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthenticateArtifactResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AuthenticateArtifactResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthenticateArtifactResponse::GetClassData() const { return &_class_data_; }

void AuthenticateArtifactResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AuthenticateArtifactResponse *>(to)->MergeFrom(
      static_cast<const AuthenticateArtifactResponse &>(from));
}


void AuthenticateArtifactResponse::MergeFrom(const AuthenticateArtifactResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.AuthenticateArtifactResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ei_user_id(from._internal_ei_user_id());
    }
    if (cached_has_bits & 0x00000002u) {
      original_item_id_ = from.original_item_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      success_ = from.success_;
    }
    if (cached_has_bits & 0x00000008u) {
      demote_ = from.demote_;
    }
    if (cached_has_bits & 0x00000010u) {
      delete__ = from.delete__;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthenticateArtifactResponse::CopyFrom(const AuthenticateArtifactResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.AuthenticateArtifactResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthenticateArtifactResponse::IsInitialized() const {
  return true;
}

void AuthenticateArtifactResponse::InternalSwap(AuthenticateArtifactResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ei_user_id_, lhs_arena,
      &other->ei_user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AuthenticateArtifactResponse, delete__)
      + sizeof(AuthenticateArtifactResponse::delete__)
      - PROTOBUF_FIELD_OFFSET(AuthenticateArtifactResponse, original_item_id_)>(
          reinterpret_cast<char*>(&original_item_id_),
          reinterpret_cast<char*>(&other->original_item_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthenticateArtifactResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[138]);
}

// ===================================================================

class SetArtifactRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<SetArtifactRequest>()._has_bits_);
  static const ::ei::BasicRequestInfo& rinfo(const SetArtifactRequest* msg);
  static void set_has_rinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ei::ArtifactInventoryItem& artifact(const SetArtifactRequest* msg);
  static void set_has_artifact(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_gold_price_paid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::ei::BasicRequestInfo&
SetArtifactRequest::_Internal::rinfo(const SetArtifactRequest* msg) {
  return *msg->rinfo_;
}
const ::ei::ArtifactInventoryItem&
SetArtifactRequest::_Internal::artifact(const SetArtifactRequest* msg) {
  return *msg->artifact_;
}
SetArtifactRequest::SetArtifactRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  stones_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.SetArtifactRequest)
}
SetArtifactRequest::SetArtifactRequest(const SetArtifactRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      stones_(from.stones_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_rinfo()) {
    rinfo_ = new ::ei::BasicRequestInfo(*from.rinfo_);
  } else {
    rinfo_ = nullptr;
  }
  if (from._internal_has_artifact()) {
    artifact_ = new ::ei::ArtifactInventoryItem(*from.artifact_);
  } else {
    artifact_ = nullptr;
  }
  gold_price_paid_ = from.gold_price_paid_;
  // @@protoc_insertion_point(copy_constructor:ei.SetArtifactRequest)
}

inline void SetArtifactRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rinfo_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&gold_price_paid_) -
    reinterpret_cast<char*>(&rinfo_)) + sizeof(gold_price_paid_));
}

SetArtifactRequest::~SetArtifactRequest() {
  // @@protoc_insertion_point(destructor:ei.SetArtifactRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetArtifactRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete rinfo_;
  if (this != internal_default_instance()) delete artifact_;
}

void SetArtifactRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SetArtifactRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.SetArtifactRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  stones_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(rinfo_ != nullptr);
      rinfo_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(artifact_ != nullptr);
      artifact_->Clear();
    }
  }
  gold_price_paid_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetArtifactRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.BasicRequestInfo rinfo = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_rinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.ArtifactInventoryItem artifact = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_artifact(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ArtifactSpec stones = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_stones(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional double gold_price_paid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_gold_price_paid(&has_bits);
          gold_price_paid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetArtifactRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.SetArtifactRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.BasicRequestInfo rinfo = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::rinfo(this),
        _Internal::rinfo(this).GetCachedSize(), target, stream);
  }

  // optional .ei.ArtifactInventoryItem artifact = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::artifact(this),
        _Internal::artifact(this).GetCachedSize(), target, stream);
  }

  // repeated .ei.ArtifactSpec stones = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_stones_size()); i < n; i++) {
    const auto& repfield = this->_internal_stones(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional double gold_price_paid = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_gold_price_paid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.SetArtifactRequest)
  return target;
}

size_t SetArtifactRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.SetArtifactRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.ArtifactSpec stones = 3;
  total_size += 1UL * this->_internal_stones_size();
  for (const auto& msg : this->stones_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .ei.BasicRequestInfo rinfo = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rinfo_);
    }

    // optional .ei.ArtifactInventoryItem artifact = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *artifact_);
    }

    // optional double gold_price_paid = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetArtifactRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SetArtifactRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetArtifactRequest::GetClassData() const { return &_class_data_; }

void SetArtifactRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SetArtifactRequest *>(to)->MergeFrom(
      static_cast<const SetArtifactRequest &>(from));
}


void SetArtifactRequest::MergeFrom(const SetArtifactRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.SetArtifactRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  stones_.MergeFrom(from.stones_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_rinfo()->::ei::BasicRequestInfo::MergeFrom(from._internal_rinfo());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_artifact()->::ei::ArtifactInventoryItem::MergeFrom(from._internal_artifact());
    }
    if (cached_has_bits & 0x00000004u) {
      gold_price_paid_ = from.gold_price_paid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetArtifactRequest::CopyFrom(const SetArtifactRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.SetArtifactRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetArtifactRequest::IsInitialized() const {
  return true;
}

void SetArtifactRequest::InternalSwap(SetArtifactRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  stones_.InternalSwap(&other->stones_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SetArtifactRequest, gold_price_paid_)
      + sizeof(SetArtifactRequest::gold_price_paid_)
      - PROTOBUF_FIELD_OFFSET(SetArtifactRequest, rinfo_)>(
          reinterpret_cast<char*>(&rinfo_),
          reinterpret_cast<char*>(&other->rinfo_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SetArtifactRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[139]);
}

// ===================================================================

class SetArtifactResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<SetArtifactResponse>()._has_bits_);
  static void set_has_success(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_original_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ei_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SetArtifactResponse::SetArtifactResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.SetArtifactResponse)
}
SetArtifactResponse::SetArtifactResponse(const SetArtifactResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ei_user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ei_user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ei_user_id()) {
    ei_user_id_.Set(from._internal_ei_user_id(), 
      GetArenaForAllocation());
  }
  ::memcpy(&original_item_id_, &from.original_item_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&success_) -
    reinterpret_cast<char*>(&original_item_id_)) + sizeof(success_));
  // @@protoc_insertion_point(copy_constructor:ei.SetArtifactResponse)
}

inline void SetArtifactResponse::SharedCtor() {
ei_user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ei_user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&original_item_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&success_) -
    reinterpret_cast<char*>(&original_item_id_)) + sizeof(success_));
}

SetArtifactResponse::~SetArtifactResponse() {
  // @@protoc_insertion_point(destructor:ei.SetArtifactResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetArtifactResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ei_user_id_.Destroy();
}

void SetArtifactResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SetArtifactResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.SetArtifactResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ei_user_id_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&original_item_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&success_) -
        reinterpret_cast<char*>(&original_item_id_)) + sizeof(success_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetArtifactResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool success = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_success(&has_bits);
          success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 original_item_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_original_item_id(&has_bits);
          original_item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string ei_user_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_ei_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.SetArtifactResponse.ei_user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetArtifactResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.SetArtifactResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool success = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_success(), target);
  }

  // optional uint64 original_item_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_original_item_id(), target);
  }

  // optional string ei_user_id = 5;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ei_user_id().data(), static_cast<int>(this->_internal_ei_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.SetArtifactResponse.ei_user_id");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_ei_user_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.SetArtifactResponse)
  return target;
}

size_t SetArtifactResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.SetArtifactResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string ei_user_id = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ei_user_id());
    }

    // optional uint64 original_item_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_original_item_id());
    }

    // optional bool success = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetArtifactResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SetArtifactResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetArtifactResponse::GetClassData() const { return &_class_data_; }

void SetArtifactResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SetArtifactResponse *>(to)->MergeFrom(
      static_cast<const SetArtifactResponse &>(from));
}


void SetArtifactResponse::MergeFrom(const SetArtifactResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.SetArtifactResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ei_user_id(from._internal_ei_user_id());
    }
    if (cached_has_bits & 0x00000002u) {
      original_item_id_ = from.original_item_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      success_ = from.success_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetArtifactResponse::CopyFrom(const SetArtifactResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.SetArtifactResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetArtifactResponse::IsInitialized() const {
  return true;
}

void SetArtifactResponse::InternalSwap(SetArtifactResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ei_user_id_, lhs_arena,
      &other->ei_user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SetArtifactResponse, success_)
      + sizeof(SetArtifactResponse::success_)
      - PROTOBUF_FIELD_OFFSET(SetArtifactResponse, original_item_id_)>(
          reinterpret_cast<char*>(&original_item_id_),
          reinterpret_cast<char*>(&other->original_item_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SetArtifactResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[140]);
}

// ===================================================================

class ArtifactsDB_ActiveArtifactSlot::_Internal {
 public:
  using HasBits = decltype(std::declval<ArtifactsDB_ActiveArtifactSlot>()._has_bits_);
  static void set_has_occupied(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_item_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ArtifactsDB_ActiveArtifactSlot::ArtifactsDB_ActiveArtifactSlot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ArtifactsDB.ActiveArtifactSlot)
}
ArtifactsDB_ActiveArtifactSlot::ArtifactsDB_ActiveArtifactSlot(const ArtifactsDB_ActiveArtifactSlot& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&item_id_, &from.item_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&occupied_) -
    reinterpret_cast<char*>(&item_id_)) + sizeof(occupied_));
  // @@protoc_insertion_point(copy_constructor:ei.ArtifactsDB.ActiveArtifactSlot)
}

inline void ArtifactsDB_ActiveArtifactSlot::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&item_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&occupied_) -
    reinterpret_cast<char*>(&item_id_)) + sizeof(occupied_));
}

ArtifactsDB_ActiveArtifactSlot::~ArtifactsDB_ActiveArtifactSlot() {
  // @@protoc_insertion_point(destructor:ei.ArtifactsDB.ActiveArtifactSlot)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ArtifactsDB_ActiveArtifactSlot::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ArtifactsDB_ActiveArtifactSlot::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ArtifactsDB_ActiveArtifactSlot::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ArtifactsDB.ActiveArtifactSlot)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&item_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&occupied_) -
        reinterpret_cast<char*>(&item_id_)) + sizeof(occupied_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ArtifactsDB_ActiveArtifactSlot::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool occupied = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_occupied(&has_bits);
          occupied_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 item_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_item_id(&has_bits);
          item_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArtifactsDB_ActiveArtifactSlot::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ArtifactsDB.ActiveArtifactSlot)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool occupied = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_occupied(), target);
  }

  // optional uint64 item_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_item_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ArtifactsDB.ActiveArtifactSlot)
  return target;
}

size_t ArtifactsDB_ActiveArtifactSlot::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ArtifactsDB.ActiveArtifactSlot)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 item_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_item_id());
    }

    // optional bool occupied = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ArtifactsDB_ActiveArtifactSlot::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ArtifactsDB_ActiveArtifactSlot::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ArtifactsDB_ActiveArtifactSlot::GetClassData() const { return &_class_data_; }

void ArtifactsDB_ActiveArtifactSlot::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ArtifactsDB_ActiveArtifactSlot *>(to)->MergeFrom(
      static_cast<const ArtifactsDB_ActiveArtifactSlot &>(from));
}


void ArtifactsDB_ActiveArtifactSlot::MergeFrom(const ArtifactsDB_ActiveArtifactSlot& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ArtifactsDB.ActiveArtifactSlot)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      item_id_ = from.item_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      occupied_ = from.occupied_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ArtifactsDB_ActiveArtifactSlot::CopyFrom(const ArtifactsDB_ActiveArtifactSlot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ArtifactsDB.ActiveArtifactSlot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArtifactsDB_ActiveArtifactSlot::IsInitialized() const {
  return true;
}

void ArtifactsDB_ActiveArtifactSlot::InternalSwap(ArtifactsDB_ActiveArtifactSlot* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ArtifactsDB_ActiveArtifactSlot, occupied_)
      + sizeof(ArtifactsDB_ActiveArtifactSlot::occupied_)
      - PROTOBUF_FIELD_OFFSET(ArtifactsDB_ActiveArtifactSlot, item_id_)>(
          reinterpret_cast<char*>(&item_id_),
          reinterpret_cast<char*>(&other->item_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ArtifactsDB_ActiveArtifactSlot::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[141]);
}

// ===================================================================

class ArtifactsDB_ActiveArtifactSet::_Internal {
 public:
};

ArtifactsDB_ActiveArtifactSet::ArtifactsDB_ActiveArtifactSet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  slots_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ArtifactsDB.ActiveArtifactSet)
}
ArtifactsDB_ActiveArtifactSet::ArtifactsDB_ActiveArtifactSet(const ArtifactsDB_ActiveArtifactSet& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      slots_(from.slots_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ei.ArtifactsDB.ActiveArtifactSet)
}

inline void ArtifactsDB_ActiveArtifactSet::SharedCtor() {
}

ArtifactsDB_ActiveArtifactSet::~ArtifactsDB_ActiveArtifactSet() {
  // @@protoc_insertion_point(destructor:ei.ArtifactsDB.ActiveArtifactSet)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ArtifactsDB_ActiveArtifactSet::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ArtifactsDB_ActiveArtifactSet::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ArtifactsDB_ActiveArtifactSet::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ArtifactsDB.ActiveArtifactSet)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  slots_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ArtifactsDB_ActiveArtifactSet::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .ei.ArtifactsDB.ActiveArtifactSlot slots = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_slots(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArtifactsDB_ActiveArtifactSet::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ArtifactsDB.ActiveArtifactSet)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ei.ArtifactsDB.ActiveArtifactSlot slots = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_slots_size()); i < n; i++) {
    const auto& repfield = this->_internal_slots(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ArtifactsDB.ActiveArtifactSet)
  return target;
}

size_t ArtifactsDB_ActiveArtifactSet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ArtifactsDB.ActiveArtifactSet)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.ArtifactsDB.ActiveArtifactSlot slots = 1;
  total_size += 1UL * this->_internal_slots_size();
  for (const auto& msg : this->slots_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ArtifactsDB_ActiveArtifactSet::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ArtifactsDB_ActiveArtifactSet::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ArtifactsDB_ActiveArtifactSet::GetClassData() const { return &_class_data_; }

void ArtifactsDB_ActiveArtifactSet::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ArtifactsDB_ActiveArtifactSet *>(to)->MergeFrom(
      static_cast<const ArtifactsDB_ActiveArtifactSet &>(from));
}


void ArtifactsDB_ActiveArtifactSet::MergeFrom(const ArtifactsDB_ActiveArtifactSet& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ArtifactsDB.ActiveArtifactSet)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  slots_.MergeFrom(from.slots_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ArtifactsDB_ActiveArtifactSet::CopyFrom(const ArtifactsDB_ActiveArtifactSet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ArtifactsDB.ActiveArtifactSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArtifactsDB_ActiveArtifactSet::IsInitialized() const {
  return true;
}

void ArtifactsDB_ActiveArtifactSet::InternalSwap(ArtifactsDB_ActiveArtifactSet* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  slots_.InternalSwap(&other->slots_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ArtifactsDB_ActiveArtifactSet::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[142]);
}

// ===================================================================

class ArtifactsDB_CraftableArtifact::_Internal {
 public:
  using HasBits = decltype(std::declval<ArtifactsDB_CraftableArtifact>()._has_bits_);
  static const ::ei::ArtifactSpec& spec(const ArtifactsDB_CraftableArtifact* msg);
  static void set_has_spec(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_discovered(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_craftable(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_recipe_discovered(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_seen(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::ei::ArtifactSpec&
ArtifactsDB_CraftableArtifact::_Internal::spec(const ArtifactsDB_CraftableArtifact* msg) {
  return *msg->spec_;
}
ArtifactsDB_CraftableArtifact::ArtifactsDB_CraftableArtifact(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ArtifactsDB.CraftableArtifact)
}
ArtifactsDB_CraftableArtifact::ArtifactsDB_CraftableArtifact(const ArtifactsDB_CraftableArtifact& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_spec()) {
    spec_ = new ::ei::ArtifactSpec(*from.spec_);
  } else {
    spec_ = nullptr;
  }
  ::memcpy(&count_, &from.count_,
    static_cast<size_t>(reinterpret_cast<char*>(&seen_) -
    reinterpret_cast<char*>(&count_)) + sizeof(seen_));
  // @@protoc_insertion_point(copy_constructor:ei.ArtifactsDB.CraftableArtifact)
}

inline void ArtifactsDB_CraftableArtifact::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&spec_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&seen_) -
    reinterpret_cast<char*>(&spec_)) + sizeof(seen_));
}

ArtifactsDB_CraftableArtifact::~ArtifactsDB_CraftableArtifact() {
  // @@protoc_insertion_point(destructor:ei.ArtifactsDB.CraftableArtifact)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ArtifactsDB_CraftableArtifact::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete spec_;
}

void ArtifactsDB_CraftableArtifact::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ArtifactsDB_CraftableArtifact::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ArtifactsDB.CraftableArtifact)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(spec_ != nullptr);
    spec_->Clear();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&seen_) -
        reinterpret_cast<char*>(&count_)) + sizeof(seen_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ArtifactsDB_CraftableArtifact::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.ArtifactSpec spec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool seen = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_seen(&has_bits);
          seen_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_count(&has_bits);
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool craftable = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_craftable(&has_bits);
          craftable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool recipe_discovered = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_recipe_discovered(&has_bits);
          recipe_discovered_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool discovered = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_discovered(&has_bits);
          discovered_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArtifactsDB_CraftableArtifact::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ArtifactsDB.CraftableArtifact)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.ArtifactSpec spec = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::spec(this),
        _Internal::spec(this).GetCachedSize(), target, stream);
  }

  // optional bool seen = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_seen(), target);
  }

  // optional uint32 count = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_count(), target);
  }

  // optional bool craftable = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_craftable(), target);
  }

  // optional bool recipe_discovered = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_recipe_discovered(), target);
  }

  // optional bool discovered = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_discovered(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ArtifactsDB.CraftableArtifact)
  return target;
}

size_t ArtifactsDB_CraftableArtifact::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ArtifactsDB.CraftableArtifact)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .ei.ArtifactSpec spec = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *spec_);
    }

    // optional uint32 count = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
    }

    // optional bool discovered = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool craftable = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool recipe_discovered = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool seen = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ArtifactsDB_CraftableArtifact::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ArtifactsDB_CraftableArtifact::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ArtifactsDB_CraftableArtifact::GetClassData() const { return &_class_data_; }

void ArtifactsDB_CraftableArtifact::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ArtifactsDB_CraftableArtifact *>(to)->MergeFrom(
      static_cast<const ArtifactsDB_CraftableArtifact &>(from));
}


void ArtifactsDB_CraftableArtifact::MergeFrom(const ArtifactsDB_CraftableArtifact& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ArtifactsDB.CraftableArtifact)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_spec()->::ei::ArtifactSpec::MergeFrom(from._internal_spec());
    }
    if (cached_has_bits & 0x00000002u) {
      count_ = from.count_;
    }
    if (cached_has_bits & 0x00000004u) {
      discovered_ = from.discovered_;
    }
    if (cached_has_bits & 0x00000008u) {
      craftable_ = from.craftable_;
    }
    if (cached_has_bits & 0x00000010u) {
      recipe_discovered_ = from.recipe_discovered_;
    }
    if (cached_has_bits & 0x00000020u) {
      seen_ = from.seen_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ArtifactsDB_CraftableArtifact::CopyFrom(const ArtifactsDB_CraftableArtifact& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ArtifactsDB.CraftableArtifact)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArtifactsDB_CraftableArtifact::IsInitialized() const {
  return true;
}

void ArtifactsDB_CraftableArtifact::InternalSwap(ArtifactsDB_CraftableArtifact* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ArtifactsDB_CraftableArtifact, seen_)
      + sizeof(ArtifactsDB_CraftableArtifact::seen_)
      - PROTOBUF_FIELD_OFFSET(ArtifactsDB_CraftableArtifact, spec_)>(
          reinterpret_cast<char*>(&spec_),
          reinterpret_cast<char*>(&other->spec_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ArtifactsDB_CraftableArtifact::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[143]);
}

// ===================================================================

class ArtifactsDB::_Internal {
 public:
  using HasBits = decltype(std::declval<ArtifactsDB>()._has_bits_);
  static void set_has_item_sequence(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ArtifactsDB::ArtifactsDB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  inventory_items_(arena),
  inventory_slots_(arena),
  mission_infos_(arena),
  mission_archive_(arena),
  active_artifacts_(arena),
  discovered_artifacts_deprecated_(arena),
  craftable_artifacts_deprecated_(arena),
  crafting_counts_deprecated_(arena),
  active_artifact_sets_(arena),
  artifact_status_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ArtifactsDB)
}
ArtifactsDB::ArtifactsDB(const ArtifactsDB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      inventory_items_(from.inventory_items_),
      inventory_slots_(from.inventory_slots_),
      mission_infos_(from.mission_infos_),
      mission_archive_(from.mission_archive_),
      active_artifacts_(from.active_artifacts_),
      discovered_artifacts_deprecated_(from.discovered_artifacts_deprecated_),
      craftable_artifacts_deprecated_(from.craftable_artifacts_deprecated_),
      crafting_counts_deprecated_(from.crafting_counts_deprecated_),
      active_artifact_sets_(from.active_artifact_sets_),
      artifact_status_(from.artifact_status_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  item_sequence_ = from.item_sequence_;
  // @@protoc_insertion_point(copy_constructor:ei.ArtifactsDB)
}

inline void ArtifactsDB::SharedCtor() {
item_sequence_ = uint64_t{0u};
}

ArtifactsDB::~ArtifactsDB() {
  // @@protoc_insertion_point(destructor:ei.ArtifactsDB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ArtifactsDB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ArtifactsDB::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ArtifactsDB::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ArtifactsDB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  inventory_items_.Clear();
  inventory_slots_.Clear();
  mission_infos_.Clear();
  mission_archive_.Clear();
  active_artifacts_.Clear();
  discovered_artifacts_deprecated_.Clear();
  craftable_artifacts_deprecated_.Clear();
  crafting_counts_deprecated_.Clear();
  active_artifact_sets_.Clear();
  artifact_status_.Clear();
  item_sequence_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ArtifactsDB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .ei.ArtifactInventoryItem inventory_items = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_inventory_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 item_sequence = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_item_sequence(&has_bits);
          item_sequence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.InventorySlot inventory_slots = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_inventory_slots(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.MissionInfo mission_infos = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_mission_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.MissionInfo mission_archive = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_mission_archive(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ArtifactsDB.ActiveArtifactSlot active_artifacts = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_active_artifacts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ArtifactSpec discovered_artifacts_DEPRECATED = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_discovered_artifacts_deprecated(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ArtifactsDB.CraftableArtifact craftable_artifacts_DEPRECATED = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_craftable_artifacts_deprecated(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ArtifactsDB.CraftableArtifact crafting_counts_DEPRECATED = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_crafting_counts_deprecated(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ArtifactsDB.ActiveArtifactSet active_artifact_sets = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_active_artifact_sets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ArtifactsDB.CraftableArtifact artifact_status = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_artifact_status(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArtifactsDB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ArtifactsDB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ei.ArtifactInventoryItem inventory_items = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_inventory_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_inventory_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional uint64 item_sequence = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_item_sequence(), target);
  }

  // repeated .ei.InventorySlot inventory_slots = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_inventory_slots_size()); i < n; i++) {
    const auto& repfield = this->_internal_inventory_slots(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .ei.MissionInfo mission_infos = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_mission_infos_size()); i < n; i++) {
    const auto& repfield = this->_internal_mission_infos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .ei.MissionInfo mission_archive = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_mission_archive_size()); i < n; i++) {
    const auto& repfield = this->_internal_mission_archive(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .ei.ArtifactsDB.ActiveArtifactSlot active_artifacts = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_active_artifacts_size()); i < n; i++) {
    const auto& repfield = this->_internal_active_artifacts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .ei.ArtifactSpec discovered_artifacts_DEPRECATED = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_discovered_artifacts_deprecated_size()); i < n; i++) {
    const auto& repfield = this->_internal_discovered_artifacts_deprecated(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .ei.ArtifactsDB.CraftableArtifact craftable_artifacts_DEPRECATED = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_craftable_artifacts_deprecated_size()); i < n; i++) {
    const auto& repfield = this->_internal_craftable_artifacts_deprecated(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .ei.ArtifactsDB.CraftableArtifact crafting_counts_DEPRECATED = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_crafting_counts_deprecated_size()); i < n; i++) {
    const auto& repfield = this->_internal_crafting_counts_deprecated(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .ei.ArtifactsDB.ActiveArtifactSet active_artifact_sets = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_active_artifact_sets_size()); i < n; i++) {
    const auto& repfield = this->_internal_active_artifact_sets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .ei.ArtifactsDB.CraftableArtifact artifact_status = 12;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_artifact_status_size()); i < n; i++) {
    const auto& repfield = this->_internal_artifact_status(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ArtifactsDB)
  return target;
}

size_t ArtifactsDB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ArtifactsDB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.ArtifactInventoryItem inventory_items = 1;
  total_size += 1UL * this->_internal_inventory_items_size();
  for (const auto& msg : this->inventory_items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.InventorySlot inventory_slots = 3;
  total_size += 1UL * this->_internal_inventory_slots_size();
  for (const auto& msg : this->inventory_slots_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.MissionInfo mission_infos = 4;
  total_size += 1UL * this->_internal_mission_infos_size();
  for (const auto& msg : this->mission_infos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.MissionInfo mission_archive = 5;
  total_size += 1UL * this->_internal_mission_archive_size();
  for (const auto& msg : this->mission_archive_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.ArtifactsDB.ActiveArtifactSlot active_artifacts = 7;
  total_size += 1UL * this->_internal_active_artifacts_size();
  for (const auto& msg : this->active_artifacts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.ArtifactSpec discovered_artifacts_DEPRECATED = 8;
  total_size += 1UL * this->_internal_discovered_artifacts_deprecated_size();
  for (const auto& msg : this->discovered_artifacts_deprecated_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.ArtifactsDB.CraftableArtifact craftable_artifacts_DEPRECATED = 9;
  total_size += 1UL * this->_internal_craftable_artifacts_deprecated_size();
  for (const auto& msg : this->craftable_artifacts_deprecated_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.ArtifactsDB.CraftableArtifact crafting_counts_DEPRECATED = 10;
  total_size += 1UL * this->_internal_crafting_counts_deprecated_size();
  for (const auto& msg : this->crafting_counts_deprecated_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.ArtifactsDB.ActiveArtifactSet active_artifact_sets = 11;
  total_size += 1UL * this->_internal_active_artifact_sets_size();
  for (const auto& msg : this->active_artifact_sets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.ArtifactsDB.CraftableArtifact artifact_status = 12;
  total_size += 1UL * this->_internal_artifact_status_size();
  for (const auto& msg : this->artifact_status_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional uint64 item_sequence = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_item_sequence());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ArtifactsDB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ArtifactsDB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ArtifactsDB::GetClassData() const { return &_class_data_; }

void ArtifactsDB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ArtifactsDB *>(to)->MergeFrom(
      static_cast<const ArtifactsDB &>(from));
}


void ArtifactsDB::MergeFrom(const ArtifactsDB& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ArtifactsDB)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  inventory_items_.MergeFrom(from.inventory_items_);
  inventory_slots_.MergeFrom(from.inventory_slots_);
  mission_infos_.MergeFrom(from.mission_infos_);
  mission_archive_.MergeFrom(from.mission_archive_);
  active_artifacts_.MergeFrom(from.active_artifacts_);
  discovered_artifacts_deprecated_.MergeFrom(from.discovered_artifacts_deprecated_);
  craftable_artifacts_deprecated_.MergeFrom(from.craftable_artifacts_deprecated_);
  crafting_counts_deprecated_.MergeFrom(from.crafting_counts_deprecated_);
  active_artifact_sets_.MergeFrom(from.active_artifact_sets_);
  artifact_status_.MergeFrom(from.artifact_status_);
  if (from._internal_has_item_sequence()) {
    _internal_set_item_sequence(from._internal_item_sequence());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ArtifactsDB::CopyFrom(const ArtifactsDB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ArtifactsDB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArtifactsDB::IsInitialized() const {
  return true;
}

void ArtifactsDB::InternalSwap(ArtifactsDB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  inventory_items_.InternalSwap(&other->inventory_items_);
  inventory_slots_.InternalSwap(&other->inventory_slots_);
  mission_infos_.InternalSwap(&other->mission_infos_);
  mission_archive_.InternalSwap(&other->mission_archive_);
  active_artifacts_.InternalSwap(&other->active_artifacts_);
  discovered_artifacts_deprecated_.InternalSwap(&other->discovered_artifacts_deprecated_);
  craftable_artifacts_deprecated_.InternalSwap(&other->craftable_artifacts_deprecated_);
  crafting_counts_deprecated_.InternalSwap(&other->crafting_counts_deprecated_);
  active_artifact_sets_.InternalSwap(&other->active_artifact_sets_);
  artifact_status_.InternalSwap(&other->artifact_status_);
  swap(item_sequence_, other->item_sequence_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ArtifactsDB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[144]);
}

// ===================================================================

class AuthenticatedMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<AuthenticatedMessage>()._has_bits_);
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_code(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_compressed(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_original_size(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

AuthenticatedMessage::AuthenticatedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.AuthenticatedMessage)
}
AuthenticatedMessage::AuthenticatedMessage(const AuthenticatedMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    message_.Set(from._internal_message(), 
      GetArenaForAllocation());
  }
  code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_code()) {
    code_.Set(from._internal_code(), 
      GetArenaForAllocation());
  }
  ::memcpy(&version_, &from.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&original_size_) -
    reinterpret_cast<char*>(&version_)) + sizeof(original_size_));
  // @@protoc_insertion_point(copy_constructor:ei.AuthenticatedMessage)
}

inline void AuthenticatedMessage::SharedCtor() {
message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
code_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  code_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&version_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&original_size_) -
    reinterpret_cast<char*>(&version_)) + sizeof(original_size_));
}

AuthenticatedMessage::~AuthenticatedMessage() {
  // @@protoc_insertion_point(destructor:ei.AuthenticatedMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthenticatedMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  message_.Destroy();
  code_.Destroy();
}

void AuthenticatedMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AuthenticatedMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.AuthenticatedMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      code_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&original_size_) -
        reinterpret_cast<char*>(&version_)) + sizeof(original_size_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthenticatedMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AuthenticatedMessage.code");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool compressed = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_compressed(&has_bits);
          compressed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 original_size = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_original_size(&has_bits);
          original_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AuthenticatedMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.AuthenticatedMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes message = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_message(), target);
  }

  // optional string code = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_code().data(), static_cast<int>(this->_internal_code().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AuthenticatedMessage.code");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_code(), target);
  }

  // optional uint32 version = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_version(), target);
  }

  // optional bool compressed = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_compressed(), target);
  }

  // optional uint32 original_size = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_original_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.AuthenticatedMessage)
  return target;
}

size_t AuthenticatedMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.AuthenticatedMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes message = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_message());
    }

    // optional string code = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_code());
    }

    // optional uint32 version = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version());
    }

    // optional bool compressed = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional uint32 original_size = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_original_size());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthenticatedMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AuthenticatedMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthenticatedMessage::GetClassData() const { return &_class_data_; }

void AuthenticatedMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AuthenticatedMessage *>(to)->MergeFrom(
      static_cast<const AuthenticatedMessage &>(from));
}


void AuthenticatedMessage::MergeFrom(const AuthenticatedMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.AuthenticatedMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_code(from._internal_code());
    }
    if (cached_has_bits & 0x00000004u) {
      version_ = from.version_;
    }
    if (cached_has_bits & 0x00000008u) {
      compressed_ = from.compressed_;
    }
    if (cached_has_bits & 0x00000010u) {
      original_size_ = from.original_size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthenticatedMessage::CopyFrom(const AuthenticatedMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.AuthenticatedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthenticatedMessage::IsInitialized() const {
  return true;
}

void AuthenticatedMessage::InternalSwap(AuthenticatedMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &message_, lhs_arena,
      &other->message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &code_, lhs_arena,
      &other->code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AuthenticatedMessage, original_size_)
      + sizeof(AuthenticatedMessage::original_size_)
      - PROTOBUF_FIELD_OFFSET(AuthenticatedMessage, version_)>(
          reinterpret_cast<char*>(&version_),
          reinterpret_cast<char*>(&other->version_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthenticatedMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[145]);
}

// ===================================================================

class LogCompleteMissionPayload::_Internal {
 public:
  using HasBits = decltype(std::declval<LogCompleteMissionPayload>()._has_bits_);
  static const ::ei::MissionRequest& req(const LogCompleteMissionPayload* msg);
  static void set_has_req(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ei::CompleteMissionResponse& res(const LogCompleteMissionPayload* msg);
  static void set_has_res(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::ei::MissionRequest&
LogCompleteMissionPayload::_Internal::req(const LogCompleteMissionPayload* msg) {
  return *msg->req_;
}
const ::ei::CompleteMissionResponse&
LogCompleteMissionPayload::_Internal::res(const LogCompleteMissionPayload* msg) {
  return *msg->res_;
}
LogCompleteMissionPayload::LogCompleteMissionPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.LogCompleteMissionPayload)
}
LogCompleteMissionPayload::LogCompleteMissionPayload(const LogCompleteMissionPayload& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_req()) {
    req_ = new ::ei::MissionRequest(*from.req_);
  } else {
    req_ = nullptr;
  }
  if (from._internal_has_res()) {
    res_ = new ::ei::CompleteMissionResponse(*from.res_);
  } else {
    res_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:ei.LogCompleteMissionPayload)
}

inline void LogCompleteMissionPayload::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&req_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&res_) -
    reinterpret_cast<char*>(&req_)) + sizeof(res_));
}

LogCompleteMissionPayload::~LogCompleteMissionPayload() {
  // @@protoc_insertion_point(destructor:ei.LogCompleteMissionPayload)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LogCompleteMissionPayload::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete req_;
  if (this != internal_default_instance()) delete res_;
}

void LogCompleteMissionPayload::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LogCompleteMissionPayload::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.LogCompleteMissionPayload)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(req_ != nullptr);
      req_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(res_ != nullptr);
      res_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LogCompleteMissionPayload::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.MissionRequest req = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_req(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.CompleteMissionResponse res = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_res(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LogCompleteMissionPayload::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.LogCompleteMissionPayload)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.MissionRequest req = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::req(this),
        _Internal::req(this).GetCachedSize(), target, stream);
  }

  // optional .ei.CompleteMissionResponse res = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::res(this),
        _Internal::res(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.LogCompleteMissionPayload)
  return target;
}

size_t LogCompleteMissionPayload::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.LogCompleteMissionPayload)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .ei.MissionRequest req = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *req_);
    }

    // optional .ei.CompleteMissionResponse res = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *res_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LogCompleteMissionPayload::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LogCompleteMissionPayload::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LogCompleteMissionPayload::GetClassData() const { return &_class_data_; }

void LogCompleteMissionPayload::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LogCompleteMissionPayload *>(to)->MergeFrom(
      static_cast<const LogCompleteMissionPayload &>(from));
}


void LogCompleteMissionPayload::MergeFrom(const LogCompleteMissionPayload& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.LogCompleteMissionPayload)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_req()->::ei::MissionRequest::MergeFrom(from._internal_req());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_res()->::ei::CompleteMissionResponse::MergeFrom(from._internal_res());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LogCompleteMissionPayload::CopyFrom(const LogCompleteMissionPayload& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.LogCompleteMissionPayload)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogCompleteMissionPayload::IsInitialized() const {
  return true;
}

void LogCompleteMissionPayload::InternalSwap(LogCompleteMissionPayload* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LogCompleteMissionPayload, res_)
      + sizeof(LogCompleteMissionPayload::res_)
      - PROTOBUF_FIELD_OFFSET(LogCompleteMissionPayload, req_)>(
          reinterpret_cast<char*>(&req_),
          reinterpret_cast<char*>(&other->req_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LogCompleteMissionPayload::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[146]);
}

// ===================================================================

class LogCraftArtifactPayload::_Internal {
 public:
  using HasBits = decltype(std::declval<LogCraftArtifactPayload>()._has_bits_);
  static const ::ei::CraftArtifactRequest& req(const LogCraftArtifactPayload* msg);
  static void set_has_req(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ei::CraftArtifactResponse& res(const LogCraftArtifactPayload* msg);
  static void set_has_res(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::ei::CraftArtifactRequest&
LogCraftArtifactPayload::_Internal::req(const LogCraftArtifactPayload* msg) {
  return *msg->req_;
}
const ::ei::CraftArtifactResponse&
LogCraftArtifactPayload::_Internal::res(const LogCraftArtifactPayload* msg) {
  return *msg->res_;
}
LogCraftArtifactPayload::LogCraftArtifactPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.LogCraftArtifactPayload)
}
LogCraftArtifactPayload::LogCraftArtifactPayload(const LogCraftArtifactPayload& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_req()) {
    req_ = new ::ei::CraftArtifactRequest(*from.req_);
  } else {
    req_ = nullptr;
  }
  if (from._internal_has_res()) {
    res_ = new ::ei::CraftArtifactResponse(*from.res_);
  } else {
    res_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:ei.LogCraftArtifactPayload)
}

inline void LogCraftArtifactPayload::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&req_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&res_) -
    reinterpret_cast<char*>(&req_)) + sizeof(res_));
}

LogCraftArtifactPayload::~LogCraftArtifactPayload() {
  // @@protoc_insertion_point(destructor:ei.LogCraftArtifactPayload)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LogCraftArtifactPayload::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete req_;
  if (this != internal_default_instance()) delete res_;
}

void LogCraftArtifactPayload::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LogCraftArtifactPayload::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.LogCraftArtifactPayload)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(req_ != nullptr);
      req_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(res_ != nullptr);
      res_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LogCraftArtifactPayload::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.CraftArtifactRequest req = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_req(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.CraftArtifactResponse res = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_res(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LogCraftArtifactPayload::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.LogCraftArtifactPayload)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.CraftArtifactRequest req = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::req(this),
        _Internal::req(this).GetCachedSize(), target, stream);
  }

  // optional .ei.CraftArtifactResponse res = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::res(this),
        _Internal::res(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.LogCraftArtifactPayload)
  return target;
}

size_t LogCraftArtifactPayload::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.LogCraftArtifactPayload)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .ei.CraftArtifactRequest req = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *req_);
    }

    // optional .ei.CraftArtifactResponse res = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *res_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LogCraftArtifactPayload::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LogCraftArtifactPayload::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LogCraftArtifactPayload::GetClassData() const { return &_class_data_; }

void LogCraftArtifactPayload::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LogCraftArtifactPayload *>(to)->MergeFrom(
      static_cast<const LogCraftArtifactPayload &>(from));
}


void LogCraftArtifactPayload::MergeFrom(const LogCraftArtifactPayload& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.LogCraftArtifactPayload)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_req()->::ei::CraftArtifactRequest::MergeFrom(from._internal_req());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_res()->::ei::CraftArtifactResponse::MergeFrom(from._internal_res());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LogCraftArtifactPayload::CopyFrom(const LogCraftArtifactPayload& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.LogCraftArtifactPayload)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogCraftArtifactPayload::IsInitialized() const {
  return true;
}

void LogCraftArtifactPayload::InternalSwap(LogCraftArtifactPayload* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LogCraftArtifactPayload, res_)
      + sizeof(LogCraftArtifactPayload::res_)
      - PROTOBUF_FIELD_OFFSET(LogCraftArtifactPayload, req_)>(
          reinterpret_cast<char*>(&req_),
          reinterpret_cast<char*>(&other->req_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LogCraftArtifactPayload::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[147]);
}

// ===================================================================

class LogConsumeArtifactPayload::_Internal {
 public:
  using HasBits = decltype(std::declval<LogConsumeArtifactPayload>()._has_bits_);
  static const ::ei::ConsumeArtifactRequest& req(const LogConsumeArtifactPayload* msg);
  static void set_has_req(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ei::ConsumeArtifactResponse& res(const LogConsumeArtifactPayload* msg);
  static void set_has_res(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::ei::ConsumeArtifactRequest&
LogConsumeArtifactPayload::_Internal::req(const LogConsumeArtifactPayload* msg) {
  return *msg->req_;
}
const ::ei::ConsumeArtifactResponse&
LogConsumeArtifactPayload::_Internal::res(const LogConsumeArtifactPayload* msg) {
  return *msg->res_;
}
LogConsumeArtifactPayload::LogConsumeArtifactPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.LogConsumeArtifactPayload)
}
LogConsumeArtifactPayload::LogConsumeArtifactPayload(const LogConsumeArtifactPayload& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_req()) {
    req_ = new ::ei::ConsumeArtifactRequest(*from.req_);
  } else {
    req_ = nullptr;
  }
  if (from._internal_has_res()) {
    res_ = new ::ei::ConsumeArtifactResponse(*from.res_);
  } else {
    res_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:ei.LogConsumeArtifactPayload)
}

inline void LogConsumeArtifactPayload::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&req_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&res_) -
    reinterpret_cast<char*>(&req_)) + sizeof(res_));
}

LogConsumeArtifactPayload::~LogConsumeArtifactPayload() {
  // @@protoc_insertion_point(destructor:ei.LogConsumeArtifactPayload)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LogConsumeArtifactPayload::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete req_;
  if (this != internal_default_instance()) delete res_;
}

void LogConsumeArtifactPayload::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LogConsumeArtifactPayload::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.LogConsumeArtifactPayload)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(req_ != nullptr);
      req_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(res_ != nullptr);
      res_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LogConsumeArtifactPayload::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.ConsumeArtifactRequest req = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_req(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.ConsumeArtifactResponse res = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_res(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LogConsumeArtifactPayload::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.LogConsumeArtifactPayload)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.ConsumeArtifactRequest req = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::req(this),
        _Internal::req(this).GetCachedSize(), target, stream);
  }

  // optional .ei.ConsumeArtifactResponse res = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::res(this),
        _Internal::res(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.LogConsumeArtifactPayload)
  return target;
}

size_t LogConsumeArtifactPayload::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.LogConsumeArtifactPayload)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .ei.ConsumeArtifactRequest req = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *req_);
    }

    // optional .ei.ConsumeArtifactResponse res = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *res_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LogConsumeArtifactPayload::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LogConsumeArtifactPayload::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LogConsumeArtifactPayload::GetClassData() const { return &_class_data_; }

void LogConsumeArtifactPayload::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LogConsumeArtifactPayload *>(to)->MergeFrom(
      static_cast<const LogConsumeArtifactPayload &>(from));
}


void LogConsumeArtifactPayload::MergeFrom(const LogConsumeArtifactPayload& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.LogConsumeArtifactPayload)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_req()->::ei::ConsumeArtifactRequest::MergeFrom(from._internal_req());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_res()->::ei::ConsumeArtifactResponse::MergeFrom(from._internal_res());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LogConsumeArtifactPayload::CopyFrom(const LogConsumeArtifactPayload& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.LogConsumeArtifactPayload)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogConsumeArtifactPayload::IsInitialized() const {
  return true;
}

void LogConsumeArtifactPayload::InternalSwap(LogConsumeArtifactPayload* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LogConsumeArtifactPayload, res_)
      + sizeof(LogConsumeArtifactPayload::res_)
      - PROTOBUF_FIELD_OFFSET(LogConsumeArtifactPayload, req_)>(
          reinterpret_cast<char*>(&req_),
          reinterpret_cast<char*>(&other->req_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LogConsumeArtifactPayload::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[148]);
}

// ===================================================================

class LogSetArtifactPayload::_Internal {
 public:
  using HasBits = decltype(std::declval<LogSetArtifactPayload>()._has_bits_);
  static const ::ei::SetArtifactRequest& req(const LogSetArtifactPayload* msg);
  static void set_has_req(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ei::SetArtifactResponse& res(const LogSetArtifactPayload* msg);
  static void set_has_res(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::ei::SetArtifactRequest&
LogSetArtifactPayload::_Internal::req(const LogSetArtifactPayload* msg) {
  return *msg->req_;
}
const ::ei::SetArtifactResponse&
LogSetArtifactPayload::_Internal::res(const LogSetArtifactPayload* msg) {
  return *msg->res_;
}
LogSetArtifactPayload::LogSetArtifactPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.LogSetArtifactPayload)
}
LogSetArtifactPayload::LogSetArtifactPayload(const LogSetArtifactPayload& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_req()) {
    req_ = new ::ei::SetArtifactRequest(*from.req_);
  } else {
    req_ = nullptr;
  }
  if (from._internal_has_res()) {
    res_ = new ::ei::SetArtifactResponse(*from.res_);
  } else {
    res_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:ei.LogSetArtifactPayload)
}

inline void LogSetArtifactPayload::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&req_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&res_) -
    reinterpret_cast<char*>(&req_)) + sizeof(res_));
}

LogSetArtifactPayload::~LogSetArtifactPayload() {
  // @@protoc_insertion_point(destructor:ei.LogSetArtifactPayload)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LogSetArtifactPayload::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete req_;
  if (this != internal_default_instance()) delete res_;
}

void LogSetArtifactPayload::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LogSetArtifactPayload::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.LogSetArtifactPayload)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(req_ != nullptr);
      req_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(res_ != nullptr);
      res_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LogSetArtifactPayload::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.SetArtifactRequest req = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_req(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.SetArtifactResponse res = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_res(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LogSetArtifactPayload::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.LogSetArtifactPayload)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.SetArtifactRequest req = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::req(this),
        _Internal::req(this).GetCachedSize(), target, stream);
  }

  // optional .ei.SetArtifactResponse res = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::res(this),
        _Internal::res(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.LogSetArtifactPayload)
  return target;
}

size_t LogSetArtifactPayload::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.LogSetArtifactPayload)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .ei.SetArtifactRequest req = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *req_);
    }

    // optional .ei.SetArtifactResponse res = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *res_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LogSetArtifactPayload::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LogSetArtifactPayload::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LogSetArtifactPayload::GetClassData() const { return &_class_data_; }

void LogSetArtifactPayload::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LogSetArtifactPayload *>(to)->MergeFrom(
      static_cast<const LogSetArtifactPayload &>(from));
}


void LogSetArtifactPayload::MergeFrom(const LogSetArtifactPayload& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.LogSetArtifactPayload)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_req()->::ei::SetArtifactRequest::MergeFrom(from._internal_req());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_res()->::ei::SetArtifactResponse::MergeFrom(from._internal_res());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LogSetArtifactPayload::CopyFrom(const LogSetArtifactPayload& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.LogSetArtifactPayload)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogSetArtifactPayload::IsInitialized() const {
  return true;
}

void LogSetArtifactPayload::InternalSwap(LogSetArtifactPayload* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LogSetArtifactPayload, res_)
      + sizeof(LogSetArtifactPayload::res_)
      - PROTOBUF_FIELD_OFFSET(LogSetArtifactPayload, req_)>(
          reinterpret_cast<char*>(&req_),
          reinterpret_cast<char*>(&other->req_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LogSetArtifactPayload::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[149]);
}

// ===================================================================

class AccountTransferPayload::_Internal {
 public:
  using HasBits = decltype(std::declval<AccountTransferPayload>()._has_bits_);
  static void set_has_from_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_to_ei_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AccountTransferPayload::AccountTransferPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.AccountTransferPayload)
}
AccountTransferPayload::AccountTransferPayload(const AccountTransferPayload& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  from_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    from_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_from_id()) {
    from_id_.Set(from._internal_from_id(), 
      GetArenaForAllocation());
  }
  to_ei_user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    to_ei_user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_to_ei_user_id()) {
    to_ei_user_id_.Set(from._internal_to_ei_user_id(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:ei.AccountTransferPayload)
}

inline void AccountTransferPayload::SharedCtor() {
from_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  from_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
to_ei_user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  to_ei_user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AccountTransferPayload::~AccountTransferPayload() {
  // @@protoc_insertion_point(destructor:ei.AccountTransferPayload)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AccountTransferPayload::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  from_id_.Destroy();
  to_ei_user_id_.Destroy();
}

void AccountTransferPayload::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AccountTransferPayload::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.AccountTransferPayload)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      from_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      to_ei_user_id_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AccountTransferPayload::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string from_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_from_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AccountTransferPayload.from_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string to_ei_user_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_to_ei_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.AccountTransferPayload.to_ei_user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AccountTransferPayload::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.AccountTransferPayload)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string from_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_from_id().data(), static_cast<int>(this->_internal_from_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AccountTransferPayload.from_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_from_id(), target);
  }

  // optional string to_ei_user_id = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_to_ei_user_id().data(), static_cast<int>(this->_internal_to_ei_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.AccountTransferPayload.to_ei_user_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_to_ei_user_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.AccountTransferPayload)
  return target;
}

size_t AccountTransferPayload::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.AccountTransferPayload)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string from_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_from_id());
    }

    // optional string to_ei_user_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_to_ei_user_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AccountTransferPayload::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AccountTransferPayload::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AccountTransferPayload::GetClassData() const { return &_class_data_; }

void AccountTransferPayload::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AccountTransferPayload *>(to)->MergeFrom(
      static_cast<const AccountTransferPayload &>(from));
}


void AccountTransferPayload::MergeFrom(const AccountTransferPayload& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.AccountTransferPayload)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_from_id(from._internal_from_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_to_ei_user_id(from._internal_to_ei_user_id());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AccountTransferPayload::CopyFrom(const AccountTransferPayload& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.AccountTransferPayload)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountTransferPayload::IsInitialized() const {
  return true;
}

void AccountTransferPayload::InternalSwap(AccountTransferPayload* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &from_id_, lhs_arena,
      &other->from_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &to_ei_user_id_, lhs_arena,
      &other->to_ei_user_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata AccountTransferPayload::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[150]);
}

// ===================================================================

class SaveBackupResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<SaveBackupResponse>()._has_bits_);
  static void set_has_success(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_error_code(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ei::Backup& existing_backup(const SaveBackupResponse* msg);
  static void set_has_existing_backup(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::ei::Backup&
SaveBackupResponse::_Internal::existing_backup(const SaveBackupResponse* msg) {
  return *msg->existing_backup_;
}
SaveBackupResponse::SaveBackupResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.SaveBackupResponse)
}
SaveBackupResponse::SaveBackupResponse(const SaveBackupResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    message_.Set(from._internal_message(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_existing_backup()) {
    existing_backup_ = new ::ei::Backup(*from.existing_backup_);
  } else {
    existing_backup_ = nullptr;
  }
  ::memcpy(&success_, &from.success_,
    static_cast<size_t>(reinterpret_cast<char*>(&error_code_) -
    reinterpret_cast<char*>(&success_)) + sizeof(error_code_));
  // @@protoc_insertion_point(copy_constructor:ei.SaveBackupResponse)
}

inline void SaveBackupResponse::SharedCtor() {
message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&existing_backup_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&error_code_) -
    reinterpret_cast<char*>(&existing_backup_)) + sizeof(error_code_));
}

SaveBackupResponse::~SaveBackupResponse() {
  // @@protoc_insertion_point(destructor:ei.SaveBackupResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SaveBackupResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  message_.Destroy();
  if (this != internal_default_instance()) delete existing_backup_;
}

void SaveBackupResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SaveBackupResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.SaveBackupResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(existing_backup_ != nullptr);
      existing_backup_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&success_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&error_code_) -
        reinterpret_cast<char*>(&success_)) + sizeof(error_code_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SaveBackupResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool success = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_success(&has_bits);
          success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 error_code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_error_code(&has_bits);
          error_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string message = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.SaveBackupResponse.message");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .ei.Backup existing_backup = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_existing_backup(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SaveBackupResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.SaveBackupResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool success = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_success(), target);
  }

  // optional uint32 error_code = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_error_code(), target);
  }

  // optional string message = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_message().data(), static_cast<int>(this->_internal_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.SaveBackupResponse.message");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_message(), target);
  }

  // optional .ei.Backup existing_backup = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::existing_backup(this),
        _Internal::existing_backup(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.SaveBackupResponse)
  return target;
}

size_t SaveBackupResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.SaveBackupResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string message = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_message());
    }

    // optional .ei.Backup existing_backup = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *existing_backup_);
    }

    // optional bool success = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional uint32 error_code = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_error_code());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SaveBackupResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SaveBackupResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SaveBackupResponse::GetClassData() const { return &_class_data_; }

void SaveBackupResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SaveBackupResponse *>(to)->MergeFrom(
      static_cast<const SaveBackupResponse &>(from));
}


void SaveBackupResponse::MergeFrom(const SaveBackupResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.SaveBackupResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_existing_backup()->::ei::Backup::MergeFrom(from._internal_existing_backup());
    }
    if (cached_has_bits & 0x00000004u) {
      success_ = from.success_;
    }
    if (cached_has_bits & 0x00000008u) {
      error_code_ = from.error_code_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SaveBackupResponse::CopyFrom(const SaveBackupResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.SaveBackupResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SaveBackupResponse::IsInitialized() const {
  return true;
}

void SaveBackupResponse::InternalSwap(SaveBackupResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &message_, lhs_arena,
      &other->message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SaveBackupResponse, error_code_)
      + sizeof(SaveBackupResponse::error_code_)
      - PROTOBUF_FIELD_OFFSET(SaveBackupResponse, existing_backup_)>(
          reinterpret_cast<char*>(&existing_backup_),
          reinterpret_cast<char*>(&other->existing_backup_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SaveBackupResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[151]);
}

// ===================================================================

class CleanAccountRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CleanAccountRequest>()._has_bits_);
  static void set_has_ei_user_id_to_keep(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_game_services_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CleanAccountRequest::CleanAccountRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.CleanAccountRequest)
}
CleanAccountRequest::CleanAccountRequest(const CleanAccountRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ei_user_id_to_keep_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ei_user_id_to_keep_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ei_user_id_to_keep()) {
    ei_user_id_to_keep_.Set(from._internal_ei_user_id_to_keep(), 
      GetArenaForAllocation());
  }
  game_services_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    game_services_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_game_services_id()) {
    game_services_id_.Set(from._internal_game_services_id(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:ei.CleanAccountRequest)
}

inline void CleanAccountRequest::SharedCtor() {
ei_user_id_to_keep_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ei_user_id_to_keep_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
game_services_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  game_services_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CleanAccountRequest::~CleanAccountRequest() {
  // @@protoc_insertion_point(destructor:ei.CleanAccountRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CleanAccountRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ei_user_id_to_keep_.Destroy();
  game_services_id_.Destroy();
}

void CleanAccountRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CleanAccountRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.CleanAccountRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ei_user_id_to_keep_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      game_services_id_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CleanAccountRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string ei_user_id_to_keep = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ei_user_id_to_keep();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.CleanAccountRequest.ei_user_id_to_keep");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string game_services_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_game_services_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.CleanAccountRequest.game_services_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CleanAccountRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.CleanAccountRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string ei_user_id_to_keep = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ei_user_id_to_keep().data(), static_cast<int>(this->_internal_ei_user_id_to_keep().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.CleanAccountRequest.ei_user_id_to_keep");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ei_user_id_to_keep(), target);
  }

  // optional string game_services_id = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_game_services_id().data(), static_cast<int>(this->_internal_game_services_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.CleanAccountRequest.game_services_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_game_services_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.CleanAccountRequest)
  return target;
}

size_t CleanAccountRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.CleanAccountRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string ei_user_id_to_keep = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ei_user_id_to_keep());
    }

    // optional string game_services_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_game_services_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CleanAccountRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CleanAccountRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CleanAccountRequest::GetClassData() const { return &_class_data_; }

void CleanAccountRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CleanAccountRequest *>(to)->MergeFrom(
      static_cast<const CleanAccountRequest &>(from));
}


void CleanAccountRequest::MergeFrom(const CleanAccountRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.CleanAccountRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ei_user_id_to_keep(from._internal_ei_user_id_to_keep());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_game_services_id(from._internal_game_services_id());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CleanAccountRequest::CopyFrom(const CleanAccountRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.CleanAccountRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CleanAccountRequest::IsInitialized() const {
  return true;
}

void CleanAccountRequest::InternalSwap(CleanAccountRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ei_user_id_to_keep_, lhs_arena,
      &other->ei_user_id_to_keep_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &game_services_id_, lhs_arena,
      &other->game_services_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CleanAccountRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[152]);
}

// ===================================================================

class ReturnEDTPayload::_Internal {
 public:
  using HasBits = decltype(std::declval<ReturnEDTPayload>()._has_bits_);
  static void set_has_ei_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ReturnEDTPayload::ReturnEDTPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ReturnEDTPayload)
}
ReturnEDTPayload::ReturnEDTPayload(const ReturnEDTPayload& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ei_user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ei_user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ei_user_id()) {
    ei_user_id_.Set(from._internal_ei_user_id(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:ei.ReturnEDTPayload)
}

inline void ReturnEDTPayload::SharedCtor() {
ei_user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ei_user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReturnEDTPayload::~ReturnEDTPayload() {
  // @@protoc_insertion_point(destructor:ei.ReturnEDTPayload)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReturnEDTPayload::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ei_user_id_.Destroy();
}

void ReturnEDTPayload::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ReturnEDTPayload::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ReturnEDTPayload)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ei_user_id_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReturnEDTPayload::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string ei_user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ei_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ReturnEDTPayload.ei_user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReturnEDTPayload::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ReturnEDTPayload)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string ei_user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ei_user_id().data(), static_cast<int>(this->_internal_ei_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ReturnEDTPayload.ei_user_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ei_user_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ReturnEDTPayload)
  return target;
}

size_t ReturnEDTPayload::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ReturnEDTPayload)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string ei_user_id = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ei_user_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReturnEDTPayload::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ReturnEDTPayload::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReturnEDTPayload::GetClassData() const { return &_class_data_; }

void ReturnEDTPayload::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ReturnEDTPayload *>(to)->MergeFrom(
      static_cast<const ReturnEDTPayload &>(from));
}


void ReturnEDTPayload::MergeFrom(const ReturnEDTPayload& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ReturnEDTPayload)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_ei_user_id()) {
    _internal_set_ei_user_id(from._internal_ei_user_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReturnEDTPayload::CopyFrom(const ReturnEDTPayload& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ReturnEDTPayload)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReturnEDTPayload::IsInitialized() const {
  return true;
}

void ReturnEDTPayload::InternalSwap(ReturnEDTPayload* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ei_user_id_, lhs_arena,
      &other->ei_user_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ReturnEDTPayload::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[153]);
}

// ===================================================================

class DLCItem::_Internal {
 public:
  using HasBits = decltype(std::declval<DLCItem>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_directory(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ext(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_compressed(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_original_size(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_checksum(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

DLCItem::DLCItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.DLCItem)
}
DLCItem::DLCItem(const DLCItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  directory_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    directory_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_directory()) {
    directory_.Set(from._internal_directory(), 
      GetArenaForAllocation());
  }
  ext_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ext_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ext()) {
    ext_.Set(from._internal_ext(), 
      GetArenaForAllocation());
  }
  url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    url_.Set(from._internal_url(), 
      GetArenaForAllocation());
  }
  checksum_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    checksum_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_checksum()) {
    checksum_.Set(from._internal_checksum(), 
      GetArenaForAllocation());
  }
  ::memcpy(&original_size_, &from.original_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&compressed_) -
    reinterpret_cast<char*>(&original_size_)) + sizeof(compressed_));
  // @@protoc_insertion_point(copy_constructor:ei.DLCItem)
}

inline void DLCItem::SharedCtor() {
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
directory_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  directory_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
ext_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ext_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
checksum_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  checksum_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&original_size_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&compressed_) -
    reinterpret_cast<char*>(&original_size_)) + sizeof(compressed_));
}

DLCItem::~DLCItem() {
  // @@protoc_insertion_point(destructor:ei.DLCItem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DLCItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.Destroy();
  directory_.Destroy();
  ext_.Destroy();
  url_.Destroy();
  checksum_.Destroy();
}

void DLCItem::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DLCItem::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.DLCItem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      directory_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      ext_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      checksum_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000060u) {
    ::memset(&original_size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&compressed_) -
        reinterpret_cast<char*>(&original_size_)) + sizeof(compressed_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DLCItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.DLCItem.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string directory = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_directory();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.DLCItem.directory");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string ext = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_ext();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.DLCItem.ext");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string url = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.DLCItem.url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string checksum = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_checksum();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.DLCItem.checksum");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool compressed = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_compressed(&has_bits);
          compressed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 original_size = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_original_size(&has_bits);
          original_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DLCItem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.DLCItem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.DLCItem.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string directory = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_directory().data(), static_cast<int>(this->_internal_directory().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.DLCItem.directory");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_directory(), target);
  }

  // optional string ext = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ext().data(), static_cast<int>(this->_internal_ext().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.DLCItem.ext");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_ext(), target);
  }

  // optional string url = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_url().data(), static_cast<int>(this->_internal_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.DLCItem.url");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_url(), target);
  }

  // optional string checksum = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_checksum().data(), static_cast<int>(this->_internal_checksum().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.DLCItem.checksum");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_checksum(), target);
  }

  // optional bool compressed = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_compressed(), target);
  }

  // optional uint64 original_size = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_original_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.DLCItem)
  return target;
}

size_t DLCItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.DLCItem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string directory = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_directory());
    }

    // optional string ext = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ext());
    }

    // optional string url = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

    // optional string checksum = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_checksum());
    }

    // optional uint64 original_size = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_original_size());
    }

    // optional bool compressed = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DLCItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DLCItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DLCItem::GetClassData() const { return &_class_data_; }

void DLCItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DLCItem *>(to)->MergeFrom(
      static_cast<const DLCItem &>(from));
}


void DLCItem::MergeFrom(const DLCItem& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.DLCItem)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_directory(from._internal_directory());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_ext(from._internal_ext());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_checksum(from._internal_checksum());
    }
    if (cached_has_bits & 0x00000020u) {
      original_size_ = from.original_size_;
    }
    if (cached_has_bits & 0x00000040u) {
      compressed_ = from.compressed_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DLCItem::CopyFrom(const DLCItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.DLCItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DLCItem::IsInitialized() const {
  return true;
}

void DLCItem::InternalSwap(DLCItem* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &directory_, lhs_arena,
      &other->directory_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ext_, lhs_arena,
      &other->ext_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &url_, lhs_arena,
      &other->url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &checksum_, lhs_arena,
      &other->checksum_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DLCItem, compressed_)
      + sizeof(DLCItem::compressed_)
      - PROTOBUF_FIELD_OFFSET(DLCItem, original_size_)>(
          reinterpret_cast<char*>(&original_size_),
          reinterpret_cast<char*>(&other->original_size_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DLCItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[154]);
}

// ===================================================================

class ShellSpec_ShellPiece::_Internal {
 public:
  using HasBits = decltype(std::declval<ShellSpec_ShellPiece>()._has_bits_);
  static void set_has_asset_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::ei::DLCItem& dlc(const ShellSpec_ShellPiece* msg);
  static void set_has_dlc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::ei::DLCItem&
ShellSpec_ShellPiece::_Internal::dlc(const ShellSpec_ShellPiece* msg) {
  return *msg->dlc_;
}
ShellSpec_ShellPiece::ShellSpec_ShellPiece(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ShellSpec.ShellPiece)
}
ShellSpec_ShellPiece::ShellSpec_ShellPiece(const ShellSpec_ShellPiece& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_dlc()) {
    dlc_ = new ::ei::DLCItem(*from.dlc_);
  } else {
    dlc_ = nullptr;
  }
  asset_type_ = from.asset_type_;
  // @@protoc_insertion_point(copy_constructor:ei.ShellSpec.ShellPiece)
}

inline void ShellSpec_ShellPiece::SharedCtor() {
dlc_ = nullptr;
asset_type_ = 1;
}

ShellSpec_ShellPiece::~ShellSpec_ShellPiece() {
  // @@protoc_insertion_point(destructor:ei.ShellSpec.ShellPiece)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShellSpec_ShellPiece::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete dlc_;
}

void ShellSpec_ShellPiece::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShellSpec_ShellPiece::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ShellSpec.ShellPiece)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(dlc_ != nullptr);
      dlc_->Clear();
    }
    asset_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShellSpec_ShellPiece::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.ShellSpec.AssetType asset_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::ShellSpec_AssetType_IsValid(val))) {
            _internal_set_asset_type(static_cast<::ei::ShellSpec_AssetType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .ei.DLCItem dlc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_dlc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShellSpec_ShellPiece::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ShellSpec.ShellPiece)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.ShellSpec.AssetType asset_type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_asset_type(), target);
  }

  // optional .ei.DLCItem dlc = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::dlc(this),
        _Internal::dlc(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ShellSpec.ShellPiece)
  return target;
}

size_t ShellSpec_ShellPiece::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ShellSpec.ShellPiece)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .ei.DLCItem dlc = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *dlc_);
    }

    // optional .ei.ShellSpec.AssetType asset_type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_asset_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShellSpec_ShellPiece::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ShellSpec_ShellPiece::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShellSpec_ShellPiece::GetClassData() const { return &_class_data_; }

void ShellSpec_ShellPiece::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ShellSpec_ShellPiece *>(to)->MergeFrom(
      static_cast<const ShellSpec_ShellPiece &>(from));
}


void ShellSpec_ShellPiece::MergeFrom(const ShellSpec_ShellPiece& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ShellSpec.ShellPiece)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_dlc()->::ei::DLCItem::MergeFrom(from._internal_dlc());
    }
    if (cached_has_bits & 0x00000002u) {
      asset_type_ = from.asset_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShellSpec_ShellPiece::CopyFrom(const ShellSpec_ShellPiece& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ShellSpec.ShellPiece)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShellSpec_ShellPiece::IsInitialized() const {
  return true;
}

void ShellSpec_ShellPiece::InternalSwap(ShellSpec_ShellPiece* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(dlc_, other->dlc_);
  swap(asset_type_, other->asset_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ShellSpec_ShellPiece::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[155]);
}

// ===================================================================

class ShellSpec::_Internal {
 public:
  using HasBits = decltype(std::declval<ShellSpec>()._has_bits_);
  static void set_has_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ei::ShellSpec_ShellPiece& primary_piece(const ShellSpec* msg);
  static void set_has_primary_piece(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_set_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_modified_geometry(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_price(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_required_eop(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_required_soul_eggs(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_required_parent_shell(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_is_new(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_expires(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_seconds_until_available(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_seconds_remaining(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_default_appearance(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
};

const ::ei::ShellSpec_ShellPiece&
ShellSpec::_Internal::primary_piece(const ShellSpec* msg) {
  return *msg->primary_piece_;
}
ShellSpec::ShellSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  pieces_(arena),
  alt_assets_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ShellSpec)
}
ShellSpec::ShellSpec(const ShellSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      pieces_(from.pieces_),
      alt_assets_(from.alt_assets_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_identifier()) {
    identifier_.Set(from._internal_identifier(), 
      GetArenaForAllocation());
  }
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  set_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    set_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_set_identifier()) {
    set_identifier_.Set(from._internal_set_identifier(), 
      GetArenaForAllocation());
  }
  required_parent_shell_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    required_parent_shell_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_required_parent_shell()) {
    required_parent_shell_.Set(from._internal_required_parent_shell(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_primary_piece()) {
    primary_piece_ = new ::ei::ShellSpec_ShellPiece(*from.primary_piece_);
  } else {
    primary_piece_ = nullptr;
  }
  ::memcpy(&price_, &from.price_,
    static_cast<size_t>(reinterpret_cast<char*>(&default_appearance_) -
    reinterpret_cast<char*>(&price_)) + sizeof(default_appearance_));
  // @@protoc_insertion_point(copy_constructor:ei.ShellSpec)
}

inline void ShellSpec::SharedCtor() {
identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
set_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  set_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
required_parent_shell_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  required_parent_shell_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&primary_piece_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&default_appearance_) -
    reinterpret_cast<char*>(&primary_piece_)) + sizeof(default_appearance_));
}

ShellSpec::~ShellSpec() {
  // @@protoc_insertion_point(destructor:ei.ShellSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShellSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  identifier_.Destroy();
  name_.Destroy();
  set_identifier_.Destroy();
  required_parent_shell_.Destroy();
  if (this != internal_default_instance()) delete primary_piece_;
}

void ShellSpec::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShellSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ShellSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  pieces_.Clear();
  alt_assets_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      set_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      required_parent_shell_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(primary_piece_ != nullptr);
      primary_piece_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&price_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&required_soul_eggs_) -
        reinterpret_cast<char*>(&price_)) + sizeof(required_soul_eggs_));
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&seconds_remaining_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&default_appearance_) -
        reinterpret_cast<char*>(&seconds_remaining_)) + sizeof(default_appearance_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShellSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ShellSpec.identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ShellSpec.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 price = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_price(&has_bits);
          price_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 required_eop = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_required_eop(&has_bits);
          required_eop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double required_soul_eggs = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_required_soul_eggs(&has_bits);
          required_soul_eggs_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool default_appearance = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_default_appearance(&has_bits);
          default_appearance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ShellSpec.ShellPiece pieces = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_pieces(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .ei.ShellSpec.ShellPiece primary_piece = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_primary_piece(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string set_identifier = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_set_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ShellSpec.set_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool is_new = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_is_new(&has_bits);
          is_new_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool expires = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_expires(&has_bits);
          expires_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double seconds_remaining = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 129)) {
          _Internal::set_has_seconds_remaining(&has_bits);
          seconds_remaining_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double seconds_until_available = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 137)) {
          _Internal::set_has_seconds_until_available(&has_bits);
          seconds_until_available_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.DLCItem alt_assets = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_alt_assets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<146>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool modified_geometry = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_modified_geometry(&has_bits);
          modified_geometry_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string required_parent_shell = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_required_parent_shell();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ShellSpec.required_parent_shell");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShellSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ShellSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_identifier().data(), static_cast<int>(this->_internal_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellSpec.identifier");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_identifier(), target);
  }

  // optional string name = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellSpec.name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_name(), target);
  }

  // optional uint32 price = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_price(), target);
  }

  // optional uint32 required_eop = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_required_eop(), target);
  }

  // optional double required_soul_eggs = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_required_soul_eggs(), target);
  }

  // optional bool default_appearance = 8;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_default_appearance(), target);
  }

  // repeated .ei.ShellSpec.ShellPiece pieces = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_pieces_size()); i < n; i++) {
    const auto& repfield = this->_internal_pieces(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .ei.ShellSpec.ShellPiece primary_piece = 12;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::primary_piece(this),
        _Internal::primary_piece(this).GetCachedSize(), target, stream);
  }

  // optional string set_identifier = 13;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_set_identifier().data(), static_cast<int>(this->_internal_set_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellSpec.set_identifier");
    target = stream->WriteStringMaybeAliased(
        13, this->_internal_set_identifier(), target);
  }

  // optional bool is_new = 14;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_is_new(), target);
  }

  // optional bool expires = 15;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_expires(), target);
  }

  // optional double seconds_remaining = 16;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(16, this->_internal_seconds_remaining(), target);
  }

  // optional double seconds_until_available = 17;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(17, this->_internal_seconds_until_available(), target);
  }

  // repeated .ei.DLCItem alt_assets = 18;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_alt_assets_size()); i < n; i++) {
    const auto& repfield = this->_internal_alt_assets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(18, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool modified_geometry = 19;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(19, this->_internal_modified_geometry(), target);
  }

  // optional string required_parent_shell = 20;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_required_parent_shell().data(), static_cast<int>(this->_internal_required_parent_shell().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellSpec.required_parent_shell");
    target = stream->WriteStringMaybeAliased(
        20, this->_internal_required_parent_shell(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ShellSpec)
  return target;
}

size_t ShellSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ShellSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.ShellSpec.ShellPiece pieces = 11;
  total_size += 1UL * this->_internal_pieces_size();
  for (const auto& msg : this->pieces_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.DLCItem alt_assets = 18;
  total_size += 2UL * this->_internal_alt_assets_size();
  for (const auto& msg : this->alt_assets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string identifier = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_identifier());
    }

    // optional string name = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string set_identifier = 13;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_set_identifier());
    }

    // optional string required_parent_shell = 20;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_required_parent_shell());
    }

    // optional .ei.ShellSpec.ShellPiece primary_piece = 12;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *primary_piece_);
    }

    // optional uint32 price = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_price());
    }

    // optional uint32 required_eop = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_required_eop());
    }

    // optional double required_soul_eggs = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional double seconds_remaining = 16;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 + 8;
    }

    // optional double seconds_until_available = 17;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 + 8;
    }

    // optional bool modified_geometry = 19;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 + 1;
    }

    // optional bool is_new = 14;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool expires = 15;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool default_appearance = 8;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShellSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ShellSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShellSpec::GetClassData() const { return &_class_data_; }

void ShellSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ShellSpec *>(to)->MergeFrom(
      static_cast<const ShellSpec &>(from));
}


void ShellSpec::MergeFrom(const ShellSpec& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ShellSpec)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  pieces_.MergeFrom(from.pieces_);
  alt_assets_.MergeFrom(from.alt_assets_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_identifier(from._internal_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_set_identifier(from._internal_set_identifier());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_required_parent_shell(from._internal_required_parent_shell());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_primary_piece()->::ei::ShellSpec_ShellPiece::MergeFrom(from._internal_primary_piece());
    }
    if (cached_has_bits & 0x00000020u) {
      price_ = from.price_;
    }
    if (cached_has_bits & 0x00000040u) {
      required_eop_ = from.required_eop_;
    }
    if (cached_has_bits & 0x00000080u) {
      required_soul_eggs_ = from.required_soul_eggs_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      seconds_remaining_ = from.seconds_remaining_;
    }
    if (cached_has_bits & 0x00000200u) {
      seconds_until_available_ = from.seconds_until_available_;
    }
    if (cached_has_bits & 0x00000400u) {
      modified_geometry_ = from.modified_geometry_;
    }
    if (cached_has_bits & 0x00000800u) {
      is_new_ = from.is_new_;
    }
    if (cached_has_bits & 0x00001000u) {
      expires_ = from.expires_;
    }
    if (cached_has_bits & 0x00002000u) {
      default_appearance_ = from.default_appearance_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShellSpec::CopyFrom(const ShellSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ShellSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShellSpec::IsInitialized() const {
  return true;
}

void ShellSpec::InternalSwap(ShellSpec* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  pieces_.InternalSwap(&other->pieces_);
  alt_assets_.InternalSwap(&other->alt_assets_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &identifier_, lhs_arena,
      &other->identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &set_identifier_, lhs_arena,
      &other->set_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &required_parent_shell_, lhs_arena,
      &other->required_parent_shell_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShellSpec, default_appearance_)
      + sizeof(ShellSpec::default_appearance_)
      - PROTOBUF_FIELD_OFFSET(ShellSpec, primary_piece_)>(
          reinterpret_cast<char*>(&primary_piece_),
          reinterpret_cast<char*>(&other->primary_piece_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ShellSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[156]);
}

// ===================================================================

class ShellSetSpec_VariationSpec::_Internal {
 public:
  using HasBits = decltype(std::declval<ShellSetSpec_VariationSpec>()._has_bits_);
  static void set_has_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hex_color(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_price(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sort_priority(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_default_appearance(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_custom_appearance(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

ShellSetSpec_VariationSpec::ShellSetSpec_VariationSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ShellSetSpec.VariationSpec)
}
ShellSetSpec_VariationSpec::ShellSetSpec_VariationSpec(const ShellSetSpec_VariationSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_identifier()) {
    identifier_.Set(from._internal_identifier(), 
      GetArenaForAllocation());
  }
  hex_color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    hex_color_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hex_color()) {
    hex_color_.Set(from._internal_hex_color(), 
      GetArenaForAllocation());
  }
  ::memcpy(&price_, &from.price_,
    static_cast<size_t>(reinterpret_cast<char*>(&sort_priority_) -
    reinterpret_cast<char*>(&price_)) + sizeof(sort_priority_));
  // @@protoc_insertion_point(copy_constructor:ei.ShellSetSpec.VariationSpec)
}

inline void ShellSetSpec_VariationSpec::SharedCtor() {
identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
hex_color_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  hex_color_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&price_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&sort_priority_) -
    reinterpret_cast<char*>(&price_)) + sizeof(sort_priority_));
}

ShellSetSpec_VariationSpec::~ShellSetSpec_VariationSpec() {
  // @@protoc_insertion_point(destructor:ei.ShellSetSpec.VariationSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShellSetSpec_VariationSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  identifier_.Destroy();
  hex_color_.Destroy();
}

void ShellSetSpec_VariationSpec::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShellSetSpec_VariationSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ShellSetSpec.VariationSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      hex_color_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&price_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&sort_priority_) -
        reinterpret_cast<char*>(&price_)) + sizeof(sort_priority_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShellSetSpec_VariationSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ShellSetSpec.VariationSpec.identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string hex_color = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_hex_color();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ShellSetSpec.VariationSpec.hex_color");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 price = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_price(&has_bits);
          price_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool default_appearance = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_default_appearance(&has_bits);
          default_appearance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool custom_appearance = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_custom_appearance(&has_bits);
          custom_appearance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 sort_priority = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_sort_priority(&has_bits);
          sort_priority_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShellSetSpec_VariationSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ShellSetSpec.VariationSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_identifier().data(), static_cast<int>(this->_internal_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellSetSpec.VariationSpec.identifier");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_identifier(), target);
  }

  // optional string hex_color = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_hex_color().data(), static_cast<int>(this->_internal_hex_color().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellSetSpec.VariationSpec.hex_color");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_hex_color(), target);
  }

  // optional uint32 price = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_price(), target);
  }

  // optional bool default_appearance = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_default_appearance(), target);
  }

  // optional bool custom_appearance = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_custom_appearance(), target);
  }

  // optional int32 sort_priority = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_sort_priority(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ShellSetSpec.VariationSpec)
  return target;
}

size_t ShellSetSpec_VariationSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ShellSetSpec.VariationSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string identifier = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_identifier());
    }

    // optional string hex_color = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_hex_color());
    }

    // optional uint32 price = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_price());
    }

    // optional bool default_appearance = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool custom_appearance = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional int32 sort_priority = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sort_priority());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShellSetSpec_VariationSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ShellSetSpec_VariationSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShellSetSpec_VariationSpec::GetClassData() const { return &_class_data_; }

void ShellSetSpec_VariationSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ShellSetSpec_VariationSpec *>(to)->MergeFrom(
      static_cast<const ShellSetSpec_VariationSpec &>(from));
}


void ShellSetSpec_VariationSpec::MergeFrom(const ShellSetSpec_VariationSpec& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ShellSetSpec.VariationSpec)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_identifier(from._internal_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_hex_color(from._internal_hex_color());
    }
    if (cached_has_bits & 0x00000004u) {
      price_ = from.price_;
    }
    if (cached_has_bits & 0x00000008u) {
      default_appearance_ = from.default_appearance_;
    }
    if (cached_has_bits & 0x00000010u) {
      custom_appearance_ = from.custom_appearance_;
    }
    if (cached_has_bits & 0x00000020u) {
      sort_priority_ = from.sort_priority_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShellSetSpec_VariationSpec::CopyFrom(const ShellSetSpec_VariationSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ShellSetSpec.VariationSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShellSetSpec_VariationSpec::IsInitialized() const {
  return true;
}

void ShellSetSpec_VariationSpec::InternalSwap(ShellSetSpec_VariationSpec* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &identifier_, lhs_arena,
      &other->identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &hex_color_, lhs_arena,
      &other->hex_color_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShellSetSpec_VariationSpec, sort_priority_)
      + sizeof(ShellSetSpec_VariationSpec::sort_priority_)
      - PROTOBUF_FIELD_OFFSET(ShellSetSpec_VariationSpec, price_)>(
          reinterpret_cast<char*>(&price_),
          reinterpret_cast<char*>(&other->price_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ShellSetSpec_VariationSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[157]);
}

// ===================================================================

class ShellSetSpec::_Internal {
 public:
  using HasBits = decltype(std::declval<ShellSetSpec>()._has_bits_);
  static void set_has_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_price(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_price_mult_deprecated(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_discount(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_required_eop(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_required_soul_eggs(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_required_parent_set(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_is_new(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_expires(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_seconds_until_available(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_seconds_remaining(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_decorator(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_modified_geometry(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_element_set(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_hex_base_color(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::ei::DLCItem& icon(const ShellSetSpec* msg);
  static void set_has_icon(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_default_appearance(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_custom_appearance(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

const ::ei::DLCItem&
ShellSetSpec::_Internal::icon(const ShellSetSpec* msg) {
  return *msg->icon_;
}
ShellSetSpec::ShellSetSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  variations_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ShellSetSpec)
}
ShellSetSpec::ShellSetSpec(const ShellSetSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      variations_(from.variations_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_identifier()) {
    identifier_.Set(from._internal_identifier(), 
      GetArenaForAllocation());
  }
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  hex_base_color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    hex_base_color_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hex_base_color()) {
    hex_base_color_.Set(from._internal_hex_base_color(), 
      GetArenaForAllocation());
  }
  required_parent_set_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    required_parent_set_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_required_parent_set()) {
    required_parent_set_.Set(from._internal_required_parent_set(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_icon()) {
    icon_ = new ::ei::DLCItem(*from.icon_);
  } else {
    icon_ = nullptr;
  }
  ::memcpy(&price_, &from.price_,
    static_cast<size_t>(reinterpret_cast<char*>(&price_mult_deprecated_) -
    reinterpret_cast<char*>(&price_)) + sizeof(price_mult_deprecated_));
  // @@protoc_insertion_point(copy_constructor:ei.ShellSetSpec)
}

inline void ShellSetSpec::SharedCtor() {
identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
hex_base_color_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  hex_base_color_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
required_parent_set_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  required_parent_set_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&icon_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&seconds_until_available_) -
    reinterpret_cast<char*>(&icon_)) + sizeof(seconds_until_available_));
price_mult_deprecated_ = 1;
}

ShellSetSpec::~ShellSetSpec() {
  // @@protoc_insertion_point(destructor:ei.ShellSetSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShellSetSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  identifier_.Destroy();
  name_.Destroy();
  hex_base_color_.Destroy();
  required_parent_set_.Destroy();
  if (this != internal_default_instance()) delete icon_;
}

void ShellSetSpec::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShellSetSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ShellSetSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  variations_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      hex_base_color_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      required_parent_set_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(icon_ != nullptr);
      icon_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&price_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&required_soul_eggs_) -
        reinterpret_cast<char*>(&price_)) + sizeof(required_soul_eggs_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&element_set_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&seconds_remaining_) -
        reinterpret_cast<char*>(&element_set_)) + sizeof(seconds_remaining_));
  }
  if (cached_has_bits & 0x00070000u) {
    ::memset(&discount_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&seconds_until_available_) -
        reinterpret_cast<char*>(&discount_)) + sizeof(seconds_until_available_));
    price_mult_deprecated_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShellSetSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ShellSetSpec.identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ShellSetSpec.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 price = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_price(&has_bits);
          price_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 required_eop = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_required_eop(&has_bits);
          required_eop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double required_soul_eggs = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_required_soul_eggs(&has_bits);
          required_soul_eggs_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool default_appearance = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_default_appearance(&has_bits);
          default_appearance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool element_set = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_element_set(&has_bits);
          element_set_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double price_mult_DEPRECATED = 8 [default = 1];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _Internal::set_has_price_mult_deprecated(&has_bits);
          price_mult_deprecated_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_new = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_is_new(&has_bits);
          is_new_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool expires = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_expires(&has_bits);
          expires_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double seconds_remaining = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _Internal::set_has_seconds_remaining(&has_bits);
          seconds_remaining_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool custom_appearance = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_custom_appearance(&has_bits);
          custom_appearance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool modified_geometry = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_modified_geometry(&has_bits);
          modified_geometry_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool decorator = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_decorator(&has_bits);
          decorator_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ShellSetSpec.VariationSpec variations = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_variations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<122>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string hex_base_color = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          auto str = _internal_mutable_hex_base_color();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ShellSetSpec.hex_base_color");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double discount = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 137)) {
          _Internal::set_has_discount(&has_bits);
          discount_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double seconds_until_available = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 145)) {
          _Internal::set_has_seconds_until_available(&has_bits);
          seconds_until_available_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.DLCItem icon = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_icon(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string required_parent_set = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_required_parent_set();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ShellSetSpec.required_parent_set");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShellSetSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ShellSetSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_identifier().data(), static_cast<int>(this->_internal_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellSetSpec.identifier");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_identifier(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellSetSpec.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional uint32 price = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_price(), target);
  }

  // optional uint32 required_eop = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_required_eop(), target);
  }

  // optional double required_soul_eggs = 5;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_required_soul_eggs(), target);
  }

  // optional bool default_appearance = 6;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_default_appearance(), target);
  }

  // optional bool element_set = 7;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_element_set(), target);
  }

  // optional double price_mult_DEPRECATED = 8 [default = 1];
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_price_mult_deprecated(), target);
  }

  // optional bool is_new = 9;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_is_new(), target);
  }

  // optional bool expires = 10;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_expires(), target);
  }

  // optional double seconds_remaining = 11;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(11, this->_internal_seconds_remaining(), target);
  }

  // optional bool custom_appearance = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_custom_appearance(), target);
  }

  // optional bool modified_geometry = 13;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_modified_geometry(), target);
  }

  // optional bool decorator = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_decorator(), target);
  }

  // repeated .ei.ShellSetSpec.VariationSpec variations = 15;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_variations_size()); i < n; i++) {
    const auto& repfield = this->_internal_variations(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(15, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string hex_base_color = 16;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_hex_base_color().data(), static_cast<int>(this->_internal_hex_base_color().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellSetSpec.hex_base_color");
    target = stream->WriteStringMaybeAliased(
        16, this->_internal_hex_base_color(), target);
  }

  // optional double discount = 17;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(17, this->_internal_discount(), target);
  }

  // optional double seconds_until_available = 18;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(18, this->_internal_seconds_until_available(), target);
  }

  // optional .ei.DLCItem icon = 19;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::icon(this),
        _Internal::icon(this).GetCachedSize(), target, stream);
  }

  // optional string required_parent_set = 20;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_required_parent_set().data(), static_cast<int>(this->_internal_required_parent_set().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellSetSpec.required_parent_set");
    target = stream->WriteStringMaybeAliased(
        20, this->_internal_required_parent_set(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ShellSetSpec)
  return target;
}

size_t ShellSetSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ShellSetSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.ShellSetSpec.VariationSpec variations = 15;
  total_size += 1UL * this->_internal_variations_size();
  for (const auto& msg : this->variations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string identifier = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_identifier());
    }

    // optional string name = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string hex_base_color = 16;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_hex_base_color());
    }

    // optional string required_parent_set = 20;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_required_parent_set());
    }

    // optional .ei.DLCItem icon = 19;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *icon_);
    }

    // optional uint32 price = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_price());
    }

    // optional uint32 required_eop = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_required_eop());
    }

    // optional double required_soul_eggs = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool element_set = 7;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool default_appearance = 6;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool custom_appearance = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool is_new = 9;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool expires = 10;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool decorator = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional bool modified_geometry = 13;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

    // optional double seconds_remaining = 11;
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x00070000u) {
    // optional double discount = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 8;
    }

    // optional double seconds_until_available = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 8;
    }

    // optional double price_mult_DEPRECATED = 8 [default = 1];
    if (cached_has_bits & 0x00040000u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShellSetSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ShellSetSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShellSetSpec::GetClassData() const { return &_class_data_; }

void ShellSetSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ShellSetSpec *>(to)->MergeFrom(
      static_cast<const ShellSetSpec &>(from));
}


void ShellSetSpec::MergeFrom(const ShellSetSpec& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ShellSetSpec)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  variations_.MergeFrom(from.variations_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_identifier(from._internal_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_hex_base_color(from._internal_hex_base_color());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_required_parent_set(from._internal_required_parent_set());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_icon()->::ei::DLCItem::MergeFrom(from._internal_icon());
    }
    if (cached_has_bits & 0x00000020u) {
      price_ = from.price_;
    }
    if (cached_has_bits & 0x00000040u) {
      required_eop_ = from.required_eop_;
    }
    if (cached_has_bits & 0x00000080u) {
      required_soul_eggs_ = from.required_soul_eggs_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      element_set_ = from.element_set_;
    }
    if (cached_has_bits & 0x00000200u) {
      default_appearance_ = from.default_appearance_;
    }
    if (cached_has_bits & 0x00000400u) {
      custom_appearance_ = from.custom_appearance_;
    }
    if (cached_has_bits & 0x00000800u) {
      is_new_ = from.is_new_;
    }
    if (cached_has_bits & 0x00001000u) {
      expires_ = from.expires_;
    }
    if (cached_has_bits & 0x00002000u) {
      decorator_ = from.decorator_;
    }
    if (cached_has_bits & 0x00004000u) {
      modified_geometry_ = from.modified_geometry_;
    }
    if (cached_has_bits & 0x00008000u) {
      seconds_remaining_ = from.seconds_remaining_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00070000u) {
    if (cached_has_bits & 0x00010000u) {
      discount_ = from.discount_;
    }
    if (cached_has_bits & 0x00020000u) {
      seconds_until_available_ = from.seconds_until_available_;
    }
    if (cached_has_bits & 0x00040000u) {
      price_mult_deprecated_ = from.price_mult_deprecated_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShellSetSpec::CopyFrom(const ShellSetSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ShellSetSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShellSetSpec::IsInitialized() const {
  return true;
}

void ShellSetSpec::InternalSwap(ShellSetSpec* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  variations_.InternalSwap(&other->variations_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &identifier_, lhs_arena,
      &other->identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &hex_base_color_, lhs_arena,
      &other->hex_base_color_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &required_parent_set_, lhs_arena,
      &other->required_parent_set_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShellSetSpec, seconds_until_available_)
      + sizeof(ShellSetSpec::seconds_until_available_)
      - PROTOBUF_FIELD_OFFSET(ShellSetSpec, icon_)>(
          reinterpret_cast<char*>(&icon_),
          reinterpret_cast<char*>(&other->icon_));
  swap(price_mult_deprecated_, other->price_mult_deprecated_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ShellSetSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[158]);
}

// ===================================================================

class ShellObjectSpec_LODPiece::_Internal {
 public:
  using HasBits = decltype(std::declval<ShellObjectSpec_LODPiece>()._has_bits_);
  static const ::ei::DLCItem& dlc(const ShellObjectSpec_LODPiece* msg);
  static void set_has_dlc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lod(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::ei::DLCItem&
ShellObjectSpec_LODPiece::_Internal::dlc(const ShellObjectSpec_LODPiece* msg) {
  return *msg->dlc_;
}
ShellObjectSpec_LODPiece::ShellObjectSpec_LODPiece(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ShellObjectSpec.LODPiece)
}
ShellObjectSpec_LODPiece::ShellObjectSpec_LODPiece(const ShellObjectSpec_LODPiece& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_dlc()) {
    dlc_ = new ::ei::DLCItem(*from.dlc_);
  } else {
    dlc_ = nullptr;
  }
  lod_ = from.lod_;
  // @@protoc_insertion_point(copy_constructor:ei.ShellObjectSpec.LODPiece)
}

inline void ShellObjectSpec_LODPiece::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dlc_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&lod_) -
    reinterpret_cast<char*>(&dlc_)) + sizeof(lod_));
}

ShellObjectSpec_LODPiece::~ShellObjectSpec_LODPiece() {
  // @@protoc_insertion_point(destructor:ei.ShellObjectSpec.LODPiece)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShellObjectSpec_LODPiece::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete dlc_;
}

void ShellObjectSpec_LODPiece::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShellObjectSpec_LODPiece::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ShellObjectSpec.LODPiece)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(dlc_ != nullptr);
    dlc_->Clear();
  }
  lod_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShellObjectSpec_LODPiece::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.DLCItem dlc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_dlc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lod = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_lod(&has_bits);
          lod_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShellObjectSpec_LODPiece::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ShellObjectSpec.LODPiece)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.DLCItem dlc = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::dlc(this),
        _Internal::dlc(this).GetCachedSize(), target, stream);
  }

  // optional uint32 lod = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_lod(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ShellObjectSpec.LODPiece)
  return target;
}

size_t ShellObjectSpec_LODPiece::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ShellObjectSpec.LODPiece)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .ei.DLCItem dlc = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *dlc_);
    }

    // optional uint32 lod = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lod());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShellObjectSpec_LODPiece::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ShellObjectSpec_LODPiece::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShellObjectSpec_LODPiece::GetClassData() const { return &_class_data_; }

void ShellObjectSpec_LODPiece::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ShellObjectSpec_LODPiece *>(to)->MergeFrom(
      static_cast<const ShellObjectSpec_LODPiece &>(from));
}


void ShellObjectSpec_LODPiece::MergeFrom(const ShellObjectSpec_LODPiece& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ShellObjectSpec.LODPiece)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_dlc()->::ei::DLCItem::MergeFrom(from._internal_dlc());
    }
    if (cached_has_bits & 0x00000002u) {
      lod_ = from.lod_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShellObjectSpec_LODPiece::CopyFrom(const ShellObjectSpec_LODPiece& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ShellObjectSpec.LODPiece)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShellObjectSpec_LODPiece::IsInitialized() const {
  return true;
}

void ShellObjectSpec_LODPiece::InternalSwap(ShellObjectSpec_LODPiece* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShellObjectSpec_LODPiece, lod_)
      + sizeof(ShellObjectSpec_LODPiece::lod_)
      - PROTOBUF_FIELD_OFFSET(ShellObjectSpec_LODPiece, dlc_)>(
          reinterpret_cast<char*>(&dlc_),
          reinterpret_cast<char*>(&other->dlc_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ShellObjectSpec_LODPiece::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[159]);
}

// ===================================================================

class ShellObjectSpec::_Internal {
 public:
  using HasBits = decltype(std::declval<ShellObjectSpec>()._has_bits_);
  static void set_has_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_asset_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_object_class(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_price(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_required_eop(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_required_soul_eggs(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_is_new(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_expires(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_seconds_until_available(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_seconds_remaining(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_no_hats(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_chicken_animation(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_sort_priority(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_default_appearance(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

ShellObjectSpec::ShellObjectSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  metadata_(arena),
  pieces_(arena),
  icon_colors_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ShellObjectSpec)
}
ShellObjectSpec::ShellObjectSpec(const ShellObjectSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      metadata_(from.metadata_),
      pieces_(from.pieces_),
      icon_colors_(from.icon_colors_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_identifier()) {
    identifier_.Set(from._internal_identifier(), 
      GetArenaForAllocation());
  }
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  object_class_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    object_class_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_object_class()) {
    object_class_.Set(from._internal_object_class(), 
      GetArenaForAllocation());
  }
  ::memcpy(&price_, &from.price_,
    static_cast<size_t>(reinterpret_cast<char*>(&asset_type_) -
    reinterpret_cast<char*>(&price_)) + sizeof(asset_type_));
  // @@protoc_insertion_point(copy_constructor:ei.ShellObjectSpec)
}

inline void ShellObjectSpec::SharedCtor() {
identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
object_class_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  object_class_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&price_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&sort_priority_) -
    reinterpret_cast<char*>(&price_)) + sizeof(sort_priority_));
asset_type_ = 1;
}

ShellObjectSpec::~ShellObjectSpec() {
  // @@protoc_insertion_point(destructor:ei.ShellObjectSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShellObjectSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  identifier_.Destroy();
  name_.Destroy();
  object_class_.Destroy();
}

void ShellObjectSpec::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShellObjectSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ShellObjectSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  metadata_.Clear();
  pieces_.Clear();
  icon_colors_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      object_class_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&price_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&expires_) -
        reinterpret_cast<char*>(&price_)) + sizeof(expires_));
  }
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&no_hats_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&sort_priority_) -
        reinterpret_cast<char*>(&no_hats_)) + sizeof(sort_priority_));
    asset_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShellObjectSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ShellObjectSpec.identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ShellObjectSpec.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .ei.ShellSpec.AssetType asset_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::ShellSpec_AssetType_IsValid(val))) {
            _internal_set_asset_type(static_cast<::ei::ShellSpec_AssetType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 price = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_price(&has_bits);
          price_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 required_eop = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_required_eop(&has_bits);
          required_eop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double required_soul_eggs = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_required_soul_eggs(&has_bits);
          required_soul_eggs_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated double metadata = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_metadata(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<57>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_metadata(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ShellObjectSpec.LODPiece pieces = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_pieces(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool default_appearance = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_default_appearance(&has_bits);
          default_appearance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_new = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_is_new(&has_bits);
          is_new_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool expires = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_expires(&has_bits);
          expires_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double seconds_remaining = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 97)) {
          _Internal::set_has_seconds_remaining(&has_bits);
          seconds_remaining_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool no_hats = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_no_hats(&has_bits);
          no_hats_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string object_class = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_object_class();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ShellObjectSpec.object_class");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated string icon_colors = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_icon_colors();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "ei.ShellObjectSpec.icon_colors");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<122>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .ei.ShellObjectSpec.ChickenAnimation chicken_animation = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::ShellObjectSpec_ChickenAnimation_IsValid(val))) {
            _internal_set_chicken_animation(static_cast<::ei::ShellObjectSpec_ChickenAnimation>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(16, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 sort_priority = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_sort_priority(&has_bits);
          sort_priority_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double seconds_until_available = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 145)) {
          _Internal::set_has_seconds_until_available(&has_bits);
          seconds_until_available_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShellObjectSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ShellObjectSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_identifier().data(), static_cast<int>(this->_internal_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellObjectSpec.identifier");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_identifier(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellObjectSpec.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional .ei.ShellSpec.AssetType asset_type = 3;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_asset_type(), target);
  }

  // optional uint32 price = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_price(), target);
  }

  // optional uint32 required_eop = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_required_eop(), target);
  }

  // optional double required_soul_eggs = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_required_soul_eggs(), target);
  }

  // repeated double metadata = 7;
  for (int i = 0, n = this->_internal_metadata_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_metadata(i), target);
  }

  // repeated .ei.ShellObjectSpec.LODPiece pieces = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_pieces_size()); i < n; i++) {
    const auto& repfield = this->_internal_pieces(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool default_appearance = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_default_appearance(), target);
  }

  // optional bool is_new = 10;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_is_new(), target);
  }

  // optional bool expires = 11;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_expires(), target);
  }

  // optional double seconds_remaining = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(12, this->_internal_seconds_remaining(), target);
  }

  // optional bool no_hats = 13;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_no_hats(), target);
  }

  // optional string object_class = 14;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_object_class().data(), static_cast<int>(this->_internal_object_class().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellObjectSpec.object_class");
    target = stream->WriteStringMaybeAliased(
        14, this->_internal_object_class(), target);
  }

  // repeated string icon_colors = 15;
  for (int i = 0, n = this->_internal_icon_colors_size(); i < n; i++) {
    const auto& s = this->_internal_icon_colors(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellObjectSpec.icon_colors");
    target = stream->WriteString(15, s, target);
  }

  // optional .ei.ShellObjectSpec.ChickenAnimation chicken_animation = 16;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      16, this->_internal_chicken_animation(), target);
  }

  // optional int32 sort_priority = 17;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(17, this->_internal_sort_priority(), target);
  }

  // optional double seconds_until_available = 18;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(18, this->_internal_seconds_until_available(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ShellObjectSpec)
  return target;
}

size_t ShellObjectSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ShellObjectSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double metadata = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_metadata_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_metadata_size());
    total_size += data_size;
  }

  // repeated .ei.ShellObjectSpec.LODPiece pieces = 8;
  total_size += 1UL * this->_internal_pieces_size();
  for (const auto& msg : this->pieces_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string icon_colors = 15;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(icon_colors_.size());
  for (int i = 0, n = icon_colors_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      icon_colors_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string identifier = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_identifier());
    }

    // optional string name = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string object_class = 14;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_object_class());
    }

    // optional uint32 price = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_price());
    }

    // optional uint32 required_eop = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_required_eop());
    }

    // optional double required_soul_eggs = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional bool is_new = 10;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool expires = 11;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional bool no_hats = 13;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool default_appearance = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional .ei.ShellObjectSpec.ChickenAnimation chicken_animation = 16;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_chicken_animation());
    }

    // optional double seconds_remaining = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 8;
    }

    // optional double seconds_until_available = 18;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + 8;
    }

    // optional int32 sort_priority = 17;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_sort_priority());
    }

    // optional .ei.ShellSpec.AssetType asset_type = 3;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_asset_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShellObjectSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ShellObjectSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShellObjectSpec::GetClassData() const { return &_class_data_; }

void ShellObjectSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ShellObjectSpec *>(to)->MergeFrom(
      static_cast<const ShellObjectSpec &>(from));
}


void ShellObjectSpec::MergeFrom(const ShellObjectSpec& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ShellObjectSpec)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  metadata_.MergeFrom(from.metadata_);
  pieces_.MergeFrom(from.pieces_);
  icon_colors_.MergeFrom(from.icon_colors_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_identifier(from._internal_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_object_class(from._internal_object_class());
    }
    if (cached_has_bits & 0x00000008u) {
      price_ = from.price_;
    }
    if (cached_has_bits & 0x00000010u) {
      required_eop_ = from.required_eop_;
    }
    if (cached_has_bits & 0x00000020u) {
      required_soul_eggs_ = from.required_soul_eggs_;
    }
    if (cached_has_bits & 0x00000040u) {
      is_new_ = from.is_new_;
    }
    if (cached_has_bits & 0x00000080u) {
      expires_ = from.expires_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      no_hats_ = from.no_hats_;
    }
    if (cached_has_bits & 0x00000200u) {
      default_appearance_ = from.default_appearance_;
    }
    if (cached_has_bits & 0x00000400u) {
      chicken_animation_ = from.chicken_animation_;
    }
    if (cached_has_bits & 0x00000800u) {
      seconds_remaining_ = from.seconds_remaining_;
    }
    if (cached_has_bits & 0x00001000u) {
      seconds_until_available_ = from.seconds_until_available_;
    }
    if (cached_has_bits & 0x00002000u) {
      sort_priority_ = from.sort_priority_;
    }
    if (cached_has_bits & 0x00004000u) {
      asset_type_ = from.asset_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShellObjectSpec::CopyFrom(const ShellObjectSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ShellObjectSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShellObjectSpec::IsInitialized() const {
  return true;
}

void ShellObjectSpec::InternalSwap(ShellObjectSpec* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  metadata_.InternalSwap(&other->metadata_);
  pieces_.InternalSwap(&other->pieces_);
  icon_colors_.InternalSwap(&other->icon_colors_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &identifier_, lhs_arena,
      &other->identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &object_class_, lhs_arena,
      &other->object_class_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShellObjectSpec, sort_priority_)
      + sizeof(ShellObjectSpec::sort_priority_)
      - PROTOBUF_FIELD_OFFSET(ShellObjectSpec, price_)>(
          reinterpret_cast<char*>(&price_),
          reinterpret_cast<char*>(&other->price_));
  swap(asset_type_, other->asset_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ShellObjectSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[160]);
}

// ===================================================================

class ShellGroupSpec::_Internal {
 public:
  using HasBits = decltype(std::declval<ShellGroupSpec>()._has_bits_);
  static void set_has_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_asset_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_price_mult_deprecated(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ShellGroupSpec::ShellGroupSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  member_ids_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ShellGroupSpec)
}
ShellGroupSpec::ShellGroupSpec(const ShellGroupSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      member_ids_(from.member_ids_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_identifier()) {
    identifier_.Set(from._internal_identifier(), 
      GetArenaForAllocation());
  }
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&price_mult_deprecated_, &from.price_mult_deprecated_,
    static_cast<size_t>(reinterpret_cast<char*>(&asset_type_) -
    reinterpret_cast<char*>(&price_mult_deprecated_)) + sizeof(asset_type_));
  // @@protoc_insertion_point(copy_constructor:ei.ShellGroupSpec)
}

inline void ShellGroupSpec::SharedCtor() {
identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
price_mult_deprecated_ = 0;
asset_type_ = 1;
}

ShellGroupSpec::~ShellGroupSpec() {
  // @@protoc_insertion_point(destructor:ei.ShellGroupSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShellGroupSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  identifier_.Destroy();
  name_.Destroy();
}

void ShellGroupSpec::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShellGroupSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ShellGroupSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  member_ids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    price_mult_deprecated_ = 0;
    asset_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShellGroupSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ShellGroupSpec.identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ShellGroupSpec.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated string member_ids = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_member_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "ei.ShellGroupSpec.member_ids");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional double price_mult_DEPRECATED = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_price_mult_deprecated(&has_bits);
          price_mult_deprecated_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.ShellSpec.AssetType asset_type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::ShellSpec_AssetType_IsValid(val))) {
            _internal_set_asset_type(static_cast<::ei::ShellSpec_AssetType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShellGroupSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ShellGroupSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_identifier().data(), static_cast<int>(this->_internal_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellGroupSpec.identifier");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_identifier(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellGroupSpec.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // repeated string member_ids = 3;
  for (int i = 0, n = this->_internal_member_ids_size(); i < n; i++) {
    const auto& s = this->_internal_member_ids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellGroupSpec.member_ids");
    target = stream->WriteString(3, s, target);
  }

  // optional double price_mult_DEPRECATED = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_price_mult_deprecated(), target);
  }

  // optional .ei.ShellSpec.AssetType asset_type = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_asset_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ShellGroupSpec)
  return target;
}

size_t ShellGroupSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ShellGroupSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string member_ids = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(member_ids_.size());
  for (int i = 0, n = member_ids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      member_ids_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string identifier = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_identifier());
    }

    // optional string name = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional double price_mult_DEPRECATED = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional .ei.ShellSpec.AssetType asset_type = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_asset_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShellGroupSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ShellGroupSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShellGroupSpec::GetClassData() const { return &_class_data_; }

void ShellGroupSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ShellGroupSpec *>(to)->MergeFrom(
      static_cast<const ShellGroupSpec &>(from));
}


void ShellGroupSpec::MergeFrom(const ShellGroupSpec& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ShellGroupSpec)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  member_ids_.MergeFrom(from.member_ids_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_identifier(from._internal_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000004u) {
      price_mult_deprecated_ = from.price_mult_deprecated_;
    }
    if (cached_has_bits & 0x00000008u) {
      asset_type_ = from.asset_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShellGroupSpec::CopyFrom(const ShellGroupSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ShellGroupSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShellGroupSpec::IsInitialized() const {
  return true;
}

void ShellGroupSpec::InternalSwap(ShellGroupSpec* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  member_ids_.InternalSwap(&other->member_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &identifier_, lhs_arena,
      &other->identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  swap(price_mult_deprecated_, other->price_mult_deprecated_);
  swap(asset_type_, other->asset_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ShellGroupSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[161]);
}

// ===================================================================

class DLCCatalog::_Internal {
 public:
};

DLCCatalog::DLCCatalog(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  items_(arena),
  shells_(arena),
  shell_sets_(arena),
  shell_objects_(arena),
  shell_groups_(arena),
  decorators_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.DLCCatalog)
}
DLCCatalog::DLCCatalog(const DLCCatalog& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      items_(from.items_),
      shells_(from.shells_),
      shell_sets_(from.shell_sets_),
      shell_objects_(from.shell_objects_),
      shell_groups_(from.shell_groups_),
      decorators_(from.decorators_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ei.DLCCatalog)
}

inline void DLCCatalog::SharedCtor() {
}

DLCCatalog::~DLCCatalog() {
  // @@protoc_insertion_point(destructor:ei.DLCCatalog)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DLCCatalog::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DLCCatalog::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DLCCatalog::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.DLCCatalog)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  items_.Clear();
  shells_.Clear();
  shell_sets_.Clear();
  shell_objects_.Clear();
  shell_groups_.Clear();
  decorators_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DLCCatalog::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .ei.DLCItem items = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ShellSpec shells = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_shells(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ShellSetSpec shell_sets = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_shell_sets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ShellObjectSpec shell_objects = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_shell_objects(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ShellGroupSpec shell_groups = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_shell_groups(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ShellSetSpec decorators = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_decorators(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DLCCatalog::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.DLCCatalog)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ei.DLCItem items = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .ei.ShellSpec shells = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_shells_size()); i < n; i++) {
    const auto& repfield = this->_internal_shells(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .ei.ShellSetSpec shell_sets = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_shell_sets_size()); i < n; i++) {
    const auto& repfield = this->_internal_shell_sets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .ei.ShellObjectSpec shell_objects = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_shell_objects_size()); i < n; i++) {
    const auto& repfield = this->_internal_shell_objects(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .ei.ShellGroupSpec shell_groups = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_shell_groups_size()); i < n; i++) {
    const auto& repfield = this->_internal_shell_groups(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .ei.ShellSetSpec decorators = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_decorators_size()); i < n; i++) {
    const auto& repfield = this->_internal_decorators(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.DLCCatalog)
  return target;
}

size_t DLCCatalog::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.DLCCatalog)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.DLCItem items = 1;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.ShellSpec shells = 2;
  total_size += 1UL * this->_internal_shells_size();
  for (const auto& msg : this->shells_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.ShellSetSpec shell_sets = 3;
  total_size += 1UL * this->_internal_shell_sets_size();
  for (const auto& msg : this->shell_sets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.ShellObjectSpec shell_objects = 4;
  total_size += 1UL * this->_internal_shell_objects_size();
  for (const auto& msg : this->shell_objects_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.ShellGroupSpec shell_groups = 5;
  total_size += 1UL * this->_internal_shell_groups_size();
  for (const auto& msg : this->shell_groups_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.ShellSetSpec decorators = 6;
  total_size += 1UL * this->_internal_decorators_size();
  for (const auto& msg : this->decorators_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DLCCatalog::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DLCCatalog::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DLCCatalog::GetClassData() const { return &_class_data_; }

void DLCCatalog::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DLCCatalog *>(to)->MergeFrom(
      static_cast<const DLCCatalog &>(from));
}


void DLCCatalog::MergeFrom(const DLCCatalog& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.DLCCatalog)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  items_.MergeFrom(from.items_);
  shells_.MergeFrom(from.shells_);
  shell_sets_.MergeFrom(from.shell_sets_);
  shell_objects_.MergeFrom(from.shell_objects_);
  shell_groups_.MergeFrom(from.shell_groups_);
  decorators_.MergeFrom(from.decorators_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DLCCatalog::CopyFrom(const DLCCatalog& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.DLCCatalog)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DLCCatalog::IsInitialized() const {
  return true;
}

void DLCCatalog::InternalSwap(DLCCatalog* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  items_.InternalSwap(&other->items_);
  shells_.InternalSwap(&other->shells_);
  shell_sets_.InternalSwap(&other->shell_sets_);
  shell_objects_.InternalSwap(&other->shell_objects_);
  shell_groups_.InternalSwap(&other->shell_groups_);
  decorators_.InternalSwap(&other->decorators_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DLCCatalog::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[162]);
}

// ===================================================================

class ShellDB_ShellStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<ShellDB_ShellStatus>()._has_bits_);
  static void set_has_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_owned(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ShellDB_ShellStatus::ShellDB_ShellStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ShellDB.ShellStatus)
}
ShellDB_ShellStatus::ShellDB_ShellStatus(const ShellDB_ShellStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_identifier()) {
    identifier_.Set(from._internal_identifier(), 
      GetArenaForAllocation());
  }
  owned_ = from.owned_;
  // @@protoc_insertion_point(copy_constructor:ei.ShellDB.ShellStatus)
}

inline void ShellDB_ShellStatus::SharedCtor() {
identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
owned_ = false;
}

ShellDB_ShellStatus::~ShellDB_ShellStatus() {
  // @@protoc_insertion_point(destructor:ei.ShellDB.ShellStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShellDB_ShellStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  identifier_.Destroy();
}

void ShellDB_ShellStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShellDB_ShellStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ShellDB.ShellStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    identifier_.ClearNonDefaultToEmpty();
  }
  owned_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShellDB_ShellStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ShellDB.ShellStatus.identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool owned = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_owned(&has_bits);
          owned_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShellDB_ShellStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ShellDB.ShellStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_identifier().data(), static_cast<int>(this->_internal_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellDB.ShellStatus.identifier");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_identifier(), target);
  }

  // optional bool owned = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_owned(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ShellDB.ShellStatus)
  return target;
}

size_t ShellDB_ShellStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ShellDB.ShellStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string identifier = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_identifier());
    }

    // optional bool owned = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShellDB_ShellStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ShellDB_ShellStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShellDB_ShellStatus::GetClassData() const { return &_class_data_; }

void ShellDB_ShellStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ShellDB_ShellStatus *>(to)->MergeFrom(
      static_cast<const ShellDB_ShellStatus &>(from));
}


void ShellDB_ShellStatus::MergeFrom(const ShellDB_ShellStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ShellDB.ShellStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_identifier(from._internal_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      owned_ = from.owned_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShellDB_ShellStatus::CopyFrom(const ShellDB_ShellStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ShellDB.ShellStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShellDB_ShellStatus::IsInitialized() const {
  return true;
}

void ShellDB_ShellStatus::InternalSwap(ShellDB_ShellStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &identifier_, lhs_arena,
      &other->identifier_, rhs_arena
  );
  swap(owned_, other->owned_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ShellDB_ShellStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[163]);
}

// ===================================================================

class ShellDB_ShellElementStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<ShellDB_ShellElementStatus>()._has_bits_);
  static void set_has_element(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_set_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ShellDB_ShellElementStatus::ShellDB_ShellElementStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ShellDB.ShellElementStatus)
}
ShellDB_ShellElementStatus::ShellDB_ShellElementStatus(const ShellDB_ShellElementStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  set_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    set_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_set_identifier()) {
    set_identifier_.Set(from._internal_set_identifier(), 
      GetArenaForAllocation());
  }
  element_ = from.element_;
  // @@protoc_insertion_point(copy_constructor:ei.ShellDB.ShellElementStatus)
}

inline void ShellDB_ShellElementStatus::SharedCtor() {
set_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  set_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
element_ = 1;
}

ShellDB_ShellElementStatus::~ShellDB_ShellElementStatus() {
  // @@protoc_insertion_point(destructor:ei.ShellDB.ShellElementStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShellDB_ShellElementStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  set_identifier_.Destroy();
}

void ShellDB_ShellElementStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShellDB_ShellElementStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ShellDB.ShellElementStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      set_identifier_.ClearNonDefaultToEmpty();
    }
    element_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShellDB_ShellElementStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.ShellDB.FarmElement element = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::ShellDB_FarmElement_IsValid(val))) {
            _internal_set_element(static_cast<::ei::ShellDB_FarmElement>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string set_identifier = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_set_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ShellDB.ShellElementStatus.set_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShellDB_ShellElementStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ShellDB.ShellElementStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.ShellDB.FarmElement element = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_element(), target);
  }

  // optional string set_identifier = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_set_identifier().data(), static_cast<int>(this->_internal_set_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellDB.ShellElementStatus.set_identifier");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_set_identifier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ShellDB.ShellElementStatus)
  return target;
}

size_t ShellDB_ShellElementStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ShellDB.ShellElementStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string set_identifier = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_set_identifier());
    }

    // optional .ei.ShellDB.FarmElement element = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_element());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShellDB_ShellElementStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ShellDB_ShellElementStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShellDB_ShellElementStatus::GetClassData() const { return &_class_data_; }

void ShellDB_ShellElementStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ShellDB_ShellElementStatus *>(to)->MergeFrom(
      static_cast<const ShellDB_ShellElementStatus &>(from));
}


void ShellDB_ShellElementStatus::MergeFrom(const ShellDB_ShellElementStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ShellDB.ShellElementStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_set_identifier(from._internal_set_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      element_ = from.element_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShellDB_ShellElementStatus::CopyFrom(const ShellDB_ShellElementStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ShellDB.ShellElementStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShellDB_ShellElementStatus::IsInitialized() const {
  return true;
}

void ShellDB_ShellElementStatus::InternalSwap(ShellDB_ShellElementStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &set_identifier_, lhs_arena,
      &other->set_identifier_, rhs_arena
  );
  swap(element_, other->element_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ShellDB_ShellElementStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[164]);
}

// ===================================================================

class ShellDB_ShellSetVariationStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<ShellDB_ShellSetVariationStatus>()._has_bits_);
  static void set_has_set_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ShellDB_ShellSetVariationStatus::ShellDB_ShellSetVariationStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  owned_variations_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ShellDB.ShellSetVariationStatus)
}
ShellDB_ShellSetVariationStatus::ShellDB_ShellSetVariationStatus(const ShellDB_ShellSetVariationStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      owned_variations_(from.owned_variations_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  set_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    set_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_set_identifier()) {
    set_identifier_.Set(from._internal_set_identifier(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:ei.ShellDB.ShellSetVariationStatus)
}

inline void ShellDB_ShellSetVariationStatus::SharedCtor() {
set_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  set_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ShellDB_ShellSetVariationStatus::~ShellDB_ShellSetVariationStatus() {
  // @@protoc_insertion_point(destructor:ei.ShellDB.ShellSetVariationStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShellDB_ShellSetVariationStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  set_identifier_.Destroy();
}

void ShellDB_ShellSetVariationStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShellDB_ShellSetVariationStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ShellDB.ShellSetVariationStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  owned_variations_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    set_identifier_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShellDB_ShellSetVariationStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string set_identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_set_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ShellDB.ShellSetVariationStatus.set_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated string owned_variations = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_owned_variations();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "ei.ShellDB.ShellSetVariationStatus.owned_variations");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShellDB_ShellSetVariationStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ShellDB.ShellSetVariationStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string set_identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_set_identifier().data(), static_cast<int>(this->_internal_set_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellDB.ShellSetVariationStatus.set_identifier");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_set_identifier(), target);
  }

  // repeated string owned_variations = 2;
  for (int i = 0, n = this->_internal_owned_variations_size(); i < n; i++) {
    const auto& s = this->_internal_owned_variations(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellDB.ShellSetVariationStatus.owned_variations");
    target = stream->WriteString(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ShellDB.ShellSetVariationStatus)
  return target;
}

size_t ShellDB_ShellSetVariationStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ShellDB.ShellSetVariationStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string owned_variations = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(owned_variations_.size());
  for (int i = 0, n = owned_variations_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      owned_variations_.Get(i));
  }

  // optional string set_identifier = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_set_identifier());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShellDB_ShellSetVariationStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ShellDB_ShellSetVariationStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShellDB_ShellSetVariationStatus::GetClassData() const { return &_class_data_; }

void ShellDB_ShellSetVariationStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ShellDB_ShellSetVariationStatus *>(to)->MergeFrom(
      static_cast<const ShellDB_ShellSetVariationStatus &>(from));
}


void ShellDB_ShellSetVariationStatus::MergeFrom(const ShellDB_ShellSetVariationStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ShellDB.ShellSetVariationStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  owned_variations_.MergeFrom(from.owned_variations_);
  if (from._internal_has_set_identifier()) {
    _internal_set_set_identifier(from._internal_set_identifier());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShellDB_ShellSetVariationStatus::CopyFrom(const ShellDB_ShellSetVariationStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ShellDB.ShellSetVariationStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShellDB_ShellSetVariationStatus::IsInitialized() const {
  return true;
}

void ShellDB_ShellSetVariationStatus::InternalSwap(ShellDB_ShellSetVariationStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  owned_variations_.InternalSwap(&other->owned_variations_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &set_identifier_, lhs_arena,
      &other->set_identifier_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ShellDB_ShellSetVariationStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[165]);
}

// ===================================================================

class ShellDB_FarmConfiguration::_Internal {
 public:
  using HasBits = decltype(std::declval<ShellDB_FarmConfiguration>()._has_bits_);
  static void set_has_configure_chickens_by_group(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ShellDB_FarmConfiguration::ShellDB_FarmConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  shell_configs_(arena),
  shell_set_configs_(arena),
  group_configs_(arena),
  chicken_configs_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ShellDB.FarmConfiguration)
}
ShellDB_FarmConfiguration::ShellDB_FarmConfiguration(const ShellDB_FarmConfiguration& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      shell_configs_(from.shell_configs_),
      shell_set_configs_(from.shell_set_configs_),
      group_configs_(from.group_configs_),
      chicken_configs_(from.chicken_configs_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  configure_chickens_by_group_ = from.configure_chickens_by_group_;
  // @@protoc_insertion_point(copy_constructor:ei.ShellDB.FarmConfiguration)
}

inline void ShellDB_FarmConfiguration::SharedCtor() {
configure_chickens_by_group_ = false;
}

ShellDB_FarmConfiguration::~ShellDB_FarmConfiguration() {
  // @@protoc_insertion_point(destructor:ei.ShellDB.FarmConfiguration)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShellDB_FarmConfiguration::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ShellDB_FarmConfiguration::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShellDB_FarmConfiguration::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ShellDB.FarmConfiguration)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  shell_configs_.Clear();
  shell_set_configs_.Clear();
  group_configs_.Clear();
  chicken_configs_.Clear();
  configure_chickens_by_group_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShellDB_FarmConfiguration::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .ei.ShellDB.ShellConfiguration shell_configs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_shell_configs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ShellDB.ShellSetConfiguration shell_set_configs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_shell_set_configs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool configure_chickens_by_group = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_configure_chickens_by_group(&has_bits);
          configure_chickens_by_group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ShellDB.ShellGroupConfiguration group_configs = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_group_configs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ShellDB.ChickenConfig chicken_configs = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_chicken_configs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShellDB_FarmConfiguration::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ShellDB.FarmConfiguration)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ei.ShellDB.ShellConfiguration shell_configs = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_shell_configs_size()); i < n; i++) {
    const auto& repfield = this->_internal_shell_configs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .ei.ShellDB.ShellSetConfiguration shell_set_configs = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_shell_set_configs_size()); i < n; i++) {
    const auto& repfield = this->_internal_shell_set_configs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool configure_chickens_by_group = 7;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_configure_chickens_by_group(), target);
  }

  // repeated .ei.ShellDB.ShellGroupConfiguration group_configs = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_group_configs_size()); i < n; i++) {
    const auto& repfield = this->_internal_group_configs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .ei.ShellDB.ChickenConfig chicken_configs = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_chicken_configs_size()); i < n; i++) {
    const auto& repfield = this->_internal_chicken_configs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ShellDB.FarmConfiguration)
  return target;
}

size_t ShellDB_FarmConfiguration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ShellDB.FarmConfiguration)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.ShellDB.ShellConfiguration shell_configs = 1;
  total_size += 1UL * this->_internal_shell_configs_size();
  for (const auto& msg : this->shell_configs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.ShellDB.ShellSetConfiguration shell_set_configs = 2;
  total_size += 1UL * this->_internal_shell_set_configs_size();
  for (const auto& msg : this->shell_set_configs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.ShellDB.ShellGroupConfiguration group_configs = 8;
  total_size += 1UL * this->_internal_group_configs_size();
  for (const auto& msg : this->group_configs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.ShellDB.ChickenConfig chicken_configs = 9;
  total_size += 1UL * this->_internal_chicken_configs_size();
  for (const auto& msg : this->chicken_configs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bool configure_chickens_by_group = 7;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShellDB_FarmConfiguration::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ShellDB_FarmConfiguration::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShellDB_FarmConfiguration::GetClassData() const { return &_class_data_; }

void ShellDB_FarmConfiguration::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ShellDB_FarmConfiguration *>(to)->MergeFrom(
      static_cast<const ShellDB_FarmConfiguration &>(from));
}


void ShellDB_FarmConfiguration::MergeFrom(const ShellDB_FarmConfiguration& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ShellDB.FarmConfiguration)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  shell_configs_.MergeFrom(from.shell_configs_);
  shell_set_configs_.MergeFrom(from.shell_set_configs_);
  group_configs_.MergeFrom(from.group_configs_);
  chicken_configs_.MergeFrom(from.chicken_configs_);
  if (from._internal_has_configure_chickens_by_group()) {
    _internal_set_configure_chickens_by_group(from._internal_configure_chickens_by_group());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShellDB_FarmConfiguration::CopyFrom(const ShellDB_FarmConfiguration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ShellDB.FarmConfiguration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShellDB_FarmConfiguration::IsInitialized() const {
  return true;
}

void ShellDB_FarmConfiguration::InternalSwap(ShellDB_FarmConfiguration* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  shell_configs_.InternalSwap(&other->shell_configs_);
  shell_set_configs_.InternalSwap(&other->shell_set_configs_);
  group_configs_.InternalSwap(&other->group_configs_);
  chicken_configs_.InternalSwap(&other->chicken_configs_);
  swap(configure_chickens_by_group_, other->configure_chickens_by_group_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ShellDB_FarmConfiguration::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[166]);
}

// ===================================================================

class ShellDB_SavedFarmConfiguration::_Internal {
 public:
  using HasBits = decltype(std::declval<ShellDB_SavedFarmConfiguration>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ei::ShellDB_FarmConfiguration& config(const ShellDB_SavedFarmConfiguration* msg);
  static void set_has_config(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_client_save_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::ei::ShellDB_FarmConfiguration&
ShellDB_SavedFarmConfiguration::_Internal::config(const ShellDB_SavedFarmConfiguration* msg) {
  return *msg->config_;
}
ShellDB_SavedFarmConfiguration::ShellDB_SavedFarmConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ShellDB.SavedFarmConfiguration)
}
ShellDB_SavedFarmConfiguration::ShellDB_SavedFarmConfiguration(const ShellDB_SavedFarmConfiguration& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_config()) {
    config_ = new ::ei::ShellDB_FarmConfiguration(*from.config_);
  } else {
    config_ = nullptr;
  }
  client_save_time_ = from.client_save_time_;
  // @@protoc_insertion_point(copy_constructor:ei.ShellDB.SavedFarmConfiguration)
}

inline void ShellDB_SavedFarmConfiguration::SharedCtor() {
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&config_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&client_save_time_) -
    reinterpret_cast<char*>(&config_)) + sizeof(client_save_time_));
}

ShellDB_SavedFarmConfiguration::~ShellDB_SavedFarmConfiguration() {
  // @@protoc_insertion_point(destructor:ei.ShellDB.SavedFarmConfiguration)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShellDB_SavedFarmConfiguration::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.Destroy();
  if (this != internal_default_instance()) delete config_;
}

void ShellDB_SavedFarmConfiguration::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShellDB_SavedFarmConfiguration::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ShellDB.SavedFarmConfiguration)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(config_ != nullptr);
      config_->Clear();
    }
  }
  client_save_time_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShellDB_SavedFarmConfiguration::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ShellDB.SavedFarmConfiguration.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .ei.ShellDB.FarmConfiguration config = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double client_save_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_client_save_time(&has_bits);
          client_save_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShellDB_SavedFarmConfiguration::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ShellDB.SavedFarmConfiguration)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellDB.SavedFarmConfiguration.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional .ei.ShellDB.FarmConfiguration config = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::config(this),
        _Internal::config(this).GetCachedSize(), target, stream);
  }

  // optional double client_save_time = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_client_save_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ShellDB.SavedFarmConfiguration)
  return target;
}

size_t ShellDB_SavedFarmConfiguration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ShellDB.SavedFarmConfiguration)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional .ei.ShellDB.FarmConfiguration config = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *config_);
    }

    // optional double client_save_time = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShellDB_SavedFarmConfiguration::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ShellDB_SavedFarmConfiguration::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShellDB_SavedFarmConfiguration::GetClassData() const { return &_class_data_; }

void ShellDB_SavedFarmConfiguration::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ShellDB_SavedFarmConfiguration *>(to)->MergeFrom(
      static_cast<const ShellDB_SavedFarmConfiguration &>(from));
}


void ShellDB_SavedFarmConfiguration::MergeFrom(const ShellDB_SavedFarmConfiguration& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ShellDB.SavedFarmConfiguration)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_config()->::ei::ShellDB_FarmConfiguration::MergeFrom(from._internal_config());
    }
    if (cached_has_bits & 0x00000004u) {
      client_save_time_ = from.client_save_time_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShellDB_SavedFarmConfiguration::CopyFrom(const ShellDB_SavedFarmConfiguration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ShellDB.SavedFarmConfiguration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShellDB_SavedFarmConfiguration::IsInitialized() const {
  return true;
}

void ShellDB_SavedFarmConfiguration::InternalSwap(ShellDB_SavedFarmConfiguration* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShellDB_SavedFarmConfiguration, client_save_time_)
      + sizeof(ShellDB_SavedFarmConfiguration::client_save_time_)
      - PROTOBUF_FIELD_OFFSET(ShellDB_SavedFarmConfiguration, config_)>(
          reinterpret_cast<char*>(&config_),
          reinterpret_cast<char*>(&other->config_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ShellDB_SavedFarmConfiguration::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[167]);
}

// ===================================================================

class ShellDB_ShellConfiguration::_Internal {
 public:
  using HasBits = decltype(std::declval<ShellDB_ShellConfiguration>()._has_bits_);
  static void set_has_asset_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_shell_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ShellDB_ShellConfiguration::ShellDB_ShellConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ShellDB.ShellConfiguration)
}
ShellDB_ShellConfiguration::ShellDB_ShellConfiguration(const ShellDB_ShellConfiguration& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  shell_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    shell_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_shell_identifier()) {
    shell_identifier_.Set(from._internal_shell_identifier(), 
      GetArenaForAllocation());
  }
  ::memcpy(&index_, &from.index_,
    static_cast<size_t>(reinterpret_cast<char*>(&asset_type_) -
    reinterpret_cast<char*>(&index_)) + sizeof(asset_type_));
  // @@protoc_insertion_point(copy_constructor:ei.ShellDB.ShellConfiguration)
}

inline void ShellDB_ShellConfiguration::SharedCtor() {
shell_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  shell_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
index_ = 0u;
asset_type_ = 1;
}

ShellDB_ShellConfiguration::~ShellDB_ShellConfiguration() {
  // @@protoc_insertion_point(destructor:ei.ShellDB.ShellConfiguration)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShellDB_ShellConfiguration::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  shell_identifier_.Destroy();
}

void ShellDB_ShellConfiguration::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShellDB_ShellConfiguration::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ShellDB.ShellConfiguration)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    shell_identifier_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    index_ = 0u;
    asset_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShellDB_ShellConfiguration::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.ShellSpec.AssetType asset_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::ShellSpec_AssetType_IsValid(val))) {
            _internal_set_asset_type(static_cast<::ei::ShellSpec_AssetType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_index(&has_bits);
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string shell_identifier = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_shell_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ShellDB.ShellConfiguration.shell_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShellDB_ShellConfiguration::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ShellDB.ShellConfiguration)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.ShellSpec.AssetType asset_type = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_asset_type(), target);
  }

  // optional uint32 index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_index(), target);
  }

  // optional string shell_identifier = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_shell_identifier().data(), static_cast<int>(this->_internal_shell_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellDB.ShellConfiguration.shell_identifier");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_shell_identifier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ShellDB.ShellConfiguration)
  return target;
}

size_t ShellDB_ShellConfiguration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ShellDB.ShellConfiguration)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string shell_identifier = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_shell_identifier());
    }

    // optional uint32 index = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_index());
    }

    // optional .ei.ShellSpec.AssetType asset_type = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_asset_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShellDB_ShellConfiguration::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ShellDB_ShellConfiguration::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShellDB_ShellConfiguration::GetClassData() const { return &_class_data_; }

void ShellDB_ShellConfiguration::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ShellDB_ShellConfiguration *>(to)->MergeFrom(
      static_cast<const ShellDB_ShellConfiguration &>(from));
}


void ShellDB_ShellConfiguration::MergeFrom(const ShellDB_ShellConfiguration& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ShellDB.ShellConfiguration)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_shell_identifier(from._internal_shell_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      index_ = from.index_;
    }
    if (cached_has_bits & 0x00000004u) {
      asset_type_ = from.asset_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShellDB_ShellConfiguration::CopyFrom(const ShellDB_ShellConfiguration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ShellDB.ShellConfiguration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShellDB_ShellConfiguration::IsInitialized() const {
  return true;
}

void ShellDB_ShellConfiguration::InternalSwap(ShellDB_ShellConfiguration* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &shell_identifier_, lhs_arena,
      &other->shell_identifier_, rhs_arena
  );
  swap(index_, other->index_);
  swap(asset_type_, other->asset_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ShellDB_ShellConfiguration::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[168]);
}

// ===================================================================

class ShellDB_ShellSetConfiguration::_Internal {
 public:
  using HasBits = decltype(std::declval<ShellDB_ShellSetConfiguration>()._has_bits_);
  static void set_has_element(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_shell_set_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_variation_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_decorator_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ShellDB_ShellSetConfiguration::ShellDB_ShellSetConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ShellDB.ShellSetConfiguration)
}
ShellDB_ShellSetConfiguration::ShellDB_ShellSetConfiguration(const ShellDB_ShellSetConfiguration& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  shell_set_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    shell_set_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_shell_set_identifier()) {
    shell_set_identifier_.Set(from._internal_shell_set_identifier(), 
      GetArenaForAllocation());
  }
  variation_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    variation_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_variation_identifier()) {
    variation_identifier_.Set(from._internal_variation_identifier(), 
      GetArenaForAllocation());
  }
  decorator_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    decorator_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_decorator_identifier()) {
    decorator_identifier_.Set(from._internal_decorator_identifier(), 
      GetArenaForAllocation());
  }
  ::memcpy(&index_, &from.index_,
    static_cast<size_t>(reinterpret_cast<char*>(&element_) -
    reinterpret_cast<char*>(&index_)) + sizeof(element_));
  // @@protoc_insertion_point(copy_constructor:ei.ShellDB.ShellSetConfiguration)
}

inline void ShellDB_ShellSetConfiguration::SharedCtor() {
shell_set_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  shell_set_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
variation_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  variation_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
decorator_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  decorator_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
index_ = 0u;
element_ = 1;
}

ShellDB_ShellSetConfiguration::~ShellDB_ShellSetConfiguration() {
  // @@protoc_insertion_point(destructor:ei.ShellDB.ShellSetConfiguration)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShellDB_ShellSetConfiguration::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  shell_set_identifier_.Destroy();
  variation_identifier_.Destroy();
  decorator_identifier_.Destroy();
}

void ShellDB_ShellSetConfiguration::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShellDB_ShellSetConfiguration::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ShellDB.ShellSetConfiguration)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      shell_set_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      variation_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      decorator_identifier_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    index_ = 0u;
    element_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShellDB_ShellSetConfiguration::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.ShellDB.FarmElement element = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::ShellDB_FarmElement_IsValid(val))) {
            _internal_set_element(static_cast<::ei::ShellDB_FarmElement>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_index(&has_bits);
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string shell_set_identifier = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_shell_set_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ShellDB.ShellSetConfiguration.shell_set_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string variation_identifier = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_variation_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ShellDB.ShellSetConfiguration.variation_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string decorator_identifier = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_decorator_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ShellDB.ShellSetConfiguration.decorator_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShellDB_ShellSetConfiguration::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ShellDB.ShellSetConfiguration)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.ShellDB.FarmElement element = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_element(), target);
  }

  // optional uint32 index = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_index(), target);
  }

  // optional string shell_set_identifier = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_shell_set_identifier().data(), static_cast<int>(this->_internal_shell_set_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellDB.ShellSetConfiguration.shell_set_identifier");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_shell_set_identifier(), target);
  }

  // optional string variation_identifier = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_variation_identifier().data(), static_cast<int>(this->_internal_variation_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellDB.ShellSetConfiguration.variation_identifier");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_variation_identifier(), target);
  }

  // optional string decorator_identifier = 5;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_decorator_identifier().data(), static_cast<int>(this->_internal_decorator_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellDB.ShellSetConfiguration.decorator_identifier");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_decorator_identifier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ShellDB.ShellSetConfiguration)
  return target;
}

size_t ShellDB_ShellSetConfiguration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ShellDB.ShellSetConfiguration)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string shell_set_identifier = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_shell_set_identifier());
    }

    // optional string variation_identifier = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_variation_identifier());
    }

    // optional string decorator_identifier = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_decorator_identifier());
    }

    // optional uint32 index = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_index());
    }

    // optional .ei.ShellDB.FarmElement element = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_element());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShellDB_ShellSetConfiguration::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ShellDB_ShellSetConfiguration::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShellDB_ShellSetConfiguration::GetClassData() const { return &_class_data_; }

void ShellDB_ShellSetConfiguration::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ShellDB_ShellSetConfiguration *>(to)->MergeFrom(
      static_cast<const ShellDB_ShellSetConfiguration &>(from));
}


void ShellDB_ShellSetConfiguration::MergeFrom(const ShellDB_ShellSetConfiguration& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ShellDB.ShellSetConfiguration)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_shell_set_identifier(from._internal_shell_set_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_variation_identifier(from._internal_variation_identifier());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_decorator_identifier(from._internal_decorator_identifier());
    }
    if (cached_has_bits & 0x00000008u) {
      index_ = from.index_;
    }
    if (cached_has_bits & 0x00000010u) {
      element_ = from.element_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShellDB_ShellSetConfiguration::CopyFrom(const ShellDB_ShellSetConfiguration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ShellDB.ShellSetConfiguration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShellDB_ShellSetConfiguration::IsInitialized() const {
  return true;
}

void ShellDB_ShellSetConfiguration::InternalSwap(ShellDB_ShellSetConfiguration* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &shell_set_identifier_, lhs_arena,
      &other->shell_set_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &variation_identifier_, lhs_arena,
      &other->variation_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &decorator_identifier_, lhs_arena,
      &other->decorator_identifier_, rhs_arena
  );
  swap(index_, other->index_);
  swap(element_, other->element_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ShellDB_ShellSetConfiguration::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[169]);
}

// ===================================================================

class ShellDB_ShellGroupConfiguration::_Internal {
 public:
  using HasBits = decltype(std::declval<ShellDB_ShellGroupConfiguration>()._has_bits_);
  static void set_has_asset_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_group_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ShellDB_ShellGroupConfiguration::ShellDB_ShellGroupConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ShellDB.ShellGroupConfiguration)
}
ShellDB_ShellGroupConfiguration::ShellDB_ShellGroupConfiguration(const ShellDB_ShellGroupConfiguration& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  group_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    group_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_group_identifier()) {
    group_identifier_.Set(from._internal_group_identifier(), 
      GetArenaForAllocation());
  }
  asset_type_ = from.asset_type_;
  // @@protoc_insertion_point(copy_constructor:ei.ShellDB.ShellGroupConfiguration)
}

inline void ShellDB_ShellGroupConfiguration::SharedCtor() {
group_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  group_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
asset_type_ = 1;
}

ShellDB_ShellGroupConfiguration::~ShellDB_ShellGroupConfiguration() {
  // @@protoc_insertion_point(destructor:ei.ShellDB.ShellGroupConfiguration)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShellDB_ShellGroupConfiguration::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  group_identifier_.Destroy();
}

void ShellDB_ShellGroupConfiguration::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShellDB_ShellGroupConfiguration::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ShellDB.ShellGroupConfiguration)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      group_identifier_.ClearNonDefaultToEmpty();
    }
    asset_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShellDB_ShellGroupConfiguration::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.ShellSpec.AssetType asset_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::ShellSpec_AssetType_IsValid(val))) {
            _internal_set_asset_type(static_cast<::ei::ShellSpec_AssetType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string group_identifier = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_group_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ShellDB.ShellGroupConfiguration.group_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShellDB_ShellGroupConfiguration::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ShellDB.ShellGroupConfiguration)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.ShellSpec.AssetType asset_type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_asset_type(), target);
  }

  // optional string group_identifier = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_group_identifier().data(), static_cast<int>(this->_internal_group_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellDB.ShellGroupConfiguration.group_identifier");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_group_identifier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ShellDB.ShellGroupConfiguration)
  return target;
}

size_t ShellDB_ShellGroupConfiguration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ShellDB.ShellGroupConfiguration)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string group_identifier = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_group_identifier());
    }

    // optional .ei.ShellSpec.AssetType asset_type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_asset_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShellDB_ShellGroupConfiguration::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ShellDB_ShellGroupConfiguration::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShellDB_ShellGroupConfiguration::GetClassData() const { return &_class_data_; }

void ShellDB_ShellGroupConfiguration::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ShellDB_ShellGroupConfiguration *>(to)->MergeFrom(
      static_cast<const ShellDB_ShellGroupConfiguration &>(from));
}


void ShellDB_ShellGroupConfiguration::MergeFrom(const ShellDB_ShellGroupConfiguration& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ShellDB.ShellGroupConfiguration)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_group_identifier(from._internal_group_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      asset_type_ = from.asset_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShellDB_ShellGroupConfiguration::CopyFrom(const ShellDB_ShellGroupConfiguration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ShellDB.ShellGroupConfiguration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShellDB_ShellGroupConfiguration::IsInitialized() const {
  return true;
}

void ShellDB_ShellGroupConfiguration::InternalSwap(ShellDB_ShellGroupConfiguration* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &group_identifier_, lhs_arena,
      &other->group_identifier_, rhs_arena
  );
  swap(asset_type_, other->asset_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ShellDB_ShellGroupConfiguration::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[170]);
}

// ===================================================================

class ShellDB_ChickenConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<ShellDB_ChickenConfig>()._has_bits_);
  static void set_has_chicken_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hat_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ShellDB_ChickenConfig::ShellDB_ChickenConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ShellDB.ChickenConfig)
}
ShellDB_ChickenConfig::ShellDB_ChickenConfig(const ShellDB_ChickenConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  chicken_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    chicken_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_chicken_identifier()) {
    chicken_identifier_.Set(from._internal_chicken_identifier(), 
      GetArenaForAllocation());
  }
  hat_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    hat_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hat_identifier()) {
    hat_identifier_.Set(from._internal_hat_identifier(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:ei.ShellDB.ChickenConfig)
}

inline void ShellDB_ChickenConfig::SharedCtor() {
chicken_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  chicken_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
hat_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  hat_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ShellDB_ChickenConfig::~ShellDB_ChickenConfig() {
  // @@protoc_insertion_point(destructor:ei.ShellDB.ChickenConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShellDB_ChickenConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  chicken_identifier_.Destroy();
  hat_identifier_.Destroy();
}

void ShellDB_ChickenConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShellDB_ChickenConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ShellDB.ChickenConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      chicken_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      hat_identifier_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShellDB_ChickenConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string chicken_identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_chicken_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ShellDB.ChickenConfig.chicken_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string hat_identifier = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_hat_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ShellDB.ChickenConfig.hat_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShellDB_ChickenConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ShellDB.ChickenConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string chicken_identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_chicken_identifier().data(), static_cast<int>(this->_internal_chicken_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellDB.ChickenConfig.chicken_identifier");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_chicken_identifier(), target);
  }

  // optional string hat_identifier = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_hat_identifier().data(), static_cast<int>(this->_internal_hat_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellDB.ChickenConfig.hat_identifier");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_hat_identifier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ShellDB.ChickenConfig)
  return target;
}

size_t ShellDB_ChickenConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ShellDB.ChickenConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string chicken_identifier = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_chicken_identifier());
    }

    // optional string hat_identifier = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_hat_identifier());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShellDB_ChickenConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ShellDB_ChickenConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShellDB_ChickenConfig::GetClassData() const { return &_class_data_; }

void ShellDB_ChickenConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ShellDB_ChickenConfig *>(to)->MergeFrom(
      static_cast<const ShellDB_ChickenConfig &>(from));
}


void ShellDB_ChickenConfig::MergeFrom(const ShellDB_ChickenConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ShellDB.ChickenConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_chicken_identifier(from._internal_chicken_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_hat_identifier(from._internal_hat_identifier());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShellDB_ChickenConfig::CopyFrom(const ShellDB_ChickenConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ShellDB.ChickenConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShellDB_ChickenConfig::IsInitialized() const {
  return true;
}

void ShellDB_ChickenConfig::InternalSwap(ShellDB_ChickenConfig* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &chicken_identifier_, lhs_arena,
      &other->chicken_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &hat_identifier_, lhs_arena,
      &other->hat_identifier_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ShellDB_ChickenConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[171]);
}

// ===================================================================

class ShellDB::_Internal {
 public:
};

ShellDB::ShellDB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  shell_inventory_(arena),
  shell_set_inventory_(arena),
  farm_configs_(arena),
  shell_object_inventory_(arena),
  shell_element_inventory_(arena),
  new_shells_downloaded_(arena),
  new_shells_seen_(arena),
  shell_variation_inventory_(arena),
  saved_configs_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ShellDB)
}
ShellDB::ShellDB(const ShellDB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      shell_inventory_(from.shell_inventory_),
      shell_set_inventory_(from.shell_set_inventory_),
      farm_configs_(from.farm_configs_),
      shell_object_inventory_(from.shell_object_inventory_),
      shell_element_inventory_(from.shell_element_inventory_),
      new_shells_downloaded_(from.new_shells_downloaded_),
      new_shells_seen_(from.new_shells_seen_),
      shell_variation_inventory_(from.shell_variation_inventory_),
      saved_configs_(from.saved_configs_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ei.ShellDB)
}

inline void ShellDB::SharedCtor() {
}

ShellDB::~ShellDB() {
  // @@protoc_insertion_point(destructor:ei.ShellDB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShellDB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ShellDB::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShellDB::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ShellDB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  shell_inventory_.Clear();
  shell_set_inventory_.Clear();
  farm_configs_.Clear();
  shell_object_inventory_.Clear();
  shell_element_inventory_.Clear();
  new_shells_downloaded_.Clear();
  new_shells_seen_.Clear();
  shell_variation_inventory_.Clear();
  saved_configs_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShellDB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .ei.ShellDB.ShellStatus shell_inventory = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_shell_inventory(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ShellDB.ShellStatus shell_set_inventory = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_shell_set_inventory(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ShellDB.FarmConfiguration farm_configs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_farm_configs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ShellDB.ShellStatus shell_object_inventory = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_shell_object_inventory(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ShellDB.ShellElementStatus shell_element_inventory = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_shell_element_inventory(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string new_shells_downloaded = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_new_shells_downloaded();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "ei.ShellDB.new_shells_downloaded");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string new_shells_seen = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_new_shells_seen();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "ei.ShellDB.new_shells_seen");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ShellDB.ShellSetVariationStatus shell_variation_inventory = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_shell_variation_inventory(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.ShellDB.SavedFarmConfiguration saved_configs = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_saved_configs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShellDB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ShellDB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ei.ShellDB.ShellStatus shell_inventory = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_shell_inventory_size()); i < n; i++) {
    const auto& repfield = this->_internal_shell_inventory(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .ei.ShellDB.ShellStatus shell_set_inventory = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_shell_set_inventory_size()); i < n; i++) {
    const auto& repfield = this->_internal_shell_set_inventory(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .ei.ShellDB.FarmConfiguration farm_configs = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_farm_configs_size()); i < n; i++) {
    const auto& repfield = this->_internal_farm_configs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .ei.ShellDB.ShellStatus shell_object_inventory = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_shell_object_inventory_size()); i < n; i++) {
    const auto& repfield = this->_internal_shell_object_inventory(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .ei.ShellDB.ShellElementStatus shell_element_inventory = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_shell_element_inventory_size()); i < n; i++) {
    const auto& repfield = this->_internal_shell_element_inventory(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string new_shells_downloaded = 6;
  for (int i = 0, n = this->_internal_new_shells_downloaded_size(); i < n; i++) {
    const auto& s = this->_internal_new_shells_downloaded(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellDB.new_shells_downloaded");
    target = stream->WriteString(6, s, target);
  }

  // repeated string new_shells_seen = 7;
  for (int i = 0, n = this->_internal_new_shells_seen_size(); i < n; i++) {
    const auto& s = this->_internal_new_shells_seen(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellDB.new_shells_seen");
    target = stream->WriteString(7, s, target);
  }

  // repeated .ei.ShellDB.ShellSetVariationStatus shell_variation_inventory = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_shell_variation_inventory_size()); i < n; i++) {
    const auto& repfield = this->_internal_shell_variation_inventory(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .ei.ShellDB.SavedFarmConfiguration saved_configs = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_saved_configs_size()); i < n; i++) {
    const auto& repfield = this->_internal_saved_configs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ShellDB)
  return target;
}

size_t ShellDB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ShellDB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.ShellDB.ShellStatus shell_inventory = 1;
  total_size += 1UL * this->_internal_shell_inventory_size();
  for (const auto& msg : this->shell_inventory_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.ShellDB.ShellStatus shell_set_inventory = 2;
  total_size += 1UL * this->_internal_shell_set_inventory_size();
  for (const auto& msg : this->shell_set_inventory_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.ShellDB.FarmConfiguration farm_configs = 3;
  total_size += 1UL * this->_internal_farm_configs_size();
  for (const auto& msg : this->farm_configs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.ShellDB.ShellStatus shell_object_inventory = 4;
  total_size += 1UL * this->_internal_shell_object_inventory_size();
  for (const auto& msg : this->shell_object_inventory_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.ShellDB.ShellElementStatus shell_element_inventory = 5;
  total_size += 1UL * this->_internal_shell_element_inventory_size();
  for (const auto& msg : this->shell_element_inventory_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string new_shells_downloaded = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(new_shells_downloaded_.size());
  for (int i = 0, n = new_shells_downloaded_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      new_shells_downloaded_.Get(i));
  }

  // repeated string new_shells_seen = 7;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(new_shells_seen_.size());
  for (int i = 0, n = new_shells_seen_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      new_shells_seen_.Get(i));
  }

  // repeated .ei.ShellDB.ShellSetVariationStatus shell_variation_inventory = 8;
  total_size += 1UL * this->_internal_shell_variation_inventory_size();
  for (const auto& msg : this->shell_variation_inventory_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ei.ShellDB.SavedFarmConfiguration saved_configs = 9;
  total_size += 1UL * this->_internal_saved_configs_size();
  for (const auto& msg : this->saved_configs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShellDB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ShellDB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShellDB::GetClassData() const { return &_class_data_; }

void ShellDB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ShellDB *>(to)->MergeFrom(
      static_cast<const ShellDB &>(from));
}


void ShellDB::MergeFrom(const ShellDB& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ShellDB)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  shell_inventory_.MergeFrom(from.shell_inventory_);
  shell_set_inventory_.MergeFrom(from.shell_set_inventory_);
  farm_configs_.MergeFrom(from.farm_configs_);
  shell_object_inventory_.MergeFrom(from.shell_object_inventory_);
  shell_element_inventory_.MergeFrom(from.shell_element_inventory_);
  new_shells_downloaded_.MergeFrom(from.new_shells_downloaded_);
  new_shells_seen_.MergeFrom(from.new_shells_seen_);
  shell_variation_inventory_.MergeFrom(from.shell_variation_inventory_);
  saved_configs_.MergeFrom(from.saved_configs_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShellDB::CopyFrom(const ShellDB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ShellDB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShellDB::IsInitialized() const {
  return true;
}

void ShellDB::InternalSwap(ShellDB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  shell_inventory_.InternalSwap(&other->shell_inventory_);
  shell_set_inventory_.InternalSwap(&other->shell_set_inventory_);
  farm_configs_.InternalSwap(&other->farm_configs_);
  shell_object_inventory_.InternalSwap(&other->shell_object_inventory_);
  shell_element_inventory_.InternalSwap(&other->shell_element_inventory_);
  new_shells_downloaded_.InternalSwap(&other->new_shells_downloaded_);
  new_shells_seen_.InternalSwap(&other->new_shells_seen_);
  shell_variation_inventory_.InternalSwap(&other->shell_variation_inventory_);
  saved_configs_.InternalSwap(&other->saved_configs_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ShellDB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[172]);
}

// ===================================================================

class ShellsActionLog::_Internal {
 public:
  using HasBits = decltype(std::declval<ShellsActionLog>()._has_bits_);
  static const ::ei::BasicRequestInfo& rinfo(const ShellsActionLog* msg);
  static void set_has_rinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_action(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sub_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_farm_element(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_approx_time(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_farm_index(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_soul_eggs(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_tickets_spent(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_gold_spent(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

const ::ei::BasicRequestInfo&
ShellsActionLog::_Internal::rinfo(const ShellsActionLog* msg) {
  return *msg->rinfo_;
}
ShellsActionLog::ShellsActionLog(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.ShellsActionLog)
}
ShellsActionLog::ShellsActionLog(const ShellsActionLog& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_id()) {
    user_id_.Set(from._internal_user_id(), 
      GetArenaForAllocation());
  }
  action_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    action_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_action()) {
    action_.Set(from._internal_action(), 
      GetArenaForAllocation());
  }
  sub_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sub_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sub_id()) {
    sub_id_.Set(from._internal_sub_id(), 
      GetArenaForAllocation());
  }
  version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_version()) {
    version_.Set(from._internal_version(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_rinfo()) {
    rinfo_ = new ::ei::BasicRequestInfo(*from.rinfo_);
  } else {
    rinfo_ = nullptr;
  }
  ::memcpy(&approx_time_, &from.approx_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&farm_element_) -
    reinterpret_cast<char*>(&approx_time_)) + sizeof(farm_element_));
  // @@protoc_insertion_point(copy_constructor:ei.ShellsActionLog)
}

inline void ShellsActionLog::SharedCtor() {
user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
action_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  action_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
sub_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sub_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rinfo_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&gold_spent_) -
    reinterpret_cast<char*>(&rinfo_)) + sizeof(gold_spent_));
farm_element_ = 1;
}

ShellsActionLog::~ShellsActionLog() {
  // @@protoc_insertion_point(destructor:ei.ShellsActionLog)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShellsActionLog::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_id_.Destroy();
  action_.Destroy();
  sub_id_.Destroy();
  version_.Destroy();
  if (this != internal_default_instance()) delete rinfo_;
}

void ShellsActionLog::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShellsActionLog::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.ShellsActionLog)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      user_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      action_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      sub_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(rinfo_ != nullptr);
      rinfo_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&approx_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&farm_index_) -
        reinterpret_cast<char*>(&approx_time_)) + sizeof(farm_index_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&soul_eggs_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gold_spent_) -
        reinterpret_cast<char*>(&soul_eggs_)) + sizeof(gold_spent_));
    farm_element_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShellsActionLog::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ShellsActionLog.user_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string action = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_action();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ShellsActionLog.action");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string sub_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_sub_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ShellsActionLog.sub_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 cost = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_cost(&has_bits);
          cost_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double approx_time = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_approx_time(&has_bits);
          approx_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional string version = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.ShellsActionLog.version");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 farm_index = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_farm_index(&has_bits);
          farm_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.BasicRequestInfo rinfo = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_rinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.ShellDB.FarmElement farm_element = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::ShellDB_FarmElement_IsValid(val))) {
            _internal_set_farm_element(static_cast<::ei::ShellDB_FarmElement>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional double soul_eggs = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _Internal::set_has_soul_eggs(&has_bits);
          soul_eggs_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 tickets_spent = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_tickets_spent(&has_bits);
          tickets_spent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 gold_spent = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_gold_spent(&has_bits);
          gold_spent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShellsActionLog::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.ShellsActionLog)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellsActionLog.user_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_id(), target);
  }

  // optional string action = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_action().data(), static_cast<int>(this->_internal_action().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellsActionLog.action");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_action(), target);
  }

  // optional string sub_id = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sub_id().data(), static_cast<int>(this->_internal_sub_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellsActionLog.sub_id");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_sub_id(), target);
  }

  // optional uint32 cost = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_cost(), target);
  }

  // optional double approx_time = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_approx_time(), target);
  }

  // optional string version = 6;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_version().data(), static_cast<int>(this->_internal_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.ShellsActionLog.version");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_version(), target);
  }

  // optional int32 farm_index = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_farm_index(), target);
  }

  // optional .ei.BasicRequestInfo rinfo = 8;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::rinfo(this),
        _Internal::rinfo(this).GetCachedSize(), target, stream);
  }

  // optional .ei.ShellDB.FarmElement farm_element = 9;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_farm_element(), target);
  }

  // optional double soul_eggs = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(10, this->_internal_soul_eggs(), target);
  }

  // optional uint64 tickets_spent = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(11, this->_internal_tickets_spent(), target);
  }

  // optional uint64 gold_spent = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(12, this->_internal_gold_spent(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.ShellsActionLog)
  return target;
}

size_t ShellsActionLog::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.ShellsActionLog)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string user_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_id());
    }

    // optional string action = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_action());
    }

    // optional string sub_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_sub_id());
    }

    // optional string version = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_version());
    }

    // optional .ei.BasicRequestInfo rinfo = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rinfo_);
    }

    // optional double approx_time = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional uint32 cost = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_cost());
    }

    // optional int32 farm_index = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_farm_index());
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional double soul_eggs = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 8;
    }

    // optional uint64 tickets_spent = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_tickets_spent());
    }

    // optional uint64 gold_spent = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_gold_spent());
    }

    // optional .ei.ShellDB.FarmElement farm_element = 9;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_farm_element());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShellsActionLog::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ShellsActionLog::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShellsActionLog::GetClassData() const { return &_class_data_; }

void ShellsActionLog::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ShellsActionLog *>(to)->MergeFrom(
      static_cast<const ShellsActionLog &>(from));
}


void ShellsActionLog::MergeFrom(const ShellsActionLog& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.ShellsActionLog)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_id(from._internal_user_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_action(from._internal_action());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_sub_id(from._internal_sub_id());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_version(from._internal_version());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_rinfo()->::ei::BasicRequestInfo::MergeFrom(from._internal_rinfo());
    }
    if (cached_has_bits & 0x00000020u) {
      approx_time_ = from.approx_time_;
    }
    if (cached_has_bits & 0x00000040u) {
      cost_ = from.cost_;
    }
    if (cached_has_bits & 0x00000080u) {
      farm_index_ = from.farm_index_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      soul_eggs_ = from.soul_eggs_;
    }
    if (cached_has_bits & 0x00000200u) {
      tickets_spent_ = from.tickets_spent_;
    }
    if (cached_has_bits & 0x00000400u) {
      gold_spent_ = from.gold_spent_;
    }
    if (cached_has_bits & 0x00000800u) {
      farm_element_ = from.farm_element_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShellsActionLog::CopyFrom(const ShellsActionLog& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.ShellsActionLog)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShellsActionLog::IsInitialized() const {
  return true;
}

void ShellsActionLog::InternalSwap(ShellsActionLog* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &action_, lhs_arena,
      &other->action_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sub_id_, lhs_arena,
      &other->sub_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &version_, lhs_arena,
      &other->version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShellsActionLog, gold_spent_)
      + sizeof(ShellsActionLog::gold_spent_)
      - PROTOBUF_FIELD_OFFSET(ShellsActionLog, rinfo_)>(
          reinterpret_cast<char*>(&rinfo_),
          reinterpret_cast<char*>(&other->rinfo_));
  swap(farm_element_, other->farm_element_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ShellsActionLog::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[173]);
}

// ===================================================================

class UserVerificationAnalysis::_Internal {
 public:
  using HasBits = decltype(std::declval<UserVerificationAnalysis>()._has_bits_);
  static void set_has_overall_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_start_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_completion_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_num_prestiges(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_soul_eggs(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_eggs_of_prophecy(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_iap_status(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_verified_pro_permit(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_verified_piggy_breaks(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_verified_other_iap(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_unverified_iap(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_gold_earned(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_regular_iap_buyer(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_regular_iap_cheater(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_artifacts_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_missions_completed(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_artifacts_collected(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_artifacts_consumed(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_artifacts_in_inventory(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_gold_spent_crafting(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_excessive_consumes(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_excessive_inventory(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_excessive_spend(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_contracts_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_num_coop_memberships(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_valid_contracts(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_excessive_eop(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_excessive_invalid_contracts(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_verified(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_verification_override(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_verification_override_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
};

UserVerificationAnalysis::UserVerificationAnalysis(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  invalid_contracts_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.UserVerificationAnalysis)
}
UserVerificationAnalysis::UserVerificationAnalysis(const UserVerificationAnalysis& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      invalid_contracts_(from.invalid_contracts_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&start_time_, &from.start_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&verification_override_value_) -
    reinterpret_cast<char*>(&start_time_)) + sizeof(verification_override_value_));
  // @@protoc_insertion_point(copy_constructor:ei.UserVerificationAnalysis)
}

inline void UserVerificationAnalysis::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&start_time_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&verification_override_value_) -
    reinterpret_cast<char*>(&start_time_)) + sizeof(verification_override_value_));
}

UserVerificationAnalysis::~UserVerificationAnalysis() {
  // @@protoc_insertion_point(destructor:ei.UserVerificationAnalysis)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserVerificationAnalysis::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UserVerificationAnalysis::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UserVerificationAnalysis::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.UserVerificationAnalysis)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  invalid_contracts_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&start_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&artifacts_consumed_) -
        reinterpret_cast<char*>(&start_time_)) + sizeof(artifacts_consumed_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&missions_completed_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&iap_status_) -
        reinterpret_cast<char*>(&missions_completed_)) + sizeof(iap_status_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&verified_pro_permit_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&eggs_of_prophecy_) -
        reinterpret_cast<char*>(&verified_pro_permit_)) + sizeof(eggs_of_prophecy_));
  }
  if (cached_has_bits & 0x7f000000u) {
    ::memset(&excessive_inventory_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&verification_override_value_) -
        reinterpret_cast<char*>(&excessive_inventory_)) + sizeof(verification_override_value_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UserVerificationAnalysis::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ei.UserVerificationAnalysis.Status overall_status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::UserVerificationAnalysis_Status_IsValid(val))) {
            _internal_set_overall_status(static_cast<::ei::UserVerificationAnalysis_Status>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional double start_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_start_time(&has_bits);
          start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double completion_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_completion_time(&has_bits);
          completion_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool verified_pro_permit = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_verified_pro_permit(&has_bits);
          verified_pro_permit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 verified_piggy_breaks = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_verified_piggy_breaks(&has_bits);
          verified_piggy_breaks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 verified_other_iap = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_verified_other_iap(&has_bits);
          verified_other_iap_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 unverified_iap = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_unverified_iap(&has_bits);
          unverified_iap_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 missions_completed = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_missions_completed(&has_bits);
          missions_completed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double artifacts_collected = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          _Internal::set_has_artifacts_collected(&has_bits);
          artifacts_collected_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double artifacts_consumed = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _Internal::set_has_artifacts_consumed(&has_bits);
          artifacts_consumed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double artifacts_in_inventory = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _Internal::set_has_artifacts_in_inventory(&has_bits);
          artifacts_in_inventory_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 num_coop_memberships = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_num_coop_memberships(&has_bits);
          num_coop_memberships_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double gold_earned = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 105)) {
          _Internal::set_has_gold_earned(&has_bits);
          gold_earned_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double num_prestiges = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 113)) {
          _Internal::set_has_num_prestiges(&has_bits);
          num_prestiges_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double soul_eggs = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 121)) {
          _Internal::set_has_soul_eggs(&has_bits);
          soul_eggs_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 valid_contracts = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_valid_contracts(&has_bits);
          valid_contracts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string invalid_contracts = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_invalid_contracts();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "ei.UserVerificationAnalysis.invalid_contracts");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<138>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .ei.UserVerificationAnalysis.Status iap_status = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::UserVerificationAnalysis_Status_IsValid(val))) {
            _internal_set_iap_status(static_cast<::ei::UserVerificationAnalysis_Status>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(18, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .ei.UserVerificationAnalysis.Status artifacts_status = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::UserVerificationAnalysis_Status_IsValid(val))) {
            _internal_set_artifacts_status(static_cast<::ei::UserVerificationAnalysis_Status>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(19, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .ei.UserVerificationAnalysis.Status contracts_status = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::UserVerificationAnalysis_Status_IsValid(val))) {
            _internal_set_contracts_status(static_cast<::ei::UserVerificationAnalysis_Status>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(20, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional double gold_spent_crafting = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 169)) {
          _Internal::set_has_gold_spent_crafting(&has_bits);
          gold_spent_crafting_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool regular_iap_buyer = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_regular_iap_buyer(&has_bits);
          regular_iap_buyer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool regular_iap_cheater = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_regular_iap_cheater(&has_bits);
          regular_iap_cheater_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool excessive_consumes = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_excessive_consumes(&has_bits);
          excessive_consumes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool excessive_inventory = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_excessive_inventory(&has_bits);
          excessive_inventory_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool excessive_spend = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_excessive_spend(&has_bits);
          excessive_spend_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 eggs_of_prophecy = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_eggs_of_prophecy(&has_bits);
          eggs_of_prophecy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool excessive_eop = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_excessive_eop(&has_bits);
          excessive_eop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool excessive_invalid_contracts = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_excessive_invalid_contracts(&has_bits);
          excessive_invalid_contracts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool verified = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          _Internal::set_has_verified(&has_bits);
          verified_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool verification_override = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _Internal::set_has_verification_override(&has_bits);
          verification_override_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool verification_override_value = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          _Internal::set_has_verification_override_value(&has_bits);
          verification_override_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserVerificationAnalysis::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.UserVerificationAnalysis)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ei.UserVerificationAnalysis.Status overall_status = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_overall_status(), target);
  }

  // optional double start_time = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_start_time(), target);
  }

  // optional double completion_time = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_completion_time(), target);
  }

  // optional bool verified_pro_permit = 4;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_verified_pro_permit(), target);
  }

  // optional uint32 verified_piggy_breaks = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_verified_piggy_breaks(), target);
  }

  // optional uint32 verified_other_iap = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_verified_other_iap(), target);
  }

  // optional uint32 unverified_iap = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_unverified_iap(), target);
  }

  // optional uint32 missions_completed = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_missions_completed(), target);
  }

  // optional double artifacts_collected = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(9, this->_internal_artifacts_collected(), target);
  }

  // optional double artifacts_consumed = 10;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(10, this->_internal_artifacts_consumed(), target);
  }

  // optional double artifacts_in_inventory = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(11, this->_internal_artifacts_in_inventory(), target);
  }

  // optional uint32 num_coop_memberships = 12;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_num_coop_memberships(), target);
  }

  // optional double gold_earned = 13;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(13, this->_internal_gold_earned(), target);
  }

  // optional double num_prestiges = 14;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(14, this->_internal_num_prestiges(), target);
  }

  // optional double soul_eggs = 15;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(15, this->_internal_soul_eggs(), target);
  }

  // optional uint32 valid_contracts = 16;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_valid_contracts(), target);
  }

  // repeated string invalid_contracts = 17;
  for (int i = 0, n = this->_internal_invalid_contracts_size(); i < n; i++) {
    const auto& s = this->_internal_invalid_contracts(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.UserVerificationAnalysis.invalid_contracts");
    target = stream->WriteString(17, s, target);
  }

  // optional .ei.UserVerificationAnalysis.Status iap_status = 18;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      18, this->_internal_iap_status(), target);
  }

  // optional .ei.UserVerificationAnalysis.Status artifacts_status = 19;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      19, this->_internal_artifacts_status(), target);
  }

  // optional .ei.UserVerificationAnalysis.Status contracts_status = 20;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      20, this->_internal_contracts_status(), target);
  }

  // optional double gold_spent_crafting = 21;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(21, this->_internal_gold_spent_crafting(), target);
  }

  // optional bool regular_iap_buyer = 22;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(22, this->_internal_regular_iap_buyer(), target);
  }

  // optional bool regular_iap_cheater = 23;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(23, this->_internal_regular_iap_cheater(), target);
  }

  // optional bool excessive_consumes = 24;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(24, this->_internal_excessive_consumes(), target);
  }

  // optional bool excessive_inventory = 25;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(25, this->_internal_excessive_inventory(), target);
  }

  // optional bool excessive_spend = 26;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(26, this->_internal_excessive_spend(), target);
  }

  // optional uint32 eggs_of_prophecy = 27;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(27, this->_internal_eggs_of_prophecy(), target);
  }

  // optional bool excessive_eop = 28;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(28, this->_internal_excessive_eop(), target);
  }

  // optional bool excessive_invalid_contracts = 29;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(29, this->_internal_excessive_invalid_contracts(), target);
  }

  // optional bool verified = 30;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(30, this->_internal_verified(), target);
  }

  // optional bool verification_override = 31;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(31, this->_internal_verification_override(), target);
  }

  // optional bool verification_override_value = 32;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(32, this->_internal_verification_override_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.UserVerificationAnalysis)
  return target;
}

size_t UserVerificationAnalysis::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.UserVerificationAnalysis)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string invalid_contracts = 17;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(invalid_contracts_.size());
  for (int i = 0, n = invalid_contracts_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      invalid_contracts_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional double start_time = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double completion_time = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional .ei.UserVerificationAnalysis.Status overall_status = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_overall_status());
    }

    // optional uint32 verified_piggy_breaks = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_verified_piggy_breaks());
    }

    // optional uint32 verified_other_iap = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_verified_other_iap());
    }

    // optional uint32 unverified_iap = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_unverified_iap());
    }

    // optional double artifacts_collected = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional double artifacts_consumed = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 missions_completed = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_missions_completed());
    }

    // optional uint32 num_coop_memberships = 12;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_coop_memberships());
    }

    // optional double artifacts_in_inventory = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 8;
    }

    // optional double gold_earned = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 8;
    }

    // optional double num_prestiges = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 8;
    }

    // optional double soul_eggs = 15;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 8;
    }

    // optional uint32 valid_contracts = 16;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_valid_contracts());
    }

    // optional .ei.UserVerificationAnalysis.Status iap_status = 18;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_iap_status());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional bool verified_pro_permit = 4;
    if (cached_has_bits & 0x00010000u) {
      total_size += 1 + 1;
    }

    // optional bool regular_iap_buyer = 22;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 1;
    }

    // optional bool regular_iap_cheater = 23;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 1;
    }

    // optional bool excessive_consumes = 24;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 1;
    }

    // optional .ei.UserVerificationAnalysis.Status artifacts_status = 19;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_artifacts_status());
    }

    // optional double gold_spent_crafting = 21;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 + 8;
    }

    // optional .ei.UserVerificationAnalysis.Status contracts_status = 20;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_contracts_status());
    }

    // optional uint32 eggs_of_prophecy = 27;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_eggs_of_prophecy());
    }

  }
  if (cached_has_bits & 0x7f000000u) {
    // optional bool excessive_inventory = 25;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + 1;
    }

    // optional bool excessive_spend = 26;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + 1;
    }

    // optional bool excessive_eop = 28;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 + 1;
    }

    // optional bool excessive_invalid_contracts = 29;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 + 1;
    }

    // optional bool verified = 30;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 + 1;
    }

    // optional bool verification_override = 31;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 + 1;
    }

    // optional bool verification_override_value = 32;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UserVerificationAnalysis::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UserVerificationAnalysis::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UserVerificationAnalysis::GetClassData() const { return &_class_data_; }

void UserVerificationAnalysis::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UserVerificationAnalysis *>(to)->MergeFrom(
      static_cast<const UserVerificationAnalysis &>(from));
}


void UserVerificationAnalysis::MergeFrom(const UserVerificationAnalysis& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.UserVerificationAnalysis)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  invalid_contracts_.MergeFrom(from.invalid_contracts_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      start_time_ = from.start_time_;
    }
    if (cached_has_bits & 0x00000002u) {
      completion_time_ = from.completion_time_;
    }
    if (cached_has_bits & 0x00000004u) {
      overall_status_ = from.overall_status_;
    }
    if (cached_has_bits & 0x00000008u) {
      verified_piggy_breaks_ = from.verified_piggy_breaks_;
    }
    if (cached_has_bits & 0x00000010u) {
      verified_other_iap_ = from.verified_other_iap_;
    }
    if (cached_has_bits & 0x00000020u) {
      unverified_iap_ = from.unverified_iap_;
    }
    if (cached_has_bits & 0x00000040u) {
      artifacts_collected_ = from.artifacts_collected_;
    }
    if (cached_has_bits & 0x00000080u) {
      artifacts_consumed_ = from.artifacts_consumed_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      missions_completed_ = from.missions_completed_;
    }
    if (cached_has_bits & 0x00000200u) {
      num_coop_memberships_ = from.num_coop_memberships_;
    }
    if (cached_has_bits & 0x00000400u) {
      artifacts_in_inventory_ = from.artifacts_in_inventory_;
    }
    if (cached_has_bits & 0x00000800u) {
      gold_earned_ = from.gold_earned_;
    }
    if (cached_has_bits & 0x00001000u) {
      num_prestiges_ = from.num_prestiges_;
    }
    if (cached_has_bits & 0x00002000u) {
      soul_eggs_ = from.soul_eggs_;
    }
    if (cached_has_bits & 0x00004000u) {
      valid_contracts_ = from.valid_contracts_;
    }
    if (cached_has_bits & 0x00008000u) {
      iap_status_ = from.iap_status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      verified_pro_permit_ = from.verified_pro_permit_;
    }
    if (cached_has_bits & 0x00020000u) {
      regular_iap_buyer_ = from.regular_iap_buyer_;
    }
    if (cached_has_bits & 0x00040000u) {
      regular_iap_cheater_ = from.regular_iap_cheater_;
    }
    if (cached_has_bits & 0x00080000u) {
      excessive_consumes_ = from.excessive_consumes_;
    }
    if (cached_has_bits & 0x00100000u) {
      artifacts_status_ = from.artifacts_status_;
    }
    if (cached_has_bits & 0x00200000u) {
      gold_spent_crafting_ = from.gold_spent_crafting_;
    }
    if (cached_has_bits & 0x00400000u) {
      contracts_status_ = from.contracts_status_;
    }
    if (cached_has_bits & 0x00800000u) {
      eggs_of_prophecy_ = from.eggs_of_prophecy_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x7f000000u) {
    if (cached_has_bits & 0x01000000u) {
      excessive_inventory_ = from.excessive_inventory_;
    }
    if (cached_has_bits & 0x02000000u) {
      excessive_spend_ = from.excessive_spend_;
    }
    if (cached_has_bits & 0x04000000u) {
      excessive_eop_ = from.excessive_eop_;
    }
    if (cached_has_bits & 0x08000000u) {
      excessive_invalid_contracts_ = from.excessive_invalid_contracts_;
    }
    if (cached_has_bits & 0x10000000u) {
      verified_ = from.verified_;
    }
    if (cached_has_bits & 0x20000000u) {
      verification_override_ = from.verification_override_;
    }
    if (cached_has_bits & 0x40000000u) {
      verification_override_value_ = from.verification_override_value_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UserVerificationAnalysis::CopyFrom(const UserVerificationAnalysis& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.UserVerificationAnalysis)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserVerificationAnalysis::IsInitialized() const {
  return true;
}

void UserVerificationAnalysis::InternalSwap(UserVerificationAnalysis* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  invalid_contracts_.InternalSwap(&other->invalid_contracts_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserVerificationAnalysis, verification_override_value_)
      + sizeof(UserVerificationAnalysis::verification_override_value_)
      - PROTOBUF_FIELD_OFFSET(UserVerificationAnalysis, start_time_)>(
          reinterpret_cast<char*>(&start_time_),
          reinterpret_cast<char*>(&other->start_time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UserVerificationAnalysis::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[174]);
}

// ===================================================================

class UserSubscriptionInfo_HistoryEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<UserSubscriptionInfo_HistoryEntry>()._has_bits_);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_message_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

UserSubscriptionInfo_HistoryEntry::UserSubscriptionInfo_HistoryEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.UserSubscriptionInfo.HistoryEntry)
}
UserSubscriptionInfo_HistoryEntry::UserSubscriptionInfo_HistoryEntry(const UserSubscriptionInfo_HistoryEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  message_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    message_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message_id()) {
    message_id_.Set(from._internal_message_id(), 
      GetArenaForAllocation());
  }
  message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    message_.Set(from._internal_message(), 
      GetArenaForAllocation());
  }
  timestamp_ = from.timestamp_;
  // @@protoc_insertion_point(copy_constructor:ei.UserSubscriptionInfo.HistoryEntry)
}

inline void UserSubscriptionInfo_HistoryEntry::SharedCtor() {
message_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  message_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
timestamp_ = 0;
}

UserSubscriptionInfo_HistoryEntry::~UserSubscriptionInfo_HistoryEntry() {
  // @@protoc_insertion_point(destructor:ei.UserSubscriptionInfo.HistoryEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserSubscriptionInfo_HistoryEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  message_id_.Destroy();
  message_.Destroy();
}

void UserSubscriptionInfo_HistoryEntry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UserSubscriptionInfo_HistoryEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.UserSubscriptionInfo.HistoryEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      message_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      message_.ClearNonDefaultToEmpty();
    }
  }
  timestamp_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UserSubscriptionInfo_HistoryEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_timestamp(&has_bits);
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional string message_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_message_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.UserSubscriptionInfo.HistoryEntry.message_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string message = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.UserSubscriptionInfo.HistoryEntry.message");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserSubscriptionInfo_HistoryEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.UserSubscriptionInfo.HistoryEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double timestamp = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_timestamp(), target);
  }

  // optional string message_id = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_message_id().data(), static_cast<int>(this->_internal_message_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.UserSubscriptionInfo.HistoryEntry.message_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_message_id(), target);
  }

  // optional string message = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_message().data(), static_cast<int>(this->_internal_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.UserSubscriptionInfo.HistoryEntry.message");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.UserSubscriptionInfo.HistoryEntry)
  return target;
}

size_t UserSubscriptionInfo_HistoryEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.UserSubscriptionInfo.HistoryEntry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string message_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_message_id());
    }

    // optional string message = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_message());
    }

    // optional double timestamp = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UserSubscriptionInfo_HistoryEntry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UserSubscriptionInfo_HistoryEntry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UserSubscriptionInfo_HistoryEntry::GetClassData() const { return &_class_data_; }

void UserSubscriptionInfo_HistoryEntry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UserSubscriptionInfo_HistoryEntry *>(to)->MergeFrom(
      static_cast<const UserSubscriptionInfo_HistoryEntry &>(from));
}


void UserSubscriptionInfo_HistoryEntry::MergeFrom(const UserSubscriptionInfo_HistoryEntry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.UserSubscriptionInfo.HistoryEntry)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_message_id(from._internal_message_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000004u) {
      timestamp_ = from.timestamp_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UserSubscriptionInfo_HistoryEntry::CopyFrom(const UserSubscriptionInfo_HistoryEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.UserSubscriptionInfo.HistoryEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserSubscriptionInfo_HistoryEntry::IsInitialized() const {
  return true;
}

void UserSubscriptionInfo_HistoryEntry::InternalSwap(UserSubscriptionInfo_HistoryEntry* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &message_id_, lhs_arena,
      &other->message_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &message_, lhs_arena,
      &other->message_, rhs_arena
  );
  swap(timestamp_, other->timestamp_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UserSubscriptionInfo_HistoryEntry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[175]);
}

// ===================================================================

class UserSubscriptionInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<UserSubscriptionInfo>()._has_bits_);
  static void set_has_subscription_level(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_next_subscription_level(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_lock_next_subscription_level(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_platform(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_original_transaction_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_linked_transaction_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_acknowledged(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_first_subscribed(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_period_end(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_store_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_auto_renew(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_sandbox(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_last_updated(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

UserSubscriptionInfo::UserSubscriptionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  history_(arena),
  past_user_ids_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.UserSubscriptionInfo)
}
UserSubscriptionInfo::UserSubscriptionInfo(const UserSubscriptionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      history_(from.history_),
      past_user_ids_(from.past_user_ids_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  original_transaction_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    original_transaction_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_original_transaction_id()) {
    original_transaction_id_.Set(from._internal_original_transaction_id(), 
      GetArenaForAllocation());
  }
  store_status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    store_status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_store_status()) {
    store_status_.Set(from._internal_store_status(), 
      GetArenaForAllocation());
  }
  linked_transaction_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    linked_transaction_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_linked_transaction_id()) {
    linked_transaction_id_.Set(from._internal_linked_transaction_id(), 
      GetArenaForAllocation());
  }
  ::memcpy(&first_subscribed_, &from.first_subscribed_,
    static_cast<size_t>(reinterpret_cast<char*>(&platform_) -
    reinterpret_cast<char*>(&first_subscribed_)) + sizeof(platform_));
  // @@protoc_insertion_point(copy_constructor:ei.UserSubscriptionInfo)
}

inline void UserSubscriptionInfo::SharedCtor() {
original_transaction_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  original_transaction_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
store_status_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  store_status_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
linked_transaction_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  linked_transaction_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&first_subscribed_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&sandbox_) -
    reinterpret_cast<char*>(&first_subscribed_)) + sizeof(sandbox_));
platform_ = 1;
}

UserSubscriptionInfo::~UserSubscriptionInfo() {
  // @@protoc_insertion_point(destructor:ei.UserSubscriptionInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserSubscriptionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  original_transaction_id_.Destroy();
  store_status_.Destroy();
  linked_transaction_id_.Destroy();
}

void UserSubscriptionInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UserSubscriptionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.UserSubscriptionInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  history_.Clear();
  past_user_ids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      original_transaction_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      store_status_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      linked_transaction_id_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&first_subscribed_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&subscription_level_) -
        reinterpret_cast<char*>(&first_subscribed_)) + sizeof(subscription_level_));
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&next_subscription_level_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&sandbox_) -
        reinterpret_cast<char*>(&next_subscription_level_)) + sizeof(sandbox_));
    platform_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UserSubscriptionInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string original_transaction_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_original_transaction_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.UserSubscriptionInfo.original_transaction_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double first_subscribed = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_first_subscribed(&has_bits);
          first_subscribed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double period_end = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_period_end(&has_bits);
          period_end_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .ei.UserSubscriptionInfo.Status status = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::UserSubscriptionInfo_Status_IsValid(val))) {
            _internal_set_status(static_cast<::ei::UserSubscriptionInfo_Status>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool auto_renew = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_auto_renew(&has_bits);
          auto_renew_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double last_updated = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _Internal::set_has_last_updated(&has_bits);
          last_updated_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated .ei.UserSubscriptionInfo.HistoryEntry history = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_history(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .ei.Platform platform = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::Platform_IsValid(val))) {
            _internal_set_platform(static_cast<::ei::Platform>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated string past_user_ids = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_past_user_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "ei.UserSubscriptionInfo.past_user_ids");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .ei.UserSubscriptionInfo.Level subscription_level = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::UserSubscriptionInfo_Level_IsValid(val))) {
            _internal_set_subscription_level(static_cast<::ei::UserSubscriptionInfo_Level>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(13, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string store_status = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_store_status();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.UserSubscriptionInfo.store_status");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .ei.UserSubscriptionInfo.Level next_subscription_level = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::UserSubscriptionInfo_Level_IsValid(val))) {
            _internal_set_next_subscription_level(static_cast<::ei::UserSubscriptionInfo_Level>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(15, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string linked_transaction_id = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          auto str = _internal_mutable_linked_transaction_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.UserSubscriptionInfo.linked_transaction_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool acknowledged = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_acknowledged(&has_bits);
          acknowledged_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool lock_next_subscription_level = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_lock_next_subscription_level(&has_bits);
          lock_next_subscription_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool sandbox = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_sandbox(&has_bits);
          sandbox_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserSubscriptionInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.UserSubscriptionInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string original_transaction_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_original_transaction_id().data(), static_cast<int>(this->_internal_original_transaction_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.UserSubscriptionInfo.original_transaction_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_original_transaction_id(), target);
  }

  // optional double first_subscribed = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_first_subscribed(), target);
  }

  // optional double period_end = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_period_end(), target);
  }

  // optional .ei.UserSubscriptionInfo.Status status = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_status(), target);
  }

  // optional bool auto_renew = 6;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_auto_renew(), target);
  }

  // optional double last_updated = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_last_updated(), target);
  }

  // repeated .ei.UserSubscriptionInfo.HistoryEntry history = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_history_size()); i < n; i++) {
    const auto& repfield = this->_internal_history(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .ei.Platform platform = 10;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      10, this->_internal_platform(), target);
  }

  // repeated string past_user_ids = 11;
  for (int i = 0, n = this->_internal_past_user_ids_size(); i < n; i++) {
    const auto& s = this->_internal_past_user_ids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.UserSubscriptionInfo.past_user_ids");
    target = stream->WriteString(11, s, target);
  }

  // optional .ei.UserSubscriptionInfo.Level subscription_level = 13;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      13, this->_internal_subscription_level(), target);
  }

  // optional string store_status = 14;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_store_status().data(), static_cast<int>(this->_internal_store_status().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.UserSubscriptionInfo.store_status");
    target = stream->WriteStringMaybeAliased(
        14, this->_internal_store_status(), target);
  }

  // optional .ei.UserSubscriptionInfo.Level next_subscription_level = 15;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      15, this->_internal_next_subscription_level(), target);
  }

  // optional string linked_transaction_id = 16;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_linked_transaction_id().data(), static_cast<int>(this->_internal_linked_transaction_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.UserSubscriptionInfo.linked_transaction_id");
    target = stream->WriteStringMaybeAliased(
        16, this->_internal_linked_transaction_id(), target);
  }

  // optional bool acknowledged = 17;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(17, this->_internal_acknowledged(), target);
  }

  // optional bool lock_next_subscription_level = 18;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(18, this->_internal_lock_next_subscription_level(), target);
  }

  // optional bool sandbox = 19;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(19, this->_internal_sandbox(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.UserSubscriptionInfo)
  return target;
}

size_t UserSubscriptionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.UserSubscriptionInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ei.UserSubscriptionInfo.HistoryEntry history = 9;
  total_size += 1UL * this->_internal_history_size();
  for (const auto& msg : this->history_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string past_user_ids = 11;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(past_user_ids_.size());
  for (int i = 0, n = past_user_ids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      past_user_ids_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string original_transaction_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_original_transaction_id());
    }

    // optional string store_status = 14;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_store_status());
    }

    // optional string linked_transaction_id = 16;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_linked_transaction_id());
    }

    // optional double first_subscribed = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double period_end = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double last_updated = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional .ei.UserSubscriptionInfo.Status status = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
    }

    // optional .ei.UserSubscriptionInfo.Level subscription_level = 13;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_subscription_level());
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional .ei.UserSubscriptionInfo.Level next_subscription_level = 15;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_next_subscription_level());
    }

    // optional bool lock_next_subscription_level = 18;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 + 1;
    }

    // optional bool acknowledged = 17;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 + 1;
    }

    // optional bool auto_renew = 6;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool sandbox = 19;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + 1;
    }

    // optional .ei.Platform platform = 10;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_platform());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UserSubscriptionInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UserSubscriptionInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UserSubscriptionInfo::GetClassData() const { return &_class_data_; }

void UserSubscriptionInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UserSubscriptionInfo *>(to)->MergeFrom(
      static_cast<const UserSubscriptionInfo &>(from));
}


void UserSubscriptionInfo::MergeFrom(const UserSubscriptionInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.UserSubscriptionInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  history_.MergeFrom(from.history_);
  past_user_ids_.MergeFrom(from.past_user_ids_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_original_transaction_id(from._internal_original_transaction_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_store_status(from._internal_store_status());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_linked_transaction_id(from._internal_linked_transaction_id());
    }
    if (cached_has_bits & 0x00000008u) {
      first_subscribed_ = from.first_subscribed_;
    }
    if (cached_has_bits & 0x00000010u) {
      period_end_ = from.period_end_;
    }
    if (cached_has_bits & 0x00000020u) {
      last_updated_ = from.last_updated_;
    }
    if (cached_has_bits & 0x00000040u) {
      status_ = from.status_;
    }
    if (cached_has_bits & 0x00000080u) {
      subscription_level_ = from.subscription_level_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      next_subscription_level_ = from.next_subscription_level_;
    }
    if (cached_has_bits & 0x00000200u) {
      lock_next_subscription_level_ = from.lock_next_subscription_level_;
    }
    if (cached_has_bits & 0x00000400u) {
      acknowledged_ = from.acknowledged_;
    }
    if (cached_has_bits & 0x00000800u) {
      auto_renew_ = from.auto_renew_;
    }
    if (cached_has_bits & 0x00001000u) {
      sandbox_ = from.sandbox_;
    }
    if (cached_has_bits & 0x00002000u) {
      platform_ = from.platform_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UserSubscriptionInfo::CopyFrom(const UserSubscriptionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.UserSubscriptionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserSubscriptionInfo::IsInitialized() const {
  return true;
}

void UserSubscriptionInfo::InternalSwap(UserSubscriptionInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  history_.InternalSwap(&other->history_);
  past_user_ids_.InternalSwap(&other->past_user_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &original_transaction_id_, lhs_arena,
      &other->original_transaction_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &store_status_, lhs_arena,
      &other->store_status_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &linked_transaction_id_, lhs_arena,
      &other->linked_transaction_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserSubscriptionInfo, sandbox_)
      + sizeof(UserSubscriptionInfo::sandbox_)
      - PROTOBUF_FIELD_OFFSET(UserSubscriptionInfo, first_subscribed_)>(
          reinterpret_cast<char*>(&first_subscribed_),
          reinterpret_cast<char*>(&other->first_subscribed_));
  swap(platform_, other->platform_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UserSubscriptionInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[176]);
}

// ===================================================================

class SubscriptionChangeHintRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<SubscriptionChangeHintRequest>()._has_bits_);
  static const ::ei::BasicRequestInfo& rinfo(const SubscriptionChangeHintRequest* msg);
  static void set_has_rinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_original_transaction_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_next_subscription_level(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::ei::BasicRequestInfo&
SubscriptionChangeHintRequest::_Internal::rinfo(const SubscriptionChangeHintRequest* msg) {
  return *msg->rinfo_;
}
SubscriptionChangeHintRequest::SubscriptionChangeHintRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.SubscriptionChangeHintRequest)
}
SubscriptionChangeHintRequest::SubscriptionChangeHintRequest(const SubscriptionChangeHintRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  original_transaction_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    original_transaction_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_original_transaction_id()) {
    original_transaction_id_.Set(from._internal_original_transaction_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_rinfo()) {
    rinfo_ = new ::ei::BasicRequestInfo(*from.rinfo_);
  } else {
    rinfo_ = nullptr;
  }
  next_subscription_level_ = from.next_subscription_level_;
  // @@protoc_insertion_point(copy_constructor:ei.SubscriptionChangeHintRequest)
}

inline void SubscriptionChangeHintRequest::SharedCtor() {
original_transaction_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  original_transaction_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rinfo_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&next_subscription_level_) -
    reinterpret_cast<char*>(&rinfo_)) + sizeof(next_subscription_level_));
}

SubscriptionChangeHintRequest::~SubscriptionChangeHintRequest() {
  // @@protoc_insertion_point(destructor:ei.SubscriptionChangeHintRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubscriptionChangeHintRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  original_transaction_id_.Destroy();
  if (this != internal_default_instance()) delete rinfo_;
}

void SubscriptionChangeHintRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SubscriptionChangeHintRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.SubscriptionChangeHintRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      original_transaction_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(rinfo_ != nullptr);
      rinfo_->Clear();
    }
  }
  next_subscription_level_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubscriptionChangeHintRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string original_transaction_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_original_transaction_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.SubscriptionChangeHintRequest.original_transaction_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .ei.UserSubscriptionInfo.Level next_subscription_level = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ei::UserSubscriptionInfo_Level_IsValid(val))) {
            _internal_set_next_subscription_level(static_cast<::ei::UserSubscriptionInfo_Level>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .ei.BasicRequestInfo rinfo = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_rinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SubscriptionChangeHintRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.SubscriptionChangeHintRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string original_transaction_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_original_transaction_id().data(), static_cast<int>(this->_internal_original_transaction_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.SubscriptionChangeHintRequest.original_transaction_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_original_transaction_id(), target);
  }

  // optional .ei.UserSubscriptionInfo.Level next_subscription_level = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_next_subscription_level(), target);
  }

  // optional .ei.BasicRequestInfo rinfo = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::rinfo(this),
        _Internal::rinfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.SubscriptionChangeHintRequest)
  return target;
}

size_t SubscriptionChangeHintRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.SubscriptionChangeHintRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string original_transaction_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_original_transaction_id());
    }

    // optional .ei.BasicRequestInfo rinfo = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rinfo_);
    }

    // optional .ei.UserSubscriptionInfo.Level next_subscription_level = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_next_subscription_level());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubscriptionChangeHintRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SubscriptionChangeHintRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubscriptionChangeHintRequest::GetClassData() const { return &_class_data_; }

void SubscriptionChangeHintRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SubscriptionChangeHintRequest *>(to)->MergeFrom(
      static_cast<const SubscriptionChangeHintRequest &>(from));
}


void SubscriptionChangeHintRequest::MergeFrom(const SubscriptionChangeHintRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.SubscriptionChangeHintRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_original_transaction_id(from._internal_original_transaction_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_rinfo()->::ei::BasicRequestInfo::MergeFrom(from._internal_rinfo());
    }
    if (cached_has_bits & 0x00000004u) {
      next_subscription_level_ = from.next_subscription_level_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubscriptionChangeHintRequest::CopyFrom(const SubscriptionChangeHintRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.SubscriptionChangeHintRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubscriptionChangeHintRequest::IsInitialized() const {
  return true;
}

void SubscriptionChangeHintRequest::InternalSwap(SubscriptionChangeHintRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &original_transaction_id_, lhs_arena,
      &other->original_transaction_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SubscriptionChangeHintRequest, next_subscription_level_)
      + sizeof(SubscriptionChangeHintRequest::next_subscription_level_)
      - PROTOBUF_FIELD_OFFSET(SubscriptionChangeHintRequest, rinfo_)>(
          reinterpret_cast<char*>(&rinfo_),
          reinterpret_cast<char*>(&other->rinfo_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SubscriptionChangeHintRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[177]);
}

// ===================================================================

class CXPEvalRolloutInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CXPEvalRolloutInfo>()._has_bits_);
  static void set_has_current_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_basis_points(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CXPEvalRolloutInfo::CXPEvalRolloutInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ei.CXPEvalRolloutInfo)
}
CXPEvalRolloutInfo::CXPEvalRolloutInfo(const CXPEvalRolloutInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  current_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    current_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_current_id()) {
    current_id_.Set(from._internal_current_id(), 
      GetArenaForAllocation());
  }
  basis_points_ = from.basis_points_;
  // @@protoc_insertion_point(copy_constructor:ei.CXPEvalRolloutInfo)
}

inline void CXPEvalRolloutInfo::SharedCtor() {
current_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  current_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
basis_points_ = 0u;
}

CXPEvalRolloutInfo::~CXPEvalRolloutInfo() {
  // @@protoc_insertion_point(destructor:ei.CXPEvalRolloutInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CXPEvalRolloutInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  current_id_.Destroy();
}

void CXPEvalRolloutInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CXPEvalRolloutInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:ei.CXPEvalRolloutInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    current_id_.ClearNonDefaultToEmpty();
  }
  basis_points_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CXPEvalRolloutInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string current_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_current_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "ei.CXPEvalRolloutInfo.current_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 basis_points = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_basis_points(&has_bits);
          basis_points_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CXPEvalRolloutInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ei.CXPEvalRolloutInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string current_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_current_id().data(), static_cast<int>(this->_internal_current_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ei.CXPEvalRolloutInfo.current_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_current_id(), target);
  }

  // optional uint32 basis_points = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_basis_points(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ei.CXPEvalRolloutInfo)
  return target;
}

size_t CXPEvalRolloutInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ei.CXPEvalRolloutInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string current_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_current_id());
    }

    // optional uint32 basis_points = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_basis_points());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CXPEvalRolloutInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CXPEvalRolloutInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CXPEvalRolloutInfo::GetClassData() const { return &_class_data_; }

void CXPEvalRolloutInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CXPEvalRolloutInfo *>(to)->MergeFrom(
      static_cast<const CXPEvalRolloutInfo &>(from));
}


void CXPEvalRolloutInfo::MergeFrom(const CXPEvalRolloutInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ei.CXPEvalRolloutInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_current_id(from._internal_current_id());
    }
    if (cached_has_bits & 0x00000002u) {
      basis_points_ = from.basis_points_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CXPEvalRolloutInfo::CopyFrom(const CXPEvalRolloutInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ei.CXPEvalRolloutInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CXPEvalRolloutInfo::IsInitialized() const {
  return true;
}

void CXPEvalRolloutInfo::InternalSwap(CXPEvalRolloutInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &current_id_, lhs_arena,
      &other->current_id_, rhs_arena
  );
  swap(basis_points_, other->basis_points_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CXPEvalRolloutInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ei_2eproto_getter, &descriptor_table_ei_2eproto_once,
      file_level_metadata_ei_2eproto[178]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace ei
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::ei::Backup_Settings*
Arena::CreateMaybeMessage< ::ei::Backup_Settings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::Backup_Settings >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::Backup_Tutorial*
Arena::CreateMaybeMessage< ::ei::Backup_Tutorial >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::Backup_Tutorial >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::Backup_Stats*
Arena::CreateMaybeMessage< ::ei::Backup_Stats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::Backup_Stats >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::Backup_Game*
Arena::CreateMaybeMessage< ::ei::Backup_Game >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::Backup_Game >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::Backup_Artifacts*
Arena::CreateMaybeMessage< ::ei::Backup_Artifacts >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::Backup_Artifacts >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::Backup_Shells*
Arena::CreateMaybeMessage< ::ei::Backup_Shells >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::Backup_Shells >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::Backup_Simulation*
Arena::CreateMaybeMessage< ::ei::Backup_Simulation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::Backup_Simulation >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::Backup_Mission*
Arena::CreateMaybeMessage< ::ei::Backup_Mission >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::Backup_Mission >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::Backup_Misc*
Arena::CreateMaybeMessage< ::ei::Backup_Misc >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::Backup_Misc >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::Backup_ResearchItem*
Arena::CreateMaybeMessage< ::ei::Backup_ResearchItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::Backup_ResearchItem >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::Backup_NewsHeadline*
Arena::CreateMaybeMessage< ::ei::Backup_NewsHeadline >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::Backup_NewsHeadline >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::Backup_AchievementInfo*
Arena::CreateMaybeMessage< ::ei::Backup_AchievementInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::Backup_AchievementInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::Backup_ActiveBoost*
Arena::CreateMaybeMessage< ::ei::Backup_ActiveBoost >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::Backup_ActiveBoost >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::Backup_OwnedBoost*
Arena::CreateMaybeMessage< ::ei::Backup_OwnedBoost >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::Backup_OwnedBoost >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::Backup_MissionInfo*
Arena::CreateMaybeMessage< ::ei::Backup_MissionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::Backup_MissionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::Backup*
Arena::CreateMaybeMessage< ::ei::Backup >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::Backup >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::EggIncFirstContactRequest*
Arena::CreateMaybeMessage< ::ei::EggIncFirstContactRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::EggIncFirstContactRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::EggIncFirstContactResponse*
Arena::CreateMaybeMessage< ::ei::EggIncFirstContactResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::EggIncFirstContactResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::EggIncAdConfig*
Arena::CreateMaybeMessage< ::ei::EggIncAdConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::EggIncAdConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::DailyGiftInfo*
Arena::CreateMaybeMessage< ::ei::DailyGiftInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::DailyGiftInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::SalesInfoRequest*
Arena::CreateMaybeMessage< ::ei::SalesInfoRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::SalesInfoRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::IAPSaleEntry*
Arena::CreateMaybeMessage< ::ei::IAPSaleEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::IAPSaleEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::SalesInfo*
Arena::CreateMaybeMessage< ::ei::SalesInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::SalesInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::EggIncEvent*
Arena::CreateMaybeMessage< ::ei::EggIncEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::EggIncEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::EggIncCurrentEvents*
Arena::CreateMaybeMessage< ::ei::EggIncCurrentEvents >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::EggIncCurrentEvents >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::DeviceInfo*
Arena::CreateMaybeMessage< ::ei::DeviceInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::DeviceInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::AppInfo*
Arena::CreateMaybeMessage< ::ei::AppInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::AppInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ActionKeyValuePair*
Arena::CreateMaybeMessage< ::ei::ActionKeyValuePair >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ActionKeyValuePair >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::GenericAction*
Arena::CreateMaybeMessage< ::ei::GenericAction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::GenericAction >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::GenericActionBatchRequest*
Arena::CreateMaybeMessage< ::ei::GenericActionBatchRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::GenericActionBatchRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::VerifyPurchaseRequest*
Arena::CreateMaybeMessage< ::ei::VerifyPurchaseRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::VerifyPurchaseRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::VerifyPurchaseResponse*
Arena::CreateMaybeMessage< ::ei::VerifyPurchaseResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::VerifyPurchaseResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::CurrencyFlowLog*
Arena::CreateMaybeMessage< ::ei::CurrencyFlowLog >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::CurrencyFlowLog >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::CurrencyFlowBatchRequest*
Arena::CreateMaybeMessage< ::ei::CurrencyFlowBatchRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::CurrencyFlowBatchRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::Reward*
Arena::CreateMaybeMessage< ::ei::Reward >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::Reward >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::GameModifier*
Arena::CreateMaybeMessage< ::ei::GameModifier >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::GameModifier >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::Contract_Goal*
Arena::CreateMaybeMessage< ::ei::Contract_Goal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::Contract_Goal >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::Contract_GoalSet*
Arena::CreateMaybeMessage< ::ei::Contract_GoalSet >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::Contract_GoalSet >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::Contract_GradeSpec*
Arena::CreateMaybeMessage< ::ei::Contract_GradeSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::Contract_GradeSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::Contract*
Arena::CreateMaybeMessage< ::ei::Contract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::Contract >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ContractPlayerInfo*
Arena::CreateMaybeMessage< ::ei::ContractPlayerInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ContractPlayerInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ContractEvaluation*
Arena::CreateMaybeMessage< ::ei::ContractEvaluation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ContractEvaluation >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ContractCitation*
Arena::CreateMaybeMessage< ::ei::ContractCitation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ContractCitation >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ContractEvaluationBatch_Pair*
Arena::CreateMaybeMessage< ::ei::ContractEvaluationBatch_Pair >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ContractEvaluationBatch_Pair >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ContractEvaluationBatch*
Arena::CreateMaybeMessage< ::ei::ContractEvaluationBatch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ContractEvaluationBatch >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::CoopCompletionSnapshot_ContributorSnapshot*
Arena::CreateMaybeMessage< ::ei::CoopCompletionSnapshot_ContributorSnapshot >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::CoopCompletionSnapshot_ContributorSnapshot >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::CoopCompletionSnapshot*
Arena::CreateMaybeMessage< ::ei::CoopCompletionSnapshot >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::CoopCompletionSnapshot >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::BasicRequestInfo*
Arena::CreateMaybeMessage< ::ei::BasicRequestInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::BasicRequestInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ContractSimConfig_ContractGradeSimConfig_GoalParams*
Arena::CreateMaybeMessage< ::ei::ContractSimConfig_ContractGradeSimConfig_GoalParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ContractSimConfig_ContractGradeSimConfig_GoalParams >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ContractSimConfig_ContractGradeSimConfig*
Arena::CreateMaybeMessage< ::ei::ContractSimConfig_ContractGradeSimConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ContractSimConfig_ContractGradeSimConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ContractSimConfig*
Arena::CreateMaybeMessage< ::ei::ContractSimConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ContractSimConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ContractSimPoll*
Arena::CreateMaybeMessage< ::ei::ContractSimPoll >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ContractSimPoll >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ContractSimPollResponse*
Arena::CreateMaybeMessage< ::ei::ContractSimPollResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ContractSimPollResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ContractSimResultUpdate_GoalInfo*
Arena::CreateMaybeMessage< ::ei::ContractSimResultUpdate_GoalInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ContractSimResultUpdate_GoalInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ContractSimResultUpdate*
Arena::CreateMaybeMessage< ::ei::ContractSimResultUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ContractSimResultUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ContractsRequest*
Arena::CreateMaybeMessage< ::ei::ContractsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ContractsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ContractsResponse*
Arena::CreateMaybeMessage< ::ei::ContractsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ContractsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ContractCoopStatusRequest*
Arena::CreateMaybeMessage< ::ei::ContractCoopStatusRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ContractCoopStatusRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::FarmProductionParams*
Arena::CreateMaybeMessage< ::ei::FarmProductionParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::FarmProductionParams >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::PlayerFarmInfo*
Arena::CreateMaybeMessage< ::ei::PlayerFarmInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::PlayerFarmInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ContractCoopStatusResponse_ContributionInfo*
Arena::CreateMaybeMessage< ::ei::ContractCoopStatusResponse_ContributionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ContractCoopStatusResponse_ContributionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ContractCoopStatusResponse_CoopGift*
Arena::CreateMaybeMessage< ::ei::ContractCoopStatusResponse_CoopGift >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ContractCoopStatusResponse_CoopGift >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ContractCoopStatusResponse_ChickenRun*
Arena::CreateMaybeMessage< ::ei::ContractCoopStatusResponse_ChickenRun >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ContractCoopStatusResponse_ChickenRun >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ContractCoopStatusResponse*
Arena::CreateMaybeMessage< ::ei::ContractCoopStatusResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ContractCoopStatusResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::LocalContract*
Arena::CreateMaybeMessage< ::ei::LocalContract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::LocalContract >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::MyContracts*
Arena::CreateMaybeMessage< ::ei::MyContracts >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::MyContracts >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::QueryCoopRequest*
Arena::CreateMaybeMessage< ::ei::QueryCoopRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::QueryCoopRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::QueryCoopResponse*
Arena::CreateMaybeMessage< ::ei::QueryCoopResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::QueryCoopResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::CreateCoopRequest*
Arena::CreateMaybeMessage< ::ei::CreateCoopRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::CreateCoopRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::CreateCoopResponse*
Arena::CreateMaybeMessage< ::ei::CreateCoopResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::CreateCoopResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::JoinCoopRequest*
Arena::CreateMaybeMessage< ::ei::JoinCoopRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::JoinCoopRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::JoinCoopResponse*
Arena::CreateMaybeMessage< ::ei::JoinCoopResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::JoinCoopResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::AutoJoinCoopRequest*
Arena::CreateMaybeMessage< ::ei::AutoJoinCoopRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::AutoJoinCoopRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::UpdateCoopPermissionsRequest*
Arena::CreateMaybeMessage< ::ei::UpdateCoopPermissionsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::UpdateCoopPermissionsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::UpdateCoopPermissionsResponse*
Arena::CreateMaybeMessage< ::ei::UpdateCoopPermissionsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::UpdateCoopPermissionsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::LeaveCoopRequest*
Arena::CreateMaybeMessage< ::ei::LeaveCoopRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::LeaveCoopRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::GiftPlayerCoopRequest*
Arena::CreateMaybeMessage< ::ei::GiftPlayerCoopRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::GiftPlayerCoopRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::SendChickenRunCoopRequest*
Arena::CreateMaybeMessage< ::ei::SendChickenRunCoopRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::SendChickenRunCoopRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ReportPlayerCoopRequest*
Arena::CreateMaybeMessage< ::ei::ReportPlayerCoopRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ReportPlayerCoopRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::KickPlayerCoopRequest*
Arena::CreateMaybeMessage< ::ei::KickPlayerCoopRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::KickPlayerCoopRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ContractCoopStatusUpdateRequest*
Arena::CreateMaybeMessage< ::ei::ContractCoopStatusUpdateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ContractCoopStatusUpdateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ContractCoopStatusUpdateResponse*
Arena::CreateMaybeMessage< ::ei::ContractCoopStatusUpdateResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ContractCoopStatusUpdateResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::CoopBuffState*
Arena::CreateMaybeMessage< ::ei::CoopBuffState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::CoopBuffState >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::CoopBuffHistory*
Arena::CreateMaybeMessage< ::ei::CoopBuffHistory >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::CoopBuffHistory >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::CoopChickenRunEntry*
Arena::CreateMaybeMessage< ::ei::CoopChickenRunEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::CoopChickenRunEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::CoopLastChickenRunTimes*
Arena::CreateMaybeMessage< ::ei::CoopLastChickenRunTimes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::CoopLastChickenRunTimes >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::LeaderboardAnalysis_Chunk*
Arena::CreateMaybeMessage< ::ei::LeaderboardAnalysis_Chunk >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::LeaderboardAnalysis_Chunk >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::LeaderboardAnalysis*
Arena::CreateMaybeMessage< ::ei::LeaderboardAnalysis >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::LeaderboardAnalysis >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::LeaderboardInfo_Season*
Arena::CreateMaybeMessage< ::ei::LeaderboardInfo_Season >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::LeaderboardInfo_Season >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::LeaderboardInfo*
Arena::CreateMaybeMessage< ::ei::LeaderboardInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::LeaderboardInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::LeaderboardRequest*
Arena::CreateMaybeMessage< ::ei::LeaderboardRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::LeaderboardRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::LeaderboardResponse_Entry*
Arena::CreateMaybeMessage< ::ei::LeaderboardResponse_Entry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::LeaderboardResponse_Entry >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::LeaderboardResponse*
Arena::CreateMaybeMessage< ::ei::LeaderboardResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::LeaderboardResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ContractsArchive*
Arena::CreateMaybeMessage< ::ei::ContractsArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ContractsArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ContractAction*
Arena::CreateMaybeMessage< ::ei::ContractAction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ContractAction >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::UserDataInfoRequest*
Arena::CreateMaybeMessage< ::ei::UserDataInfoRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::UserDataInfoRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::UserDataInfoResponse*
Arena::CreateMaybeMessage< ::ei::UserDataInfoResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::UserDataInfoResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ClearAllUserDataRequest*
Arena::CreateMaybeMessage< ::ei::ClearAllUserDataRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ClearAllUserDataRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ServerGift*
Arena::CreateMaybeMessage< ::ei::ServerGift >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ServerGift >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::LiveConfig_BoostsConfig_ItemConfig*
Arena::CreateMaybeMessage< ::ei::LiveConfig_BoostsConfig_ItemConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::LiveConfig_BoostsConfig_ItemConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::LiveConfig_BoostsConfig*
Arena::CreateMaybeMessage< ::ei::LiveConfig_BoostsConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::LiveConfig_BoostsConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::LiveConfig_GiftConfig_GiftValueConfig*
Arena::CreateMaybeMessage< ::ei::LiveConfig_GiftConfig_GiftValueConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::LiveConfig_GiftConfig_GiftValueConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::LiveConfig_GiftConfig_GiftMuConfig*
Arena::CreateMaybeMessage< ::ei::LiveConfig_GiftConfig_GiftMuConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::LiveConfig_GiftConfig_GiftMuConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::LiveConfig_GiftConfig*
Arena::CreateMaybeMessage< ::ei::LiveConfig_GiftConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::LiveConfig_GiftConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::LiveConfig_MiscConfig*
Arena::CreateMaybeMessage< ::ei::LiveConfig_MiscConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::LiveConfig_MiscConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::LiveConfig*
Arena::CreateMaybeMessage< ::ei::LiveConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::LiveConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::InGameMail*
Arena::CreateMaybeMessage< ::ei::InGameMail >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::InGameMail >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::MailDB*
Arena::CreateMaybeMessage< ::ei::MailDB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::MailDB >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::PeriodicalsResponse*
Arena::CreateMaybeMessage< ::ei::PeriodicalsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::PeriodicalsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::GetPeriodicalsRequest*
Arena::CreateMaybeMessage< ::ei::GetPeriodicalsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::GetPeriodicalsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ConfigRequest*
Arena::CreateMaybeMessage< ::ei::ConfigRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ConfigRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ConfigResponse*
Arena::CreateMaybeMessage< ::ei::ConfigResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ConfigResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::AdAttributionRawData*
Arena::CreateMaybeMessage< ::ei::AdAttributionRawData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::AdAttributionRawData >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::AdAttributionRow*
Arena::CreateMaybeMessage< ::ei::AdAttributionRow >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::AdAttributionRow >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::AdAttributionInfo*
Arena::CreateMaybeMessage< ::ei::AdAttributionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::AdAttributionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ArtifactsClientInfo_LaunchCount*
Arena::CreateMaybeMessage< ::ei::ArtifactsClientInfo_LaunchCount >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ArtifactsClientInfo_LaunchCount >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ArtifactsClientInfo*
Arena::CreateMaybeMessage< ::ei::ArtifactsClientInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ArtifactsClientInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::MissionInfo_Fuel*
Arena::CreateMaybeMessage< ::ei::MissionInfo_Fuel >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::MissionInfo_Fuel >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::MissionInfo*
Arena::CreateMaybeMessage< ::ei::MissionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::MissionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ArtifactSpec*
Arena::CreateMaybeMessage< ::ei::ArtifactSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ArtifactSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::CompleteArtifact*
Arena::CreateMaybeMessage< ::ei::CompleteArtifact >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::CompleteArtifact >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ArtifactInventoryItem*
Arena::CreateMaybeMessage< ::ei::ArtifactInventoryItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ArtifactInventoryItem >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::InventorySlot*
Arena::CreateMaybeMessage< ::ei::InventorySlot >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::InventorySlot >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ArtifactsConfigurationRequest*
Arena::CreateMaybeMessage< ::ei::ArtifactsConfigurationRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ArtifactsConfigurationRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ArtifactsConfigurationResponse_MissionParameters_Duration*
Arena::CreateMaybeMessage< ::ei::ArtifactsConfigurationResponse_MissionParameters_Duration >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ArtifactsConfigurationResponse_MissionParameters_Duration >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ArtifactsConfigurationResponse_MissionParameters*
Arena::CreateMaybeMessage< ::ei::ArtifactsConfigurationResponse_MissionParameters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ArtifactsConfigurationResponse_MissionParameters >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ArtifactsConfigurationResponse_ArtifactParameters*
Arena::CreateMaybeMessage< ::ei::ArtifactsConfigurationResponse_ArtifactParameters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ArtifactsConfigurationResponse_ArtifactParameters >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ArtifactsConfigurationResponse_CraftingLevelInfo*
Arena::CreateMaybeMessage< ::ei::ArtifactsConfigurationResponse_CraftingLevelInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ArtifactsConfigurationResponse_CraftingLevelInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ArtifactsConfigurationResponse*
Arena::CreateMaybeMessage< ::ei::ArtifactsConfigurationResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ArtifactsConfigurationResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::MissionRequest*
Arena::CreateMaybeMessage< ::ei::MissionRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::MissionRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::MissionResponse*
Arena::CreateMaybeMessage< ::ei::MissionResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::MissionResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::CompleteMissionResponse_SecureArtifactSpec*
Arena::CreateMaybeMessage< ::ei::CompleteMissionResponse_SecureArtifactSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::CompleteMissionResponse_SecureArtifactSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::CompleteMissionResponse*
Arena::CreateMaybeMessage< ::ei::CompleteMissionResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::CompleteMissionResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::CollectContractArtifactRewardsRequest*
Arena::CreateMaybeMessage< ::ei::CollectContractArtifactRewardsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::CollectContractArtifactRewardsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::CraftArtifactRequest*
Arena::CreateMaybeMessage< ::ei::CraftArtifactRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::CraftArtifactRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::CraftArtifactResponse*
Arena::CreateMaybeMessage< ::ei::CraftArtifactResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::CraftArtifactResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ConsumeArtifactRequest*
Arena::CreateMaybeMessage< ::ei::ConsumeArtifactRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ConsumeArtifactRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ConsumeArtifactResponse*
Arena::CreateMaybeMessage< ::ei::ConsumeArtifactResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ConsumeArtifactResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::AuthenticateArtifactResponse*
Arena::CreateMaybeMessage< ::ei::AuthenticateArtifactResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::AuthenticateArtifactResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::SetArtifactRequest*
Arena::CreateMaybeMessage< ::ei::SetArtifactRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::SetArtifactRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::SetArtifactResponse*
Arena::CreateMaybeMessage< ::ei::SetArtifactResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::SetArtifactResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ArtifactsDB_ActiveArtifactSlot*
Arena::CreateMaybeMessage< ::ei::ArtifactsDB_ActiveArtifactSlot >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ArtifactsDB_ActiveArtifactSlot >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ArtifactsDB_ActiveArtifactSet*
Arena::CreateMaybeMessage< ::ei::ArtifactsDB_ActiveArtifactSet >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ArtifactsDB_ActiveArtifactSet >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ArtifactsDB_CraftableArtifact*
Arena::CreateMaybeMessage< ::ei::ArtifactsDB_CraftableArtifact >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ArtifactsDB_CraftableArtifact >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ArtifactsDB*
Arena::CreateMaybeMessage< ::ei::ArtifactsDB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ArtifactsDB >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::AuthenticatedMessage*
Arena::CreateMaybeMessage< ::ei::AuthenticatedMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::AuthenticatedMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::LogCompleteMissionPayload*
Arena::CreateMaybeMessage< ::ei::LogCompleteMissionPayload >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::LogCompleteMissionPayload >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::LogCraftArtifactPayload*
Arena::CreateMaybeMessage< ::ei::LogCraftArtifactPayload >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::LogCraftArtifactPayload >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::LogConsumeArtifactPayload*
Arena::CreateMaybeMessage< ::ei::LogConsumeArtifactPayload >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::LogConsumeArtifactPayload >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::LogSetArtifactPayload*
Arena::CreateMaybeMessage< ::ei::LogSetArtifactPayload >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::LogSetArtifactPayload >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::AccountTransferPayload*
Arena::CreateMaybeMessage< ::ei::AccountTransferPayload >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::AccountTransferPayload >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::SaveBackupResponse*
Arena::CreateMaybeMessage< ::ei::SaveBackupResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::SaveBackupResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::CleanAccountRequest*
Arena::CreateMaybeMessage< ::ei::CleanAccountRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::CleanAccountRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ReturnEDTPayload*
Arena::CreateMaybeMessage< ::ei::ReturnEDTPayload >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ReturnEDTPayload >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::DLCItem*
Arena::CreateMaybeMessage< ::ei::DLCItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::DLCItem >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ShellSpec_ShellPiece*
Arena::CreateMaybeMessage< ::ei::ShellSpec_ShellPiece >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ShellSpec_ShellPiece >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ShellSpec*
Arena::CreateMaybeMessage< ::ei::ShellSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ShellSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ShellSetSpec_VariationSpec*
Arena::CreateMaybeMessage< ::ei::ShellSetSpec_VariationSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ShellSetSpec_VariationSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ShellSetSpec*
Arena::CreateMaybeMessage< ::ei::ShellSetSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ShellSetSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ShellObjectSpec_LODPiece*
Arena::CreateMaybeMessage< ::ei::ShellObjectSpec_LODPiece >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ShellObjectSpec_LODPiece >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ShellObjectSpec*
Arena::CreateMaybeMessage< ::ei::ShellObjectSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ShellObjectSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ShellGroupSpec*
Arena::CreateMaybeMessage< ::ei::ShellGroupSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ShellGroupSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::DLCCatalog*
Arena::CreateMaybeMessage< ::ei::DLCCatalog >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::DLCCatalog >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ShellDB_ShellStatus*
Arena::CreateMaybeMessage< ::ei::ShellDB_ShellStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ShellDB_ShellStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ShellDB_ShellElementStatus*
Arena::CreateMaybeMessage< ::ei::ShellDB_ShellElementStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ShellDB_ShellElementStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ShellDB_ShellSetVariationStatus*
Arena::CreateMaybeMessage< ::ei::ShellDB_ShellSetVariationStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ShellDB_ShellSetVariationStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ShellDB_FarmConfiguration*
Arena::CreateMaybeMessage< ::ei::ShellDB_FarmConfiguration >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ShellDB_FarmConfiguration >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ShellDB_SavedFarmConfiguration*
Arena::CreateMaybeMessage< ::ei::ShellDB_SavedFarmConfiguration >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ShellDB_SavedFarmConfiguration >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ShellDB_ShellConfiguration*
Arena::CreateMaybeMessage< ::ei::ShellDB_ShellConfiguration >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ShellDB_ShellConfiguration >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ShellDB_ShellSetConfiguration*
Arena::CreateMaybeMessage< ::ei::ShellDB_ShellSetConfiguration >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ShellDB_ShellSetConfiguration >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ShellDB_ShellGroupConfiguration*
Arena::CreateMaybeMessage< ::ei::ShellDB_ShellGroupConfiguration >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ShellDB_ShellGroupConfiguration >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ShellDB_ChickenConfig*
Arena::CreateMaybeMessage< ::ei::ShellDB_ChickenConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ShellDB_ChickenConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ShellDB*
Arena::CreateMaybeMessage< ::ei::ShellDB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ShellDB >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::ShellsActionLog*
Arena::CreateMaybeMessage< ::ei::ShellsActionLog >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::ShellsActionLog >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::UserVerificationAnalysis*
Arena::CreateMaybeMessage< ::ei::UserVerificationAnalysis >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::UserVerificationAnalysis >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::UserSubscriptionInfo_HistoryEntry*
Arena::CreateMaybeMessage< ::ei::UserSubscriptionInfo_HistoryEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::UserSubscriptionInfo_HistoryEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::UserSubscriptionInfo*
Arena::CreateMaybeMessage< ::ei::UserSubscriptionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::UserSubscriptionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::SubscriptionChangeHintRequest*
Arena::CreateMaybeMessage< ::ei::SubscriptionChangeHintRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::SubscriptionChangeHintRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::ei::CXPEvalRolloutInfo*
Arena::CreateMaybeMessage< ::ei::CXPEvalRolloutInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ei::CXPEvalRolloutInfo >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
